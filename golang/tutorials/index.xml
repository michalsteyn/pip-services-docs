<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title> – Tutorials</title>
    <link>/golang/tutorials/</link>
    <description>Recent content in Tutorials on </description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    
	  <atom:link href="/golang/tutorials/index.xml" rel="self" type="application/rss+xml" />
    
    
      
        
      
    
    
    <item>
      <title>Golang: Client Library!</title>
      <link>/golang/tutorials/client_library/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/golang/tutorials/client_library/</guid>
      <description>
        
        
        &lt;p&gt;&lt;strong&gt;TODO: need rewrite on Golang&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;introduction&#34;&gt;Introduction&lt;/h3&gt;
&lt;p&gt;Knowing how to create a client library for your microservice is almost as important as knowing how to create the microservice itself. Some people question whether or not client libraries are actually necessary, and say that it’s enough to just describe the external interface and let the users of the microservice implement their own interaction protocol.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../images/tutorials/client_library/client_library_diagram.png&#34; alt=&#34;Client Library Diagram&#34;&gt;&lt;/p&gt;
&lt;p&gt;We strongly recommend the use of client libraries due to the following:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Client libraries are created once and can be used by all users of the microservice, which significantly reduces development time.&lt;/li&gt;
&lt;li&gt;In addition to providing a ready interaction protocol, client libraries can also contain well written mocks. These allow users to cut off dependencies to the actual microservice and use its local mock replacement for unit tests.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;To avoid running into problems, we recommend following the rules below:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The microservices external interface should use interoperable protocols and be well documented. This is done so that, if the need occurs (e.g. no clients exist for a new programming language), users of the microservice would be able to create a client on their own&lt;/li&gt;
&lt;li&gt;It’s necessary to keep to the principle of ”smart endpoints - dumb pipes”. I.e. client libraries shouldn’t contain any business logic. All business logic should be implemented in the microservice itself, to avoid ending up with multiple implementations that unexpectedly start conflicting with each other.&lt;/li&gt;
&lt;li&gt;The only exception to the previous rule is optimizing requests to the server and providing a client API that is more convenient than the one that is supported on the protocol’s level.&lt;/li&gt;
&lt;li&gt;The number of external dependencies should be minimized in client libraries. The use of 3rd party libraries is acceptable only if they lack conflicting versions and provide complete backwards compatibility. Otherwise, client libraries that are written using conflicting versions of 3rd party libraries will start getting in each other’s way, when used in the same process. This rule is applicable to most programming languages, like .NET, Java, and Golang. The Pip.Services Toolkit fully complies with this rule and can safely be used to write client libraries.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;As we mentioned earlier, it’s highly recommended to implement mock versions of clients, as well as random data generators for simplifying the process of writing unit tests. And all mock clients should be tested using the same tests that are used to test the real clients, to exclude any and all differences in their implementation.&lt;/p&gt;
&lt;p&gt;The client library that we will be creating in this tutorial is for the microservice described in the &lt;a href=&#34;../data_microservice&#34;&gt;Data microservice&lt;/a&gt; tutorial. To better understand the client’s logic, it’s a good idea to familiarize yourself with that tutorial first, if you haven’t done so already.
To make it easier to follow along, we’ve broken up the tutorial on writing your first client library into the following steps:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;step1&#34;&gt;Step 1. Setting up the project&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;step2&#34;&gt;Step 2. Implementing Direct Client&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;step3&#34;&gt;Step 3. Implementing HTTP Client&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;step4&#34;&gt;Step 4. Implementing Mock client&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;step5&#34;&gt;Step 5. Testing HTTP client with Remote Microservice&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Let&amp;rsquo;s get started! Head on over to Step 1. Setting up the project.&lt;/p&gt;
&lt;h3 id=&#34;see-also&#34;&gt;See also&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;../microservice_facade&#34;&gt;Tutorial how to create microservice facade&lt;/a&gt;
&lt;a href=&#34;../microservice_dockerization&#34;&gt;Tutorial how to dockerize a microservice&lt;/a&gt;&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Golang: Data Microservice!</title>
      <link>/golang/tutorials/data_microservice/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/golang/tutorials/data_microservice/</guid>
      <description>
        
        
        &lt;p&gt;&lt;strong&gt;TODO: need rewrite on Golang&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;overview&#34;&gt;Overview&lt;/h3&gt;
&lt;p&gt;In this tutorial, we’ll be writing from scratch a fully-functional Data microservice, using the patterns and mechanisms available in the Pip.Services toolkit, as well as the programming language you have selected. The microservice that we are going to be using as an example in this tutorial is called [The Beacons microservice], which is part of [The IoT Microservices Collection]. This microservice is meant to perform the following simple tasks:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Store a list of BLE beacons (a.k.a. iBeacons), their unique identifiers, and the positions at which they were installed.&lt;/li&gt;
&lt;li&gt;Calculate the position of a device, using the beacons it “sees” in its vicinity.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;../../images/tutorials/data_microservice/beacon.png&#34; alt=&#34;Beacon&#34;&gt;&lt;/p&gt;
&lt;p&gt;Imagine the following situation: you are walking through a building that has beacons installed at various locations throughout the entire building. These beacons are broadcasting signals via bluetooth, at regular time intervals, which can be “seen” from about 200 feet away. The beacons, along with their positions, are stored in our microservice. When your smartphone starts “seeing” some of these signals, it sends a list of the beacons it “sees” to the microservice, which then calculates the position of your phone as being in the middle of the beacons it “sees”. Simple, but effective - wouldn’t you agree?&lt;/p&gt;
&lt;p&gt;The Beacons microservice that we are going to be developing will consist of a number of loosely-coupled components, following the &lt;a href=&#34;../../getting_started&#34;&gt;componentized microservice design&lt;/a&gt;. The structure of this microservice is displayed on the diagram below:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../images/tutorials/data_microservice/beacon_diagram.png&#34; alt=&#34;BeaconDiagram&#34;&gt;&lt;/p&gt;
&lt;p&gt;To make it easier to follow along, we’ve divided the tutorial into the following 7 steps:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;step1&#34;&gt;Step 1. Setting up the project&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;step2&#34;&gt;Step 2. Data model development&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;step3&#34;&gt;Step 3. Implementing persistence components (with tests)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;step4&#34;&gt;Step 4. Implementing a controller (with tests)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;step5&#34;&gt;Step 5. Implementing an HTTP service (with tests)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;step6&#34;&gt;Step 6. Wrapping microservice into container&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;step7&#34;&gt;Step 7. Running and testing the microservice&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;see-also&#34;&gt;See also&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../client_library&#34;&gt;Tutorial how to create a client library&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../microservice-dockerization&#34;&gt;Tutorial how to dockerize a microservice&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
    
    <item>
      <title>Golang: Microservice Dockerization</title>
      <link>/golang/tutorials/microservice_dockerization/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/golang/tutorials/microservice_dockerization/</guid>
      <description>
        
        
        &lt;hr&gt;
&lt;h3 id=&#34;introduction&#34;&gt;Introduction&lt;/h3&gt;
&lt;p&gt;Running microservices in Docker containers has become one of the most popular ways of deploying a system. However, Docker can be used for much more. Containers can be used for automating builds and testing, resulting in a 100% standardized process between developers and the CI/CD pipelines on build servers.&lt;/p&gt;
&lt;p&gt;In this tutorial, we will be demonstrating the entire process of building a microservice using Docker containers - from compiling the source code, to composing the built microservice in a container and publishing it to a repository. This can be done with any language that is supported by the Pip.Services Toolkit.&lt;/p&gt;
&lt;p&gt;The scripts used in this tutorial are meant to be used by developers, as well as by CI/CD pipelines. At the same time however, the CI/CD pipelines are always simple and look alike, no matter the language or features of the microservice itself. Build, Test, Package, and Publish scripts make up the standard set that we use in our projects.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../images/tutorials/microservice_dockerization/pipeline_scheme.png&#34; alt=&#34;Pipeline scheme&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;creating-a-dockerized-microservice&#34;&gt;Creating a dockerized microservice&lt;/h3&gt;
&lt;p&gt;To make it easier to follow along, we’ve broken up this tutorial into the following steps:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;step1&#34;&gt;Step 1. Building a microservice&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;step2&#34;&gt;Step 2. Running automated tests&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;step3&#34;&gt;Step 3. Packaging a microservice into a container&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;step4&#34;&gt;Step 4. Publishing a microservice container to a registry&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;step5&#34;&gt;Step 5. Running a dockerized microservice&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;span class=&#34;hide-title-link&#34;&gt;
&lt;h4 id=&#34;step-1-building-a-microservicestep1&#34;&gt;&lt;a href=&#34;step1&#34;&gt;Step 1. Building a microservice&lt;/a&gt;&lt;/h4&gt;
&lt;h4 id=&#34;step-2-running-automated-testsstep2&#34;&gt;&lt;a href=&#34;step2&#34;&gt;Step 2. Running automated tests&lt;/a&gt;&lt;/h4&gt;
&lt;h4 id=&#34;step-3-packaging-a-microservice-into-a-containerstep3&#34;&gt;&lt;a href=&#34;step3&#34;&gt;Step 3. Packaging a microservice into a container&lt;/a&gt;&lt;/h4&gt;
&lt;h4 id=&#34;step-4-publishing-a-microservice-container-to-a-registrystep4&#34;&gt;&lt;a href=&#34;step4&#34;&gt;Step 4. Publishing a microservice container to a registry&lt;/a&gt;&lt;/h4&gt;
&lt;h4 id=&#34;step-5-running-a-dockerized-microservicestep5&#34;&gt;&lt;a href=&#34;step5&#34;&gt;Step 5. Running a dockerized microservice&lt;/a&gt;&lt;/h4&gt;
&lt;/span&gt;

      </description>
    </item>
    
  </channel>
</rss>
