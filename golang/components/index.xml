<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title> â€“ Components module</title>
    <link>/golang/components/</link>
    <description>Recent content in Components module on </description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    
	  <atom:link href="/golang/components/index.xml" rel="self" type="application/rss+xml" />
    
    
      
        
      
    
    
    <item>
      <title>Golang: Auth</title>
      <link>/golang/components/auth/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/golang/components/auth/</guid>
      <description>
        
        
        &lt;hr&gt;
&lt;p&gt;&lt;strong&gt;Important points&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Examples of credentials are passwords, logins, application keys, and secrets.&lt;/li&gt;
&lt;li&gt;Credentials&#39; information is usually linked with connection parameters.&lt;/li&gt;
&lt;li&gt;Configuration and connection parameters are stored separately from authentication information as they need added security and protection.&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;module-body&#34;&gt;  
&lt;br&gt;
&lt;h3 id=&#34;interfaces&#34;&gt;Interfaces&lt;/h3&gt;
&lt;h4 id=&#34;icredentialstoreicredential_store&#34;&gt;&lt;a href=&#34;icredential_store&#34;&gt;ICredentialStore&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;Interface for credential stores which are used to store and lookup credentials
to authenticate against external services.&lt;/p&gt;
&lt;br&gt;
&lt;h3 id=&#34;classes&#34;&gt;Classes&lt;/h3&gt;
&lt;h4 id=&#34;credentialparamscredential_params&#34;&gt;&lt;a href=&#34;credential_params&#34;&gt;CredentialParams&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;Contains credentials used to authenticate against external services.
They are used together with connection parameters, but usually stored
in a separate store, protected from unauthorized access.&lt;/p&gt;
&lt;h4 id=&#34;credentialresolvercredential_resolver&#34;&gt;&lt;a href=&#34;credential_resolver&#34;&gt;CredentialResolver&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;Helper class to retrieve component credentials.&lt;/p&gt;
&lt;p&gt;If credentials are configured to be retrieved from &lt;a href=&#34;icredential_store&#34;&gt;ICredentialStore&lt;/a&gt;,
it automatically locates &lt;a href=&#34;icredential_store&#34;&gt;ICredentialStore&lt;/a&gt; in component references
and retrieves credentials from there using store_key parameter.&lt;/p&gt;
&lt;h4 id=&#34;defaultcredentialstorefactorydefault_credential_store_factory&#34;&gt;&lt;a href=&#34;default_credential_store_factory&#34;&gt;DefaultCredentialStoreFactory&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;Creates &lt;a href=&#34;icredential_store&#34;&gt;ICredentialStore&lt;/a&gt; components based on their descriptors.&lt;/p&gt;
&lt;h4 id=&#34;memorycredentialstorememory_credential_store&#34;&gt;&lt;a href=&#34;memory_credential_store&#34;&gt;MemoryCredentialStore&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;Credential store that keeps credentials in memory.&lt;/p&gt;
&lt;/div&gt;

      </description>
    </item>
    
    <item>
      <title>Golang: Build</title>
      <link>/golang/components/build/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/golang/components/build/</guid>
      <description>
        
        
        &lt;hr&gt;
&lt;div class=&#34;module-body&#34;&gt; 
&lt;h3 id=&#34;interfaces&#34;&gt;Interfaces&lt;/h3&gt;
&lt;h4 id=&#34;ifactoryifactory&#34;&gt;&lt;a href=&#34;ifactory&#34;&gt;IFactory&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;Interface for component factories.&lt;/p&gt;
&lt;br&gt;
&lt;h3 id=&#34;classes&#34;&gt;Classes&lt;/h3&gt;
&lt;h4 id=&#34;compositefactorycomposite_factory&#34;&gt;&lt;a href=&#34;composite_factory&#34;&gt;CompositeFactory&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;Aggregates multiple factories into a single factory component.&lt;/p&gt;
&lt;h4 id=&#34;createexceptioncreate_exception&#34;&gt;&lt;a href=&#34;create_exception&#34;&gt;CreateException&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;Error raised when factory is not able to create the requested component.&lt;/p&gt;
&lt;h4 id=&#34;factoryfactory&#34;&gt;&lt;a href=&#34;factory&#34;&gt;Factory&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;Basic component factory that creates components using registered types and factory functions.&lt;/p&gt;
&lt;/div&gt;

      </description>
    </item>
    
    <item>
      <title>Golang: Cache</title>
      <link>/golang/components/cache/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/golang/components/cache/</guid>
      <description>
        
        
        &lt;hr&gt;
&lt;div class=&#34;module-body&#34;&gt; 
&lt;h3 id=&#34;interfaces&#34;&gt;Interfaces&lt;/h3&gt;
&lt;h4 id=&#34;icacheicache&#34;&gt;&lt;a href=&#34;icache&#34;&gt;ICache&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;Interface for caches that are used to cache values to improve performance.&lt;/p&gt;
&lt;br&gt;
&lt;h3 id=&#34;classes&#34;&gt;Classes&lt;/h3&gt;
&lt;h4 id=&#34;cacheentrycache_entry&#34;&gt;&lt;a href=&#34;cache_entry&#34;&gt;CacheEntry&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;Data object to store cached values with their keys used by &lt;a href=&#34;../memory_cache&#34;&gt;MemoryCache&lt;/a&gt;.&lt;/p&gt;
&lt;h4 id=&#34;defaultcachefactorydefault_cache_factory&#34;&gt;&lt;a href=&#34;default_cache_factory&#34;&gt;DefaultCacheFactory&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;Creates &lt;a href=&#34;icache&#34;&gt;ICache&lt;/a&gt; components by their descriptors.&lt;/p&gt;
&lt;h4 id=&#34;memorycachememory_cache&#34;&gt;&lt;a href=&#34;memory_cache&#34;&gt;MemoryCache&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;Cache that stores values in the process memory.
Remember: This implementation is not suitable for synchronization of distributed processes.&lt;/p&gt;
&lt;h4 id=&#34;nullcachenull_cache&#34;&gt;&lt;a href=&#34;null_cache&#34;&gt;NullCache&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;Dummy cache implementation that doesn&amp;rsquo;t do anything.&lt;/p&gt;
&lt;p&gt;It can be used in testing or in situations when cache is required
but shall be disabled.&lt;/p&gt;
&lt;/div&gt;

      </description>
    </item>
    
    <item>
      <title>Golang: Config</title>
      <link>/golang/components/config/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/golang/components/config/</guid>
      <description>
        
        
        &lt;hr&gt;
&lt;div class=&#34;module-body&#34;&gt; 
&lt;h3 id=&#34;interfaces&#34;&gt;Interfaces&lt;/h3&gt;
&lt;h4 id=&#34;iconfigreadericonfig_reader&#34;&gt;&lt;a href=&#34;iconfig_reader&#34;&gt;IConfigReader&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;Interface for configuration readers that retrieve configurations from various sources
and make it available for other components.&lt;/p&gt;
&lt;p&gt;Some IConfigReader implementations may support configuration parameterization.
The parameterization allows to use configuration as a template and inject there dynamic values.
The values may come from application command like arguments or environment variables.&lt;/p&gt;
&lt;br&gt;
&lt;h3 id=&#34;classes&#34;&gt;Classes&lt;/h3&gt;
&lt;h4 id=&#34;configreaderconfig_reader&#34;&gt;&lt;a href=&#34;config_reader&#34;&gt;ConfigReader&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;Data object used to store cached values with their keys used by &lt;a href=&#34;../memory_cache&#34;&gt;MemoryCache&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&#34;defaultconfigreaderfactorydefault_config_reader_factory&#34;&gt;&lt;a href=&#34;default_config_reader_factory&#34;&gt;DefaultConfigReaderFactory&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;Creates &lt;a href=&#34;iconfig_reader&#34;&gt;IConfigReader&lt;/a&gt; components by their descriptors.&lt;/p&gt;
&lt;h4 id=&#34;fileconfigreaderfile_config_reader&#34;&gt;&lt;a href=&#34;file_config_reader&#34;&gt;FileConfigReader&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;Abstract config reader that reads a configuration from a file.
Child classes add support for config files in their specific format
like JSON, YAML or property files.&lt;/p&gt;
&lt;h4 id=&#34;jsonconfigreaderjson_config_reader&#34;&gt;&lt;a href=&#34;json_config_reader&#34;&gt;JsonConfigReader&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;Config reader that reads a configuration from JSON file.&lt;/p&gt;
&lt;p&gt;The reader supports parameterization using Handlebar template engine.&lt;/p&gt;
&lt;h4 id=&#34;memoryconfigreadermemory_config_reader&#34;&gt;&lt;a href=&#34;memory_config_reader&#34;&gt;MemoryConfigReader&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;Config reader that stores a configuration in memory.&lt;/p&gt;
&lt;h4 id=&#34;yamlconfigreaderyaml_config_reader&#34;&gt;&lt;a href=&#34;yaml_config_reader&#34;&gt;YamlConfigReader&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;Config reader that reads a configuration from YAML file.&lt;/p&gt;
&lt;/div&gt;

      </description>
    </item>
    
    <item>
      <title>Golang: Connect</title>
      <link>/golang/components/connect/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/golang/components/connect/</guid>
      <description>
        
        
        &lt;hr&gt;
&lt;p&gt;&lt;strong&gt;Important points&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A Discovery is a service that stores a registry of various end-points.&lt;/li&gt;
&lt;li&gt;There are two types of discovery:
&lt;ul&gt;
&lt;li&gt;Static discovery: all services have static IP addresses that are configured from the start and don&amp;rsquo;t change along the way. As of lately, it is used more often than dynamic, because it is simpler to use and more reliable.&lt;/li&gt;
&lt;li&gt;Dynamic discovery: every time a service starts, it registers its address in the discovery service. Clients then ask to resolve the address by which the requested service can be reached. The service has a general name, by which other services can resolve it.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;module-body&#34;&gt; 
&lt;br&gt;
&lt;h3 id=&#34;interfaces&#34;&gt;Interfaces&lt;/h3&gt;
&lt;h4 id=&#34;idiscoveryidiscovery&#34;&gt;&lt;a href=&#34;idiscovery&#34;&gt;IDiscovery&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;Interface for discovery services which are used to store and resolve connection parameters
to connect to external services.&lt;/p&gt;
&lt;br&gt;
&lt;h3 id=&#34;classes&#34;&gt;Classes&lt;/h3&gt;
&lt;h4 id=&#34;compositeconnectionresolvercomposite_connection_resolver&#34;&gt;&lt;a href=&#34;composite_connection_resolver&#34;&gt;CompositeConnectionResolver&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;Helper class that resolves connection and credential parameters,
validates them, and generates connection options.&lt;/p&gt;
&lt;h4 id=&#34;connectionparamsconnection_params&#34;&gt;&lt;a href=&#34;connection_params&#34;&gt;ConnectionParams&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;Contains connection parameters to connect to external services.
They are used together with credential parameters, but usually stored
separately from more protected sensitive values.&lt;/p&gt;
&lt;h4 id=&#34;connectionresolverconnection_resolver&#34;&gt;&lt;a href=&#34;connection_resolver&#34;&gt;ConnectionResolver&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;Helper class to retrieve component connections.&lt;/p&gt;
&lt;h4 id=&#34;connectionutilsconnection_utils&#34;&gt;&lt;a href=&#34;connection_utils&#34;&gt;ConnectionUtils&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;A set of utility functions to process connection parameters&lt;/p&gt;
&lt;h4 id=&#34;defaultdiscoveryfactorydefault_discovery_factory&#34;&gt;&lt;a href=&#34;default_discovery_factory&#34;&gt;DefaultDiscoveryFactory&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;Creates &lt;a href=&#34;idiscovery&#34;&gt;IDiscovery&lt;/a&gt; components by their descriptors.&lt;/p&gt;
&lt;h4 id=&#34;memorydiscoverymemory_discovery&#34;&gt;&lt;a href=&#34;memory_discovery&#34;&gt;MemoryDiscovery&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;Discovery service that keeps connections in memory.&lt;/p&gt;
&lt;/div&gt;

      </description>
    </item>
    
    <item>
      <title>Golang: Count</title>
      <link>/golang/components/count/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/golang/components/count/</guid>
      <description>
        
        
        &lt;hr&gt;
&lt;p&gt;&lt;strong&gt;Important points&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Performance counters show non-functional characteristics about how the code works, such as times called, response time, objects saved/processed. Using these numbers, it is possible to show how the code works in the system â€“ how stable, fast, expandable it is.&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;module-body&#34;&gt; 
&lt;br&gt;
&lt;h3 id=&#34;constants&#34;&gt;Constants&lt;/h3&gt;
&lt;h4 id=&#34;countertypecounter_type&#34;&gt;&lt;a href=&#34;counter_type&#34;&gt;CounterType&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;Types of counters that measure different types of metrics&lt;/p&gt;
&lt;br&gt;
&lt;h3 id=&#34;interfaces&#34;&gt;Interfaces&lt;/h3&gt;
&lt;h4 id=&#34;icountersicounters&#34;&gt;&lt;a href=&#34;icounters&#34;&gt;ICounters&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;Interface for performance counters that measure execution metrics.&lt;/p&gt;
&lt;p&gt;The performance counters measure how code is performing:
how fast or slow, how many transactions performed, how many objects
are stored, what was the latest transaction time and so on.&lt;/p&gt;
&lt;h4 id=&#34;icountertimingcallbackicounter_timing_callback&#34;&gt;&lt;a href=&#34;icounter_timing_callback&#34;&gt;ICounterTimingCallback&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;Interface for a callback to end measurement of execution elapsed time.&lt;/p&gt;
&lt;br&gt;
&lt;h3 id=&#34;classes&#34;&gt;Classes&lt;/h3&gt;
&lt;h4 id=&#34;cachedcounterscached_counters&#34;&gt;&lt;a href=&#34;cached_counters&#34;&gt;CachedCounters&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;Abstract implementation of performance counters that measures and stores counters in memory.
Child classes implement saving of the counters into various destinations.&lt;/p&gt;
&lt;h4 id=&#34;compositecounterscomposite_counters&#34;&gt;&lt;a href=&#34;composite_counters&#34;&gt;CompositeCounters&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;Aggregates all counters from component references under a single component.&lt;/p&gt;
&lt;p&gt;It allows to capture metrics and conveniently send them to multiple destinations.&lt;/p&gt;
&lt;h4 id=&#34;countercounter&#34;&gt;&lt;a href=&#34;counter&#34;&gt;Counter&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;Data object to store measurement for a performance counter.
This object is used by &lt;a href=&#34;../cached_counters&#34;&gt;CachedCounters&lt;/a&gt; to store counters.&lt;/p&gt;
&lt;h4 id=&#34;countertimingtiming&#34;&gt;&lt;a href=&#34;timing&#34;&gt;CounterTiming&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;Callback object returned by &lt;a href=&#34;icounters/#begintiming&#34;&gt;ICounters.BeginTiming&lt;/a&gt; to end timing
of execution block and update the associated counter.&lt;/p&gt;
&lt;h4 id=&#34;defaultcountersfactorydefault_counters_factory&#34;&gt;&lt;a href=&#34;default_counters_factory&#34;&gt;DefaultCountersFactory&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;Creates &lt;a href=&#34;icounters&#34;&gt;ICounters&lt;/a&gt; components by their descriptors.&lt;/p&gt;
&lt;h4 id=&#34;icachedcountersoverridesicached_counters_overrides&#34;&gt;&lt;a href=&#34;icached_counters_overrides&#34;&gt;ICachedCountersOverrides&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;Provides a save method for counters.&lt;/p&gt;
&lt;h4 id=&#34;logcounterslog_counters&#34;&gt;&lt;a href=&#34;log_counters&#34;&gt;LogCounters&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;Performance counters that periodically dumps counters measurements to logger.&lt;/p&gt;
&lt;h4 id=&#34;nullcountersnull_counters&#34;&gt;&lt;a href=&#34;null_counters&#34;&gt;NullCounters&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;Dummy implementation of performance counters that doesn&amp;rsquo;t do anything.&lt;/p&gt;
&lt;p&gt;It can be used in testing or in situations when a counter is required
but shall be disabled.&lt;/p&gt;
&lt;/div&gt;

      </description>
    </item>
    
    <item>
      <title>Golang: Info</title>
      <link>/golang/components/info/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/golang/components/info/</guid>
      <description>
        
        
        &lt;hr&gt;
&lt;p&gt;&lt;strong&gt;Important information&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;This package is useful for various logging functions where it is necessary to know things like: what source we are logging from, what is
the process name, or what the process is/does.&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;module-body&#34;&gt; 
&lt;br&gt;
&lt;h3 id=&#34;classes&#34;&gt;Classes&lt;/h3&gt;
&lt;h4 id=&#34;contextinfocontext_info&#34;&gt;&lt;a href=&#34;context_info&#34;&gt;ContextInfo&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;Context information component that provides detailed information
about execution context: container or/and process.&lt;/p&gt;
&lt;p&gt;Most often ContextInfo is used by logging and performance counters
to identify the source of the collected logs and metrics.&lt;/p&gt;
&lt;h4 id=&#34;defaultinfofactorydefault_info_factory&#34;&gt;&lt;a href=&#34;default_info_factory&#34;&gt;DefaultInfoFactory&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;Creates information components by their descriptors.&lt;/p&gt;
&lt;/div&gt;

      </description>
    </item>
    
    <item>
      <title>Golang: Lock</title>
      <link>/golang/components/lock/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/golang/components/lock/</guid>
      <description>
        
        
        &lt;hr&gt;
&lt;div class=&#34;module-body&#34;&gt; 
&lt;h3 id=&#34;interfaces&#34;&gt;Interfaces&lt;/h3&gt;
&lt;h4 id=&#34;ilockilock&#34;&gt;&lt;a href=&#34;ilock&#34;&gt;ILock&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;Interface for locks to synchronize work or parallel processes and to prevent collisions.
The lock allows to manage multiple locks identified by unique keys.&lt;/p&gt;
&lt;br&gt;
&lt;h3 id=&#34;classes&#34;&gt;Classes&lt;/h3&gt;
&lt;h4 id=&#34;defaultlockfactorydefault_lock_factory&#34;&gt;&lt;a href=&#34;default_lock_factory&#34;&gt;DefaultLockFactory&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;Creates &lt;a href=&#34;ilock&#34;&gt;ILock&lt;/a&gt; components by their descriptors.&lt;/p&gt;
&lt;h4 id=&#34;locklock&#34;&gt;&lt;a href=&#34;lock&#34;&gt;Lock&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;Abstract lock that implements default lock acquisition routine.&lt;/p&gt;
&lt;h4 id=&#34;memorylockmemory_lock&#34;&gt;&lt;a href=&#34;memory_lock&#34;&gt;MemoryLock&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;Lock that is used to synchronize execution within one process using shared memory.
This implementation is not suitable for synchronization of distributed processes.&lt;/p&gt;
&lt;h4 id=&#34;nulllocknull_lock&#34;&gt;&lt;a href=&#34;null_lock&#34;&gt;NullLock&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;Dummy lock implementation that doesn&amp;rsquo;t do anything.&lt;/p&gt;
&lt;p&gt;It can be used in testing or in situations when lock is required
but shall be disabled.&lt;/p&gt;
&lt;/div&gt;

      </description>
    </item>
    
    <item>
      <title>Golang: Log</title>
      <link>/golang/components/log/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/golang/components/log/</guid>
      <description>
        
        
        &lt;hr&gt;
&lt;div class=&#34;module-body&#34;&gt; 
&lt;h3 id=&#34;constants&#34;&gt;Constants&lt;/h3&gt;
&lt;h4 id=&#34;loglevellog_level&#34;&gt;&lt;a href=&#34;log_level&#34;&gt;LogLevel&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;Standard log levels.&lt;/p&gt;
&lt;p&gt;Logs at debug and trace levels are usually captured
only locally for troubleshooting
and never sent to consolidated log services.&lt;/p&gt;
&lt;br&gt;
&lt;h3 id=&#34;interfaces&#34;&gt;Interfaces&lt;/h3&gt;
&lt;h4 id=&#34;iloggerilogger&#34;&gt;&lt;a href=&#34;ilogger&#34;&gt;ILogger&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;Interface for logger components that capture execution log messages.&lt;/p&gt;
&lt;br&gt;
&lt;h3 id=&#34;classes&#34;&gt;Classes&lt;/h3&gt;
&lt;h4 id=&#34;cachedloggercached_logger&#34;&gt;&lt;a href=&#34;cached_logger&#34;&gt;CachedLogger&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;Abstract logger that caches captured log messages in memory and periodically dumps them.
Child classes implement saving cached messages to their specified destinations.&lt;/p&gt;
&lt;h4 id=&#34;compositeloggercomposite_logger&#34;&gt;&lt;a href=&#34;composite_logger&#34;&gt;CompositeLogger&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;Aggregates all loggers from component references under a single component.&lt;/p&gt;
&lt;p&gt;It allows to log messages and conveniently send them to multiple destinations.&lt;/p&gt;
&lt;h4 id=&#34;consoleloggerconsole_logger&#34;&gt;&lt;a href=&#34;console_logger&#34;&gt;ConsoleLogger&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;Logger that writes log messages to console.&lt;/p&gt;
&lt;p&gt;Errors are written to standard err stream
and all other messages to the standard out stream.&lt;/p&gt;
&lt;h4 id=&#34;defaultloggerfactorydefault_logger_factory&#34;&gt;&lt;a href=&#34;default_logger_factory&#34;&gt;DefaultLoggerFactory&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;Creates &lt;a href=&#34;ilogger&#34;&gt;ILogger&lt;/a&gt; components by their descriptors.&lt;/p&gt;
&lt;h4 id=&#34;loggerlogger&#34;&gt;&lt;a href=&#34;logger&#34;&gt;Logger&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;Abstract logger that captures and formats log messages.
Child classes take the captured messages and write them to their specific destinations.&lt;/p&gt;
&lt;h4 id=&#34;loglevelconverterlog_level_converter&#34;&gt;&lt;a href=&#34;log_level_converter&#34;&gt;LogLevelConverter&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;Helper class to convert log level values.&lt;/p&gt;
&lt;h4 id=&#34;logmessagelog_message&#34;&gt;&lt;a href=&#34;log_message&#34;&gt;LogMessage&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;Data object used to store captured log messages.
This object is used by &lt;a href=&#34;../cached_logger&#34;&gt;CachedLogger&lt;/a&gt;.&lt;/p&gt;
&lt;h4 id=&#34;nullloggernull_logger&#34;&gt;&lt;a href=&#34;null_logger&#34;&gt;NullLogger&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;Dummy implementation of logger that doesn&amp;rsquo;t do anything.&lt;/p&gt;
&lt;p&gt;It can be used in testing or in situations when logger is required
but shall be disabled.&lt;/p&gt;
&lt;/div&gt;

      </description>
    </item>
    
    <item>
      <title>Golang: Test</title>
      <link>/golang/components/test/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/golang/components/test/</guid>
      <description>
        
        
        &lt;hr&gt;
&lt;div class=&#34;module-body&#34;&gt; 
&lt;h3 id=&#34;classes&#34;&gt;Classes&lt;/h3&gt;
&lt;h4 id=&#34;defaulttestfactorydefault_test_factory&#34;&gt;&lt;a href=&#34;default_test_factory&#34;&gt;DefaultTestFactory&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;Creates test components by their descriptors.&lt;/p&gt;
&lt;h4 id=&#34;shutdownshutdown&#34;&gt;&lt;a href=&#34;shutdown&#34;&gt;Shutdown&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;Random shutdown component that crashes the process
using various methods.&lt;/p&gt;
&lt;p&gt;The component is usually used for testing, but brave developers
can try to use it in production to randomly crash microservices.
It follows the concept of &amp;ldquo;Chaos Monkey&amp;rdquo; popularized by Netflix.&lt;/p&gt;
&lt;/div&gt;

      </description>
    </item>
    
    <item>
      <title>Golang: Trace</title>
      <link>/golang/components/trace/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/golang/components/trace/</guid>
      <description>
        
        
        &lt;hr&gt;
&lt;div class=&#34;module-body&#34;&gt; 
&lt;h3 id=&#34;interfaces&#34;&gt;Interfaces&lt;/h3&gt;
&lt;h4 id=&#34;itraceritracer&#34;&gt;&lt;a href=&#34;itracer&#34;&gt;ITracer&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;Interface for tracer components that capture operation traces.&lt;/p&gt;
&lt;br&gt;
&lt;h3 id=&#34;classes&#34;&gt;Classes&lt;/h3&gt;
&lt;h4 id=&#34;cachedtracercached_tracer&#34;&gt;&lt;a href=&#34;cached_tracer&#34;&gt;CachedTracer&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;Abstract tracer that caches recorded traces in memory and periodically dumps them.&lt;/p&gt;
&lt;h4 id=&#34;compositetracercomposite_tracer&#34;&gt;&lt;a href=&#34;composite_tracer&#34;&gt;CompositeTracer&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;Aggregates all tracers from component references under a single component.&lt;/p&gt;
&lt;h4 id=&#34;defaulttracerfactorydefault_tracer_factory&#34;&gt;&lt;a href=&#34;default_tracer_factory&#34;&gt;DefaultTracerFactory&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;Creates &lt;a href=&#34;itracer&#34;&gt;ITracer&lt;/a&gt; components by their descriptors.&lt;/p&gt;
&lt;h4 id=&#34;logtracerlog_tracer&#34;&gt;&lt;a href=&#34;log_tracer&#34;&gt;LogTracer&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;Tracer that dumps recorded traces to logger.&lt;/p&gt;
&lt;h4 id=&#34;nulltracernull_tracer&#34;&gt;&lt;a href=&#34;null_tracer&#34;&gt;NullTracer&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;Dummy implementation of tracer that doesn&amp;rsquo;t do anything.&lt;/p&gt;
&lt;h4 id=&#34;operationtraceoperation_trace&#34;&gt;&lt;a href=&#34;operation_trace&#34;&gt;OperationTrace&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;Data object to store captured operation traces.&lt;/p&gt;
&lt;h4 id=&#34;tracetimingtrace_timing&#34;&gt;&lt;a href=&#34;trace_timing&#34;&gt;TraceTiming&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;Timing object returned by &lt;a href=&#34;itracer/#beginTrace&#34;&gt;ITracer.BeginTrace&lt;/a&gt; to end timing
of execution block and record the associated trace.&lt;/p&gt;
&lt;/div&gt;

      </description>
    </item>
    
  </channel>
</rss>
