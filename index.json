[{"content":"Implements: RestOperations\nDescription The AboutOperations class is used to obtain information about running services.\nMethods About Gets information from a service. Send JSON string with information about the service.\n (c *AboutOperations) About(res http.ResponseWriter, req *http.Request)\n  res: http.ResponseWriter - an HTTP request req: *http.Request - an HTTP response  GetAboutOperation Gets the service\u0026rsquo;s information.\n (c *AboutOperations) GetAboutOperation() func(res http.ResponseWriter, req *http.Request)\n  returns: func(res http.ResponseWriter, req *http.Request) - the about method  SetReferences Sets the references of the service.\n (c *AboutOperations) SetReferences(references crefer.IReferences)\n  references: crefer.IReferences - service\u0026rsquo;s references.  ","description":"Class used to obtain information about running services.\n","image":null,"permalink":"/golang/rpc/services/about_operations/","subtitle":null,"tags":null,"title":"AboutOperations"},{"content":"Inherits: RestOperations\nDescription The AboutOperations class is used to obtain information about running services.\nInstance methods About Gets information from a service. Send JSON string with information about the service.\n public Task AboutAsync(HttpRequest request, HttpResponse response, ClaimsPrincipal user)\n  request: HttpRequest - an HTTP request. response: HttpResponse - an HTTP response. user: ClaimsPrincipal - to identify current user.  GetAboutOperation Gets the service\u0026rsquo;s information.\n public Func\u0026lt;HttpRequest, HttpResponse, ClaimsPrincipal, Task\u0026gt; GetAboutOperation()\n  returns: Func\u0026lt;HttpRequest, HttpResponse, ClaimsPrincipal, Task\u0026gt; - the about method  SetReferences Sets the references of the service.\n public void SetReferences([IReferences](../../../commons/refer/ireferences references)\n  references: IReferences - service\u0026rsquo;s references.  ","description":"Class used to obtain information about running services.\n","image":null,"permalink":"/net/rpc/services/about_operations/","subtitle":null,"tags":null,"title":"AboutOperations"},{"content":"Extends: RestOperations\nDescription The AboutOperations class is used to obtain information about running services.\nInstance methods about Gets information from a service. Send JSON string with information about the service.\n public about(req, res): void\n  req: any - an HTTP request res: any - an HTTP response  getAboutOperation Gets the service\u0026rsquo;s information.\n public getAboutOperation(): function\n  returns: function - the about method  setReferences Sets the references of the service.\n public setReferences(references: IReferences): void\n  references: IReferences - service\u0026rsquo;s references.  ","description":"Class used to obtain information about running services.\n","image":null,"permalink":"/node/rpc/services/about_operations/","subtitle":null,"tags":null,"title":"AboutOperations"},{"content":"Implements: RestOperations\nDescription The AboutOperations class is used to obtain information about running services.\nInstance methods get_about Gets information from a service.\n get_about(): str\n  returns: str - JSON string with information about the service.  get_about_operation Gets the service\u0026rsquo;s information.\n get_about_operation(): Callable\n  returns: Callable - get_about method  set_references Sets the references of the service.\n set_references(references: IReferences)\n  references: IReferences - service\u0026rsquo;s references.  ","description":"Class used to obtain information about running services.\n","image":null,"permalink":"/python/rpc/services/about_operations/","subtitle":null,"tags":null,"title":"AboutOperations"},{"content":"Inherits: IConfigurable, ICache, IReferenceable, IOpenable\nDescription TODO: add description\nProperties Timeout Gets or sets the timeout.\n public long Timeout { get; set; }\n Instance methods CloseAsync Configures component by passing configuration parameters.\n public virtual Task CloseAsync(string correlationId)\n  correlationId: string - (optional) transaction id to trace execution through call chain.  Configure Parameterized configuration template given as string with dynamic parameters.\n public virtual void Configure(ConfigParams config)\n  config: ConfigParams - Configuration parameters.  IsOpen Checks if component is opened\n public virtual bool IsOpen()\n  returns: bool - true if is opened  OpenAsync Opens component, establishes connections to services\n public virtual Task OpenAsync(string correlationId)\n  correlationId: string - a unique transaction id to trace calls across components  SetReferences Sets the references.\n public virtual void SetReferences(IReferences references)\n  references: IReferences - The references.  Abstract methods RemoveAsync Removes an object from cache.\n public abstract Task RemoveAsync(string correlationId, string key)\n  correlationId: string - a unique transaction id to trace calls across components key: string - Unique key identifying the object.  RemoveAsync Retrieves a value from cache by unique key.\n public abstract Task\u0026lt;T\u0026gt; RemoveAsync\u0026lt;T\u0026gt;(string correlationId, string key)\n  correlationId: string - a unique transaction id to trace calls across components key: string - Unique key identifying the object. returns: Task\u0026lt;T\u0026gt; - Cached value or null if the value is not found.  StoreAsync Stores an object identified by a unique key in cache.\n public abstract Task\u0026lt;T\u0026gt; StoreAsync\u0026lt;T\u0026gt;(string correlationId, string key, T value, long timeout)\n  correlationId: string - (optional) transaction id to trace execution through call chain. key: string - Unique key identifying a data object. value: T - The data object to store. timeout: long - Time to live for the object in milliseconds. returns: Task\u0026lt;T\u0026gt; - Cached value or null if the value is not stored.  See also   IConfigurable   ICache, IReferenceable   IOpenable   ","description":"Abstract cache class to provide common cache functionality\n","image":null,"permalink":"/net/components/cache/abstract_cache/","subtitle":null,"tags":null,"title":"AbstractCache"},{"content":"Inherits: IConfigurable, IReconfigurable\nDescription TODO: add description\nFields _dependencyResolver TODO: add description\n protected _dependencyResolver: DependencyResolver = new DependencyResolver()\n _logger TODO: add description\n protected _logger: CompositeLogger = new CompositeLogger()\n _counters TODO: add description\n protected _counters: CompositeCounters = new CompositeCounters()\n _counters TODO: add description\n protected _cache: ICache = new NullCache()\n  Properties Component TODO: add description\n public abstract string Component { get; }\n Instance methods Configure Configures component by passing configuration parameters.\n public virtual void Configure(ConfigParams config)\n  config: ConfigParams - configuration parameters to be set.  SetReferences Sets references to dependent components.\n public virtual void SetReferences(IReferences references)\n  references: IReferences - references to locate the component dependencies.  Instrument TODO: add description\n public virtual CounterTiming Instrument(string correlationId, string methodName, string message=\u0026quot;\u0026quot;)\n  correlationId: string - (optional) transaction id to trace execution through call chain. methodName: string - TODO: add description message: string - TODO: add description  HandleError TODO: add description\n public virtual void HandleError(string correlationId, string methodName, Exception ex)\n  correlationId: string - (optional) transaction id to trace execution through call chain. methodName: string - TODO: add description ex: Exception - TODO: add description  SafeInvokeAsync TODO: add description\n public virtual Task\u0026lt;T\u0026gt; SafeInvokeAsync\u0026lt;T\u0026gt;(string correlationId, string methodName, Func\u0026lt;Task\u0026lt;T\u0026gt;\u0026gt; invokeFunc, bool throwException=false)\n  correlationId: string - (optional) transaction id to trace execution through call chain. methodName: string - TODO: add description invokeFunc: Func\u0026lt;Task\u0026lt;T\u0026gt;\u0026gt; - TODO: add description throwException: bool - TODO: add description  SafeInvokeAsync TODO: add description\n public virtual Task\u0026lt;T\u0026gt; SafeInvokeAsync\u0026lt;T\u0026gt;(string correlationId, string methodName, Func\u0026lt;Task\u0026lt;T\u0026gt;\u0026gt; invokeFunc, Func\u0026lt;Task\u0026lt;T\u0026gt;\u0026gt; errorHandlerFunc, bool throwException=false)\n  correlationId: string - (optional) transaction id to trace execution through call chain. methodName: string - TODO: add description invokeFunc: Func\u0026lt;Task\u0026lt;T\u0026gt;\u0026gt; - TODO: add description errorHandlerFunc: Func\u0026lt;Task\u0026lt;T\u0026gt;\u0026gt; - TODO: add description throwException: bool - TODO: add description  RetrieveFromCacheAsync TODO: add description\n public virtual Task\u0026lt;T\u0026gt; RetrieveFromCacheAsync\u0026lt;T\u0026gt;(string correlationId, string cacheKey)\n  correlationId: string - (optional) transaction id to trace execution through call chain. cacheKey: string - TODO: add description  StoreInCacheAsync TODO: add description\n public virtual Task\u0026lt;T\u0026gt; StoreInCacheAsync\u0026lt;T\u0026gt;(string correlationId, string cacheKey, T result)\n  correlationId: string - (optional) transaction id to trace execution through call chain. cacheKey: string - TODO: add description result: T - TODO: add description  RemoveFromCacheAsync TODO: add description\n public virtual Task RemoveFromCacheAsync(string correlationId, string id)\n  correlationId: string - (optional) transaction id to trace execution through call chain. id: string - TODO: add description  GetProjectionCacheKey TODO: add description\n public virtual string GetProjectionCacheKey(string id)\n  id: string - TODO: add description  GetCacheKey TODO: add description\n public virtual string GetCacheKey(string id)\n  id: string - TODO: add description  AuditCreateAsync TODO: add description\n public virtual Task AuditCreateAsync\u0026lt;T\u0026gt;(string correlationId, string collectionName, object createdObject, Func\u0026lt;Task\u0026lt;T\u0026gt;\u0026gt; auditFunc)\n  correlationId: string - (optional) transaction id to trace execution through call chain. collectionName: string - TODO: add description createdObject: object - TODO: add description auditFunc: Func\u0026lt;Task\u0026lt;T\u0026gt;\u0026gt; - TODO: add description  AuditUpdateAsync TODO: add description\n public virtual Task AuditUpdateAsync\u0026lt;T\u0026gt;(string correlationId, string collectionName, object oldObject, object updatedObject, Func\u0026lt;Task\u0026lt;T\u0026gt;\u0026gt; auditFunc)\n  correlationId: string - (optional) transaction id to trace execution through call chain. collectionName: string - TODO: add description oldObject: object - TODO: add description updatedObject: object - TODO: add description auditFunc: Func\u0026lt;Task\u0026lt;T\u0026gt;\u0026gt; - TODO: add description  AuditUpdateAsync TODO: add description\n public virtual Task AuditDeleteAsync\u0026lt;T\u0026gt;(string correlationId, string collectionName, object deletedObject, Func\u0026lt;Task\u0026lt;T\u0026gt;\u0026gt; auditFunc)\n  correlationId: string - (optional) transaction id to trace execution through call chain. collectionName: string - TODO: add description deletedObject: object - TODO: add description auditFunc: Func\u0026lt;Task\u0026lt;T\u0026gt;\u0026gt; - TODO: add description  See also   Logger   ILogger   LogMessage   ","description":"TODO: add description\n","image":null,"permalink":"/net/components/logic/abstract_controller/","subtitle":null,"tags":null,"title":"AbstractController"},{"content":"Description The class that contains \u0026ldquo;Id\u0026rdquo; property (with no dependencies to IIdentifiable).\nTODO: add description\nConstructors Creates a new instance of the file persistence component.\n public constructor(persister?: JsonFilePersister)\n  persister: JsonFilePersister - (optional) persister component that loads and saves data from/to a flat file.  Fields MaxPageSize TODO: add description\n protected MaxPageSize: int = 100\n _objects TODO: add description\n protected _objects: Dictionary\u0026lt;string, T\u0026gt;\n  Instance methods CreateAsync TODO: add description\n public virtual Task\u0026lt;T\u0026gt; CreateAsync(string correlationId, T @object)\n  correlationId: string - TODO: add description @object: T - TODO: add description  ClearAsync TODO: add description\n public virtual Task ClearAsync()\n DeleteAsync TODO: add description\n public virtual Task/ DeleteAsync(string correlationId, string id)\n  correlationId: string - TODO: add description id: string - TODO: add description  GetAsync TODO: add description\n public virtual Task\u0026lt;DataPage\u0026lt;T\u0026gt;\u0026gt; GetAsync(string correlationId, FilterParams filter, PagingParams paging)\n  correlationId: string - TODO: add description filter: FilterParams - TODO: add description paging: PagingParams - TODO: add description returns: Task\u0026lt;DataPage\u0026lt;T\u0026gt;\u0026gt; - TODO: add description  GetAsync TODO: add description\n public virtual Task\u0026lt;DataPage\u0026lt;object\u0026gt;\u0026gt; GetAsync(string correlationId, FilterParams filter, PagingParams paging, ProjectionParams projection)\n  correlationId: string - TODO: add description filter: FilterParams - TODO: add description paging: PagingParams - TODO: add description projection: ProjectionParams - TODO: add description returns: Task\u0026lt;DataPage\u0026lt;object\u0026gt;\u0026gt; - TODO: add description  GetByIdAsync TODO: add description\n public virtual Task\u0026lt;T\u0026gt; GetByIdAsync(string correlationId, string id)\n  correlationId: string - TODO: add description id: string - TODO: add description  TODO: add description\n public virtual Task\u0026lt;object\u0026gt; GetByIdAsync(string correlationId, string id, ProjectionParams projection)\n  correlationId: string - TODO: add description id: string - TODO: add description projection: ProjectionParams - TODO: add description  UpdateAsync TODO: add description\n public virtual Task\u0026lt;T\u0026gt; UpdateAsync(string correlationId, T @object)\n  correlationId: string - TODO: add description @object: T - TODO: add description  ModifyAsync TODO: add description\n public virtual Task\u0026lt;T\u0026gt; ModifyAsync(string correlationId, string id, AnyValueMap updateMap)\n  correlationId: string - TODO: add description id: string - TODO: add description updateMap: AnyValueMap - TODO: add description  ","description":"Abstract Mock DB Persistence (keep data in memory) with ability to test basic projections\n","image":null,"permalink":"/net/data/persistence/abstract_mockdb_persistence/","subtitle":null,"tags":null,"title":"AbstractMockDbPersistence\u003cT\u003e"},{"content":"Implements: ITokenizer\nDescription The AbstractTokenizer class defines a general tokenizer.\nFields _lastTokenType Last token type\n protected _lastTokenType: TokenType = TokenType.Unknown\n _nextToken Next token\n protected _nextToken: Token\n _scanner Scanner\n protected _scanner: IScanner\n commentState Comment state\n public commentState: ICommentState\n decodeStrings Boolean that defines the option to decode strings or not.\n public decodeStrings: boolean\n mergeWhitespaces Boolean that defines the option to unify white spaces.\n public mergeWhitespaces: boolean\n numberState Number state\n public numberState: INumberState\n quoteState Quote state\n public quoteState: IQuoteState\n skipComments Boolean that defines the option to skip comments.\n public skipComments: boolean\n skipEof Boolean that defines the option to skip EOF.\n public skipEof: boolean\n skipUnknown Boolean that defines the option to skip unknowns.\n public skipUnknown: boolean\n skipWhitespaces Boolean that defines the option to skip white spaces.\n public skipWhitespaces: boolean\n symbolState Symbol state\n public symbolState: ISymbolState\n unifyNumbers Boolean that defines the option to unify numbers.\n public unifyNumbers: boolean\n whitespaceState White space state.\n public whitespaceState: IWhitespaceState\n wordState Word state.\n public wordState: IWordState\n  Properties scanner Scanner\n public scanner(): IScanner\n  returns: IScanner - TODO: add description   public scanner(value: IScanner)\n  value: IScanner - TODO: add description  Instance methods clearCharacterStates Clears all character states.\n public clearCharacterStates(): void\n getCharacterState Gest the state for a given character.\n public getCharacterState(symbol: number): ITokenizerState\n  symbol: number - symbol returns: ITokenizerState - tokenizer state  hasNextToken Finds out if the tokenizer has a next token.\n public hasNextToken(): boolean\n  returns: boolean - true if it has a next token, false otherwise.  nextToken Gets the next token.\n public nextToken(): Token\n  returns: Token - next token  readNextToken Reads the next token.\n protected readNextToken(): Token\n  returns: Token - next token  setCharacterState Sets the characters state.\n public setCharacterState(fromSymbol: number, toSymbol: number, state: ITokenizerState): void\n  fromSymbol: number - first symbol toSymbol: number - last symbol state: ITokenizerState - tokenizer state  tokenizeBuffer Provides a token for a string buffer.\n public tokenizeBuffer(buffer: string): Token[]\n  buffer: string - buffer returns: Token[] - token  tokenizeBufferToStrings Creates a list of token values.\n public tokenizeBufferToStrings(buffer: string): string[]\n  buffer: string - buffer returns: string[] - list of token values  tokenizeStream Creates a list of tokens\n public tokenizeStream(scanner: IScanner): Token[]\n  scanner: IScanner - scanner returns: Token[] - list of tokens  tokenizeStreamToStrings Creates a list of token values.\n public tokenizeStreamToStrings(scanner: IScanner): string[]\n  scanner: IScanner - scanner returns: string[] - list of token values  ","description":"Defines a general tokenizer.\n","image":null,"permalink":"/node/expressions/tokenizers/abstract_tokenizer/","subtitle":null,"tags":null,"title":"AbstractTokenizer"},{"content":"Implements: IVariantOperations\nDescription The AbstractVariantOperations class allows you to implement abstract variant operations manager objects.\nInstance methods add Performs \u0026lsquo;+\u0026rsquo; operation for two variants.\n public add(value1: Variant, value2: Variant): Variant\n  value1: Variant - first operand for this operation. value2: Variant - second operand for this operation. returns: Variant - result variant object.  and Performs AND operation for two variants.\n public and(value1: Variant, value2: Variant): Variant\n  value1: Variant - first operand for this operation. value2: Variant - second operand for this operation. returns: Variant - result variant object.  div Performs \u0026lsquo;/\u0026rsquo; operation for two variants.\n public div(value1: Variant, value2: Variant): Variant\n  value1: Variant - first operand for this operation. value2: Variant - second operand for this operation. returns: Variant - result variant object.  equal Performs \u0026lsquo;=\u0026rsquo; operation for two variants.\n public equal(value1: Variant, value2: Variant): Variant\n  value1: Variant - first operand for this operation. value2: Variant - second operand for this operation. returns: Variant - result variant object.  getElement Performs [] operation for two variants.\n public getElement(value1: Variant, value2: Variant): Variant\n  value1: Variant - first operand for this operation. value2: Variant - second operand for this operation. returns: Variant - result variant object.  in Performs IN operation for two variants.\n public in(value1: Variant, value2: Variant): Variant\n  value1: Variant - first operand for this operation. value2: Variant - second operand for this operation. returns: Variant - result variant object.  less Performs \u0026lsquo;\u0026lt;\u0026rsquo; operation for two variants.\n public less(value1: Variant, value2: Variant): Variant\n  value1: Variant - first operand for this operation. value2: Variant - second operand for this operation. returns: Variant - result variant object.  lessEqual Performs \u0026lsquo;\u0026lt;=\u0026rsquo; operation for two variants.\n public lessEqual(value1: Variant, value2: Variant): Variant\n  value1: Variant - first operand for this operation. value2: Variant - second operand for this operation. returns: Variant - result variant object.  lsh Performs \u0026lsquo;\u0026laquo;\u0026rsquo; operation for two variants.\n public lsh(value1: Variant, value2: Variant): Variant\n  value1: Variant - first operand for this operation. value2: Variant - second operand for this operation. returns: Variant - result variant object.  mod Performs \u0026lsquo;%\u0026rsquo; operation for two variants.\n public mod(value1: Variant, value2: Variant): Variant\n  value1: Variant - first operand for this operation. value2: Variant - second operand for this operation. returns: Variant - result variant object.  more Performs \u0026lsquo;\u0026gt;\u0026rsquo; operation for two variants.\n public more(value1: Variant, value2: Variant): Variant\n  value1: Variant - first operand for this operation. value2: Variant - second operand for this operation. returns: Variant - result variant object.  moreEqual Performs \u0026lsquo;\u0026gt;=\u0026rsquo; operation for two variants.\n public moreEqual(value1: Variant, value2: Variant): Variant\n  value1: Variant - first operand for this operation. value2: Variant - second operand for this operation. returns: Variant - result variant object.  mul Performs \u0026lsquo;*\u0026rsquo; operation for two variants.\n public mul(value1: Variant, value2: Variant): Variant\n  value1: Variant - first operand for this operation. value2: Variant - second operand for this operation. returns: Variant - result variant object.  negative Performs unary \u0026lsquo;-\u0026rsquo; operation for a variant.\n public negative(value: Variant): Variant\n  value: Variant - first operand for this operation. returns: Variant - result variant object.  not Performs NOT operation for a variant.\n public not(value: Variant): Variant\n  value: Variant - first operand for this operation. returns: Variant - result variant object.  notEqual Performs \u0026lsquo;\u0026lt;\u0026gt;\u0026rsquo; operation for two variants.\n public notEqual(value1: Variant, value2: Variant): Variant\n  value1: Variant - first operand for this operation. value2: Variant - second operand for this operation. returns: Variant - result variant object.  or Performs OR operation for two variants.\n public or(value1: Variant, value2: Variant): Variant\n  value1: Variant - first operand for this operation. value2: Variant - second operand for this operation. returns: Variant - result variant object.  pow Performs \u0026lsquo;^\u0026rsquo; operation for two variants.\n public pow(value1: Variant, value2: Variant): Variant\n  value1: Variant - first operand for this operation. value2: Variant - second operand for this operation. returns: Variant - result variant object.  rsh Performs \u0026lsquo;\u0026raquo;\u0026rsquo; operation for two variants.\n public rsh(value1: Variant, value2: Variant): Variant\n  value1: Variant - first operand for this operation. value2: Variant - second operand for this operation. returns: Variant - result variant object.  sub Performs \u0026lsquo;-\u0026rsquo; operation for two variants.\n public sub(value1: Variant, value2: Variant): Variant\n  value1: Variant - first operand for this operation. value2: Variant - second operand for this operation. returns: Variant - result variant object.  typeToString Convert variant type to string representation\n protected typeToString(value: VariantType): string\n  value: VariantType - variant type to be converted. returns: string - string representation of the type.  xor Performs XOR operation for two variants.\n public xor(value1: Variant, value2: Variant): Variant\n  value1: Variant - first operand for this operation. value2: Variant - second operand for this operation. returns: Variant - result variant object.  Abstract methods convert Converts variant to specified type.\n public abstract convert(value: Variant, newType: VariantType): Variant\n  value: Variant - variant value to be converted. newType: VariantType - type of object to be returned. returns: Variant - converted Variant value.  ","description":"Implements an abstract variant operations manager object.\n","image":null,"permalink":"/node/expressions/variants/abstract_variant_operations/","subtitle":null,"tags":null,"title":"AbstractVariantOperations"},{"content":"Description The AndRule class allows you to validate combinations of rules created with AND logical operations.\nImportant points\n When one or more of the combined rules return errors, then this rule returns all the errors that appeared. When none of the combined rules returns errors, then this rule also returns no errors.  Constructors NewAndRule Creates a new validation rule and sets its values.\n NewAndRule(rules \u0026hellip;IValidationRule) *AndRule\n  rules: \u0026hellip;IValidationRule - list of rules to join with AND operator  Methods Validate Validates a given value against this rule.\n (c *AndRule) Validate(path string, schema ISchema, value interface{}) []*ValidationResult\n  path: string - dot notation path to the value. schema: ISchema - schema this rule is called from value: interface{} - value to be validated. results: []*ValidationResult - list with validation results to add new results.  Example schema = NewSchema() .WithRule(NewAndRule( NewValueComparisonRule(\u0026#34;GTE\u0026#34;, 1), NewValueComparisonRule(\u0026#34;LTE\u0026#34;, 10) )); schema.Validate(0); // Result: 0 must be greater or equal to 1 schema.Validate(5); // Result: no error schema.Validate(20); // Result: 20 must be letter or equal 10  See also   IValidationRule   ","description":"Validation rule that allows you to check combinations of rules created with AND logical operations.\n","image":null,"permalink":"/golang/commons/validate/and_rule/","subtitle":null,"tags":null,"title":"AndRule"},{"content":"Inherits: IValidationRule\nDescription The AndRule class allows you to validate combinations of rules created with AND logical operations.\nImportant points\n When one or more of the combined rules return errors, then this rule returns all the errors that appeared. When none of the combined rules returns errors, then this rule also returns no errors.  Constructors Creates a new validation rule and sets its values.\n public AndRule(params IValidationRule[] rules)\n  rules: IValidationRule[] - list of rules to join with AND operator  Instance methods Validate Validates a given value against this rule.\n public void Validate(string path, Schema schema, object value, List\u0026lt;ValidationResult\u0026gt; results)\n  path: string - dot notation path to the value. schema: Schema - schema this rule is called from value: object - value to be validated. results: List\u0026lt;ValidationResult\u0026gt; - list with validation results to add new results.  Example var schema = new Schema().WithRule(new AndRule( new ValueComparisonRule(\u0026#34;GTE\u0026#34;, 1), new ValueComparisonRule(\u0026#34;LTE\u0026#34;, 10) )); schema.Validate(0); // Result: 0 must be greater or equal to 1 schema.Validate(5); // Result: no error schema.Validate(20); // Result: 20 must be letter or equal 10  See also   IValidationRule   ","description":"Validation rule that allows you to check combinations of rules created with AND logical operations.\n","image":null,"permalink":"/net/commons/validate/and_rule/","subtitle":null,"tags":null,"title":"AndRule"},{"content":"Implements: IValidationRule\nDescription The AndRule class allows you to validate combinations of rules created with AND logical operations.\nImportant points\n When one or more of the combined rules return errors, then this rule returns all the errors that appeared. When none of the combined rules returns errors, then this rule also returns no errors.  Constructors Creates a new validation rule and sets its values.\n public constructor(\u0026hellip;rules: IValidationRule[])\n  rules: IValidationRule[] - list of rules to join with the AND operator.  Instance methods validate Validates a given value against this rule.\n public validate(path: string, schema: Schema, value: any, results: ValidationResult[]): void\n  path: string - dot notation path to the value. schema: Schema - schema this rule is called from. value: any - value to be validated. results: IValidationRule[] - list with validation results to add new results.  Example let schema = Schema().withRule(AndRule(ValueComparisonRule(\u0026#34;GTE\u0026#34;, 1), ValueComparisonRule(\u0026#34;LTE\u0026#34;, 10))) schema.validate(0) // Result: 0 must be greater or equal to 1 schema.validate(5) // Result: no error schema.validate(20) // Result: 20 must be letter or equal 10  See also   IValidationRule   ","description":"Validation rule that allows you to check combinations of rules created with AND logical operations.\n","image":null,"permalink":"/node/commons/validate/and_rule/","subtitle":null,"tags":null,"title":"AndRule"},{"content":"Implements: IValidationRule\nDescription The AndRule class allows you to validate combinations of rules created with AND logical operations.\nImportant points\n When one or more of the combined rules return errors, then this rule returns all the errors that appeared. When none of the combined rules returns errors, then this rule also returns no errors.  Constructors Creates a new validation rule and sets its values.\n AndRule(*rules: IValidationRule)\n  rules: IValidationRule - a list of rules to join with AND operator  Instance methods validate Validates a given value against this rule.\n validate(path: str, schema: Schema, value: Any, results: List[ValidationResult])\n  path: str - a dot notation path to the value. schema: Schema - a schema this rule is called from value: Any - a value to be validated. results: List[ValidationResult] - a list with validation results to add new results.  Example schema = Schema().with_rule(AndRule(ValueComparisonRule(\u0026#34;GTE\u0026#34;, 1), ValueComparisonRule(\u0026#34;LTE\u0026#34;, 10))) schema.validate(0) # Result: 0 must be greater or equal to 1 schema.validate(5) # Result: no error schema.validate(20) # Result: 20 must be letter or equal 10 See also   IValidationRule   ","description":"Validation rule that allows you to check combinations of rules created with AND logical operations.\n","image":null,"permalink":"/python/commons/validate/and_rule/","subtitle":null,"tags":null,"title":"AndRule"},{"content":"Allows system administrators and product owners to communicate to users key system events and product updates. Each announcement:\n  Can be written in multiple languages\n  Can include pictures and document attachments\n  Supports editing lifecycle via status tracking\n  Server implementations: NodeJS\n  Communication protocols: Direct, Commandable HTTP, Commandable GRPC, GRPC\n  Persistence: Memory, Flat Files, MongoDB, Couchbase\n  Deployment options: Monolith, Process, Docker, AWS Lambda\n  Client implementations: NodeJS\n  This microservice has dependencies on the following microservices:\n Blobs Attachments - to reference pictures and documents associates with announcements  ","description":null,"image":null,"permalink":"/microservices/support/announcements/","subtitle":null,"tags":null,"title":"Announcements Microservice"},{"content":"Description The AnyValue class provides a cross-language implementation of a dynamic object that can hold a value of any type. In addition, it provides methods to convert the stored value to different types, such as string or integer.\nConstructors NewAnyValue Creates a new instance of the object and assigns its value.\n NewAnyValue(value interface{}) *AnyValue\n  value: interface{} - (optional) value to initialize this object.  NewEmptyAnyValue  NewEmptyAnyValue() *AnyValue\n Fields value The value stored by this object.\n value: interface{}\n  Methods Clone Creates a binary clone of this object.\n (c *AnyValue) Clone() interface{}\n  returns: interface{} - clone of this object.  Equals Compares this object value to a specified value. When direct comparison gives negative results it tries to compare values as strings.\n (c *AnyValue) Equals(obj interface{}) bool\n  obj: interface{} - value to be compared with. returns: bool - true when objects are equal and false otherwise.  EqualsAsType Compares this object value to a specified value. When direct comparison gives negative results it converts values to type specified by type code and compares them again. See TypeConverter.toType\n (c *AnyValue) EqualsAsType(typ convert.TypeCode, obj interface{}) bool\n  type: convert.TypeCode - value to be compared with. obj: interface{} - args to be compared with. returns: bool - true when objects are equal and false otherwise.  GetAsArray Converts an object value into an AnyArray or returns an empty AnyArray if the conversion is not possible.\nSee AnyValueArray.NewAnyValueArrayFromValue\n (c *AnyValue) GetAsArray() *AnyValueArray\n  returns: *AnyValueArray - AnyArray value or empty AnyArray if the conversion is not supported.  GetAsBoolean Converts an object value into a boolean or returns false if the conversion is not possible.\n (c *AnyValue) GetAsBoolean() bool\n  returns: bool - string value or false if the conversion is not supported.  GetAsBooleanWithDefault Converts an object value into a boolean or returns the default value if the conversion is not possible.\nSee BooleanConverter.ToBooleanWithDefault\n (c *AnyValue) GetAsBooleanWithDefault(defaultValue bool) bool\n  defaultValue: bool - default value. returns: bool - boolean value or default if the conversion is not supported.  GetAsDateTime Converts an object value into a Date or returns the current date if the conversion is not possible.\n (c *AnyValue) GetAsDateTime() time.Time\n  returns: time.Time - Date value or current date if conversion is not supported.  GetAsDateTimeWithDefault Converts an object value into a Date or returns the default value if the conversion is not possible.\nSee DateTimeConverter.ToDateTimeWithDefault\n (c *AnyValue) GetAsDateTimeWithDefault(defaultValue time.Time) time.Time\n  defaultValue: time.Time - default value. returns: time.Time - Date value or default value if the conversion is not supported.  GetAsDouble Converts an object value into a double or returns 0 if the conversion is not possible.\n (c *AnyValue) GetAsDouble() float64\n  returns: float64 - double value or 0 if conversion is not supported.  GetAsDoubleWithDefault Converts an object value into a double or returns a default value if the conversion is not possible. See DoubleConverter.ToDoubleWithDefault\n (c *AnyValue) GetAsDoubleWithDefault(defaultValue float64) float64\n  defaultValue: float64 - default value. returns: float64 - double value or default value if the conversion is not supported.  GetAsFloat Converts an object value into a float or returns 0 if the conversion is not possible.\n (c *AnyValue) GetAsFloat() float32\n  returns: float32 - float value or 0 if the conversion is not supported.  GetAsFloatWithDefault Converts an object value into a float or returns a default value if the conversion is not possible. See FloatConverter.ToFloatWithDefault\n (c *AnyValue) GetAsFloatWithDefault(defaultValue float32) float32\n  defaultValue: float32 - default value. returns: float32 - float value or default value if the conversion is not supported.  GetAsInteger Converts an object value into an integer or returns 0 if the conversion is not possible.\n (c *AnyValue) GetAsInteger() int\n  returns: int - integer value or 0 if the conversion is not supported.  GetAsIntegerWithDefault Converts an object value into an integer or returns a default value if the conversion is not possible. See IntegerConverter.ToIntegerWithDefault\n (c *AnyValue) GetAsIntegerWithDefault(defaultValue int) int\n  defaultValue: int - the default value. returns: int - integer value or default if conversion is not supported.  GetAsLong Converts an object value into a long or returns 0 if the conversion is not possible.\n (c *AnyValue) GetAsLong() int64\n  returns: int64 - long value or 0 if the conversion is not supported.  GetAsLongWithDefault Converts an object value into a long or returns a default value if the conversion is not possible. See LongConverter.ToLongWithDefault\n (c *AnyValue) GetAsLongWithDefault(defaultValue int64) int64\n  defaultValue: int64 - the default value. returns: int64 - long value or default if the conversion is not supported.  GetAsMap Converts an object value into AnyMap or returns an empty AnyMap if the conversion is not possible. See AnyValueMap.NewAnyValueMapFromValue\n (c *AnyValue) GetAsMap() *AnyValueMap\n  returns: *AnyValueMap - AnyMap value or empty AnyMap if the conversion is not supported.  GetAsNullableBoolean Converts an object value into a boolean or returns nil if the conversion is not possible.\nSee BooleanConverter.ToNullableBoolean\n (c *AnyValue) GetAsNullableBoolean() *bool\n  returns: *bool - boolean value or nil if the conversion is not supported.  GetAsNullableDateTime Converts an object value into a Date or returns nil if the conversion is not possible.\nSee DateTimeConverter.ToNullableDateTime\n (c *AnyValue) GetAsNullableDateTime() *time.Time\n  returns: *time.Time - Date value or nil if conversion is not supported.  GetAsNullableDouble Converts an object value into a double or returns nil if the conversion is not possible. See DoubleConverter.ToNullableDouble\n (c *AnyValue) GetAsNullableDouble() *float64\n  returns: *float64 - double value or nil if the conversion is not supported.  GetAsNullableFloat Converts an object value into a float or returns nil if the conversion is not possible. See FloatConverter.ToNullableFloat\n (c *AnyValue) GetAsNullableFloat() *float32\n  returns: *float32 - float value or nil if conversion is not supported.  GetAsNullableInteger Converts an object value into an integer or returns nil if the conversion is not possible.\nSee IntegerConverter.ToNullableInteger\n (c *AnyValue) GetAsNullableInteger() *int\n  returns: *int - integer value or nil if the conversion is not supported.  GetAsNullableLong Converts an object value into a long or returns nil if the conversion is not possible.\nSee LongConverter.ToNullableLong\n (c *AnyValue) GetAsNullableLong() *int64\n  returns: *int64 - long value or nil if conversion is not supported.  GetAsNullableString Converts an object value into a string or returns nil if the conversion is not possible. See StringConverter.ToNullableString\n (c *AnyValue) GetAsNullableString() *string\n  returns: *string - string value or nil if conversion is not supported.  GetAsNullableType Converts an object value into a value defined by a specified typecode. If the conversion is not possible it returns nil.\nSee TypeConverter.ToNullableType\n (c *AnyValue) GetAsNullableType(typ convert.TypeCode) interface{}\n  type: convert.TypeCode - TypeCode that defined the type of the result returns: interface{} - value defined by the typecode or nil if the conversion is not supported.  GetAsObject Gets the value stored in this object without any conversions.\n (c *AnyValue) GetAsObject() interface{}\n  returns: interface{} - object value.  GetAsString Converts an object value into a string or returns \u0026quot;\u0026quot; if the conversion is not possible.\n (c *AnyValue) GetAsString() string\n  returns: string - string value or \u0026quot;\u0026quot; if the conversion is not supported.  GetAsStringWithDefault Converts an object value into a string or returns a default value if the conversion is not possible.\n (c *AnyValue) GetAsStringWithDefault(defaultValue string) string\n  defaultValue: string - default value. returns: string - string value or default if the conversion is not supported.  GetAsType Converts an object value into a value defined by a specified typecode. If conversion is not possible it returns default value for the specified type.\n (c *AnyValue) GetAsType(typ convert.TypeCode) interface{}\n  typeCode: convert.TypeCode - TypeCode that defined the type of the result returns: interface{} - value defined by the typecode or type default value if the conversion is not supported.  GetAsTypeWithDefault Converts object value into a value defined by specied typecode. If conversion is not possible it returns a default value.\n (c *AnyValue) GetAsTypeWithDefault(typ convert.TypeCode, defaultValue interface{}) interface{}\n  typeCode: convert.TypeCode - TypeCode that defined the type of the result defaultValue: interface{} - default value returns: interface{} - value defined by the typecode or type default value if conversion is not supported.  TypeCode Gets type code for the value stored in this object.\nSee TypeConverter.toTypeCode\n (c *AnyValue) TypeCode() convert.TypeCod\n  returns: convert.TypeCod - type code of the object value.  SetAsObject Sets a new value for this object\n (c *AnyValue) SetAsObject(value interface{})\n  value: interface{} - new object value.  String Gets a string representation of the object.\nSee StringConverter.String\n (c *AnyValue) String() string\n  returns: string - string representation of the object.  Examples value := data.NewAnyValue(\u0026#34;123.456\u0026#34;) value.GetAsInteger() // Result: 123 value.GetAsString() // Result: \u0026#34;123.456\u0026#34; value.GetAsFloat() // Result: 123.456 See also   StringConverter   TypeConverter   BooleanConverter   IntegerConverter   LongConverter   DoubleConverter   FloatConverter   DateTimeConverter   ICloneable   ","description":"Cross-language implementation of a dynamic object that can hold a value of any type. It also provides methods to convert the stored value to different types.\n","image":null,"permalink":"/golang/commons/data/any_value/","subtitle":null,"tags":null,"title":"AnyValue"},{"content":"Inherits: ICloneable\nDescription The AnyValue class provides a cross-language implementation of a dynamic object that can hold a value of any type. In addition, it provides methods to convert the stored value to different types, such as string or integer.\nConstructors Creates a new instance of the object and assigns its value.\n public AnyValue(object value = null)\n  value: object - (optional) value used to initialize this object.  Creates a new instance of the object and assigns its value.\n public AnyValue(AnyValue value)\n  value: object - (optional) value to initialize this object.  Properties Value The value stored by this object.\n public object Value [ get, private set ]\n Instance methods Clone Creates a binary clone of this object.\n public object Clone()\n  returns: object - clone of this object.  Equals Compares this object\u0026rsquo;s value to a specified specified value. When a direct comparison gives a negative results it tries to compare values as strings.\n public override bool Equals(object obj)\n  obj: object - value to be compared with. returns: bool - true when objects are equal and false otherwise.  EqualsAs Compares this object\u0026rsquo;s value to a specified specified value. When direct comparison gives negative results it converts the values to a type specified by type code and compares them again.\nT - the class type. See TypeConverter.ToType\n public bool EqualsAs/(object obj)\n  obj: object - args to be compared with. returns: object - true when the objects are equal and false otherwise.  GetAsArray Converts an object\u0026rsquo;s value into an AnyArray or returns and empty AnyArray if the conversion is not possible.\nSee AnyValueArray.FromValue\n public AnyValueArray GetAsArray()\n  returns: AnyValueArray - AnyArray value or an empty AnyArray if the conversion is not supported.  GetAsBoolean Converts object value into a bool or returns false if the conversion is not possible.\n public bool GetAsBoolean()\n  returns: bool - string value or false if the conversion is not supported.  GetAsBooleanWithDefault Converts an object\u0026rsquo;s value into a bool or returns a given default value if the conversion is not possible.\nSee BooleanConverter.ToBooleanWithDefault\n public bool GetAsBooleanWithDefault(bool defaultValue)\n  defaultValue: bool - default value. returns: bool - bool value or a given default if the conversion is not supported.  GetAsDateTime Converts an object\u0026rsquo;s value into a DateTime or returns the current date if the conversion is not possible.\n public DateTime GetAsDateTime()\n  returns: DateTime - DateTime value or the current date if the conversion is not supported.  GetAsDateTimeWithDefault Converts an object\u0026rsquo;s value into a DateTime or returns a given default value if the conversion is not possible.\nSee DateTimeConverter.ToDateTimeWithDefault\n public DateTime GetAsDateTimeWithDefault(DateTime defaultValue)\n  defaultValue: DateTime - default value. returns: DateTime - DateTime value or a given default if the conversion is not supported.  GetAsNullableTimeSpan Converts an object\u0026rsquo;s value into TimeSpan or returns null if the conversion is not possible.\n public TimeSpan GetAsNullableTimeSpan()\n  returns: TimeSpan - TimeSpan value or null if the conversion is not possible.  GetAsTimeSpan Converts an object\u0026rsquo;s value into TimeSpan.\n public TimeSpan GetAsTimeSpan()\n  returns: TimeSpan - TimeSpan value.  GetAsTimeSpanWithDefault Converts an object\u0026rsquo;s value into TimeSpan or returns a given default if the conversion is not possible.\n public TimeSpan GetAsTimeSpanWithDefault(TimeSpan? defaultValue)\n  defaultValue: TimeSpan - default value returns: TimeSpan - TimeSpan value or a given default if the conversion is not possible.  GetAsNullableEnum Converts an object\u0026rsquo;s value into an Enum or returns null if the conversion is not possible.\n public T GetAsNullableEnum\u0026lt;T\u0026gt;()\n  returns: T - Enum or null if the conversion is not possible  GetAsEnum Converts an object\u0026rsquo;s value into an Enum.\n public T GetAsEnum\u0026lt;T\u0026gt;()\n  returns: T - Enum  GetAsEnumWithDefault Converts an object\u0026rsquo;s value into an Enum or returns a given default value is the conversion is not possible.\n public T GetAsEnumWithDefault\u0026lt;T\u0026gt;(T defaultValue)\n  defaultValue: T - default value returns: T - Enum or given default value if the conversion is not possible.  GetAsDouble Converts object value into a double or returns 0 if the conversion is not possible.\n public double GetAsDouble()\n  returns: double - double value or 0 if the conversion is not supported.  GetAsDoubleWithDefault Converts an object\u0026rsquo;s value into a double or returns a given default value if the conversion is not possible. See DoubleConverter.ToDoubleWithDefault\n public double GetAsDoubleWithDefault(double defaultValue)\n  defaultValue: double - default value. returns: double - double value or default if the conversion is not supported.  GetAsFloat Converts an object\u0026rsquo;s value into a float or returns 0 if the conversion is not possible.\n public float GetAsFloat()\n  returns: float - float value or 0 if the conversion is not supported.  GetAsFloatWithDefault Converts an object\u0026rsquo;s value into a float or returns a given default value if the conversion is not possible. See FloatConverter.ToFloatWithDefault\n public float GetAsFloatWithDefault(float defaultValue)\n  defaultValue: float - default value. returns: float - float value or given default value if the conversion is not supported.  GetAsInteger Converts an object\u0026rsquo;s value into an integer or returns 0 if the conversion is not possible.\n public int GetAsInteger()\n  returns: GetAsInteger - integer value or 0 if the conversion is not supported.  GetAsIntegerWithDefault Converts an object\u0026rsquo;s value into a integer or returns a given default value if the conversion is not possible. See IntegerConverter.ToIntegerWithDefault\n public int GetAsIntegerWithDefault(int defaultValue)\n  defaultValue: int - default value. returns: int - integer value or given default if the conversion is not supported.  GetAsLong Converts an object\u0026rsquo;s value into a long or returns 0 if the conversion is not possible.\n public long GetAsLong()\n  returns: long - long value or 0 if the conversion is not supported.  GetAsLongWithDefault Converts an object\u0026rsquo;s value into a long or returns a given default value if the conversion is not possible. See LongConverter.ToLongWithDefault\n public long GetAsLongWithDefault(long defaultValue)\n  defaultValue: long - default value. returns: long - long value or given default if the conversion is not supported.  GetAsMap Converts an object\u0026rsquo;s value into AnyMap or returns an empty AnyMap if the conversion is not possible. See AnyValueMap.FromValue\n public AnyValueMap GetAsMap()\n  returns: AnyValueMap - AnyMap value or empty AnyMap if the conversion is not supported.  GetAsNullableBoolean Converts an object\u0026rsquo;s value into a bool or returns null if the conversion is not possible.\nSee BooleanConverter.ToNullableBoolean\n public bool GetAsNullableBoolean()\n  returns: bool - bool value or null if conversion is not supported.  GetAsNullableDateTime Converts an object\u0026rsquo;s value into a DateTime or returns null if conversion is not possible.\nSee DateTimeConverter.ToNullableDateTime\n public DateTime sGetAsNullableDateTime()\n  returns: DateTime - DateTime value or null if the conversion is not supported.  GetAsNullableDouble Converts an object\u0026rsquo;s value into a double or returns null if the conversion is not possible. See DoubleConverter.ToNullableDouble\n public double GetAsNullableDouble()\n  returns: double - double value or null if the conversion is not supported.  GetAsNullableFloat Converts an object\u0026rsquo;s value into a float or returns null if the conversion is not possible. See FloatConverter.ToNullableFloat\n public float GetAsNullableFloat()\n  returns: float - float value or null if the conversion is not supported.  GetAsNullableInteger Converts an object\u0026rsquo;s value into an integer or returns null if the conversion is not possible.\nSee IntegerConverter.ToNullableInteger\n public int GetAsNullableInteger()\n  returns: int - integer value or null if the conversion is not supported.  GetAsNullableLong Converts an object\u0026rsquo;s value into a long or returns null if the conversion is not possible.\nSee LongConverter.ToNullableLong\n public long GetAsNullableLong()\n  returns: long - long value or null if the conversion is not supported.  GetAsNullableString Converts an object\u0026rsquo;s value into a string or returns null if the conversion is not possible. See StringConverter.ToNullableString\n public string GetAsNullableString()\n  returns: string - string value or null if the conversion is not supported.  GetAsNullableType Converts an object\u0026rsquo;s value into a value defined by specified typecode. If conversion is not possible, it returns null.\nT - the class type See TypeConverter.toNullableType\n public T GetAsNullableType\u0026lt;T\u0026gt;()\n  returns: T - value defined by the typecode or null if the conversion is not supported.  GetAsObject Gets the value stored in this object without any conversions.\n public object GetAsObject()\n  returns: object - object value.  GetAsString Converts an object\u0026rsquo;s value into a string or returns \u0026quot;\u0026quot; if the conversion is not possible.\n public string GetAsString()\n  returns: string - string value or \u0026quot;\u0026quot; if the conversion is not supported.  GetAsStringWithDefault Converts an object value into a string or returns a given default value if the conversion is not possible.\n public string GetAsStringWithDefault(string defaultValue)\n  defaultValue: string - default value. returns: string - string value or default if the conversion is not supported.  GetAsType Converts an object\u0026rsquo;s value into a value defined by specified typecode. If the conversion is not possible, it returns a given default value for the specified type. T - the class type.\n public T GetAsType\u0026lt;T\u0026gt;()\n  returns: string - value defined by the typecode or given type default value if the conversion is not supported.  GetAsTypeWithDefault Converts an object\u0026rsquo;s value into a value defined by a specified typecode. If conversion is not possible, it returns default value. T - the class type.\n public T GetAsTypeWithDefault\u0026lt;T\u0026gt;(T defaultValue)\n  defaultValue: T - default value returns: T - value defined by the typecode or given type default value if the conversion is not supported.  GsetTypeCode! Note: this method is not available for this language\nGets the type code for the value stored in this object.\nSee TypeConverter.ToTypeCode\n public TypeCode GetTypeCode()\n  returns: TypeCode - type code of the object\u0026rsquo;s value.  GetHashCode Gets an object hash code which can be used to optimize storing and searching.\nSee TypeConverter.ToTypeCode\n public override  int GetHashCode()\n  returns: int - object hash code.  SetAsObject Sets a new value for this object.\n public void SetAsObject(object value)\n  value: object - new object value.  ToString Gets a string representation of the object.\nSee StringConverter.ToString\n public override string ToString()\n  returns: string - string representation of the object.  Examples var value1 = new AnyValue(\u0026#34;123.456\u0026#34;); value1.GetAsInteger(); // Result: 123 value1.GetAsString(); // Result: \u0026#34;123.456\u0026#34; value1.GetAsFloat(); // Result: 123.456 See also   StringConverter   TypeConverter   BooleanConverter   IntegerConverter   LongConverter   DoubleConverter   FloatConverter   DateTimeConverter   ICloneable   ","description":"Cross-language implementation of a dynamic object that can hold a value of any type. It also provides methods to convert the stored value to different types.\n","image":null,"permalink":"/net/commons/data/any_value/","subtitle":null,"tags":null,"title":"AnyValue"},{"content":"Implements: ICloneable\nDescription The AnyValue class provides a cross-language implementation of a dynamic object that can hold a value of any type. In addition, it provides methods to convert the stored value to different types, such as string or integer.\nConstructors Creates a new instance of the object and assigns its value.\n public constructor(value: any = null)\n  value: any - (optional) value to initialize this object.  Fields value Value stored by this object.\n public value: any\n  Instance methods clone Creates a binary clone of this object.\n public clone(): any\n  returns: any - clone of this object.  equals Compares this object\u0026rsquo;s value to a specified specified value. When a direct comparison gives a negative result it tries to compare the values as strings.\n public equals(obj: any): boolean\n  obj: any - value to be compared with. returns: boolean - true when objects are equal and false otherwise.  equalsAsType Compares this object\u0026rsquo;s value to a specified value. When direct comparison gives a negative result it converts the values to a type specified by the type code and compares them again. See TypeConverter.toType\n public equalsAsType/(type: TypeCode, obj: any): boolean\n  type: TypeCode - value to be compared with. obj: Any - args to be compared with. returns: any - true when the objects are equal and false otherwise.  getAsArray Converts the object\u0026rsquo;s value into an AnyArray or returns an empty AnyArray if the conversion is not possible.\nSee AnyValueArray.fromValue\n public getAsArray(): AnyValueArray\n  returns: AnyValueArray - AnyArray value or empty AnyArray if the conversion is not supported.  getAsBoolean Converts an object\u0026rsquo;s value into a boolean or returns false if the conversion is not possible.\n public getAsBoolean(): boolean\n  returns: boolean - string value or false if the conversion is not supported.  getAsBooleanWithDefault Converts an object\u0026rsquo;s value into a boolean or returns a given default value if the conversion is not possible.\nSee BooleanConverter.toBooleanWithDefault\n public getAsBooleanWithDefault(defaultValue: boolean): boolean\n  defaultValue: boolean - default value. returns: boolean - boolean value or given default if the conversion is not supported.  getAsDateTime Converts an object\u0026rsquo;s value into Date or returns the current date if the conversion is not possible.\n public getAsDateTime(): Date\n  returns: Date - Date value or current date if the conversion is not supported.  getAsDateTimeWithDefault Converts an object\u0026rsquo;s value into Date or returns a given default value if the conversion is not possible.\nSee DateTimeConverter.toDateTimeWithDefault\n public getAsDateTimeWithDefault(defaultValue: Date): Date\n  defaultValue: Date - default value. returns: Date - Date value or given default if the conversion is not supported.  getAsDouble Converts an object\u0026rsquo;s value into a double or returns 0 if the conversion is not possible.\n public getAsDouble(): number\n  returns: number - double value or 0 if the conversion is not supported.  getAsDoubleWithDefault Converts an object\u0026rsquo;s value into a double or returns a default value if the conversion is not possible. See DoubleConverter.toDoubleWithDefault\n public getAsDoubleWithDefault(defaultValue: number): number\n  defaultValue: number - default value. returns: number - double value or default if the conversion is not supported.  getAsFloat Converts an object\u0026rsquo;s value into a float or returns 0 if the conversion is not possible.\n public getAsFloat(): number\n  returns: number - float value or 0 if the conversion is not supported.  getAsFloatWithDefault Converts an object\u0026rsquo;s value into a float or returns a given default value if the conversion is not possible. See FloatConverter.toFloatWithDefault\n public getAsFloatWithDefault(defaultValue: number): number\n  defaultValue: number - default value. returns: number - float value or default if the conversion is not supported.  getAsInteger Converts an object\u0026rsquo;s value into an integer or returns 0 if the conversion is not possible.\n public getAsInteger(): number\n  returns: number - integer value or 0 if the conversion is not supported.  getAsIntegerWithDefault Converts an object\u0026rsquo;s value into an integer or returns a given default value if conversion is not possible. See IntegerConverter.toIntegerWithDefault\n public getAsIntegerWithDefault(defaultValue: number): number\n  defaultValue: number - default value. returns: number - integer value or default if the conversion is not supported.  getAsLong Converts an object\u0026rsquo;s value into a long or returns 0 if the conversion is not possible.\n public getAsLong(): number\n  returns: number - long value or 0 if the conversion is not supported.  getAsLongWithDefault Converts an object\u0026rsquo;s value into a long or returns a given default value if the conversion is not possible. See LongConverter.toLongWithDefault\n public getAsLongWithDefault(defaultValue: number): number\n  defaultValue: number - default value. returns: number - long value or given default if the conversion is not supported.  getAsMap Converts an object\u0026rsquo;s value into AnyMap or returns an empty AnyMap object if the conversion is not possible. See AnyValueMap.fromValue\n public getAsMap(): AnyValueMap\n  returns: AnyValueMap - AnyMap value or empty AnyMap if the conversion is not supported.  getAsNullableBoolean Converts an object\u0026rsquo;s value into a boolean or returns null if the conversion is not possible.\nSee BooleanConverter.toNullableBoolean\n public getAsNullableBoolean(): boolean\n  returns: boolean - boolean value or null if the conversion is not supported.  getAsNullableDateTime Converts an object\u0026rsquo;s value into Date or returns null if the conversion is not possible.\nSee DateTimeConverter.toNullableDateTime\n public getAsNullableDateTime(): Date\n  returns: Date - Date value or null if the conversion is not supported.  getAsNullableDouble Converts an object\u0026rsquo;s value into a double or returns null if the conversion is not possible. See DoubleConverter.toNullableDouble\n public getAsNullableDouble(): number\n  returns: number - double value or null if the conversion is not supported.  getAsNullableFloat Converts an object\u0026rsquo;s value into a float or returns null if the conversion is not possible. See FloatConverter.toNullableFloat\n public getAsNullableFloat(): number\n  returns: number - float value or null if the conversion is not supported.  getAsNullableInteger Converts an object\u0026rsquo;s value into an integer or returns null if the conversion is not possible.\nSee IntegerConverter.toNullableInteger\n public getAsNullableInteger(): number\n  returns: number - integer value or null if the conversion is not supported.  getAsNullableLong Converts an object\u0026rsquo;s value into a long or returns null if the conversion is not possible.\nSee LongConverter.toNullableLong\n public getAsNullableLong(): number\n  returns: number - long value or null if the conversion is not supported.  getAsNullableString Converts an object\u0026rsquo;s value into a string or returns null if the conversion is not possible. See StringConverter.toNullableString\n public getAsNullableString(): string\n  returns: string - string value or null if the conversion is not supported.  getAsNullableType Converts an object\u0026rsquo;s value into a value defined by a specified typecode. If conversion is not possible it returns null.\nSee TypeConverter.toNullableType\n public getAsNullableType\u0026lt;T\u0026gt;(type: TypeCode): T\n  type: TypeCode - TypeCode that defined the type of the result returns: T - value defined by the typecode or null if the conversion is not supported.  getAsObject Gets the value stored in this object without any conversion.\n public getAsObject(): any\n  returns: any - object value.  getAsString Converts an object\u0026rsquo;s value into a string or returns \u0026quot;\u0026quot; if the conversion is not possible.\n public getAsString(): string\n  returns: string - string value or \u0026quot;\u0026quot; if the conversion is not supported.  getAsStringWithDefault Converts an object\u0026rsquo;s value into a string or returns a given default value if the conversion is not possible.\n public getAsStringWithDefault(defaultValue: string): string\n  defaultValue: string - default value. returns: string - string value or given default if the conversion is not supported.  getAsType Converts an object\u0026rsquo;s value into a value defined by a specifieded typecode. If conversion is not possible, it returns the default value for the specified type.\n public getAsType\u0026lt;T\u0026gt;(typeCode: TypeCode): T\n  typeCode: TypeCode - TypeCode that defines the type of the result returns: string - value defined by the typecode or type default value if the conversion is not supported.  getAsTypeWithDefault Converts an object\u0026rsquo;s value into a value defined by a specified typecode. If conversion is not possible, it returns the given default value.\n public getAsTypeWithDefault\u0026lt;T\u0026gt;(typeCode: TypeCode, defaultValue: T): T\n  typeCode: TypeCode - TypeCode that defines the type of the result defaultValue: T - default value returns: T - value defined by the typecode or given default value if the conversion is not supported.  getTypeCode Gets the type\u0026rsquo;s code for the value stored in this object.\nSee TypeConverter.toTypeCode\n public getTypeCode(): TypeCode\n  returns: TypeCode - type\u0026rsquo;s code of the object\u0026rsquo;s value.  hashCode Gets an object hash code which can be used to optimize storing and searching.\nSee TypeConverter.toTypeCode\n public hashCode(): number\n  returns: number - object hash code.  setAsObject Sets a new value for this object.\n public setAsObject(value: any): void\n  value: any - new object value.  toString Gets a string representation of the object.\nSee StringConverter.toString\n public toString(): string\n  returns: string - string representation of the object.  Examples let value1 = new AnyValue(\u0026#34;123.456\u0026#34;); value1.getAsInteger(); // Result: 123 value1.getAsString(); // Result: \u0026#34;123.456\u0026#34; value1.getAsFloat(); // Result: 123.456 See also   StringConverter   TypeConverter   BooleanConverter   IntegerConverter   LongConverter   DoubleConverter   FloatConverter   DateTimeConverter   ICloneable   ","description":"Cross-language implementation of a dynamic object that can hold a value of any type. It also provides methods to convert the stored value to different types.\n","image":null,"permalink":"/node/commons/data/any_value/","subtitle":null,"tags":null,"title":"AnyValue"},{"content":"Implements: ICloneable\nDescription The AnyValue class provides a cross-language implementation of a dynamic object that can hold a value of any type. In addition, it provides methods to convert the stored value to different types, such as string or integer.\nConstructors Creates a new instance of the object and assigns its value.\n AnyValue(value: Any = None)\n  value: Any - (optional) value to initialize this object.  Fields value The value stored by this object.\n value: Any\n  Instance methods clone Creates a binary clone of this object.\n clone(): Any\n  returns: Any - a clone of this object.  equals Compares this object value to specified specified value. When direct comparison gives negative results it tries to compare values as strings.\n equals(obj: Any): bool\n  obj: Any - the value to be compared with. returns: bool - true when objects are equal and false otherwise.  equals_as_type Compares this object value to specified specified value. When a direct comparison gives negative results it converts values to type specified by type code and compares them again. See TypeConverter.to_type\n equals_as_type(value_type: TypeCode, obj: Any): bool\n  type: TypeCode - the value to be compared with. obj: Any - the args to be compared with. returns: Any - true when objects are equal and false otherwise.  get_as_srray Converts object value into an AnyArray or returns empty AnyArray if conversion is not possible.\nSee AnyValueArray.from_value\n get_as_array(): AnyValueArray\n  returns: AnyValueArray - AnyArray value or empty AnyArray if conversion is not supported.  get_as_boolean Converts object value into a boolean or returns false if conversion is not possible.\n get_as_boolean(): bool\n  returns: bool - string value or false if conversion is not supported.  get_as_boolean_with_default Converts object value into a boolean or returns default value if conversion is not possible.\nSee BooleanConverter.to_boolean_with_default\n get_as_boolean_with_default(default_value: bool): bool\n  default_value: bool - the default value. returns: bool - boolean value or default if conversion is not supported.  get_as_datetime Converts object value into a Date or returns current date if conversion is not possible.\n get_as_datetime(): datetime\n  returns: datetime - Date value or current date if conversion is not supported.  get_as_datetime_with_default Converts object value into a Date or returns default value if conversion is not possible.\nSee DateTimeConverter.to_datetime_with_default\n get_as_datetime_with_default(default_value: datetime): datetime\n  default_value: datetime - the default value. returns: datetime - datetime value or default if conversion is not supported.  get_as_double Converts object value into a double or returns 0 if conversion is not possible.\n get_as_double(): float\n  returns: float - double value or 0 if conversion is not supported.  get_as_double_with_default Converts object value into a double or returns default value if conversion is not possible. See DoubleConverter.to_double_with_default\n to_double_with_default(default_value: float): float\n  default_value: float - the default value. returns: float - double value or default if conversion is not supported.  get_as_float Converts object value into a float or returns 0 if conversion is not possible.\n get_as_float(): float\n  returns: float - float value or 0 if conversion is not supported.  get_as_float_with_default Converts object value into a float or returns default value if conversion is not possible. See FloatConverter.to_float_with_default\n get_as_float_with_default(default_value: float): float\n  default_value: float - the default value. returns: float - float value or default if conversion is not supported.  get_as_integer Converts object value into an integer or returns 0 if conversion is not possible.\n get_as_integer(): int\n  returns: int - integer value or 0 if conversion is not supported.  get_as_integer_with_default Converts object value into a integer or returns default value if conversion is not possible. See IntegerConverter.to_integer_with_default\n get_as_integer_with_default(default_value: int): int\n  default_value: int - the default value. returns: int - integer value or default if conversion is not supported.  get_as_long Converts object value into a long or returns 0 if conversion is not possible.\n get_as_long(): float\n  returns: float - long value or 0 if conversion is not supported.  get_as_long_with_default Converts object value into a long or returns default value if conversion is not possible. See LongConverter.to_long_with_default\n get_as_long_with_default(default_value: float): float\n  default_value: float - the default value. returns: float - long value or default if conversion is not supported.  get_as_map Converts object value into AnyMap or returns empty AnyMap if conversion is not possible. See AnyValueMap.from_value\n get_as_map(): AnyValueMap\n  returns: AnyValueMap - AnyMap value or empty AnyMap if conversion is not supported.  get_as_nullable_boolean Converts object value into a boolean or returns None if conversion is not possible.\nSee BooleanConverter.toNullableBoolean\n get_as_nullable_boolean(): Optional[bool]\n  returns: Optional[bool] - boolean value or None if conversion is not supported.  get_as_nullable_datetime Converts object value into a Date or returns None if conversion is not possible.\nSee DateTimeConverter.to_nullable_datetime\n get_as_nullable_datetime(): Optional[datetime]\n  returns: Optional[datetime] - Date value or None if conversion is not supported.  get_as_nullable_double Converts object value into a double or returns None if conversion is not possible. See DoubleConverter.to_nullable_double\n get_as_nullable_double(): Optional[float]\n  returns: Optional[float] - double value or None if conversion is not supported.  get_as_nullable_float Converts object value into a float or returns None if conversion is not possible. See FloatConverter.to_nullable_float\n get_as_nullable_float(): Optional[float]\n  returns: Optional[float] - float value or None if conversion is not supported.  get_as_nullable_integer Converts object value into an integer or returns None if conversion is not possible.\nSee IntegerConverter.to_nullable_integer\n get_as_nullable_integer(): Optional[int]\n  returns: Optional[int] - integer value or None if conversion is not supported.  get_as_nullable_long Converts object value into a long or returns None if conversion is not possible.\nSee LongConverter.to_nullable_long\n get_as_nullable_long(): Optional[float]\n  returns: Optional[float] - long value or None if conversion is not supported.  get_as_nullable_string Converts object value into a string or returns None if conversion is not possible. See StringConverter.to_nullable_string\n get_as_nullable_string(): Optional[str]\n  returns: Optional[str] - string value or None if conversion is not supported.  get_as_nullable_type Converts object value into a value defined by specied typecode. If conversion is not possible it returns None.\nSee TypeConverter.to_nullable_type\n get_as_nullable_type(value_type: TypeCode): Optional[Any]\n  value_type: TypeCode - the TypeCode that defined the type of the result returns: Optional[Any] - value defined by the typecode or None if conversion is not supported.  get_as_object Gets the value stored in this object without any conversion.\n get_as_object(): Any\n  returns: Any - the object value.  get_as_string Converts object value into a string or returns \u0026quot;\u0026quot; if conversion is not possible.\n get_as_string(): str\n  returns: str - string value or \u0026quot;\u0026quot; if conversion is not supported.  get_as_string_with_default Converts object value into a string or returns default value if conversion is not possible.\n get_as_string_with_default(default_value: str): str\n  default_value: str - the default value. returns: srt - string value or default if conversion is not supported.  get_as_type Converts object args into a args defined by specied typecode. If conversion is not possible it returns default args for the specified type.\n get_as_type(value_type: TypeCode): Any\n  value_type: TypeCode - the TypeCode that defined the type of the result returns: Any - args defined by the typecode or type default args if conversion is not supported.  get_as_type_with_default Converts object value into a value defined by specied typecode. If conversion is not possible it returns default value.\n get_as_type_with_default(value_type: TypeCode, default_value: Any): Any\n  value_type: TypeCode - the TypeCode that defined the type of the result default_value: Any - the default value returns: Any - value defined by the typecode or type default value if conversion is not supported.  get_type_code Gets type code for the value stored in this object.\nSee TypeConverter.to_type_code\n get_type_code(): TypeCode\n  returns: TypeCode - type code of the object value.  set_as_object Sets a new value for this object.\n set_as_object(value: Any)\n  value: Any - the new object value.  to_string Gets a string representation of the object.\nSee StringConverter.toString\n to_string(): str\n  returns: str - a string representation of the object.  Examples value1 = AnyValue(\u0026#34;123.456\u0026#34;) value1.get_as_integer() # Result: 123 value1.get_as_string() # Result: \u0026#34;123.456\u0026#34; value1.get_as_float() # Result: 123.456 See also   StringConverter   TypeConverter   BooleanConverter   IntegerConverter   LongConverter   DoubleConverter   FloatConverter   DateTimeConverter   ICloneable   ","description":"Cross-language implementation of a dynamic object that can hold a value of any type. It also provides methods to convert the stored value to different types.\n","image":null,"permalink":"/python/commons/data/any_value/","subtitle":null,"tags":null,"title":"AnyValue"},{"content":"Description The AnyValueArray class provides a cross-language implementation of a dynamic array object that can hold values of any type. In addition, it provides several methods to convert the stored values to different types, such as boolean, integer or datetime.\nConstructors NewAnyValueArray Creates a new instance of the array and assigns its value.\n NewAnyValueArray(values []interface{}) *AnyValueArray\n  values: []interface{} - (optional) values to initialize this array.  NewEmptyAnyValueArray Creates a new instance of the empty array.\n NewEmptyAnyValueArray() *AnyValueArray\n NewAnyValueArrayFromString Splits specified string into elements using a separator and assigns the elements to a newly created AnyValueArray.\n NewAnyValueArrayFromString(values string, separator string, removeDuplicates bool) *AnyValueArray\n  values: string - string value to be split and assigned to AnyValueArray separator: string - separator used to split the string removeDuplicates: bool - (optional) true to remove duplicated elements returns: *AnyValueArray - newly created AnyValueArray.  NewAnyValueArrayFromValues Splits specified string into elements using a separator and assigns the elements to a newly created AnyValueArray.\nSee ArrayConverter.ToNullableArray\n NewAnyValueArrayFromValues(values \u0026hellip;interface{}) *AnyValueArray\n  values: \u0026hellip;interface{} - value to be converted returns: *AnyValueArray - newly created AnyValueArray.  NewAnyValueArrayFromValue Creates a new AnyValueArray from a list of values\n NewAnyValueArrayFromValue(value interface{}) *AnyValueArray\n  values: interface{} - list of values to initialize the created AnyValueArray returns: *AnyValueArray - newly created AnyValueArray.  NewAnyValueArrayFromString Splits specified string into elements using a separator and assigns the elements to a newly created AnyValueArray.\n NewAnyValueArrayFromString(values string, separator string, removeDuplicates bool) *AnyValueArray\n  values: string - string value to be split and assigned to AnyValueArray separator: string - separator to split the string removeDuplicates: bool true to remove duplicated elements  Methods Append Appends new elements to this array.\n (c *AnyValueArray) Append(elements []interface{})\n  elements: []interface{} - list of elements to be added.  Clear Clears this array by removing all its elements.\n (c *AnyValueArray) Clear()\n Clone Creates a binary clone of this object.\n (c *AnyValueArray) Clone() interface{}\n  returns: interface{} - clone of this object.  Contains Checks if this array contains a value. The check uses direct comparison between elements and the specified value.\n (c *AnyValueArray) Contains(value interface{}) bool\n  value: interface{} - value to be checked returns: bool - true if this array contains the value or false otherwise.  ContainsAsType Checks if this array contains a value. The check before comparison converts elements and the value to type specified by type code.\nSee TypeConverter.ToType, TypeConverter.ToNullableType\n (c *AnyValueArray) ContainsAsType(typ convert.TypeCode, value interface{}) bool\n  typ: convert.TypeCode - type code that defines a type to convert values before comparison value: interface{} - value to be checked returns: bool - true if this array contains the value or false otherwise.  Get Gets an array element specified by its index.\n (c *AnyValueArray) Get(index int) interface{}\n  index: int - index of the element to get. returns: interface{} - value of the array element.  GetAsArray Converts an array element into an AnyValueArray or returns an empty AnyValueArray if the conversion is not possible.\n (c *AnyValueArray) GetAsArray(index int) *AnyValueArray\n  index: int - index of element to get. returns: *AnyValueArray - AnyValueArray value of the element or empty AnyValueArray if conversion is not supported.  GetAsArrayWithDefault Converts an array element into an AnyValueArray or returns a default value if the conversion is not possible.\n (c *AnyValueArray) GetAsArrayWithDefault(index int, defaultValue *AnyValueArray) *AnyValueArray\n  index: int - index of element to get. defaultValue: *AnyValueArray - default value returns: *AnyValueArray - AnyValueArray value of the element or default value if the conversion is not supported.  GetAsBoolean Converts an array element into a boolean or returns false if theconversion is not possible.\n (c *AnyValueArray) GetAsBoolean(index int) bool\n  index: int - index of element to get. returns: bool - boolean value ot the element or false if the conversion is not supported.  GetAsBooleanWithDefault Converts an array element into a boolean or returns a default value if the conversion is not possible.\nSee BooleanConverter.ToBooleanWithDefault\n (c *AnyValueArray) GetAsBooleanWithDefault(index int, defaultValue bool) bool\n  index: int - index of element to get. defaultValue: bool - default value returns: bool - boolean value ot the element or default value if the conversion is not supported.  GetAsDateTime Converts an array element into a Date or returns the current date if the conversion is not possible.\n (c *AnyValueArray) GetAsDateTime(index int) time.Time\n  index: int - index of element to get. returns: time.Time - Date value ot the element or the current date if the conversion is not supported.  GetAsDateTimeWithDefault Converts an array element into a Date or returns a default value if the conversion is not possible.\nSee DateTimeConverter.ToDateTimeWithDefault\n (c *AnyValueArray) GetAsDateTimeWithDefault(index int, defaultValue time.Time) time.Time\n  index: int - index of element to get. defaultValue: time.Time - default value returns: time.Time - Date value ot the element or default value if the conversion is not supported.  GetAsDouble Converts an array element into a double or returns 0 if the conversion is not possible.\n (c *AnyValueArray) GetAsDouble(index int) float64\n  index: int - index of element to get. returns: float64 - double value ot the element or 0 if the conversion is not supported.  GetAsDoubleWithDefault Converts an array element into a double or returns a default value if the conversion is not possible.\n (c *AnyValueArray) GetAsDoubleWithDefault(index int, defaultValue float64) float64\n  index: int - index of element to get. defaultValue: float64 - default value returns: float64 - double value ot the element or default value if the conversion is not supported.  GetAsFloat Converts an array element into a float or returns 0 if the conversion is not possible.\n (c *AnyValueArray) GetAsFloat(index int) float32\n  index: int - index of element to get. returns: float32 - float value ot the element or 0 if the conversion is not supported.  GetAsFloatWithDefault Converts an array element into a float or returns a default value if the conversion is not possible.\nSee FloatConverter.ToFloatWithDefault\n (c *AnyValueArray) GetAsFloatWithDefault(index int, defaultValue float32) float32\n  index: int - index of the element to get. defaultValue: float32 - default value returns: float32 - float value ot the element or default value if conversion is not supported.  GetAsInteger Converts an array element into an integer or returns 0 if the conversion is not possible.\n (c *AnyValueArray) GetAsInteger(index int) int\n  index: int - index of the element to get. returns: int - integer value ot the element or 0 if the conversion is not supported.  GetAsIntegerWithDefault Converts an array element into an integer or returns a default value if the conversion is not possible.\nSee IntegerConverter.ToIntegerWithDefault\n (c *AnyValueArray) GetAsIntegerWithDefault(index int, defaultValue int) int\n  index: int - index of the element to get. defaultValue: int - default value returns: int - integer value ot the element or default value if the conversion is not supported.  GetAsLong Converts an array element into a long or returns 0 if the conversion is not possible.\n (c *AnyValueArray) GetAsLong(index int) int64\n  index: int - index of the element to get. returns: int64 - long value ot the element or 0 if the conversion is not supported.  GetAsLongWithDefault Converts an array element into a long or returns a default value if the conversion is not possible.\nSee LongConverter.ToLongWithDefault\n (c *AnyValueArray) GetAsLongWithDefault(index int, defaultValue int64) int64\n  index: int - index of the element to get. defaultValue: int64 - default value returns: int64 - long value ot the element or default value if the conversion is not supported.  GetAsMap Converts an array element into an AnyValueMap or returns an empty AnyValueMap if theconversion is not possible.\nSee AnyValueMap, AnyValueMap.NeFromValue\n (c *AnyValueArray) GetAsMap(index int) *AnyValueMap\n  index: int - index of the element to get. returns: *AnyValueMap - AnyValueMap value of the element or empty AnyValueMap if the conversion is not supported.  GetAsMapWithDefault Converts an array element into an AnyValueMap or returns a default value if the conversion is not possible.\n (c *AnyValueArray) GetAsMapWithDefault(index int, defaultValue *AnyValueMap) *AnyValueMap\n  index: int - index of the element to get. defaultValue: *AnyValueMap - default value returns: *AnyValueMap - AnyValueMap value of the element or default value if the conversion is not supported.  GetAsNullableArray Converts an array element into an AnyValueArray or returns nil if the conversion is not possible.\n (c *AnyValueArray) GetAsNullableArray(index int) *AnyValueArray\n  index: int - index of the element to get. returns: *AnyValueArray - AnyValueArray value of the element or nil if the conversion is not supported.  GetAsNullableBoolean Converts array element into a boolean or returns nil if the conversion is not possible.\nSee BooleanConverter.ToNullableBoolean\n (c *AnyValueArray) GetAsNullableBoolean(index int) *bool\n  index: int - index of the element to get. returns: *bool - boolean value of the element or nil if the conversion is not supported.  GetAsNullableDateTime Converts an array element into a Date or returns nil if the conversion is not possible.\nSee DateTimeConverter.ToNullableDateTime\n (c *AnyValueArray) GetAsNullableDateTime(index int) *time.Time\n  index: int - index of the element to get. returns: *time.Time - Date value of the element or nil if the conversion is not supported.  GetAsNullableDouble Converts an array element into a double or returns nil if the conversion is not possible.\nSee DoubleConverter.ToNullableDouble\n (c *AnyValueArray) GetAsNullableDouble(index int) *float64\n  index: int - index of the element to get. returns: *float64 - double value of the element or nil if the conversion is not supported.  GetAsNullableFloat Converts an array element into a float or returns nil if the conversion is not possible.\nSee FloatConverter.ToNullableFloat\n (c *AnyValueArray) GetAsNullableFloat(index int) *float32\n  index: int - index of element to get. returns: *float32 - float value of the element or nil if the conversion is not supported.  GetAsNullableInteger Converts an array element into a float or returns nil if the conversion is not possible.\nSee IntegerConverter.ToNullableInteger\n (c *AnyValueArray) GetAsNullableInteger(index int) *int\n  index: int - index of the element to get. returns: *int - integer value of the element or nil if the conversion is not supported.  GetAsNullableLong Converts an array element into a long or returns nil if the conversion is not possible.\nSee LongConverter.ToNullableLong\n (c *AnyValueArray) GetAsNullableLong(index int) *int64\n  index: int - index of the element to get. returns: *int64 - long value of the element or nil if the conversion is not supported.  GetAsNullableMap Converts an array element into a long or returns nil if the conversion is not possible.\nSee AnyValueMap, AnyValueMap\n (c *AnyValueArray) GetAsNullableMap(index int) *AnyValueMap\n  index: number - index of the element to get. returns: *AnyValueMap - AnyValueMap value of the element or nil if conversion is not supported.  GetAsNullableString Converts an array element into a string or returns nil if the conversion is not possible.\nSee StringConverter.ToNullableString,\n (c *AnyValueArray) GetAsNullableString(index int) *string\n  index: int - a index of element to get. returns: *string - string value of the element or nil if conversion is not supported.  GetAsNullableType Converts an array element into a value defined by a specified typecode. If conversion is not possible it returns nil.\nSee TypeConverter.ToNullableType\n (c *AnyValueArray) GetAsNullableType(typ convert.TypeCode, index int) interface{}\n  typ: convert.TypeCode - tTypeCode that defined the type of the result index: int - index of the element to get. returns: interface{} - element value defined by the typecode or nil if the conversion is not supported.  GetAsObject Gets the value stored in array element without any conversions. When element index is not defined it returns the entire array value.\n (c *AnyValueArray) GetAsObject(index int) interface{}\n  index: int - (optional) index of the element to get returns: interface{} - element value or value of the array when index is not defined.  GetAsString Converts an array element into a string or returns \u0026quot;\u0026quot; if the conversion is not possible.\n (c *AnyValueArray) GetAsString(index int) string\n  index: int - index of element to get. returns: string - string value ot the element or \u0026quot;\u0026quot; if the conversion is not supported.  GetAsStringWithDefault Converts an array element into a string or returns a default value if the conversion is not possible.\nSee StringConverter.ToStringWithDefault\n (c *AnyValueArray) GetAsStringWithDefault(index int, defaultValue string) string\n  index: int - index of the element to get. defaultValue: string - default value returns: string - string value ot the element or default value if the conversion is not supported.  GetAsType Converts an array element into a value defined by a specified typecode. If conversion is not possible it returns a default value for the specified type.\n (c *AnyValueArray) GetAsType(typ convert.TypeCode, index int) interface{}\n  typ: convert.TypeCode - TypeCode that defined the type of the result index: int - index of the element to get. returns: interface{} - element value defined by the typecode or default if the conversion is not supported.  GetAsTypeWithDefault Converts an array element into a value defined by a specivied typecode. If conversion is not possible it returns a default value for the specified type.\nSee TypeConverter.ToTypeWithDefault\n (c *AnyValueArray) GetAsTypeWithDefault(typ convert.TypeCode, index int, defaultValue interface{}) interface{}\n  type: convert.TypeCode - TypeCode that defined the type of the result index: int - index of element to get. defaultValue: interface{} - default value returns: interface{} - element value defined by the typecode or default value if the conversion is not supported.  GetAsValue Converts an array element into an AnyValue or returns an empty AnyValue if the conversion is not possible.\nSee AnyValue, AnyValues.constructors\n (c *AnyValueArray) GetAsValue(index int) *AnyValue\n  index: int - index of element to get. returns: *AnyValue - AnyValue value of the element or empty AnyValue if conversion is not supported.  InnerValue Returns the inner value of array as interface{}.\n (c *AnyValue) InnerValue() interface{}\n  returns: interface{} - inner value of arrays.  Value Returns array of elements []interface{}.\n (c *AnyValue) Value() interface{}\n  returns: interface{} - array of elements.  Put Puts a new value into an array element specified by its index.\n (c *AnyValueArray) Put(index int, value interface{})\n  index: int - index of the element to put. value: interface{} - new value for array element.  Remove Removes an array element specified by its index\n (c *AnyValueArray) Remove(index int)\n  index: int - index of the element to remove.  SetAsObject Sets a new value to an array element specified by its index. When the index is not defined, it resets the entire array value. This method has double purpose because method overrides are not supported in JavaScript.\nSee ArrayConverter.ToArray\n (c *AnyValueArray) SetAsObject(index int, value interface{})\n  index: int - (optional) index of the element to set value: interface{} - new element or array value.  String Gets a string representation of the object. The result is a comma-separated list of string representations of individual elements as \u0026ldquo;value1,value2,value3\u0026rdquo;\nSee StringConverter.ToString\n (c *AnyValueArray) String() string\n  returns: string - string representation of the object.  Examples value1 := NewAnyValueArray([1, \u0026#34;123.456\u0026#34;, \u0026#34;2018-01-01\u0026#34;]); value1.GetAsBoolean(0); // Result: true value1.GetAsInteger(1); // Result: 123 value1.GetAsFloat(1); // Result: 123.456 value1.GetAsDateTime(2); // Result: new Date(2018,0,1) See also   StringConverter   TypeConverter   StringConverter   BooleanConverter   IntegerConverter   LongConverter   DoubleConverter   FloatConverter   DateTimeConverter   ICloneable   ","description":"Cross-language implementation of a dynamic array object that can hold values of any type. It also provides methods to convert the stored values to different types.\n","image":null,"permalink":"/golang/commons/data/any_value_array/","subtitle":null,"tags":null,"title":"AnyValueArray"},{"content":"Inherits: ICloneable, List\u0026lt;object\u0026gt;\nDescription The AnyValueArray class provides a cross-language implementation of a dynamic array object that can hold values of any type. In addition, it provides several methods to convert the stored values to different types, such as boolean, integer or datetime.\nConstructors Creates a new instance of the array and assigns its value.\n public AnyValueArray(object[] values)\n  values: object[] - (optional) values used to initialize this array.  Creates a new instance of the array and assigns its value.\n public AnyValueArray(IEnumerable values)\n  values: IEnumerable - (optional) values used to initialize this array.  Creates a new instance of the array.\n public AnyValueArray()\n Instance methods Append Appends new elements to this array.\n public void Append(object[] values)\n  values: object[] - list of elements to be added.  Append Appends new elements to this array.\n public void Append(IEnumerable values)\n  values: IEnumerable - list of elements to be added.  Clone Creates a binary clone of this object.\n public object Clone()\n  returns: object - clone of this object.  Contains Checks if this array contains a value. The check uses direct comparison between elements and the specified value.\n public bool Contains(object value)\n  value: object - value to be checked returns: bool - true if this array contains the value or false otherwise.  ContainsAs Checks if this array contains a value. The check before comparison converts the elements and the value to type specified by the type code.\nSee TypeConverter.ToType, TypeConverter.ToNullableType\n public bool ContainsAs\u0026lt;T\u0026gt;(object value)\n  value: object - value to be checked returns: bool - true if this array contains the value or false otherwise.  Get Gets an array element specified by its index.\n public virtual object Get(int index)\n  index: int - index of the element to get. returns: object - value of the array element.  GetAsArray Converts an array element to an AnyValueArray or returns an empty AnyValueArray if the conversion is not possible.\n public AnyValueArray GetAsArray(int index)\n  index: int - index of the element to get. returns: AnyValueArray - AnyValueArray value of the element or empty an AnyValueArray if the conversion is not supported.  GetAsArrayWithDefault Converts an array element to an AnyValueArray or returns a given default value if the conversion is not possible.\n public AnyValueArray GetAsArrayWithDefault(int index, AnyValueArray defaultValue)\n  index: int - index of the element to get. defaultValue: AnyValueArray - default value returns: AnyValueArray - AnyValueArray value of the element or a given default value if the conversion is not supported.  GetAsBoolean Converts an array element to a bool or returns false if the conversion is not possible.\n public bool GetAsBoolean(int index)\n  index: int - index of the element to get. returns: bool - bool value ot the element or false if the conversion is not supported.  GetAsBooleanWithDefault Converts an array element to a bool or returns a given default value if the conversion is not possible.\nSee BooleanConverter.ToBooleanWithDefault\n public bool GetAsBooleanWithDefault(int index, bool defaultValue)\n  index: int - index of the element to get. defaultValue: bool - default value returns: bool - bool value ot the element or given default value if the conversion is not supported.  GetAsDateTime Converts an array element to a DateTime or returns the current date if the conversion is not possible.\n public DateTime GetAsDateTime(int index)\n  index: int - index of the element to get. returns: DateTime - DateTime value of the element or the current date if the conversion is not supported.  GetAsDateTimeWithDefault Converts an array element to a DateTime or returns a given default value if the conversion is not possible.\nSee DateTimeConverter.ToDateTimeWithDefault\n public DateTime GetAsDateTimeWithDefault(int index, DateTime defaultValue?)\n  index: int - index of the element to get. defaultValue: DateTime - default value returns: DateTime - DateTime value ot the element or given default value if the conversion is not supported.  GetAsNullableTimeSpan Converts an array element to TimeSpan or returns null if the conversion is not possible.\n public TimeSpan GetAsNullableTimeSpan(int index)\n  index: int - index of the element to get. returns: TimeSpan - TimeSpan or null if the conversion is not possible.  GetAsTimeSpan Converts an array element into TimeSpan.\n public TimeSpan GetAsTimeSpan(int index)\n  index: int - index of the element to get. returns: TimeSpan - TimeSpan  GetAsTimeSpanWithDefault Converts an array element to TimeSpan or returns a given default value if the conversion is not possible.\n public TimeSpan GetAsTimeSpanWithDefault(int index, TimeSpan? defaultValue)\n  index: int - index of the element to get. defaultValue: TimeSpan - given default value returns: TimeSpan - TimeSpan or given default value if the conversion is not possible.  GetAsNullableEnum Converts an array element to Enum or returns null if the conversion is not possible.\n public T GetAsNullableEnum\u0026lt;T\u0026gt;(int index)\n  index: int - index of the element to get. returns: T - Enum or null if the conversion is not possible.  GetAsEnum Converts an array element to Enum.\n public T GetAsEnum\u0026lt;T\u0026gt;(int index)\n  index: int - index of the element to get. returns: T - Enum.  GetAsEnumWithDefault Converts an array element to Enum or returns a givend default value if the conversion is not possible.\n public T GetAsEnumWithDefault\u0026lt;T\u0026gt;(int index, T defaultValue)\n  index: int - index of the element to get. defaultValue: T - default value returns: T - Enum or a given default value if the conversion is not possile.  GetAsDouble Converts an array element into a double or returns 0 if the conversion is not possible.\n public double GetAsDouble(int index)\n  index: int - index of the element to get. returns: double - double value ot the element or 0 if conversion is not supported.  GetAsDoubleWithDefault Converts array element into a double or returns a given default value if the conversion is not possible.\n public double GetAsDoubleWithDefault(int index, double defaultValue)\n  index: int - index of element to get. defaultValue: double - default value returns: double - double value of the element or a given default value if conversion is not supported.  GetAsFloat Converts an array element into a float or returns 0 if the conversion is not possible.\n public float GetAsFloat(int index)\n  index: int - index of element to get. returns: float - float value ot the element or 0 if the conversion is not supported.  GetAsFloatWithDefault Converts an array element into a float or returns a given default value if the conversion is not possible.\nSee FloatConverter.ToFloatWithDefault\n public float GetAsFloatWithDefault(int index, float defaultValue)\n  index: int - index of the element to get. defaultValue: float - default value returns: float - float value of the element or given default value if the conversion is not supported.  GetAsInteger Converts an array element into an integer or returns 0 if the conversion is not possible.\n public int GetAsInteger(int index)\n  index: int - index of the element to get. returns: int - integer value of the element or 0 if the conversion is not supported.  GetAsIntegerWithDefault Converts array element into an integer or returns a given default value if the conversion is not possible.\nSee IntegerConverter.ToIntegerWithDefault\n public int GetAsIntegerWithDefault(int index, int defaultValue)\n  index: int - index of element to get. defaultValue: int - default value returns: int - integer value of the element or given default value if the conversion is not supported.  GetAsLong Converts an array element into a long or returns 0 if the conversion is not possible.\n public long getAsLong(int index)\n  index: int - index of element to get. returns: long - long value of the element or 0 if the conversion is not supported.  GetAsLongWithDefault Converts an array element into a long or returns a given default value if the conversion is not possible.\nSee LongConverter.ToLongWithDefault\n public long GetAsLongWithDefault(int index, long defaultValue)\n  index: int - index of element to get. defaultValue: long - default value returns: long - long value of the element or given default value if the conversion is not supported.  GetAsMap Converts an array element into an AnyValueMap or returns an empty AnyValueMap if the conversion is not possible.\nSee AnyValueMap, AnyValueMap.FromValue\n public AnyValueMap GetAsMap(int index)\n  index: int - index of the element to get. returns: AnyValueMap - AnyValueMap value of the element or an empty AnyValueMap if the conversion is not supported.  GetAsMapWithDefault Converts an array element into an AnyValueMap or returns a give default value if the conversion is not possible.\n public AnyValueMap GetAsMapWithDefault(int index, AnyValueMap defaultValue)\n  index: int - index of element to get. defaultValue: AnyValueMap - default value returns: AnyValueMap - AnyValueMap value of the element or given default value if the conversion is not supported.  GetAsNullableArray Converts an array element into an AnyValueArray or returns null if the conversion is not possible.\n public AnyValueArray GetAsNullableArray(int index)\n  index: int - index of the element to get. returns: AnyValueArray - AnyValueArray value of the element or null if the conversion is not supported.  GetAsNullableBoolean Converts array element into a bool or returns null if the conversion is not possible.\nSee BooleanConverter.ToNullableBoolean\n public bool GetAsNullableBoolean(int index)\n  index: int - index of element to get. returns: bool - bool value of the element or null if the conversion is not supported.  GetAsNullableDateTime Converts an array element into a DateTime or returns null if the conversion is not possible.\nSee DateTimeConverter.ToNullableDateTime\n public DateTime GetAsNullableDateTime(int index)\n  index: int - index of element to get. returns: DateTime - DateTime value of the element or null if the conversion is not supported.  GetAsNullableDouble Converts an array element into a double or returns null if the conversion is not possible.\nSee DoubleConverter.ToNullableDouble\n public double GetAsNullableDouble(int index)\n  index: int - index of the element to get. returns: double - double value of the element or null if the conversion is not supported.  GetAsNullableFloat Converts an array element into a float or returns null if the conversion is not possible.\nSee FloatConverter.ToNullableFloat\n public float GetAsNullableFloat(int index)\n  index: int - index of the element to get. returns: float - float value of the element or null if the conversion is not supported.  GetAsNullableInteger Converts an array element into a float or returns null if the conversion is not possible.\nSee IntegerConverter.ToNullableInteger\n public float GetAsNullableInteger(int index)\n  index: int - index of the element to get. returns: float - integer value of the element or null if the conversion is not supported.  GetAsNullableLong Converts an array element into a long or returns null if the conversion is not possible.\nSee LongConverter.ToNullableLong\n public long GetAsNullableLong(int index)\n  index: int - index of the element to get. returns: long - long value of the element or null if the conversion is not supported.  GetAsNullableMap Converts an array element into a long or returns null if the conversion is not possible.\nSee AnyValueMap, AnyValueMap\n public AnyValueMap GetAsNullableMap(int index)\n  index: int - index of the element to get. returns: AnyValueMap - AnyValueMap value of the element or null if the conversion is not supported.  GetAsNullableString Converts an array element into a string or returns null if the conversion is not possible.\nSee StringConverter.ToNullableString,\n public string GetAsNullableString(int index)\n  index: int - index of the element to get. returns: string - string value of the element or null if the conversion is not supported.  GetAsNullableType Converts an array element into a value defined by a specified typecode. If conversion is not possible, it returns null.\nSee TypeConverter.ToNullableType T - class type\n public T GetAsNullableType\u0026lt;T\u0026gt;(int index)\n  index: int - index of the element to get. returns: T - element value defined by the typecode or null if the conversion is not supported.  GetAsNullableTypeWithDefault Converts an array element into a value defined by specified typecode. If conversion is not possible, it returns a given default value. See TypeConverter.ToNullableType T - class type\n public T GetAsNullableType\u0026lt;T\u0026gt;(int index, T defaultValue)\n  index: int - index of the element to get. defaultValue: T - default value returns: T - value of element defined by the typecode or default value if the conversion is not supported.  GetAsObject Gets the value stored in this array element without any conversions.\n public object GetAsObject()\n  returns: object - value of the array element.  GetAsObject Gets the value stored in array element without any conversions. When element index is not defined, it returns the entire array value.\n public object GetAsObject(int index)\n  index: int - (optional) index of the element to get returns: object - element value or value of the array when the index is not defined.  GetAsString Converts an array element into a string or returns \u0026quot;\u0026quot; if the conversion is not possible.\n public string GetAsString(int index)\n  index: int - index of the element to get. returns: string - string value ot the element or \u0026quot;\u0026quot; if the conversion is not supported.  GetAsStringWithDefault Converts an array element into a string or returns a given default value if the conversion is not possible.\nSee StringConverter.ToStringWithDefault\n public string GetAsStringWithDefault(int index, string defaultValue)\n  index: int - index of the element to get. defaultValue: string - default value returns: string - string value ot the element or given default value if the conversion is not supported.  GetAsType! Note: this method is not available for this language\nConverts an array element into a value defined by a specified typecode. If the conversion is not possible, it returns default value for the specified type.\n public T GetAsType\u0026lt;T\u0026gt;(TypeCode type, int index)\n  type: TypeCode - TypeCode that defined the type of the result index: int - index of the element to get. returns: T - element value defined by the typecode or default if the conversion is not supported.  GetAsTypeWithDefault! Note: this method is not available for this language\nConverts an array element into a value defined by specied typecode. If conversion is not possible, it returns a given default value for the specified type.\nSee TypeConverter.toTypeWithDefault\n public T GetAsTypeWithDefault\u0026lt;T\u0026gt;(TypeCode type, int index, T defaultValue)\n  type: TypeCode - TypeCode that defined the type of the result index: int - index of the element to get. defaultValue: T - default value returns: T - element value defined by the typecode or given default value if the conversion is not supported.  GetAsValue Converts an array element into an AnyValue or returns an empty AnyValue if the conversion is not possible.\nSee AnyValue, AnyValues.constructors\n public AnyValue GetAsValue(int index)\n  index: int - index of the element to get. returns: AnyValue - AnyValue value of the element or empty AnyValue if the conversion is not supported.  Set Sets a new value into array element specified by its index.\n public virtual void Set(int index, object value)\n  index: int - index of the element to put. value: object - new value for array element.  SetAsObject Sets a new value for this array element. See ArrayConverter.ToArray\n public void SetAsObject(object value)\n  value: object - new element or array value.  SetAsObject Sets a new value to an array element specified by its index. When the index is not defined, it resets the entire array value. See ArrayConverter.toArray\n public void SetAsObject(int index, object value)\n  index: int - (optional) index of the element to set value: object - new element or array value.  ToString Gets a string representation of the object. The result is a comma-separated list of string representations of individual elements as \u0026ldquo;value1,value2,value3\u0026rdquo;\nSee StringConverter.ToString\n public override string ToString()\n  returns: string - string representation of the object.  Static methods FromString Splits a specified string into elements using a separator and assigns the elements to a newly created AnyValueArray.\n public static AnyValueArray FromString(string values, char separator, bool removeDuplicates)\n  values: string - string value to be split and assigned to AnyValueArray separator: char - separator to split the string removeDuplicates: bool - (optional) true to remove duplicated elements returns: AnyValueArray - newly created AnyValueArray.  FromString Splits a specified string into elements using a separator and assigns the elements to a newly created AnyValueArray.\n public static AnyValueArray FromString(string values, char separator)\n  values: string - string value to be split and assigned to AnyValueArray separator: char - separator to split the string returns: AnyValueArray - newly created AnyValueArray.  FromValue Splits a specified string into elements using a separator and assigns the elements to a newly created AnyValueArray.\nSee ArrayConverter.ToNullableArray\n public static AnyValueArray FromValue(object value)\n  values: object - value to be converted returns: AnyValueArray - newly created AnyValueArray.  FromValues Creates a new AnyValueArray from a list of values\n public static AnyValueArray FromValues(params object[] values)\n  values: object[] - list of values to initialize the created AnyValueArray returns: AnyValueArray - newly created AnyValueArray.  Examples var value1 = new AnyValueArray(new object[]{1, \u0026#34;123.456\u0026#34;, \u0026#34;2018-01-01\u0026#34;}); value1.GetAsBoolean(0); // Result: true value1.GetAsInteger(1); // Result: 123 value1.GetAsFloat(1); // Result: 123.456 value1.GetAsDateTime(2); // Result: new DateTime(2018,0,1) See also   StringConverter   TypeConverter   StringConverter   BooleanConverter   IntegerConverter   LongConverter   DoubleConverter   FloatConverter   DateTimeConverter   ICloneable   ","description":"Cross-language implementation of a dynamic array object that can hold values of any type. It also provides methods to convert the stored values to different types.\n","image":null,"permalink":"/net/commons/data/any_value_array/","subtitle":null,"tags":null,"title":"AnyValueArray"},{"content":"Extends: Array\u0026lt;any\u0026gt;\nImplements: ICloneable\nDescription The AnyValueArray class provides a cross-language implementation of a dynamic array object that can hold values of any type. In addition, it provides several methods to convert the stored values to different types, such as boolean, integer or datetime.\nConstructors Creates a new instance of the array and assigns its value.\n public constructor(values: any[] = null)\n  values: any[] - (optional) values used to initialize this array.  Instance methods append Appends new elements to this array.\n public append(elements: any[]): void\n  elements: any[] - list of elements to be added.  clear Clears this array by removing all its elements.\n public clear(): void\n clone Creates a binary clone of this object.\n public clone(): any\n  returns: any - clone of this object.  contains Checks if this array contains a value. The check uses direct comparison between the elements of the array and the specified value.\n public contains(value: any): boolean\n  value: any - value to be checked returns: boolean - true if this array contains the value or false otherwise.  containsAsType Checks if this array contains a value. The check converts elements and the value to type specified by type code before comparison.\nSee TypeConverter.toType, TypeConverter.toNullableType\n public containsAsType\u0026lt;T\u0026gt;(typeCode: TypeCode, value: any): boolean\n  typeCode: TypeCode - type code that defines a type to convert values before comparison value: any - value to be checked returns: boolean - true if this array contains the value or false otherwise.  get Gets an array element specified by its index.\n public get(index: number): any\n  index: number - index of the element to get. returns: any - value of the array element.  getAsArray Converts array element into an AnyValueArray or returns an empty AnyValueArray if the conversion is not possible.\n public getAsArray(index: number): AnyValueArray\n  index: number - index of the element to get. returns: AnyValueArray - AnyValueArray value of the element or empty AnyValueArray if the conversion is not supported.  getAsArrayWithDefault Converts array element into an AnyValueArray or returns a givne default value if conversion is not possible.\n public getAsArrayWithDefault(index: number, defaultValue: AnyValueArray): AnyValueArray\n  index: number - index of the element to get. defaultValue: AnyValueArray - default value returns: AnyValueArray - AnyValueArray value of the element or default value if the conversion is not supported.  getAsBoolean Converts an array\u0026rsquo;s element into a boolean or returns false if the conversion is not possible.\n public getAsBoolean(index: number): boolean\n  index: number - index of the element to get. returns: boolean - boolean value of the element or false if the conversion is not supported.  getAsBooleanWithDefault Converts an array\u0026rsquo;s element into a boolean or returns a given default value if the conversion is not possible.\nSee BooleanConverter.toBooleanWithDefault\n public getAsBooleanWithDefault(index: number, defaultValue: boolean): boolean\n  index: number - index of the element to get. defaultValue: boolean - default value returns: boolean - boolean value of the element or default value if the conversion is not supported.  getAsDateTime Converts an array\u0026rsquo;s element into Date or returns the current date if the conversion is not possible.\n public getAsDateTime(index: number): Date\n  index: number - index of the element to get. returns: Date - Date value ot the element or the current date if the conversion is not supported.  getAsDateTimeWithDefault Converts an array\u0026rsquo;s element into a Date or returns a given default value if the conversion is not possible.\nSee DateTimeConverter.toDateTimeWithDefault\n public getAsDateTimeWithDefault(index: number, defaultValue: Date): Date\n  index: number - index of the element to get. defaultValue: Date - default value returns: Date - Date value ot the element or given default value if theconversion is not supported.  getAsDouble Converts an array\u0026rsquo;s element into a double or returns 0 if the conversion is not possible.\n public getAsDouble(index: number): number\n  index: number - index of element to get. returns: number - double value of the element or 0 if the conversion is not supported.  getAsDoubleWithDefault Converts an array\u0026rsquo;s element into a double or returns a given default value if the conversion is not possible.\n public getAsDoubleWithDefault(index: number, defaultValue: number): number\n  index: number - index of the element to get. defaultValue: number - default value returns: number - double value of the element or given default value if the conversion is not supported.  getAsFloat Converts an array\u0026rsquo;s element into a float or returns 0 if the conversion is not possible.\n public getAsFloat(index: number): number\n  index: number - index of the element to get. returns: number - float value of the element or 0 if the conversion is not supported.  getAsFloatWithDefault Converts an array\u0026rsquo;s element into a float or returns a given default value if the conversion is not possible.\nSee FloatConverter.toFloatWithDefault\n public getAsFloatWithDefault(index: number, defaultValue: number): number\n  index: number - index of the element to get. defaultValue: number - default value returns: number - float value of the element or given default value if the conversion is not supported.  getAsInteger Converts an array\u0026rsquo;s element into an integer or returns 0 if the conversion is not possible.\n public getAsInteger(index: number): number\n  index: number - index of the element to get. returns: number - integer value of the element or 0 if the conversion is not supported.  getAsIntegerWithDefault Converts an array\u0026rsquo;s element into an integer or returns a given default value if the conversion is not possible.\nSee IntegerConverter.toIntegerWithDefault\n public getAsIntegerWithDefault(index: number, defaultValue: number): number\n  index: number - index of the element to get. defaultValue: number - default value returns: number - integer value of the element or default value if the conversion is not supported.  getAsLong Converts an array\u0026rsquo;s element into a long or returns 0 if the conversion is not possible.\n public getAsLong(index: number): number\n  index: number - index of the element to get. returns: number - long value ot the element or 0 if the conversion is not supported.  getAsLongWithDefault Converts an array\u0026rsquo;s element into a long or returns a given default value if the conversion is not possible.\nSee LongConverter.toLongWithDefault\n public getAsLongWithDefault(index: number, defaultValue: number): number\n  index: number - index of the element to get. defaultValue: number - default value returns: number - long value of the element or given default value if the conversion is not supported.  getAsMap Converts an array\u0026rsquo;s element into an AnyValueMap object or returns an empty AnyValueMap object if the conversion is not possible.\nSee AnyValueMap, AnyValueMap.fromValue\n public getAsMap(index: number): AnyValueMap\n  index: number - index of the element to get. returns: AnyValueMap - AnyValueMap value of the element or empty AnyValueMap object if conversion is not supported.  getAsMapWithDefault Converts an array\u0026rsquo;s element into an AnyValueMap oject or returns a given default value if the conversion is not possible.\n public getAsMapWithDefault(index: number, defaultValue: AnyValueMap): AnyValueMap\n  index: number - index of element to get. defaultValue: AnyValueMap - default value returns: AnyValueMap - AnyValueMap value of the element or given default value if the conversion is not supported.  getAsNullableArray Converts an array\u0026rsquo;s element into an AnyValueArray object or returns null if the conversion is not possible.\n public getAsNullableArray(index: number): AnyValueArray\n  index: number - index of the element to get. returns: AnyValueArray - AnyValueArray value of the element or null if the conversion is not supported.  getAsNullableBoolean Converts an array\u0026rsquo;s element into a boolean or returns null if the conversion is not possible.\nSee BooleanConverter.toNullableBoolean\n public getAsNullableBoolean(index: number): boolean\n  index: number - index of the element to get. returns: boolean - boolean value of the element or null if the conversion is not supported.  getAsNullableDateTime Converts an array\u0026rsquo;s element into a Date or returns null if the conversion is not possible.\nSee DateTimeConverter.toNullableDateTime\n public getAsNullableDateTime(index: number): Date\n  index: number - index of the element to get. returns: Date - Date value of the element or null if the conversion is not supported.  getAsNullableDouble Converts an array\u0026rsquo;s element into a double or returns null if the conversion is not possible.\nSee DoubleConverter.toNullableDouble\n public getAsNullableDouble(index: number): number\n  index: number - index of the element to get. returns: number - double value of the element or null if the conversion is not supported.  getAsNullableFloat Converts an array\u0026rsquo;s element into a float or returns null if the conversion is not possible.\nSee FloatConverter.toNullableFloat\n public getAsNullableFloat(index: number): number\n  index: number - index of the element to get. returns: number - float value of the element or null if the conversion is not supported.  getAsNullableInteger Converts an array\u0026rsquo;s element into a float or returns null if the conversion is not possible.\nSee IntegerConverter.toNullableInteger\n public getAsNullableInteger(index: number): number\n  index: number - index of the element to get. returns: number - integer value of the element or null if the conversion is not supported.  getAsNullableLong Converts an array\u0026rsquo;s element into a long or returns null if the conversion is not possible.\nSee LongConverter.toNullableLong\n public getAsNullableLong(index: number): number\n  index: number - index of the element to get. returns: number - long value of the element or null if the conversion is not supported.  getAsNullableMap Converts an array\u0026rsquo;s element into a long or returns null if the conversion is not possible.\nSee AnyValueMap, AnyValueMap\n public getAsNullableMap(index: number): AnyValueMap\n  index: number - index of the element to get. returns: AnyValueMap - AnyValueMap value of the element or null if the conversion is not supported.  getAsNullableString Converts an array\u0026rsquo;s element into a string or returns null if the conversion is not possible.\nSee StringConverter.toNullableString,\n public getAsNullableString(index: number): string\n  index: number - index of the element to get. returns: string - string value of the element or null if the conversion is not supported.  getAsNullableType Converts an array\u0026rsquo;s element into a value defined by a specified typecode. If conversion is not possible, it returns null.\nSee TypeConverter.toNullableType\n public getAsNullableType\u0026lt;T\u0026gt;(type: TypeCode, index: number): T\n  type: TypeCode - TypeCode that defines the type of the result index: number - index of the element to get. returns: T - element value defined by the typecode or null if the conversion is not supported.  getAsObject Gets the value stored in an array element without any conversion. When the element\u0026rsquo;s index is not defined, it returns the entire array value.\n public getAsObject(index: number = undefined): any\n  index: number - (optional) index of the element to get returns: any - element value or value of the array when the index is not defined.  getAsString Converts an array\u0026rsquo;s element into a string or returns \u0026quot;\u0026quot; if the conversion is not possible.\n public getAsString(index: number): string\n  index: number - index of the element to get. returns: string - string value ot the element or \u0026quot;\u0026quot; if the conversion is not supported.  getAsStringWithDefault Converts an array\u0026rsquo;s element into a string or returns a given default value if the conversion is not possible.\nSee StringConverter.toStringWithDefault\n public getAsStringWithDefault(index: number, defaultValue: string): string\n  index: number - index of the element to get. defaultValue: string - default value returns: string - string value of the element or given default value if the conversion is not supported.  getAsType Converts an array\u0026rsquo;s element into a value defined by a specified typecode. If conversion is not possible, it returns a given default value for the specified type.\n public getAsType\u0026lt;T\u0026gt;(type: TypeCode, index: number): T\n  type: TypeCode - TypeCode that defines the type of the result. index: number - index of the element to get. returns: T - element value defined by the typecode or given default if the conversion is not supported.  getAsTypeWithDefault Converts an array\u0026rsquo;s element into a value defined by a specified typecode. If conversion is not possible it returns default value for the specified type.\nSee TypeConverter.toTypeWithDefault\n public getAsTypeWithDefault\u0026lt;T\u0026gt;(type: TypeCode, index: number, defaultValue: T): T\n  type: TypeCode - TypeCode that defines the type of the result index: number - index of the element to get. defaultValue: T - default value returns: T - element value defined by the typecode or given default value if the conversion is not supported.  getAsValue Converts an array\u0026rsquo;s element into an AnyValue object or returns an empty AnyValue object if the conversion is not possible.\nSee AnyValue, AnyValues.constructors\n public getAsValue(index: number): AnyValue\n  index: number - index of element to get. returns: AnyValue - AnyValue value of the element or empty AnyValue object if the conversion is not supported.  put Puts a new value into an array\u0026rsquo;s element specified by its index.\n public put(index: number, value: any): void\n  index: number - index of the element to put. value: any - new value for the array\u0026rsquo;s element.  remove Removes an array\u0026rsquo;s element specified by its index\n public remove(index: number): void\n  index: number - index of the element to remove.  setAsObject Sets a new value to an array\u0026rsquo;s element specified by its index. When the index is not defined, it resets the entire array value. This method has double purpose because method overrides are not supported in JavaScript.\nSee ArrayConverter.toArray\n public setAsObject(index: any, value: any = undefined): void\n  index: number - (optional) index of the element to set. value: any - new element or array\u0026rsquo;s value.  toString Gets a string representation of the object. The result is a comma-separated list of string representations of individual elements as \u0026ldquo;value1,value2,value3\u0026rdquo;\nSee StringConverter.toString\n public toString(): string\n  returns: string - string representation of the object.  Static methods fromString Splits a specified string into elements using a separator and assigns the elements to a newly created AnyValueArray.\n public static fromString(values: string, separator: string, removeDuplicates: boolean = false): AnyValueArray\n  values: string - string value to be split and assigned to an AnyValueArray object. separator: string - separator to split the string. removeDuplicates: boolean - (optional) true to remove duplicated elements. returns: AnyValueArray - newly created AnyValueArray object.  fromValue Splits a specified string into elements using a separator and assigns the elements to a newly created AnyValueArray.\nSee ArrayConverter.toNullableArray\n public static fromValue(value: any): AnyValueArray\n  values: any - value to be converted returns: AnyValueArray - newly created AnyValueArray object.  fromValues Creates a new AnyValueArray object from a list of values.\n public static fromValues(\u0026hellip;values: any[]): AnyValueArray\n  values: any[] - list of values used to initialize the created AnyValueArray object. returns: AnyValueArray - newly created AnyValueArray object.  Examples let value1 = new AnyValueArray([1, \u0026#34;123.456\u0026#34;, \u0026#34;2018-01-01\u0026#34;]); value1.getAsBoolean(0); // Result: true value1.getAsInteger(1); // Result: 123 value1.getAsFloat(1); // Result: 123.456 value1.getAsDateTime(2); // Result: new Date(2018,0,1) See also   StringConverter   TypeConverter   StringConverter   BooleanConverter   IntegerConverter   LongConverter   DoubleConverter   FloatConverter   DateTimeConverter   ICloneable   ","description":"Cross-language implementation of a dynamic array object that can hold values of any type. It also provides methods to convert the stored values to different types.\n","image":null,"permalink":"/node/commons/data/any_value_array/","subtitle":null,"tags":null,"title":"AnyValueArray"},{"content":"Implements: ICloneable, list\nDescription The AnyValueArray class provides a cross-language implementation of a dynamic array object that can hold values of any type. In addition, it provides several methods to convert the stored values to different types, such as boolean, integer or datetime.\nConstructors Creates a new instance of the array and assigns its value.\n AnyValueArray(values: Sequence[Any] = None)\n  values: Sequence[Any] - (optional) values to initialize this array.  Instance methods appends Appends new elements to this array.\n appends(elements: List[Any])\n  elements: List[Any] - a list of elements to be added.  clear Clears this array by removing all its elements.\n clear()\n clone Creates a binary clone of this object.\n clone(): Any\n  returns: Any - a clone of this object.  contains Checks if this array contains a value. The check uses direct comparison between elements and the specified value.\n contains(value: Any): bool\n  value: Any - a value to be checked returns: bool - true if this array contains the value or false otherwise.  contains_as_type Checks if this array contains a value. The check before comparison converts elements and the value to type specified by type code.\nSee TypeConverter.to_type, TypeConverter.to_nullable_type\n contains_as_type(value_type: TypeCode, value: Any): bool\n  value_type: TypeCode - a type code that defines a type to convert values before comparison value: Any - a value to be checked returns: bool - true if this array contains the value or false otherwise.  get Gets an array element specified by its index.\n get(index: int): Any\n  index: int - an index of the element to get. returns: Any - the value of the array element.  get_as_array Converts array element into an AnyValueArray or returns empty AnyValueArray if conversion is not possible.\n get_as_array(index: int): AnyValueArray\n  index: int - an index of element to get. returns: AnyValueArray - AnyValueArray value of the element or empty AnyValueArray if conversion is not supported.  get_as_array_with_default Converts array element into an AnyValueArray or returns default value if conversion is not possible.\n get_as_array_with_default(index: int, default_value: AnyValueArray): AnyValueArray\n  index: int - an index of element to get. default_value: AnyValueArray - the default value returns: AnyValueArray - AnyValueArray value of the element or default value if conversion is not supported.  get_as_boolean Converts array element into a boolean or returns false if conversion is not possible.\n get_as_boolean(index: int): bool\n  index: int - an index of element to get. returns: bool - bool value ot the element or false if conversion is not supported.  get_as_boolean_with_default Converts array element into a boolean or returns default value if conversion is not possible.\nSee BooleanConverter.to_boolean_with_default\n get_as_boolean_with_default(index: int, default_value: bool): bool\n  index: int - an index of element to get. default_value: bool - the default value returns: bool - boolean value ot the element or default value if conversion is not supported.  get_as_datetime Converts array element into a Date or returns the current date if conversion is not possible.\n get_as_datetime(index: int): datetime\n  index: int - an index of element to get. returns: datetime - date value ot the element or the current date if conversion is not supported.  get_as_datetime_with_default Converts array element into a Date or returns default value if conversion is not possible.\nSee DateTimeConverter.to_datetime_with_default.\n get_as_datetime_with_default(index: int, default_value: datetime): datetime\n  index: int - an index of element to get. default_value: datetime - the default value returns: datetime - date value ot the element or default value if conversion is not supported.  get_as_double Converts array element into a double or returns 0 if conversion is not possible.\n get_as_double(index: int): float\n  index: int - an index of element to get. returns: float - double value ot the element or 0 if conversion is not supported.  get_as_double_with_default Converts array element into a double or returns default value if conversion is not possible.\n get_as_double_with_default(index: int, default_value: float): float\n  index: int - an index of element to get. default_value: float - the default value returns: float - double value ot the element or default value if conversion is not supported.  get_as_nullable_double Converts array element into a double or returns None if conversion is not possible.\n get_as_nullable_double(index: int): Optional[float]\n  index: int - an index of element to get. returns: Optional[float] - double value of the element or None if conversion is not supported.  get_as_float Converts array element into a float or returns 0 if conversion is not possible.\n get_as_float(index: int): float\n  index: int - an index of element to get. returns: float - float value ot the element or 0 if conversion is not supported.  get_as_float_with_default Converts array element into a float or returns default value if conversion is not possible.\nSee FloatConverter.to_float_with_default.\n get_as_float_with_default(index: int, default_value: float): float\n  index: int - an index of element to get. default_value: float - the default value. returns: float - number value ot the element or default value if conversion is not supported.  get_as_integer Converts array element into an integer or returns 0 if conversion is not possible.\n get_as_integer(index: int): int\n  index: int - an index of element to get. returns: int - integer value ot the element or 0 if conversion is not supported.  get_as_integer_with_default Converts array element into an integer or returns default value if conversion is not possible.\nSee IntegerConverter.to_integer_with_default.\n get_as_integer_with_default(index: int, default_value: int): int\n  index: int - an index of element to get. default_value: int - the default value. returns: int - integer value ot the element or default value if conversion is not supported.  get_as_long Converts array element into a long or returns 0 if conversion is not possible.\n get_as_long(index: int): float\n  index: int - an index of element to get. returns: float - long value ot the element or 0 if conversion is not supported.  get_as_long_with_default Converts array element into a long or returns default value if conversion is not possible.\nSee LongConverter.to_long_with_default\n get_as_long_with_default(index: int, default_value: float): float\n  index: int - an index of element to get. default_value: float - the default value returns: float - long value ot the element or default value if conversion is not supported.  get_as_map Converts array element into an AnyValueMap or returns empty AnyValueMap if conversion is not possible.\nSee AnyValueMap, AnyValueMap.from_value\n get_as_map(index: int): AnyValueMap\n  index: int - an index of element to get. returns: AnyValueMap - AnyValueMap value of the element or empty AnyValueMap if conversion is not supported.  get_as_map_with_default Converts array element into an AnyValueMap or returns default value if conversion is not possible.\n get_as_map_with_default(index: int, default_value: AnyValueMap): AnyValueMap\n  index: int - an index of element to get. default_value: AnyValueMap - the default value. returns: AnyValueMap - AnyValueMap value of the element or default value if conversion is not supported.  get_as_nullable_array Converts array element into an AnyValueArray or returns None if conversion is not possible.\n get_as_nullable_array(index: int): Optional[AnyValueArray]\n  index: int - an index of element to get. returns: Optional[AnyValueArray] - AnyValueArray value of the element or None if conversion is not supported.  get_as_nullable_boolean Converts array element into a boolean or returns None if conversion is not possible.\nSee BooleanConverter.to_nullable_boolean.\n get_as_nullable_boolean(index: int): Optional[bool]\n  index: int - an index of element to get. returns: Optional[bool] - boolean value of the element or None if conversion is not supported.  get_as_nullable_datetime Converts array element into a Date or returns None if conversion is not possible.\nSee DateTimeConverter.to_nullable_datetime.\n get_as_nullable_datetime(index: int): Optional[datetime]\n  index: int - an index of element to get. returns: Optional[datetime] - datetime value of the element or None if conversion is not supported.  get_as_nullable_double Converts array element into a double or returns None if conversion is not possible.\nSee DoubleConverter.to_nullable_double.\n get_as_nullable_double(index: int): Optional[float]\n  index: int - an index of element to get. returns: Optional[float] - double value of the element or None if conversion is not supported.  get_as_nullable_float Converts array element into a float or returns None if conversion is not possible.\nSee FloatConverter.to_nullable_float.\n get_as_nullable_float(index: int): Optional[float]\n  index: int - an index of element to get. returns: Optional[float] - float value of the element or None if conversion is not supported.  get_as_nullable_integer Converts array element into a float or returns None if conversion is not possible.\nSee IntegerConverter.to_nullable_integer\n get_as_nullable_integer(index: int): Optional[int]\n  index: int - an index of element to get. returns: Optional[int] - integer value of the element or None if conversion is not supported.  get_as_nullable_long Converts array element into a long or returns None if conversion is not possible.\nSee LongConverter.to_nullable_long\n get_as_nullable_long(index: int): Optional[float]\n  index: int - an index of element to get. returns: Optional[float] - long value of the element or None if conversion is not supported.  get_as_nullable_map Converts array element into a long or returns None if conversion is not possible.\nSee AnyValueMap, AnyValueMap.from_value\n get_as_nullable_map(index: int): Optional[AnyValueMap]\n  index: int - an index of element to get. returns: Optional[AnyValueMap] - AnyValueMap value of the element or None if conversion is not supported.  get_as_nullable_string Converts array element into a string or returns None if conversion is not possible.\nSee StringConverter.to_nullable_string.\n get_as_nullable_string(index: int): str\n  index: int - an index of element to get. returns: str - string value of the element or None if conversion is not supported.  get_as_nullable_type Converts array element into a value defined by specied typecode. If conversion is not possible it returns None.\nSee TypeConverter.to_nullable_type.\n get_as_nullable_type(value_type: TypeCode, index: int): Any\n  value_type: TypeCode - the TypeCode that defined the type of the result. index: number - an index of element to get. returns: Any - element value defined by the typecode or None if conversion is not supported.  get_as_object Gets the value stored in array element without any conversions. When element index is not defined it returns the entire array value.\n get_as_object(index: int = None): Any\n  index: int - (optional) an index of the element to get returns: Any - the element value or value of the array when index is not defined.  get_as_string Converts array element into a string or returns \u0026quot;\u0026quot; if conversion is not possible.\n get_as_string(index: int): str\n  index: int = undefined - an index of element to get. returns: str - string value ot the element or \u0026quot;\u0026quot; if conversion is not supported.  get_as_string_with_default Converts array element into a string or returns default value if conversion is not possible.\nSee StringConverter.to_string_with_default\n get_as_string_with_default(index: int, default_value: str): str\n  index: int - an index of element to get. default_value: str - the default value returns: str - string value ot the element or default value if conversion is not supported.  get_as_type Converts array element into a value defined by specied typecode. If conversion is not possible it returns default value for the specified type.\n get_as_type(value_type: TypeCode, index: int): Any\n  value_type: TypeCode - the TypeCode that defined the type of the result index: int - an index of element to get. returns: Any - element value defined by the typecode or default if conversion is not supported.  get_as_type_with_default Converts array element into a value defined by a specied typecode. If conversion is not possible it returns default value for the specified type.\nSee TypeConverter.to_type_with_default.\n get_as_type_with_default(value_type: TypeCode, index: int, default_value: Any): Any\n  value_type: TypeCode - the TypeCode that defined the type of the result index: int - an index of element to get. default_value: Any - the default value. returns: Any - element value defined by the typecode or default value if conversion is not supported.  get_as_value Converts array element into an AnyValue or returns an empty AnyValue if conversion is not possible.\nSee AnyValue, AnyValues.constructors.\n get_as_value(index: int): AnyValue\n  index: int - an index of element to get. returns: AnyValue - AnyValue value of the element or empty AnyValue if conversion is not supported.  put Puts a new value into array element specified by its index.\n put(index: int, value: Any)\n  index: int - an index of the element to put. value: Any - a new value for array element.  remove Removes an array element specified by its index.\n remove(index: int)\n  index: int - an index of the element to remove.  set_as_object Sets a new value to array element specified by its index. When the index is not defined, it resets the entire array value. See ArrayConverter.to_array.\n set_as_object(index: int, value: Any = None)\n  index: int - (optional) an index of the element to set. value: Any - a new element or array value.  to_string Gets a string representation of the object. The result is a comma-separated list of string representations of individual elements as \u0026ldquo;value1,value2,value3\u0026rdquo;.\nSee StringConverter.to_string.\n to_string(): str\n  returns: str - a string representation of the object.  from_string Splits a specified string into elements using a separator and assigns the elements to a newly created AnyValueArray.\n static from_string(values: str, separator: str, removeDuplicates: bool = False): AnyValueArray\n  values: str - a string value to be split and assigned to AnyValueArray. separator: str - a separator to split the string. removeDuplicates: bool = false - (optional) true to remove duplicated elements. returns: AnyValueArray - a newly created AnyValueArray.  from_value Splits a specified string into elements using a separator and assigns the elements to a newly created AnyValueArray.\nSee ArrayConverter.to_nullable_array.\n static from_value(value: Any): AnyValueArray\n  values: Any - value to be converted returns: AnyValueArray - a newly created AnyValueArray.  from_values Creates a new AnyValueArray from a list of values.\n static from_values(*values: Any): AnyValueArray\n  values: Any - a list of values to initialize the created AnyValueArray returns: AnyValueArray - a newly created AnyValueArray.  to_string Gets a string representation of the object. The result is a comma-separated list of string representations of individual elements as \u0026ldquo;value1,value2,value3\u0026rdquo;.\nSee StringConverter.to_string.\n to_string(): str\n  returns: str - a string representation of the object.  Examples value1 = AnyValueArray([1, \u0026#34;123.456\u0026#34;, \u0026#34;2018-01-01\u0026#34;]) value1.get_as_boolean(0) # Result: true value1.get_as_integer(1) # Result: 123 value1.get_as_float(1) # Result: 123.456 value1.get_as_datetime(2) # Result: datetime.datetime(2018,0,1) See also   StringConverter   TypeConverter   StringConverter   BooleanConverter   IntegerConverter   LongConverter   DoubleConverter   FloatConverter   DateTimeConverter   ICloneable   ","description":"Cross-language implementation of a dynamic array object that can hold values of any type. It also provides methods to convert the stored values to different types.\n","image":null,"permalink":"/python/commons/data/any_value_array/","subtitle":null,"tags":null,"title":"AnyValueArray"},{"content":"Description The AnyValueMap class provides a cross-language implementation of a dynamic map (dictionary) object that can hold values of any type. In addition, it provides several methods to convert the stored values to different types, such as boolean, integer or datetime.\nConstructors NewAnyValueMap Creates a new instance of the map and assigns its value.\n NewAnyValueMap(value map[string]interface{}) *AnyValueMap\n  values: map[string]interface{} - (optional) values to initialize this map.  InheritAnyValueMap Creates a new instance of the map and assigns base methods from interface.\n InheritAnyValueMap(base IMap) *AnyValueMap\n  base: IMap - new map  NewEmptyAnyValueMap Creates a new empty instance of the map.\n NewEmptyAnyValueMap() *AnyValueMap\n NewAnyValueMapFromMaps Creates a new AnyValueMap by merging two or more maps. Maps defined later in the list override values from previously defined maps.\n NewAnyValueMapFromMaps(maps \u0026hellip;map[string]interface{}) *AnyValueMap\n  maps: \u0026hellip;map[string]interface{} - array of maps to be merged returns: *AnyValueMap - newly created AnyValueMap.  NewAnyValueMapFromTuples Creates a new AnyValueMap from a list of key-value pairs called tuples.\n NewAnyValueMapFromTuples(tuples \u0026hellip;interface{}) *AnyValueMap\n  tuples: \u0026hellip;interface{} - list of values where odd elements are keys and the following even elements are values. returns: *AnyValueMap - newly created AnyValueArray  NewAnyValueMapFromTuplesArray Creates a new AnyValueMap from a list of key-value pairs called tuples. The method is similar to NewAnyValueMapFromTuples but tuples are passed as array instead of parameters.\n NewAnyValueMapFromTuplesArray(tuples []interface{}) *AnyValueMap\n  tuples: []interface{} - list of values where odd elements are keys and the following even elements are values returns: *AnyValueMap - newly created AnyValueArray.  NewAnyValueMapFromValue Converts a specified value into AnyValueMap.\n NewAnyValueMapFromValue(value interface{}) *AnyValueMap\n  value: interface{} - value to be converted returns: *AnyValueMap - a newly created AnyValueMap.  Methods Append Appends new elements to this map.\n (c *AnyValueMap) Append(value map[string]interface{})\n  map: map[string]interface{} - map with added elements.  Clear Clears this map by removing all its elements.\n (c *AnyValueMap) Clear()\n Clone Creates a binary clone of this object.\n (c *AnyValueMap) Clone() interface{}\n  returns: interface{} - clone of this object.  Get Gets a map element specified by its key.\n (c *AnyValueMap) Get(key string) interface{}\n  key: string - key of the element to get. returns: interface{} - value of the map element.  GetAsArray Converts a map element into an AnyValueArray or returns empty AnyValueArray if the conversion is not possible.\nSee AnyValueArray, AnyValueArray.NewAnyValueArrayFromValue\n (c *AnyValueMap) GetAsArray(key string) *AnyValueArray\n  key: string - key of element to get. returns: *AnyValueArray - AnyValueArray value of the element or empty AnyValueArray if the conversion is not supported.  GetAsArrayWithDefault Converts a map element into an AnyValueArray or returns a default value if the conversion is not possible.\nSee AnyValueArray\n (c *AnyValueMap) GetAsArrayWithDefault(key string, defaultValue *AnyValueArray) *AnyValueArray\n  key: string - key of the element to get. defaultValue: *AnyValueArray - default value returns: *AnyValueArray - AnyValueArray value of the element or default value if the conversion is not supported.  GetAsBoolean Converts a map element into a boolean or returns false if the conversion is not possible.\n (c *AnyValueMap) GetAsBoolean(key string) bool\n  key: string - key of theelement to get. returns: bool - value of the element or false if the conversion is not supported.  GetAsBooleanWithDefault Converts a map element into a boolean or returns a default value if the conversion is not possible.\nSee BooleanConverter.ToBooleanWithDefault\n (c *AnyValueMap) GetAsBooleanWithDefault(key string, defaultValue bool) bool\n  key: string - key of the element to get. defaultValue: bool - default value returns: bool - boolean value of the element or default value if the conversion is not supported.  GetAsDateTime Converts a map element into a Date or returns the current date if the conversion is not possible.\n (c *AnyValueMap) GetAsDateTime(key string) time.Time\n  key: string - key of the element to get. returns: time.Time - Date value of the element or the current date if the conversion is not supported.  GetAsDateTimeWithDefault Converts a map element into a Date or returns a default value if the conversion is not possible.\nSee DateTimeConverter.ToDateTimeWithDefault\n (c *AnyValueMap) GetAsDateTimeWithDefault(key string, defaultValue time.Time) time.Time\n  key: string - key of element to get. defaultValue: time.Time - default value returns: time.Time - Date value of the element or default value if the conversion is not supported.  GetAsDouble Converts a map element into a double or returns 0 if conversion the is not possible.\n (c *AnyValueMap) GetAsDouble(key string) float64\n  key: string - key of element to get. returns: float64 - double value of the element or 0 if the conversion is not supported.  GetAsDoubleWithDefault Converts a map element into a double or returns a default value if the conversion is not possible.\nSee DoubleConverter.ToDoubleWithDefault\n (c *AnyValueMap) GetAsDoubleWithDefault(key string, defaultValue float64) float64\n  key: string - key of the element to get. defaultValue: float64 - default value returns: float64 - double value of the element or default value if the conversion is not supported.  GetAsFloat Converts a map element into a float or returns 0 if the conversion is not possible.\n (c *AnyValueMap) GetAsFloat(key string) float32\n  key: string - key of the element to get. returns: float32 - float value of the element or 0 if the conversion is not supported.  GetAsFloatWithDefault Converts a map element into a flot or returns a default value if the conversion is not possible.\nSee FloatConverter.ToFloatWithDefault\n (c *AnyValueMap) GetAsFloatWithDefault(key string, defaultValue float32) float32\n  key: string - key of the element to get. defaultValue: float32 - default value returns: float32 - flot value of the element or default value if the conversion is not supported.  GetAsInteger Converts a map element into an integer or returns 0 if the conversion is not possible.\n (c *AnyValueMap) GetAsInteger(key string) int\n  key: string - key of the element to get. returns: int - integer value of the element or 0 if the conversion is not supported.  GetAsIntegerWithDefault Converts a map element into an integer or returns a default value if the conversion is not possible.\nSee IntegerConverter.ToIntegerWithDefault\n (c *AnyValueMap) GetAsIntegerWithDefault(key string, defaultValue int) int\n  key: string - key of the element to get. defaultValue: int - default value returns: int - integer value of the element or default value if the conversion is not supported.  GetAsLong Converts a map element into a long or returns 0 if the conversion is not possible.\nSee IntegerConverter.ToIntegerWithDefault\n (c *AnyValueMap) GetAsLong(key string) int64\n  key: string - key of the element to get. returns: int64 - long value of the element or 0 if the conversion is not supported.  GetAsLongWithDefault Converts a map element into a long or returns a default value if the conversion is not possible.\nSee LongConverter.ToLongWithDefault\n (c *AnyValueMap) GetAsLongWithDefault(key string, defaultValue int64) int64\n  key: string - key of the element to get. defaultValue: int64 - default value returns: int64 - long value of the element or default value if the conversion is not supported.  GetAsMap Converts a map element into an AnyValueMap or returns anempty AnyValueMap if the conversion is not possible. See LongConverter.toLongWithDefault\n (c *AnyValueMap) GetAsMap(key string) *AnyValueMap\n  key: string - key of the element to get. returns: *AnyValueMap - AnyValueMap value of the element or empty AnyValueMap if the conversion is not supported.  GetAsMapWithDefault Converts a map element into an AnyValueMap or returns a default value if the conversion is not possible.\n (c *AnyValueMap) GetAsMapWithDefault(key string, defaultValue *AnyValueMap) *AnyValueMap\n  key: string - key of the element to get. defaultValue: *AnyValueMap - default value returns: *AnyValueMap - AnyValueMap value of the element or default value if the conversion is not supported.  GetAsNullableArray Converts a map element into an AnyValueArray or returns nil if the conversion is not possible.\nSee AnyValueMap, AnyValueMap.NewAnyValueMapFromValue\n (c *AnyValueMap) GetAsNullableArray(key string) *AnyValueMap\n  key: string - key of the element to get. returns: *AnyValueMap - AnyValueArray value of the element or nil if the conversion is not supported.  GetAsNullableBoolean Converts a map element into a boolean or returns nil if the conversion is not possible.\nSee BooleanConverter.ToNullableBoolean\n (c *AnyValueMap) GetAsNullableBoolean(key string) *bool\n  key: string - key of the element to get. returns: *bool - boolean value of the element or nil if the conversion is not supported.  GetAsNullableDateTime Converts a map element into a long or returns default value if the conversion is not possible.\nSee DateTimeConverter.ToNullableDateTime\n (c *AnyValueMap) GetAsNullableDateTime(key string) *time.Time\n  key: string - key of the element to get. returns: *time.Time - Date value of the element or nil if the conversion is not supported.  GetAsNullableDouble Converts a map element into a double or returns nil if the conversion is not possible.\nSee DoubleConverter.ToNullableDouble\n (c *AnyValueMap) GetAsNullableDouble(key string) *float64\n  key: string - key of the element to get. returns: *float64 - double value of the element or nil if conversion is not supported.  GetAsNullableFloat Converts a map element into a float or returns nil if the conversion is not possible. See FloatConverter.ToNullableFloat\n (c *AnyValueMap) GetAsNullableFloat(key string) *float32\n  key: string - key of the element to get. returns: *float32 - float value of the element or nil if the conversion is not supported.  GetAsNullableInteger Converts a map element into an integer or returns nil if the conversion is not possible.\nSee IntegerConverter.ToNullableInteger\n (c *AnyValueMap) GetAsNullableInteger(key string) *int\n  key: string - key of the element to get. returns: *int - integer value of the element or nil if the conversion is not supported.  GetAsNullableLong Converts a map element into a long or returns nil if the conversion is not possible.\nSee LongConverter.ToNullableLong\n (c *AnyValueMap) GetAsNullableLong(key string) *int64\n  key: string - key of the element to get. returns: *int64 - long value of the element or nil if the conversion is not supported.  GetAsNullableMap Converts a map element into an AnyValueMap or returns nil if the conversion is not possible.\n (c *AnyValueMap) GetAsNullableMap(key string) *AnyValueMap\n  key: string - key of the element to get. returns: *AnyValueMap - AnyValueMap value of the element or nil if the conversion is not supported.  GetAsNullableString Converts a map element into a string or returns nil if the conversion is not possible. See StringConverter.ToNullableString\n (c *AnyValueMap) GetAsNullableString(key string) *string\n  key: string - key of element to get. returns: *string - string value of the element or nil if the conversion is not supported.  GetAsNullableType Converts a map element into a value defined by a specified typecode. If conversion is not possible it returns nil. See TypeConverter.ToNullableType\n (c *AnyValueMap) GetAsNullableType(typ convert.TypeCode, key string) interface{}\n  typ: convert.TypeCode - TypeCode that defined the type of the result key: string - key of the element to get. returns: interface{} - element value defined by the typecode or nil if the conversion is not supported.  GetAsObject Gets the value stored in map element without any conversions. When element key is not defined it returns the entire map value.\n (c *AnyValueMap) GetAsObject(key string) interface{}\n  key: string - (optional) key of the element to get returns: interface{} - the element value or value of the map when index is not defined.  GetAsString Converts a map element into a string or returns \u0026quot;\u0026quot; if the conversion is not possible.\n (c *AnyValueMap) GetAsString(key string) string\n  key: string - key of the element to get. returns: string - string value of the element or \u0026quot;\u0026quot; if the conversion is not supported.  GetAsStringWithDefault Converts a map element into a string or returns default value if the conversion is not possible. See StringConverter.ToStringWithDefault\n (c *AnyValueMap) GetAsStringWithDefault(key string, defaultValue string) string\n  key: string - key of the element to get. defaultValue: string - default value returns: string - string value of the element or default value if the conversion is not supported.  GetAsType Converts a map element into a value defined by a specified typecode. If conversion is not possible it returns a default value for the specified type.\n (c *AnyValueMap) GetAsType(typ convert.TypeCode, key string) interface{}\n  type: convert.TypeCode - TypeCode that defined the type of the result key: string - key of element to get. returns: interface{} - element value defined by the typecode or default if the conversion is not supported.  GetAsTypeWithDefault Converts a map element into a value defined by a specified typecode. If conversion is not possible it returns a default value. See TypeConverter.ToTypeWithDefault\n (c *AnyValueMap) GetAsTypeWithDefault(typ convert.TypeCode, key string, defaultValue interface{}) interface{}\n  typ: convert.TypeCode - TypeCode that defined the type of the result key: string - key of element to get. defaultValue: interface{} - default value returns: interface{} - element value defined by the typecode or default value if the conversion is not supported.  GetAsValue Converts a map element into an AnyValue or returns an empty AnyValue if the conversion is not possible.\nSee AnyValue, AnyValue.constructors\n (c *AnyValueMap) GetAsValue(key string) *AnyValue\n  key: string - key of element to get. returns: *AnyValue - AnyValue value of the element or empty AnyValue if the conversion is not supported.  GetKeys Gets the keys of all elements stored in this map.\n (c *AnyValueMap) Keys() []string\n  returns: []string - list with all the map\u0026rsquo;s keys.  InnerValue Gets the type code for the value stored in this object.\n (c *AnyValue) InnerValue() interface{}\n  returns: interface{} - type code of the object value.  Value Gets type code for the value stored in this object.\n (c *AnyValue) Value() interface{}\n  returns: interface{} - type code of the object value.  Len Gets a number of elements stored in this map.\n (c *AnyValueMap) Len() int\n  returns: int - number of elements in this map.  Put Puts a new value into a map element specified by its key.\n (c *AnyValueMap) Put(key string, value interface{})\n  key: string - key of the element to put. value: interface{} - new value for map element.  Remove Removes a map element specified by its key.\n (c *AnyValueMap) Remove(key string)\n  key: string - key of the element to remove.  SetAsObject Sets a new value to a map element specified by its index. When the index is not defined, it resets the entire map value. This method has a double purpose because method overrides are not supported in JavaScript.\n (c *AnyValueMap) SetAsObject(key string, value interface{})\n  key: string - (optional) key of the element to set value: interface{} - new element or map value.  String Gets a string representation of the object. The result is a semicolon-separated list of key-value pairs as \u0026ldquo;key1=value1;key2=value2;key=value3\u0026rdquo;\n (c *AnyValueMap) String() string\n  returns: string - string representation of the object.  Examples let value1 = new AnyValueMap({ key1: 1, key2: \u0026#34;123.456\u0026#34;, key3: \u0026#34;2018-01-01\u0026#34; }); value1.getAsBoolean(\u0026#34;key1\u0026#34;); // Result: true value1.getAsInteger(\u0026#34;key2\u0026#34;); // Result: 123 value1.getAsFloat(\u0026#34;key2\u0026#34;); // Result: 123.456 value1.getAsDateTime(\u0026#34;key3\u0026#34;); // Result: new Date(2018,0,1)  See also   StringConverter   TypeConverter   StringConverter   BooleanConverter   IntegerConverter   LongConverter   DoubleConverter   FloatConverter   DateTimeConverter   ICloneable   ","description":"Cross-language implementation of a dynamic map (dictionary) object that can hold values of any type. It also provides several methods to convert the stored values to different types.\n","image":null,"permalink":"/golang/commons/data/any_value_map/","subtitle":null,"tags":null,"title":"AnyValueMap"},{"content":"Inherits: ICloneable, Dictionary\u0026lt;string, object\u0026gt;\nDescription The AnyValueMap class provides a cross-language implementation of a dynamic map (dictionary) object that can hold values of any type. In addition, it provides several methods to convert the stored values to different types; such as bool, integer or datetime.\nConstructors Creates a new instance of the map and assigns its value.\n public AnyValueMap(IDictionary\u0026lt;string, object\u0026gt; values)\n  values: IDictionary\u0026lt;string, object\u0026gt; - (optional) values to initialize this map.  Creates a new instance of the map and assigns its value.\n public AnyValueMap(IDictionary values)\n  values: IDictionary - (optional) values to initialize this map.  Creates a new instance of the map and assigns its value.\n public AnyValueMap()\n Instance methods Append Appends new elements to this map.\n public void Append(IDictionary map)\n  map: IDictionary - map with elements to be added.  Append Appends new elements to this map.\n public void Append(IDictionary\u0026lt;string, object\u0026gt; map)\n  map: IDictionary\u0026lt;string, object\u0026gt; - map with elements to be added.  Clone Creates a binary clone of this object.\n public object Clone()\n  returns: object - clone of this object.  Get Gets a map element specified by its key.\n public virtual object Get(string key)\n  key: string - key of the element to get. returns: object - value of the map element.  GetAsArray Converts a map element into an AnyValueArray or returns an empty AnyValueArray if the conversion is not possible.\nSee AnyValueArray, AnyValueArray.FromValue\n public AnyValueArray GetAsArray(string key)\n  key: string - key of the element to get. returns: AnyValueArray - AnyValueArray value of the element or empty AnyValueArray if the conversion is not supported.  GetAsArrayWithDefault Converts a map element into an AnyValueArray or returns a given default value if the conversion is not possible.\nSee AnyValueArray\n public AnyValueArray GetAsArrayWithDefault(string key, AnyValueArray defaultValue)\n  key: string - key of the element to get. defaultValue: AnyValueArray - default value returns: AnyValueArray - AnyValueArray value of the element or given default value if the conversion is not supported.  GetAsBoolean Converts a map element into a bool or returns false if the conversion is not possible.\n public bool GetAsBoolean(string key)\n  key: string - key of the element to get. returns: bool - value of the element or false if the conversion is not supported.  GetAsBooleanWithDefault Converts a map element into a bool or returns a given default value if the conversion is not possible.\nSee BooleanConverter.toBooleanWithDefault\n public bool GetAsBooleanWithDefault(string key, bool defaultValue)\n  key: string - key of the element to get. defaultValue: bool - default value returns: bool - bool value of the element or given default value if the conversion is not supported.  GetAsDateTime Converts a map element into a DateTime or returns the current date if the conversion is not possible.\n public DateTime GetAsDateTime(string key)\n  key: string - key of the element to get. returns: DateTime - DateTime value of the element or the current date if the conversion is not supported.  GetAsDateTimeWithDefault Converts a map element into a DateTime or returns a given default value if the conversion is not possible.\nSee DateTimeConverter.toDateTimeWithDefault\n public DateTime GetAsDateTimeWithDefault(string key, DateTime defaultValue)\n  key: string - key of the element to get. defaultValue: DateTime - default value returns: DateTime - DateTime value of the element or given default value if the conversion is not supported.  GetAsNullableTimeSpan Converts a map element into a TimeSpan or returns null if the conversion is not possible.\n public TimeSpan GetAsNullableTimeSpan(string key)\n  key: string - key of the element to get. returns: TimeSpan - TimeSpan or null if the conversion is not possible.  GetAsTimeSpan Converts a map element into a TimeSpan.\n public TimeSpan GetAsTimeSpan(string key)\n  key: string - key of the element to get. returns: TimeSpan - TimeSpan  GetAsTimeSpanWithDefault TODO: add description\n public TimeSpan GetAsTimeSpanWithDefault(string key, TimeSpan? defaultValue)\n  key: string - key of the element to get. defaultValue: TimeSpan - default value returns: TimeSpan - TimeSpan  GetAsNullableEnum Converts a map element into an Enum or returns null if the conversion is not possible.\n public T GetAsNullableEnum\u0026lt;T\u0026gt;(string key)\n  key: string - key of the element to get. returns: T - Enum or null if the conversion is not possible.  GetAsEnum Converts a map element into an Enum.\n public T GetAsEnum\u0026lt;T\u0026gt;(string key)\n  key: string - key of the element to get. returns: T - Enum  GetAsEnumWithDefault Converts a map element into an Enum or returns a given default value if the conversion is not possible.\n public T GetAsEnumWithDefault\u0026lt;T\u0026gt;(string key, T defaultValue)\n  key: string - key of the element to get. defaultValue: T - default value returns: T - Enum or given default value if the conversion is not possible.  GetAsDouble Converts a map element into a double or returns 0 if the conversion is not possible.\n public double GetAsDouble(string key)\n  key: string - key of the element to get. returns: double - double value of the element or 0 if the conversion is not supported.  GetAsDoubleWithDefault Converts a map element into a double or returns a given default value if the conversion is not possible.\nSee DoubleConverter.ToDoubleWithDefault\n public double GetAsDoubleWithDefault(string key, double defaultValue)\n  key: string - key of the element to get. defaultValue: double - default value returns: double - double value of the element or given default value if the conversion is not supported.  GetAsFloat Converts a map element into a float or returns 0 if the conversion is not possible.\n public float GetAsFloat(string key)\n  key: string - key of the element to get. returns: float - float value of the element or 0 if the conversion is not supported.  GetAsFloatWithDefault Converts a map element into a flot or returns a given default value if the conversion is not possible.\nSee FloatConverter.ToFloatWithDefault\n public float GetAsFloatWithDefault(string key, float defaultValue)\n  key: string - key of the element to get. defaultValue: float - default value returns: float - flot value of the element or given default value if the conversion is not supported.  GetAsInteger Converts a map element into an integer or returns 0 if the conversion is not possible.\n public int GetAsInteger(string key)\n  key: string - key of the element to get. returns: int - integer value of the element or 0 if the conversion is not supported.  GetAsIntegerWithDefault Converts a map element into an integer or returns a given default value if the conversion is not possible.\nSee IntegerConverter.ToIntegerWithDefault\n public int GetAsIntegerWithDefault(string key, float defaultValue)\n  key: string - key of the element to get. defaultValue: float - default value returns: float - integer value of the element or given default value if the conversion is not supported.  GetAsLong Converts a map element into a long or returns 0 if the conversion is not possible.\nSee IntegerConverter.ToIntegerWithDefault\n public long GetAsLong(string key)\n  key: string - key of the element to get. returns: long - long value of the element or 0 if the conversion is not supported.  GetAsLongWithDefault Converts a map element into a long or returns a given default value if the conversion is not possible.\nSee LongConverter.ToLongWithDefault\n public long GetAsLongWithDefault(string key, long defaultValue)\n  key: string - key of the element to get. defaultValue: long - default value returns: long - long value of the element or given default value if the conversion is not supported.  GetAsMap Converts a map element into an AnyValueMap or returns an empty AnyValueMap if the conversion is not possible. See LongConverter.ToLongWithDefault\n public AnyValueMap GetAsMap(string key)\n  key: string - key of the element to get. returns: AnyValueMap - AnyValueMap value of the element or empty AnyValueMap if the conversion is not supported.  GetAsMapWithDefault Converts a map element into an AnyValueMap or returns a given default value if the conversion is not possible.\n public AnyValueMap GetAsMapWithDefault(string key, AnyValueMap defaultValue)\n  key: string - key of the element to get. defaultValue: AnyValueMap - default value returns: AnyValueMap - AnyValueMap value of the element or given default value if the conversion is not supported.  GetAsNullableArray Converts a map element into an AnyValueArray or returns null if the conversion is not possible.\nSee AnyValueMap, AnyValueMap.fromValue\n public AnyValueMap GetAsNullableArray(string key)\n  key: string - key of the element to get. returns: AnyValueMap - AnyValueArray value of the element or null if the conversion is not supported.  GetAsNullableBoolean Converts a map element into a bool or returns null if the conversion is not possible.\nSee BooleanConverter.toNullableBoolean\n public bool GetAsNullableBoolean(string key)\n  key: string - key of the element to get. returns: bool - bool value of the element or null if the conversion is not supported.  GetAsNullableDateTime Converts map element into a long or returns a given default value if the conversion is not possible.\nSee DateTimeConverter.ToNullableDateTime\n public DateTime GetAsNullableDateTime(string key)\n  key: string - key of the element to get. returns: DateTime - DateTime value of the element or null if the conversion is not supported.  GetAsNullableDouble Converts a map element into a double or returns null if the conversion is not possible.\nSee DoubleConverter.ToNullableDouble\n public double GetAsNullableDouble(string key)\n  key: string - key of the element to get. returns: double - double value of the element or null if the conversion is not supported.  GetAsNullableFloat Converts a map element into a float or returns null if the conversion is not possible. See FloatConverter.ToNullableFloat\n public float GetAsNullableFloat(string key)\n  key: string - key of the element to get. returns: float - float value of the element or null if the conversion is not supported.  GetAsNullableInteger Converts a map element into an integer or returns null if the conversion is not possible.\nSee IntegerConverter.ToNullableInteger\n public int GetAsNullableInteger(string key)\n  key: string - key of element to get. returns: int - integer value of the element or null if the conversion is not supported.  GetAsNullableLong Converts a map element into a long or returns null if the conversion is not possible.\nSee LongConverter.ToNullableLong\n public logn GetAsNullableLong(string key)\n  key: string - key of element to get. returns: logn - long value of the element or null if the conversion is not supported.  GetAsNullableMap Converts a map element into an AnyValueMap or returns null if the conversion is not possible.\n public AnyValueMap GetAsNullableMap(string key)\n  key: string - key of element to get. returns: AnyValueMap - AnyValueMap value of the element or null if the conversion is not supported.  GetAsNullableString Converts a map element into a string or returns null if the conversion is not possible. See StringConverter.ToNullableString\n public string GetAsNullableString(string key)\n  key: string - key of the element to get. returns: string - string value of the element or null if the conversion is not supported.  GetAsNullableType Converts a map element into a value defined by a specified typecode. If the conversion is not possible, it returns null. See TypeConverter.toNullableType T - class type\n public T GetAsNullableType\u0026lt;T\u0026gt;(string key)\n  key: string - key of the element to get. returns: T - element value defined by the typecode or null if the conversion is not supported.  GetAsObject Gets the value stored in this map element without any conversions.\n public object GetAsObject()\n  key: string - (optional) key of the element to get returns: object - value of the map element.  GetAsObject Gets the value stored in a map element without any conversions. When element key is not defined, it returns the entire map value.\n public object GetAsObject(string key)\n  key: string - (optional) key of the element to get returns: object - element value or value of the map when the index is not defined.  GetAsString Converts a map element into a string or returns \u0026quot;\u0026quot; if conversion is not possible.\n public string GetAsString(string key)\n  key: string - key of the element to get. returns: string - string value of the element or \u0026quot;\u0026quot; if the conversion is not supported.  GetAsStringWithDefault Converts a map element into a string or returns a given default value if the conversion is not possible. See StringConverter.ToStringWithDefault\n public string GetAsStringWithDefault(string key, string defaultValue)\n  key: string - key of the element to get. defaultValue: string - default value returns: string - string value of the element or default value if the conversion is not supported.  GetAsType Converts map element into a value defined by a specified typecode. If the conversion is not possible, it returns the default value for the specified type. T - class type\n public T GetAsType\u0026lt;T\u0026gt;(string key)\n  key: string - key of the element to get. returns: T - element value defined by the typecode or default if the conversion is not supported.  GetAsTypeWithDefault Converts a map element into a value defined by a specified typecode. If the conversion is not possible, it returns a given default value. T - class type See TypeConverter.ToTypeWithDefault\n public T GetAsTypeWithDefault\u0026lt;T\u0026gt;(string key, T defaultValue)\n  key: string - key of the element to get. defaultValue: T - the default value returns: T - element value defined by the typecode or default given value if the conversion is not supported.  GetAsValue Converts a map element into an AnyValue or returns an empty AnyValue if the conversion is not possible.\nSee AnyValue, AnyValue.constructors\n public AnyValue GetAsValue(string key)\n  key: string - key of element to get. returns: AnyValue -AnyValue value of the element or empty AnyValue if the conversion is not supported.  Set Puts a new value into a map element specified by its key.\n public virtual Set(string key, object value)\n  key: string - key of the element to put. value: object - new value for the map element.  SetAsObject Sets a new value for this array element\n public void SetAsObject(object value)\n  value: object - new element or map value.  SetAsObject Sets a new value to a map element specified by its index. When the index is not defined, it resets the entire map.\n public void SetAsObject(string key, object value)\n  key: string - (optional) key of the element to set value: object - new element or map value.  Static methods FromMaps Creates a new AnyValueMap by merging two or more maps. Maps defined later in the list override values from previously defined maps.\n public static AnyValueMap FromMaps(params IDictionary[] maps)\n  maps: IDictionary[] - array of maps to be merged returns: AnyValueMap - newly created AnyValueMap.  FromTuples Creates a new AnyValueMap from a list of key-value pairs called tuples.\n public static AnyValueMap FromTuples(params object[] tuples)\n  tuples: object[] - list of values where odd elements are keys and the following even elements are values. returns: AnyValueMap - newly created AnyValueArray.  FromTuplesArray! Note: this method is not available for this language\nCreates a new AnyValueMap from a list of key-value pairs called tuples. The method is similar to fromTuples but tuples are passed as an array instead of parameters.\n public static AnyValueMap FromTuplesArray(params object[] tuples)\n  tuples: object[] - list of values where odd elements are keys and the following even elements are values. returns: AnyValueMap - newly created AnyValueArray.  FromValue Converts a specified value into an AnyValueMap.\n public static AnyValueMap FromValue(object value)\n  value: object - value to be converted returns: AnyValueMap - newly created AnyValueMap.  Examples var value1 = new AnyValueMap(new Dictionary\u0026lt;string, object\u0026gt;{ {\u0026#34;key1\u0026#34;, 1}, {\u0026#34;key2\u0026#34;, \u0026#34;123.456\u0026#34;}, {\u0026#34;key3\u0026#34;, \u0026#34;2018-01-01\u0026#34; } }); value1.GetAsBoolean(\u0026#34;key1\u0026#34;); // Result: true value1.GetAsInteger(\u0026#34;key2\u0026#34;); // Result: 123 value1.GetAsFloat(\u0026#34;key2\u0026#34;); // Result: 123.456 value1.GetAsDateTime(\u0026#34;key3\u0026#34;); // Result: new DateTime(2018,0,1)  See also   StringConverter   TypeConverter   StringConverter   BooleanConverter   IntegerConverter   LongConverter   DoubleConverter   FloatConverter   DateTimeConverter   ICloneable   ","description":"Cross-language implementation of  a dynamic map (dictionary) object that can hold values of any type. It also provides several methods to convert the stored values to different types.\n","image":null,"permalink":"/net/commons/data/any_value_map/","subtitle":null,"tags":null,"title":"AnyValueMap"},{"content":"Implements: ICloneable\nDescription The AnyValueMap class provides a cross-language implementation of a dynamic map (dictionary) object that can hold values of any type. In addition, it provides several methods to convert the stored values to different types, such as boolean, integer or datetime.\nConstructors Creates a new instance of the map and assigns its value.\n public constructor(values: any = null)\n  values: any - (optional) values to initialize this map.  Instance methods append Appends new elements to this map.\n public append(map: any): void\n  map: any - map with elements to be added.  clear Clears this map by removing all its elements.\n public clear(): void\n clone Creates a binary clone of this object.\n public clone(): any\n  returns: any - clone of this object.  get Gets a map\u0026rsquo;s element specified by its key.\n public get(key: string): any\n  key: string - key of the element to get. returns: any - value of the map\u0026rsquo;s element.  getAsArray Converts a map\u0026rsquo;s element into an AnyValueArray object or returns an empty AnyValueArray object if theconversion is not possible.\nSee AnyValueArray, AnyValueArray.fromValue\n public getAsArray(key: string): AnyValueArray\n  key: string - key of the element to get. returns: AnyValueArray - AnyValueArray value of the element or empty AnyValueArray object if the conversion is not supported.  getAsArrayWithDefault Converts a map\u0026rsquo;s element into an AnyValueArray object or returns a given default value if the conversion is not possible.\nSee AnyValueArray\n public getAsArrayWithDefault(key: string, defaultValue: AnyValueArray): AnyValueArray\n  key: string - key of element to get. defaultValue: AnyValueArray - default value returns: AnyValueArray - AnyValueArray value of the element or default value if the conversion is not supported.  getAsBoolean Converts a map\u0026rsquo;s element into a boolean or returns false if the conversion is not possible.\n public getAsBoolean(key: string): boolean\n  key: string - key of the element to get. returns: boolean - value of the element or false if the conversion is not supported.  getAsBooleanWithDefault Converts a map\u0026rsquo;s element into a boolean or returns a given default value if the conversion is not possible.\nSee BooleanConverter.toBooleanWithDefault\n public getAsBooleanWithDefault(key: string, defaultValue: boolean): boolean\n  key: string - key of the element to get. defaultValue: boolean - default value returns: boolean - boolean value of the element or given default value if the conversion is not supported.  getAsDateTime Converts a map\u0026rsquo;s element into Date or returns the current date if the conversion is not possible.\n public getAsDateTime(key: string): Date\n  key: string - akey of the element to get. returns: Date - Date value of the element or the current date if the conversion is not supported.  getAsDateTimeWithDefault Converts a map\u0026rsquo;s element into a Date or returns a given default value if the conversion is not possible.\nSee DateTimeConverter.toDateTimeWithDefault\n public getAsDateTimeWithDefault(key: string, defaultValue: Date): Date\n  key: string - key of the element to get. defaultValue: Date - default value returns: Date - Date value of the element or given default value if the conversion is not supported.  getAsDouble Converts a map\u0026rsquo;s element into a double or returns 0 if the conversion is not possible.\n public getAsDouble(key: string): number\n  key: string - key of the element to get. returns: number - double value of the element or 0 if the conversion is not supported.  getAsDoubleWithDefault Converts a map\u0026rsquo;s element into a double or returns a given default value if the conversion is not possible.\nSee DoubleConverter.toDoubleWithDefault\n public getAsDoubleWithDefault(key: string, defaultValue: number): number\n  key: string - key of the element to get. defaultValue: number - default value returns: number - double value of the element or given default value if the conversion is not supported.  getAsFloat Converts a map\u0026rsquo;s element into a float or returns 0 if conversion the is not possible.\n public getAsFloat(key: string): number\n  key: string - key of the element to get. returns: number - float value of the element or 0 if the conversion is not supported.  getAsFloatWithDefault Converts map\u0026rsquo;s element into a float or returns a given default value if the conversion is not possible.\nSee FloatConverter.toFloatWithDefault\n public getAsFloatWithDefault(key: string, defaultValue: number): number\n  key: string - key of the element to get. defaultValue: number - default value returns: number - flaot value of the element or given default value if the conversion is not supported.  getAsInteger Converts a map\u0026rsquo;s element into an integer or returns 0 if the conversion is not possible.\n public getAsInteger(key: string): number\n  key: string - key of the element to get. returns: number - integer value of the element or 0 if the conversion is not supported.  getAsIntegerWithDefault Converts a map\u0026rsquo;s element into an integer or returns a given default value if the conversion is not possible.\nSee IntegerConverter.toIntegerWithDefault\n public getAsIntegerWithDefault(key: string, defaultValue: number): number\n  key: string - key of the element to get. defaultValue: number - default value returns: number - integer value of the element or given default value if the conversion is not supported.  getAsLong Converts a map\u0026rsquo;s element into a long or returns 0 if the conversion is not possible.\nSee IntegerConverter.toIntegerWithDefault\n public getAsLong(key: string): number\n  key: string - key of the element to get. returns: number - long value of the element or 0 if the conversion is not supported.  getAsLongWithDefault Converts a map\u0026rsquo;s element into a long or returns a given default value if the conversion is not possible.\nSee LongConverter.toLongWithDefault\n public getAsLongWithDefault(key: string, defaultValue: number): number\n  key: string - key of the element to get. defaultValue: number - default value returns: number - long value of the element or default value if the conversion is not supported.  getAsMap Converts a map\u0026rsquo;s element into an AnyValueMap object or returns an empty AnyValueMap object if the conversion is not possible. See LongConverter.toLongWithDefault\n public getAsMap(key: string): AnyValueMap\n  key: string - key of the element to get. returns: AnyValueMap - AnyValueMap value of the element or empty AnyValueMap object if the conversion is not supported.  getAsMapWithDefault Converts a map\u0026rsquo;s element into an AnyValueMap object or returns a given default value if the conversion is not possible.\n public getAsMapWithDefault(key: string, defaultValue: AnyValueMap): AnyValueMap\n  key: string - key of the element to get. defaultValue: AnyValueMap - default value returns: AnyValueMap - AnyValueMap value of the element or given default value if the conversion is not supported.  getAsNullableArray Converts a map\u0026rsquo;s element into an AnyValueArray object or returns null if the conversion is not possible.\nSee AnyValueMap, AnyValueMap.fromValue\n public getAsNullableArray(key: string): AnyValueMap\n  key: string - key of the element to get. returns: AnyValueMap - AnyValueArray value of the element or null if the conversion is not supported.  getAsNullableBoolean Converts a map\u0026rsquo;s element into a boolean or returns null if the conversion is not possible.\nSee BooleanConverter.toNullableBoolean\n public getAsNullableBoolean(key: string): boolean\n  key: string - key of the element to get. returns: boolean - boolean value of the element or null if the conversion is not supported.  getAsNullableDateTime Converts map element into a long or returns a given default value if the conversion is not possible.\nSee DateTimeConverter.toNullableDateTime\n public getAsNullableDateTime(key: string): Date\n  key: string - key of element to get. returns: Date - Date value of the element or null if the conversion is not supported.  getAsNullableDouble Converts a map\u0026rsquo;s element into a double or returns null if the conversion is not possible.\nSee DoubleConverter.toNullableDouble\n public getAsNullableDouble(key: string): number\n  key: string - key of element to get. returns: number - double value of the element or null if the conversion is not supported.  getAsNullableFloat Converts a map\u0026rsquo;s element into a float or returns null if the conversion is not possible. See FloatConverter.toNullableFloat\n public getAsNullableFloat(key: string): number\n  key: string - key of the element to get. returns: number - float value of the element or null if the conversion is not supported.  getAsNullableInteger Converts a map\u0026rsquo;s element into an integer or returns null if the conversion is not possible.\nSee IntegerConverter.toNullableInteger\n public getAsNullableInteger(key: string): number\n  key: string - key of element to get. returns: number - integer value of the element or null if the conversion is not supported.  getAsNullableLong Converts a map\u0026rsquo;s element into a long or returns null if conversion is not possible.\nSee LongConverter.toNullableLong\n public getAsNullableLong(key: string): number\n  key: string - key of the element to get. returns: number - long value of the element or null if the conversion is not supported.  getAsNullableMap Converts a map\u0026rsquo;s element into an AnyValueMap object or returns null if the conversion is not possible.\n public getAsNullableMap(key: string): AnyValueMap\n  key: string - key of the element to get. returns: AnyValueMap - AnyValueMap value of the element or null if the conversion is not supported.  getAsNullableString Converts a map\u0026rsquo;s element into a string or returns null if the conversion is not possible. See StringConverter.toNullableString\n public getAsNullableString(key: string): string\n  key: string - key of the element to get. returns: string - string value of the element or null if the conversion is not supported.  getAsNullableType Converts a map element into a value defined by a specified typecode. If conversion is not possible, it returns null. See TypeConverter.toNullableType\n public getAsNullableType\u0026lt;T\u0026gt;(type: TypeCode, key: string): T\n  type: TypeCode - TypeCode that defines the type of the result. key: string - key of the element to get. returns: T - element\u0026rsquo;s value defined by the type code or null if the conversion is not supported.  getAsObject Gets the value stored in a map\u0026rsquo;s element without any conversions. When the element\u0026rsquo;s key is not defined, it returns the entire map value.\n public getAsObject(key: string = undefined): any\n  key: string - (optional) key of the element to get returns: any - element\u0026rsquo;s value or value of the map when the index is not defined.  getAsString Converts a map\u0026rsquo;s element into a string or returns \u0026quot;\u0026quot; if the conversion is not possible.\n public getAsString(key: string): string\n  key: string - key of the element to get. returns: string - string value of the element or \u0026quot;\u0026quot; if the conversion is not supported.  getAsStringWithDefault Converts a map\u0026rsquo;s element into a string or returns a given default value if the conversion is not possible. See StringConverter.toStringWithDefault\n public getAsStringWithDefault(key: string, defaultValue: string): string\n  key: string - key of the element to get. defaultValue: string - default value returns: string - string value of the element or given default value if the conversion is not supported.  getAsType Converts a map\u0026rsquo;s element into a value defined by a specified type code. If the conversion is not possible, it returns the default value for the specified type.\n public getAsType\u0026lt;T\u0026gt;(type: TypeCode, key: string): T\n  type: TypeCode - TypeCode that defines the type of the result. key: string - key of the element to get. returns: T - element\u0026rsquo;s value defined by the typecode or default if the conversion is not supported.  getAsTypeWithDefault Converts a map\u0026rsquo;s element into a value defined by a specified type code. If the conversion is not possible, it returns a given default value. See TypeConverter.toTypeWithDefault\n public getAsTypeWithDefault\u0026lt;T\u0026gt;(type: TypeCode, key: string, defaultValue: T): T\n  type: TypeCode - TypeCode that defines the type of the result key: string - key of element to get. defaultValue: T - default value returns: T - element\u0026rsquo;s value defined by the typecode or default value if the conversion is not supported.  getAsValue Converts a map\u0026rsquo;s element into an AnyValue object or returns an empty AnyValue object if the conversion is not possible.\nSee AnyValue, AnyValue.constructors\n public getAsValue(key: string): AnyValue\n  key: string - key of the element to get. returns: AnyValue -AnyValue value of the element or empty AnyValue object if the conversion is not supported.  getKeys Gets the keys of all elements stored in this map.\n public getKeys(): string[]\n  returns: string[] - list with all keys.  length Gets the number of elements stored in this map.\n public length(): number\n  returns: number - number of elements in this map.  put Puts a new value into a map\u0026rsquo;s element specified by its key.\n public put(key: string, value: any)\n  key: string - key of the element to put. value: any - new value for map\u0026rsquo;s element.  remove Removes a map\u0026rsquo;s element specified by its key.\n public remove(key: string): void\n  key: string - key of the element to remove.  setAsObject Sets a new value to a map\u0026rsquo;s element specified by its index. When the index is not defined, it resets the entire map value. This method has a double purpose because method overrides are not supported in JavaScript.\n public setAsObject(key: any, value: any = undefined): void\n  key: any - (optional) key of the element to set value: any - new element or map value.  toString Gets a string representation of the object. The result is a semicolon-separated list of key-value pairs as \u0026ldquo;key1=value1;key2=value2;key=value3\u0026rdquo;\n public toString(): string\n  returns: string - string representation of the object.  Static methods fromMaps Creates a new AnyValueMap object by merging two or more maps. Maps defined later in the list override values from previously defined maps.\n public static fromMaps(\u0026hellip;maps: any[]): AnyValueMap\n  maps: any[] - array of maps to be merged returns: AnyValueMap - newly created AnyValueMap object.  fromTuples Creates a new AnyValueMap object from a list of key-value pairs called tuples.\n public static fromTuples(\u0026hellip;tuples: any[]): AnyValueMap\n  tuples: any[] - list of values where odd elements are keys and the following even elements are values. returns: AnyValueMap - newly created AnyValueArray object.  fromTuplesArray Creates a new AnyValueMap object from a list of key-value pairs called tuples. The method is similar to fromTuples but tuples are passed as array instead of parameters.\n public static fromTuplesArray(tuples: any[]): AnyValueMap\n  tuples: any[] - list of values where odd elements are keys and the following even elements are values. returns: AnyValueMap - newly created AnyValueArray object.  fromValue Converts a specified value into an AnyValueMap object.\n public static fromValue(value: any): AnyValueMap\n  value: any - value to be converted returns: AnyValueMap - newly created AnyValueMap object.  Examples let value1 = new AnyValueMap({ key1: 1, key2: \u0026#34;123.456\u0026#34;, key3: \u0026#34;2018-01-01\u0026#34; }); value1.getAsBoolean(\u0026#34;key1\u0026#34;); // Result: true value1.getAsInteger(\u0026#34;key2\u0026#34;); // Result: 123 value1.getAsFloat(\u0026#34;key2\u0026#34;); // Result: 123.456 value1.getAsDateTime(\u0026#34;key3\u0026#34;); // Result: new Date(2018,0,1)  See also   StringConverter   TypeConverter   StringConverter   BooleanConverter   IntegerConverter   LongConverter   DoubleConverter   FloatConverter   DateTimeConverter   ICloneable   ","description":"Cross-language implementation of a dynamic map (dictionary) object that can hold values of any type. It also provides several methods to convert the stored values to different types.\n","image":null,"permalink":"/node/commons/data/any_value_map/","subtitle":null,"tags":null,"title":"AnyValueMap"},{"content":"Implements: ICloneable, dict\nDescription The AnyValueMap class provides a cross-language implementation of a dynamic map (dictionary) object that can hold values of any type. In addition, it provides several methods to convert the stored values to different types, such as boolean, integer or datetime.\nConstructors Creates a new instance of the map and assigns its value.\n AnyValueMap(values: Any = None)\n  values: Any = None - (optional) values to initialize this map.  Instance methods append Appends new elements to this map.\n append(map: Any)\n  map: Any - a map with elements to be added.  clear Clears this map by removing all its elements.\n clear()\n clone Creates a binary clone of this object.\n clone(): Any\n  returns: Any - a clone of this object.  get Gets a map element specified by its key.\n get(key: str): Any\n  key: str - a key of the element to get. returns: Any - the value of the map element.  get_as_array Converts map element into an AnyValueArray or returns empty AnyValueArray if conversion is not possible.\nSee AnyValueArray, AnyValueArray.from_value\n get_as_array(key: str): AnyValueArray\n  key: str - a key of element to get. returns: AnyValueArray - AnyValueArray value of the element or empty AnyValueArray if conversion is not supported.  get_as_array_with_default Converts map element into an AnyValueArray or returns default value if conversion is not possible.\nSee AnyValueArray\n get_as_array_with_default(key: str, default_value: AnyValueArray): AnyValueArray\n  key: str - a key of element to get. default_value: AnyValueArray - the default value returns: AnyValueArray - AnyValueArray value of the element or default value if conversion is not supported.  get_as_boolean Converts map element into a boolean or returns false if conversion is not possible.\n get_as_boolean(key: str): bool\n  key: str - a key of element to get. returns: bool - value of the element or false if conversion is not supported.  get_as_boolean_with_default Converts map element into a boolean or returns default value if conversion is not possible.\nSee BooleanConverter.to_boolean_with_default.\n get_as_boolean_with_default(key: str, default_value: bool): bool\n  key: str - a key of element to get. default_value: bool - the default value. returns: bool - boolean value of the element or default value if conversion is not supported.  get_as_datetime Converts map element into a Date or returns the current date if conversion is not possible.\n get_as_datetime(key: str): datetime\n  key: str - a key of element to get. returns: datetime - Date value of the element or the current date if conversion is not supported.  get_as_datetime_with_default Converts map element into a Date or returns default value if conversion is not possible.\nSee DateTimeConverter.to_datetime_with_default.\n get_as_datetime_with_default(key: str, default_value: datetime): datetime\n  key: str - a key of element to get. default_value: datetime - the default value returns: datetime - Date value of the element or default value if conversion is not supported.  get_as_double Converts map element into a double or returns 0 if conversion is not possible.\n get_as_double(key: str): float\n  key: str - a key of element to get. returns: float - double value of the element or 0 if conversion is not supported.  get_as_double_with_default Converts map element into a double or returns default value if conversion is not possible.\nSee DoubleConverter.to_double_with_default.\n get_as_double_with_default(key: str, default_value: float): float\n  key: str - a key of element to get. default_value: float - the default value. returns: float - double value of the element or default value if conversion is not supported.  get_as_float Converts map element into a float or returns 0 if conversion is not possible.\n get_as_float(key: str): float\n  key: str - a key of element to get. returns: float - float value of the element or 0 if conversion is not supported.  get_as_float_with_default Converts map element into a flot or returns default value if conversion is not possible.\nSee FloatConverter.to_float_with_default.\n get_as_float_with_default(key: str, default_value: float): float\n  key: str - a key of element to get. default_value: float - the default value returns: float - flot value of the element or default value if conversion is not supported.  get_as_integer Converts map element into an integer or returns 0 if conversion is not possible.\n get_as_integer(key: str): int\n  key: str - a key of element to get. returns: int - integer value of the element or 0 if conversion is not supported.  get_as_integer_with_default Converts map element into an integer or returns default value if conversion is not possible.\nSee IntegerConverter.to_integer_with_default\n get_as_integer_with_default(key: str, default_value: int): int\n  key: str - a key of element to get. default_value: int - the default value returns: int - integer value of the element or default value if conversion is not supported.  get_as_long Converts map element into a long or returns 0 if conversion is not possible.\nSee IntegerConverter.to_integer_with_default\n get_as_long(key: str): float\n  key: str - a key of element to get. returns: float - long value of the element or 0 if conversion is not supported.  get_as_long_with_default Converts map element into a long or returns default value if conversion is not possible.\nSee LongConverter.to_long_with_default\n get_as_long_with_default(key: str, default_value: float): float\n  key: str - a key of element to get. default_value: float - the default value returns: float - long value of the element or default value if conversion is not supported.  get_as_map Converts map element into an AnyValueMap or returns empty AnyValueMap if conversion is not possible. See LongConverter.to_long_with_default\n get_as_map(key: str): AnyValueMap\n  key: str - a key of element to get. returns: AnyValueMap - AnyValueMap value of the element or empty AnyValueMap if conversion is not supported.  get_as_map_with_default Converts map element into an AnyValueMap or returns default value if conversion is not possible.\n get_as_map_with_default(key: str, default_value: AnyValueMap): AnyValueMap\n  key: str - a key of element to get. default_value: AnyValueMap - the default value. returns: AnyValueMap - AnyValueMap value of the element or default value if conversion is not supported.  get_as_nullable_array Converts map element into an AnyValueArray or returns None if conversion is not possible.\nSee AnyValueMap, AnyValueMap.from_value\n get_as_nullable_array(key: str): AnyValueMap\n  key: str - a key of element to get. returns: AnyValueMap - AnyValueArray value of the element or None if conversion is not supported.  get_as_nullable_boolean Converts map element into a boolean or returns None if conversion is not possible.\nSee BooleanConverter.to_nullable_boolean.\n get_as_nullable_boolean(key: str): Optional[bool]\n  key: str - a key of element to get. returns: Optional[bool] - boolean value of the element or None if conversion is not supported.  get_as_nullable_datetime Converts map element into a long or returns default value if conversion is not possible.\nSee DateTimeConverter.to_nullable_datetime.\n get_as_nullable_datetime(key: str): Optional[datetime]\n  key: str - a key of element to get. returns: Optional[datetime] - Date value of the element or None if conversion is not supported.  get_as_nullable_double Converts map element into a double or returns None if conversion is not possible.\nSee DoubleConverter.to_nullable_double\n get_as_nullable_double(key: str): Optional[float]\n  key: str - a key of element to get. returns: Optional[float] - double value of the element or None if conversion is not supported.  get_as_nullable_float Converts map element into a float or returns None if conversion is not possible. See FloatConverter.to_nullable_float.\n get_as_nullable_float(key: str): Optional[float]\n  key: str - a key of element to get. returns: Optional[float] - float value of the element or None if conversion is not supported.  get_as_nullable_integer Converts map element into an integer or returns None if conversion is not possible.\nSee IntegerConverter.to_nullable_integer\n get_as_nullable_integer(key: str): Optional[int]\n  key: str - a key of element to get. returns: Optional[int] - integer value of the element or None if conversion is not supported.  get_as_nullable_long Converts map element into a long or returns None if conversion is not possible.\nSee LongConverter.to_nullable_long\n get_as_nullable_long(key: str): Optional[float]\n  key: str - a key of element to get. returns: Optional[float] - long value of the element or None if conversion is not supported.  get_as_nullable_map Converts map element into an AnyValueMap or returns None if conversion is not possible.\n get_as_nullable_map(key: str): Optional[AnyValueMap]\n  key: str - a key of element to get. returns: Optional[AnyValueMap] - AnyValueMap value of the element or None if conversion is not supported.  get_as_nullable_string Converts map element into a string or returns None if conversion is not possible. See StringConverter.to_nullable_string\n get_as_nullable_string(key: str): Optional[str]\n  key: str - a key of element to get. returns: Optional[str] - string value of the element or None if conversion is not supported.  get_as_nullable_type Converts map element into a value defined by specied typecode. If conversion is not possible it returns None. See TypeConverter.to_nullable_type\n get_as_nullable_type(value_type: TypeCode, key: str): Any\n  type: TypeCode - the TypeCode that defined the type of the result key: str - a key of element to get. returns: Any - element value defined by the typecode or None if conversion is not supported.  get_as_object Gets the value stored in map element without any conversions. When element key is not defined it returns the entire map value.\n get_as_object(key: str = None): Any\n  key: str - (optional) a key of the element to get returns: Any - the element value or value of the map when index is not defined.  get_as_string Converts map element into a string or returns \u0026quot;\u0026quot; if conversion is not possible.\n get_as_string(key: str): str\n  key: str - a key of element to get. returns: str - string value of the element or \u0026quot;\u0026quot; if conversion is not supported.  get_as_string_with_default Converts map element into a string or returns default value if conversion is not possible. See StringConverter.to_string_with_default\n get_as_string_with_default(key: str, default_value: str): str\n  key: str - a key of element to get. default_value: str - the default value returns: str - string value of the element or default value if conversion is not supported.  get_as_type Converts map element into a value defined by a specified typecode. If conversion is not possible it returns default value for the specified type.\n get_as_type(value_type: TypeCode, key: str): Any\n  value_type: TypeCode - the TypeCode that defined the type of the result. key: str - a key of element to get. returns: Any - element value defined by the typecode or default if conversion is not supported.  get_as_type_with_default Converts map element into a value defined by specied typecode. If conversion is not possible it returns default value. See TypeConverter.to_type_with_default.\n get_as_type_with_default(value_type: TypeCode, key: str, default_value: Any): Any\n  value_type: TypeCode - the TypeCode that defined the type of the result. key: str - a key of element to get. default_value: Any - the default value. returns: Any - element value defined by the typecode or default value if conversion is not supported.  get_as_value Converts map element into an AnyValue or returns an empty AnyValue if conversion is not possible.\nSee AnyValue, AnyValue.constructors\n get_as_value(key: str): AnyValue\n  key: str - a key of element to get. returns: AnyValue -AnyValue value of the element or empty AnyValue if conversion is not supported.  get_keys Gets keys of all elements stored in this map.\n get_keys(): List[str]\n  returns: List[str] - a list with all map keys.  length Gets a number of elements stored in this map.\n length(): int\n  returns: int - the number of elements in this map.  put Puts a new value into map element specified by its key.\n put(key: str, value: Any)\n  key: str - a key of the element to put. value: Any - a new value for map element.  remove Removes a map element specified by its key\n remove(key: str)\n  key: str - a key of the element to remove.  set_as_object Sets a new value to map element specified by its index. When the index is not defined, it resets the entire map value.\n set_as_object(key: Any, value: Any = None)\n  key: Any - (optional) a key of the element to set value: Any - a new element or map value.  to_string Gets a string representation of the object. The result is a semicolon-separated list of key-value pairs as \u0026ldquo;key1=value1;key2=value2;key=value3\u0026rdquo;.\n to_string(): str\n  returns: str - a string representation of the object.  from_maps Creates a new AnyValueMap by merging two or more maps. Maps defined later in the list override values from previously defined maps.\n static from_maps(*maps: dict): AnyValueMap.\n  maps: dict - an array of maps to be merged returns: AnyValueMap - a newly created AnyValueMap.  from_tuples Creates a new AnyValueMap from a list of key-value pairs called tuples.\n static from_tuples(*tuples: Any): AnyValueMap.\n  tuples: Any - a list of values where odd elements are keys and the following even elements are values. returns: AnyValueMap - a newly created AnyValueArray.  from_tuples_array Creates a new AnyValueMap from a list of key-value pairs called tuples. The method is similar to fromTuples but tuples are passed as array instead of parameters.\n static from_tuples_array(tuples: Sequence[Any]): AnyValueMap\n  tuples: Sequence[Any] - a list of values where odd elements are keys and the following even elements are values. returns: AnyValueMap - a newly created AnyValueArray.  from_value Converts specified value into AnyValueMap.\n static from_value(value: Any): AnyValueMap\n  value: Any - value to be converted returns: AnyValueMap - a newly created AnyValueMap.  Examples value1 = new AnyValueMap({ key1: 1, key2: \u0026#34;123.456\u0026#34;, key3: \u0026#34;2018-01-01\u0026#34; }) value1.get_as_boolean(\u0026#34;key1\u0026#34;) # Result: true value1.get_as_integer(\u0026#34;key2\u0026#34;) # Result: 123 value1.get_as_float(\u0026#34;key2\u0026#34;) # Result: 123.456 value1.get_as_datetime(\u0026#34;key3\u0026#34;) # Result: new Date(2018,0,1) See also   StringConverter   TypeConverter   StringConverter   BooleanConverter   IntegerConverter   LongConverter   DoubleConverter   FloatConverter   DateTimeConverter   ICloneable   ","description":"Cross-language implementation of a dynamic map (dictionary) object that can hold values of any type. It also provides several methods to convert the stored values to different types.\n","image":null,"permalink":"/python/commons/data/any_value_map/","subtitle":null,"tags":null,"title":"AnyValueMap"},{"content":"Description The ApplicationError class defines a base class used to define various application exceptions.\nImportant points\n Most languages have own definition of base exception (error) types. However, this class is implemented symmetrically in all languages supported by the PipServices toolkit and allows to create portable implementations and support proper error propagation in microservices calls. Error propagation means that when a microservice implemented in one language calls a microservice(s) implemented in a different language(s), errors are returned throught the entire call chain and restored in their original (or close) type. Since the number of potential exception types is endless, the PipServices toolkit supports only 12 standard categories of exceptions, which are defined in ErrorCategory. The ApplicationError class acts as a basis for these 12 standard exception types. Most exceptions use a free-form message that describes occured error. However, this may not be sufficient to create meaninful error descriptions. Therefore, the ApplicationError class proposes an extended error definition that has more standard fields:  message: a human-readable error description category: one of the 12 standard error categories status: numeric HTTP status code for REST invocations code: a unique error code, usually defined as \u0026ldquo;MY_ERROR_CODE\u0026rdquo; correlation_id: a unique transaction id used to trace execution through a call chain details: map with error parameters that can help to recreate meaningful error description in other languages stack_trace: a stack trace cause: the original error that is wrapped by this exception   The ApplicationError class is not serializable. To pass errors through the wire it must be converted into a ErrorDescription object and then restored on the receiving end into an identical exception type.  Constructors NewError Creates a new instance of an application exception and assigns its values.\n NewError(message string) *ApplicationError\n  message: string - (optional) a human-readable description of the error.  Fields Message A human-readable error description (usually written in English)\n Message: string\n Category Standard error category\n Category: string\n Status HTTP status code associated with this error type\n Status: int\n Code A unique error code\n Code: string\n Details Map with additional details that can be used to restore error description in other languages\n Details: StringValueMap\n CorrelationId Unique transaction id used to trace execution through the call chain\n CorrelationId: string\n StackTrace Stack trace of the exception\n StackTrace: string\n Cause Original error wrapped by this exception\n Cause: string\n  Methods WithCauseString Sets original error wrapped by this exception as a string message.\n (e *ApplicationError) WithCauseString(cause string) *ApplicationError\n  value: string - an original error message.  WithCause Sets a original error wrapped by this exception This method returns a reference to this exception to implement the Builder pattern to chain additional calls.\n (e *ApplicationError) WithCause(cause error) *ApplicationError\n  cause: error - original error object returns: *ApplicationError - this exception object  WithCode Sets a unique error code.\nThis method returns reference to this exception to implement the Builder pattern to chain additional calls.\n (e *ApplicationError) WithCode(code string) *ApplicationError\n  code: string - unique error code returns: *ApplicationError - this exception object  WithCorrelationId Sets a correlation id which can be used to trace this error through the call chain.\nThis method returns reference to this exception to implement the Builder pattern to chain additional calls.\n (e *ApplicationError) WithCorrelationId(correlationId string) *ApplicationError\n  correlationId: string - unique transaction id used to trace error through the call chain returns: *ApplicationError - this exception object  WithDetails Sets a parameter for additional error details. These details can be used to restore the error description in other languages.\nThis method returns reference to this exception to implement the Builder pattern to chain additional calls.\n (e *ApplicationError) WithDetails(key string, value interface{}) *ApplicationError\n  key: string - key a details parameter name value: interface{} - value a details parameter name returns: *ApplicationError - this exception object  WithStatus Sets a HTTP status code which shall be returned by REST calls. This method returns reference to this exception to implement the Builder pattern to chain additional calls.\n (e *ApplicationError) WithStatus(status int) *ApplicationError\n  status: int - HTTP error code. returns: *ApplicationError - this exception object  Wrap Wraps another exception into an application exception object.\nIf the original exception is of ApplicationError type, it is returned without changes. Otherwise a new ApplicationError is created and original error is set as its cause.\n (e *ApplicationError) Wrap(err error) *ApplicationError\n  cause: error - original error object returns: *ApplicationError - original or newly created ApplicationError  WrapError Wraps another exception into a specified application exception object.\nIf the original exception is of ApplicationError type, it is returned without changes. Otherwise the original error is set as a cause to the specified ApplicationError object.\n WrapError(err error, message string) *ApplicationError\n  error: error - ApplicationError object to wrap the cause cause: string - original error object returns: *ApplicationError - original or newly created ApplicationError  See also   ErrorCategory   ErrorDescription   ","description":"\nDefines a base class used to define various application exceptions.\n","image":null,"permalink":"/golang/commons/errors/application_error/","subtitle":null,"tags":null,"title":"ApplicationError"},{"content":"Description The ApplicationErrorFactory acts as a factory to recreate from ErrorDescription values passed through the wire.\nMethods Create Recreates an ApplicationError object from serialized a ErrorDescription. It tries to restore the original exception type using type or error category fields.\n (c *TApplicationErrorFactory) Create(description *ErrorDescription) *ApplicationError\n  description: *ErrorDescription - serialized error description received as a result of remote call  See also   ApplicationError   ErrorDescription   ","description":"Factory to recreate exceptions from [ErrorDescription](../error_description) values passed through the wire.\n","image":null,"permalink":"/golang/commons/errors/application_error_factory/","subtitle":null,"tags":null,"title":"ApplicationErrorFactory"},{"content":"Inherits: Exception\nDescription The ApplicationException class defines a base class used to define various application exceptions.\nImportant points\n Most languages have their own definition of base exception (error) types. However, this class is implemented symmetrically in all languages supported by the PipServices toolkit and allows to create portable implementations and support proper error propagation in microservices calls. Error propagation means that when a microservice implemented in one language calls a microservice(s) implemented in a different language(s), errors are returned throught the entire call chain and restored in their original (or close) type. Since the number of potential exception types is endless, the PipServices toolkit supports only 12 standard categories of exceptions, which are defined in ErrorCategory. The ApplicationException class acts as a basis for these 12 standard exception types. Most exceptions use a free-form message that describes the occured error. However, this may not be sufficient to create meaninful error descriptions. Therefore, the ApplicationException class proposes an extended error definition that has more standard fields:  message: a human-readable error description category: one of the 12 standard error categories status: numeric HTTP status code for REST invocations code: a unique error code, usually defined as \u0026ldquo;MY_ERROR_CODE\u0026rdquo; correlation_id: a unique transaction id used to trace execution through a call chain details: map with error parameters that can help to recreate meaningful error description in other languages stack_trace: a stack trace cause: the original error that is wrapped by this exception   The ApplicationException class is not serializable. To pass errors through the wire it must be converted into a ErrorDescription object and then restored on the receiving end into an identical exception type.  Constructors Creates a new instance of application exception and assigns its values.\n public ApplicationException(string category = null, string correlationId = null, string code = null, string message = null)\n  category: string - (optional) standard error category. Default: Unknown correlationId: string - (optional) unique transaction id used to trace execution through the call chain. code: string - (optional) unique error code. Default: \u0026ldquo;UNKNOWN\u0026rdquo; message: string - (optional) human-readable description of the error.  Creates a new instance of ApplicationException.\n public ApplicationException()\n Creates a new instance of ApplicationException with string message.\n protected ApplicationException(string message)\n  message: string - human-readable description of the error.  Creates a new instance of ApplicationException.\n protected ApplicationException(SerializationInfo info, StreamingContext context)\n  info: SerializationInfo - serialization information context: StreamingContext - streaming context  Properties BaseMessage A human-readable error description (usually written in English).\n public string BaseMessage { get; set; }\n Category Standard error category.\n public string Category { get; set; }\n Status HTTP status code associated with this error type.\n public int Status = 500 { get; set; }\n Code A unique error code.\n public string Code = \u0026lsquo;UNKNOWN\u0026rsquo; { get; set; }\n Details Map with additional details that can be used to restore error descriptions in other languages.\n public StringValueMap Details\n CorrelationId A unique transaction id used to trace execution throug a call chain.\n public string CorrelationId { get; set; }\n StackTrace Stack trace of the exception.\n public string StackTrace { get; set; }\n Cause Original error wrapped by this exception.\n public string Cause { get; set; }\n Instance methods GetObjectData TODO: add description\n public override void GetObjectData(SerializationInfo info, StreamingContext context)\n  info: SerializationInfo - TODO: add description context: StreamingContext - TODO: add description  WithCause Sets a original error wrapped by this exception This method returns a reference to this exception to the implement Builder pattern to chain additional calls.\n public ApplicationException WithCause(Exception cause)\n  cause: Exception - original error object returns: ApplicationException - exception object  WithCode Sets a unique error code.\nThis method returns reference to this exception to implement the Builder pattern to chain additional calls.\n public ApplicationException WithCode(string code)\n  code: string - unique error code returns: ApplicationException - exception object  WithCorrelationId Sets a correlation id which can be used to trace this error through a call chain.\nThis method returns a reference to this exception to implement the Builder pattern to chain additional calls.\n public ApplicationException WithCorrelationId(string correlationId)\n  correlationId: string - unique transaction id used to trace an error through a call chain returns: ApplicationException - exception object  WithDetails Sets a parameter for additional error details. This details can be used to restore error description in other languages.\nThis method returns a reference to this exception to implement the Builder pattern to chain additional calls.\n public ApplicationException WithDetails(string key, object value)\n  key: string - key of the details parameter name value: object - value of the details parameter name returns: ApplicationException - exception object  WithStackTrace Sets a stack trace for this error.\nThis method returns a reference to this exception to implement the Builder pattern to chain additional calls\n public ApplicationException WithStackTrace(string stackTrace)\n  stackTrace: string - stackTrace a stack trace where this error occured returns: ApplicationException - exception object  WithStatus Sets a HTTP status code which shall be returned by REST calls. This method returns a reference to this exception to implement the Builder pattern to chain additional calls.\n public ApplicationException WithStatus(int status)\n  status: int - HTTP error code. returns: ApplicationException - exception object  Wrap Wraps another exception into an application exception object.\nIf the original exception is of ApplicationException type, it is returned without changes. Otherwise, a new ApplicationException is created and the original error is set as its cause.\n public ApplicationException Wrap(Exception cause)\n  cause: Exception - original error object returns: ApplicationException - original or newly created ApplicationException  Static methods UnwrapError! Note: this method is not available for this language\nUnwraps original exception through wrapped exception objects.\nMany frameworks like Seneca or restify wrap original exceptions. That may result in propagating less specific errors and can hide the causes of the errors.\n public static ApplicationException UnwrapError(Exception error)\n  error: Exception - error object returns: ApplicationException - original error object  WrapException Wraps another exception into a specified application exception object.\nIf the original exception is of ApplicationException type, it is returned without changes. Otherwise, the original error is set as a cause for the specified ApplicationException object.\n public static ApplicationException WrapException(ApplicationException error, Exception cause)\n  error: ApplicationException - ApplicationException object to wrap the cause cause: Exception - original error object returns: ApplicationException - original or newly created ApplicationException  See also   ErrorCategory   ErrorDescription   ","description":"\nDefines a base class used to define various application exceptions.\n","image":null,"permalink":"/net/commons/errors/application_exception/","subtitle":null,"tags":null,"title":"ApplicationException"},{"content":"Extends: Error\nDescription The ApplicationException class defines a base class used to define various application exceptions.\nImportant points\n Most languages have their own definition of base exception (error) types. However, this class is implemented symmetrically in all languages supported by the PipServices toolkit and allows to create portable implementations and support proper error propagation in microservices calls. Error propagation means that when a microservice implemented in one language calls a microservice(s) implemented in a different language(s), errors are returned throught the entire call chain and restored in their original (or close) type. Since the number of potential exception types is endless, the PipServices toolkit supports only 12 standard categories of exceptions, which are defined in ErrorCategory. The ApplicationException class acts as a basis for these 12 standard exception types. Most exceptions use a free-form message that describes occured errors. However, this may not be sufficient to create meaninful error descriptions. Therefore, the ApplicationException class proposes an extended error definition that has more standard fields:  message: human-readable error description category: one of the 12 standard error categories status: numeric HTTP status code for REST invocations code: unique error code, usually defined as \u0026ldquo;MY_ERROR_CODE\u0026rdquo; correlation_id: unique transaction id used to trace execution through a call chain details: map with error parameters that can help to recreate meaningful error description in other languages stack_trace: stack trace cause: original error that is wrapped by this exception   The ApplicationException class is not serializable. To pass errors through the wire it must be converted into a ErrorDescription object and then restored on the receiving end into an identical exception type.  Constructors Creates a new instance of ApplicationException and assigns its values.\n public constructor(category: string = null, correlation_id: string = null, code: string = null, message: string = null)\n  category: string - (optional) standard error category. Default: Unknown correlation_id: string - (optional) unique transaction id used to trace execution through the call chain. code: string - (optional) unique error code. Default: \u0026ldquo;UNKNOWN\u0026rdquo; message: string - (optional) human-readable description of the error.  Fields message Human-readable error description (usually written in English).\n public message: string\n category Standard error category.\n public category: string\n status HTTP status code associated with this error type.\n public status: number = 500\n code Unique error code.\n public code: string = \u0026lsquo;UNKNOWN\u0026rsquo;\n details Map with additional details that can be used to restore error descriptions in other languages.\n public details: StringValueMap\n correlation_id Unique transaction id used to trace execution through a call chain.\n public correlation_id: string\n stack_trace Stack trace of the exception.\n public stack_trace: string\n cause Original error wrapped by this exception.\n public cause: string\n  Instance methods getCauseString Gets the original error wrapped by this exception as a string message.\n public getCauseString(): string\n  returns: string - original error message.  getStackTraceString Gets a stack trace where this exception occured.\n public getStackTraceString(): string\n  returns: string - stack trace as a string.  setCauseString Sets original error wrapped by this exception as a string message.\n public setCauseString(value: string): void\n  value: string - original error message.  setStackTraceString Sets the stack trace where this exception occurred.\n public setStackTraceString(value: string): void\n  value: string - stack trace as a string  withCause Sets a original error wrapped by this exception This method returns a reference to this exception to implement the Builder pattern to chain additional calls.\n public withCause(cause: Error): ApplicationException\n  cause: Error - original error object returns: ApplicationException - exception object  withCode Sets a unique error code.\nThis method returns a reference to this exception used to implement the Builder pattern to chain additional calls.\n public withCode(code: string): ApplicationException\n  code: string - unique error code returns: ApplicationException - exception object  withCorrelationId Sets a correlation id which can be used to trace this error through a call chain.\nThis method returns a reference to this exception to implement the Builder pattern to chain additional calls.\n public withCorrelationId(correlationId: string): ApplicationException\n  correlationId: string - unique transaction id used to trace error through a call chain. returns: ApplicationException - exception object  withDetails Sets a parameter for additional error details. This details can be used to restore error descriptions in other languages.\nThis method returns a reference to this exception to implement the Builder pattern to chain additional calls.\n public withDetails(key: string, value: any): ApplicationException\n  key: string - key to the details parameter name value: any - value of the details parameter name returns: ApplicationException - exception object  withStackTrace Sets a stack trace for this error.\nThis method returns a reference to this exception to implement the Builder pattern to chain additional calls\n public withStackTrace(stackTrace: string): ApplicationException\n  stackTrace: string - stack trace where this error occured. returns: ApplicationException - exception object.  withStatus Sets a HTTP status code which shall be returned by REST calls. This method returns a reference to this exception to implement the Builder pattern to chain additional calls.\n public withStatus(status: number): ApplicationException\n  status: number - HTTP error code. returns: ApplicationException - exception object  wrap Wraps another exception into an application exception object.\nIf original exception is of ApplicationException type, it is returned without changes. Otherwise, a new ApplicationException object is created and the original error is set as its cause.\n public wrap(cause: any): ApplicationException\n  cause: any - original error object returns: ApplicationException - original or newly created ApplicationException object.  Static methods unwrapError Unwraps an original exception through wrapped exception objects.\nMany frameworks like Seneca or restify wrap original exceptions. That may result in propagating less specific errors and can hide causes of the errors.\n public static unwrapError(error: any): ApplicationException\n  error: any - error object returns: ApplicationException - original error object.  wrapError Wraps another exception into a specified application exception object.\nIf the original exception is of ApplicationException type, it is returned without changes. Otherwise, the original error is set as a cause for the specified ApplicationException object.\n public static wrapError(error: ApplicationException, cause: any): ApplicationException\n  error: ApplicationException - ApplicationException object used to wrap the cause. cause: any - original error object. returns: ApplicationException - original or newly created ApplicationException object.  See also   ErrorCategory   ErrorDescription   ","description":"\nDefines a base class used to define various application exceptions.\n","image":null,"permalink":"/node/commons/errors/application_exception/","subtitle":null,"tags":null,"title":"ApplicationException"},{"content":"Implements: Exception\nDescription The ApplicationException class defines a base class used to define various application exceptions.\nImportant points\n Most languages have own definition of base exception (error) types. However, this class is implemented symmetrically in all languages supported by the PipServices toolkit and allows to create portable implementations and support proper error propagation in microservices calls. Error propagation means that when a microservice implemented in one language calls a microservice(s) implemented in a different language(s), errors are returned throught the entire call chain and restored in their original (or close) type. Since the number of potential exception types is endless, the PipServices toolkit supports only 12 standard categories of exceptions, which are defined in ErrorCategory. The ApplicationException class acts as a basis for these 12 standard exception types. Most exceptions use a free-form message that describes occured error. However, this may not be sufficient to create meaninful error descriptions. Therefore, the ApplicationException class proposes an extended error definition that has more standard fields:  message: a human-readable error description category: one of the 12 standard error categories status: numeric HTTP status code for REST invocations code: a unique error code, usually defined as \u0026ldquo;MY_ERROR_CODE\u0026rdquo; correlation_id: a unique transaction id used to trace execution through a call chain details: map with error parameters that can help to recreate meaningful error description in other languages stack_trace: a stack trace cause: the original error that is wrapped by this exception   The ApplicationException class is not serializable. To pass errors through the wire it must be converted into a ErrorDescription object and then restored on the receiving end into an identical exception type.  Constructors Creates a new instance of application exception and assigns its values.\n ApplicationException(category: str = ErrorCategory.Unknown, correlation_id: Optional[str] = None, code: str = \u0026lsquo;UNKNOWN\u0026rsquo;, message: str = \u0026lsquo;Unknown error\u0026rsquo;)\n  category: str - (optional) a standard error category. Default: Unknown correlation_id: Optional[str] - (optional) a unique transaction id to trace execution through call chain. code: str - (optional) a unique error code. Default: \u0026ldquo;UNKNOWN\u0026rdquo; message: str - (optional) a human-readable description of the error.  Fields message A human-readable error description (usually written in English).\n message: str\n category Standard error category.\n category: str\n status HTTP status code associated with this error type.\n status: int = 500\n code A unique error code\n code: str = \u0026lsquo;UNKNOWN\u0026rsquo;\n details A map with additional details that can be used to restore error description in other languages.\n details: StringValueMap\n correlation_id A unique transaction id to trace execution throug call chain.\n correlation_id: Optional[str]\n stack_trace Stack trace of the exception.\n stack_trace: str\n cause Original error wrapped by this exception.\n cause: str\n  Instance methods get_cause_string Gets original error wrapped by this exception as a string message.\n get_cause_string(): str\n  returns: str - an original error message.  get_stack_trace_string Gets a stack trace where this exception occured.\n get_stack_trace_string(): str\n  returns: str - a stack trace as a string.  set_cause_string Sets original error wrapped by this exception as a string message.\n set_cause_string(value: str)\n  value: str - an original error message.  set_stack_trace_string Sets a stack trace where this exception occured.\n set_stack_trace_string(value: str)\n  value: str - a stack trace as a string  with_cause Sets a original error wrapped by this exception This method returns reference to this exception to implement Builder pattern to chain additional calls.\n with_cause(cause: Exception): ApplicationException\n  cause: Exception - original error object returns: ApplicationException - this exception object  with_code Sets a unique error code.\nThis method returns reference to this exception to implement Builder pattern to chain additional calls.\n with_code(code: str): ApplicationException\n  code: str - a unique error code returns: ApplicationException - this exception object  with_correlation_id Sets a correlation id which can be used to trace this error through a call chain.\nThis method returns reference to this exception to implement Builder pattern to chain additional calls.\n with_correlation_id(correlation_id: Optional[str]): ApplicationException\n  correlation_id: Optional[str] - a unique transaction id to trace error through call chain returns: ApplicationException - this exception object  with_details Sets a parameter for additional error details. This details can be used to restore error description in other languages.\nThis method returns reference to this exception to implement Builder pattern to chain additional calls.\n with_details(key: str, value: Any): ApplicationException\n  key: str - key a details parameter name value: Any - value a details parameter name returns: ApplicationException - this exception object  with_stack_trace Sets a stack trace for this error.\nThis method returns reference to this exception to implement Builder pattern to chain additional calls\n with_stack_trace(stack_trace: str): ApplicationException\n  stack_trace: str - a stack trace where this error occured returns: ApplicationException - this exception object  with_status Sets a HTTP status code which shall be returned by REST calls. This method returns reference to this exception to implement Builder pattern to chain additional calls.\n with_status(status: int): ApplicationException\n  status: int - an HTTP error code. returns: ApplicationException - this exception object  wrap Wraps another exception into an application exception object.\nIf original exception is of ApplicationException type it is returned without changes. Otherwise a new ApplicationException is created and original error is set as its cause.\n wrap(cause: Any): ApplicationException\n  cause: Any - an original error object. returns: ApplicationException - an original or newly created ApplicationException.  Static methods unwrap_exception! TODO: this method is not realized yet for this language\nUnwraps original exception through wrapped exception objects.\nMany frameworks like Seneca or restify wrap original exception. That may result in propagating less specific errors and can hide causes of the errors.\n static unwrap_exception(error: Exception): ApplicationException\n  error: Exception - an error object returns: ApplicationException - an original error object  wrap_error Wraps another exception into specified application exception object.\nIf original exception is of ApplicationException type it is returned without changes. Otherwise the original error is set as a cause to specified ApplicationException object.\n static wrap_error(error: ApplicationException, cause: Any): ApplicationException\n  error: ApplicationException - an ApplicationException object to wrap the cause cause: Any - an original error object returns: ApplicationException - an original or newly created ApplicationException  See also   ErrorCategory   ErrorDescription   ","description":"\nDefines a base class used to define various application exceptions.\n","image":null,"permalink":"/python/commons/errors/application_exception/","subtitle":null,"tags":null,"title":"ApplicationException"},{"content":"Description The ApplicationExceptionFactory acts as a factory to recreate from ErrorDescription values passed through the wire.\nStatic methods Create Recreates ApplicationException object from a serialized ErrorDescription. It tries to restore the original exception type using the type or error category fields.\n public static ApplicationException Create(ErrorDescription description)\n  description: ErrorDescription - serialized error description received as a result of remote call returns: ApplicationException - new instance of the ApplicationException  See also   ApplicationException   ErrorDescription   ","description":"Factory to recreate exceptions from [ErrorDescription](../error_description) values passed through the wire.\n","image":null,"permalink":"/net/commons/errors/application_exception_factory/","subtitle":null,"tags":null,"title":"ApplicationExceptionFactory"},{"content":"Description The ApplicationExceptionFactory acts as a factory to recreate from ErrorDescription values passed through the wire.\nStatic methods create Recreates ApplicationException object from serialized ErrorDescription. It tries to restore original exception type using the type or error category fields.\n public static create(description: ErrorDescription): ApplicationException\n  description: ErrorDescription - serialized error description received as a result of remote call. returns: ApplicationException - new instance of the ApplicationException.  See also   ApplicationException   ErrorDescription   ","description":"Factory to recreate exceptions from [ErrorDescription](../error_description) values passed through the wire.\n","image":null,"permalink":"/node/commons/errors/application_exception_factory/","subtitle":null,"tags":null,"title":"ApplicationExceptionFactory"},{"content":"Description The ApplicationExceptionFactory acts as a factory to recreate from ErrorDescription values passed through the wire.\nStatic methods create Recreates ApplicationException object from serialized ErrorDescription. It tries to restore original exception type using type or error category fields.\n static create(description: ErrorDescription): ApplicationException\n  description: ErrorDescription - a serialized error description received as a result of remote call returns: ApplicationException - new instance of the ApplicationException  See also   ApplicationException   ErrorDescription   ","description":"Factory to recreate exceptions from [ErrorDescription](../error_description) values passed through the wire.\n","image":null,"permalink":"/python/commons/errors/application_exception_factory/","subtitle":null,"tags":null,"title":"ApplicationExceptionFactory"},{"content":"Keeps a list of supported applications that are referenced from other content microservices.\n Server implementations: NodeJS, Dart Communication protocols: Direct, Commandable HTTP, Commandable GRPC, GRPC Persistence: Memory, Flat Files, MongoDB, Couchbase Deployment options: Monolith, Process, Docker, AWS Lambda Client implementations: NodeJS, Golang, Dart  ","description":null,"image":null,"permalink":"/microservices/content/applications/","subtitle":null,"tags":null,"title":"Applications Microservice"},{"content":"Description The ArrayConverter class provides methods to create an array from a set of values. These values can be in the form of a list, a single value or a string of comma-delimited values.\nMethods ListToArray Converts a list into an array object with empty array as default. Strings with comma-delimited values are split into an array of strings. See ToArray\n ListToArray(value interface{}) []interface{}\n  value: interface{} - list to convert. returns: []interface{} - array object or empty array when value is nil  ToArray Converts value into an array object with empty array as default. Single values are converted into arrays with single element.\n ToArray(value interface{}) []interface{}\n  value: interface{} - value to convert. returns: []interface{} - array object or empty array when value is nil.  ToArrayWithDefault Converts value into array object with specified default. Single values are converted into arrays with single element.\n ToArrayWithDefault(value interface{}, defaultValue []interface{}) []interface{}\n  value: interface{} - value to convert. defaultValue: []interface{} - default array object. returns: []interface{} - array object or default array when value is nil.  ToNullableArray Converts value into array object. Single values are converted into arrays with a single element.\n ToNullableArray(value interface{}) *[]interface{}\n  value: interface{} - value to convert. returns: *[]interface{} - array object or nil when value is nil.  Examples value1 := convert.ArrayConverter.ToArray([...]int{1, 2}) value2 := convert.ArrayConverter.ToArray(1) value3 := convert.ArrayConverter.ListToArray(\u0026#34;1,2,3\u0026#34;) fmt.Println(value1) // [1 2] fmt.Println(value2) // [1] fmt.Println(value3) // [1 2 3] TArrayConverter struct{} ","description":"The ArrayConverter class provides methods to create an array from a set of values.\n","image":null,"permalink":"/golang/commons/convert/array_converter/","subtitle":null,"tags":null,"title":"ArrayConverter"},{"content":"Description The ArrayConverter class provides methods to create an array from a set of values. These values can be in the form of a list, a single value or a string of comma-delimited values.\nStatic methods ListToArray! Note: this method is not yet available for this language\nConverts a list into an array object with an empty array as the default. Strings with comma-delimited values are split into array of strings. See ToArray\n public static IList\u0026lt;object\u0026gt; ListToArray(object value)\n  value: object - list to convert. returns: IList\u0026lt;object\u0026gt;- array object or empty array when value is null  ToArray Converts value into an array object with an empty array as the default. Single values are converted into arrays with a single element.\n public static IList\u0026lt;object\u0026gt; ToArray(object value)\n  value: object - value to convert. returns: IList\u0026lt;object\u0026gt; - array object or empty array when value is null.  ToArrayWithDefault Converts value into an array object with a specified default. Single values are converted into arrays with a single element.\n public static IList\u0026lt;object\u0026gt; ToArrayWithDefault(object value, IList\u0026lt;object\u0026gt; defaultValue)\n  value: object - value to convert. defaultValue: IList\u0026lt;object\u0026gt; - default array object. returns: IList\u0026lt;object\u0026gt; - array object or default array when value is null.  ToNullableArray Converts value into an array object. Single values are converted into arrays with a single element.\n public static IList\u0026lt;object\u0026gt; ToNullableArray(object value)\n  value: object - value to convert. returns: IList\u0026lt;object\u0026gt; - array object or null when value is null.  Examples // Array var value1 = ArrayConverter.ToArray(new int[]{1, 2}) ; // Result: [1, 2]  // Single value var value2 = ArrayConverter.ToArray(1); // Result: [1]  ","description":"The ArrayConverter class provides methods to create an array from a set of values.\n","image":null,"permalink":"/net/commons/convert/array_converter/","subtitle":null,"tags":null,"title":"ArrayConverter"},{"content":"Description The ArrayConverter class provides methods to create an array from a set of values. These values can be in the form of a list, a single value or a string of comma-delimited values.\nStatic methods listToArray Converts a list into an array object with an empty array as default. Strings with comma-delimited values are split into array of strings. See toArray\n public static listToArray(value: any): any[]\n  value: any - list to convert. returns: any[] - array object or empty array when value is null.  toArray Converts a value into an array object with an empty array as default. Single values are converted into arrays with a single element.\n public static toArray(value: any): any[]\n  value: any - value to convert. returns: any[] - array object or empty array when value is null.  toArrayWithDefault Converts a value into an array object with a specified default. Single values are converted into arrays with a single element.\n public static toArrayWithDefault(value: any, defaultValue: any[]): any[]\n  value: any - value to convert. defaultValue: any[] - default array object. returns: any[] - array object or default array when value is null.  toNullableArray Converts a value into an array object. Single values are converted into arrays with a single element.\n public static toNullableArray(value: any): any[]\n  value: any - value to convert. returns: any[] - array object or null when value is null.  Examples // Array let value1 = ArrayConverter.toArray([1, 2]) ; // Result: [1, 2]  // Single value let value2 = ArrayConverter.toArray(1); // Result: [1]  // String with comma-delimited values let value3 = ArrayConverter.listToArray(\u0026#34;1,2,3\u0026#34;); // Result: [\u0026#34;1\u0026#34;, \u0026#34;2\u0026#34;, \u0026#34;3\u0026#34;]  ","description":"The ArrayConverter class provides methods to create an array from a set of values.\n","image":null,"permalink":"/node/commons/convert/array_converter/","subtitle":null,"tags":null,"title":"ArrayConverter"},{"content":"Description The ArrayConverter class provides methods to create an array from a set of values. These values can be in the form of a list, a single value or a string of comma-delimited values.\nStatic methods list_to_array Converts a list into an array object, with empty array as default. Strings with comma-delimited values are split into array of strings. See to_array\n static list_to_array(value: Any): List[Any]\n  value: Any - the list to convert. returns: List[Any] - array object or empty array when value is None  to_array Converts value into array object with empty array as default. Single values are converted into arrays with single element.\n static to_array(value: Any): List[Any]\n  value: Any - the value to convert. returns: List[Any] - array object or empty array when value is None.  to_array_with_default Converts value into array object with specified default. Single values are converted into arrays with single element.\n static to_array_with_default(value: Any, default_value: List[Any]): List[Any]\n  value: Any - the value to convert. default_value: List[Any] - default array object. returns: List[Any] - array object or default array when value is None.  to_nullable_array Converts value into array object. Single values are converted into arrays with a single element.\n static to_nullable_array(value: Any): Optional[List[Any]]\n  value: Any - the value to convert. returns: Optional[List[Any]] - array object or None when value is None.  Examples # List value1 = ArrayConverter.to_array([1, 2]) # Result: [1, 2] # Single value value2 = ArrayConverter.to_array(1) # Result: [1] # String with comma-delimited values value3 = ArrayConverter.list_to_array(\u0026#34;1,2,3\u0026#34;) # Result: [\u0026#34;1\u0026#34;, \u0026#34;2\u0026#34;, \u0026#34;3\u0026#34;] ","description":"The ArrayConverter class provides methods to create an array from a set of values.\n","image":null,"permalink":"/python/commons/convert/array_converter/","subtitle":null,"tags":null,"title":"ArrayConverter"},{"content":"Implements: Schema\nDescription The ArraySchema class allows you to validate arrays based on a specified validation rule.\nConstructors NewArraySchema Creates a new validation rule and sets its values. See TypeCode\n NewArraySchema(valueType interface{}) *ArraySchema\n  valueType: interface{} - type of array elements. Null means that elements may have any type.  Methods ValueType Gets the type of array elements. Null means that elements may have any type.\n (c *ArraySchema) ValueType() interface{}\n  returns: interface{} - type of array elements.  PerformValidation Validates a given value against the schema and configured validation rules.\n (c *ArraySchema) PerformValidation(path string, value interface{}) []*ValidationResult\n  path: string - dot notation path to the value. value: interface{} - value to be validated. returns: []*ValidationResult - list with validation results to add new results.  SetValueType Sets the type of array elements. Null means that the elements may have any type.\n (c *ArraySchema) SetValueType(value interface{})\n  value: interface{} - type of array elements.  Examples schema := NewArraySchema(TypeCode.String); schema.Validate([\u0026#34;A\u0026#34;, \u0026#34;B\u0026#34;, \u0026#34;C\u0026#34;]); // Result: no errors schema.Validate([1, 2, 3]); // Result: element type mismatch schema.Validate(\u0026#34;A\u0026#34;); // Result: type mismatch  ","description":"Schema to validate arrays.\n","image":null,"permalink":"/golang/commons/validate/array_schema/","subtitle":null,"tags":null,"title":"ArraySchema"},{"content":"Inherits: Schema\nDescription The ArraySchema class allows you to validate arrays based on a specified validation rule.\nConstructors Creates a new validation rule and sets its values. See TypeCode\n public ArraySchema(object valueType)\n  valueType: object - type of array elements. Null means that elements may have any type.  Creates a new instance of a validation schema.\n public ArraySchema()\n Properties ValueType Gets and Sets the type of array elements. Null means that elements may have any type.\n public object ValueType { get; set; }\n Instance methods PerformValidation Validates a given value against the schema and configured validation rules.\n protected internal override void PerformValidation(string path, object value, List\u0026lt;ValidationResult\u0026gt; results)\n  path: string - dot notation path to the value. value: object - value to be validated. results: List\u0026lt;ValidationResult\u0026gt; - list with validation results to add new results.  Examples var schema = new ArraySchema(TypeCode.String); schema.Validate(new String[]{\u0026#34;A\u0026#34;, \u0026#34;B\u0026#34;, \u0026#34;C\u0026#34;}); // Result: no errors schema.Validate(new int[] {1, 2, 3}); // Result: element type mismatch schema.Validate(\u0026#34;A\u0026#34;); // Result: type mismatch  ","description":"Schema to validate arrays.\n","image":null,"permalink":"/net/commons/validate/array_schema/","subtitle":null,"tags":null,"title":"ArraySchema"},{"content":"Extends: Schema\nDescription The ArraySchema class allows you to validate arrays based on a specified validation rule.\nConstructors Creates a new validation rule and sets its values. See TypeCode\n public constructor(valueType?: any, required?: boolean, rules?: IValidationRule[])\n  valueType: any - a type of array elements. Null means that elements may have any type. required: boolean - (optional) true to always require non-null values. rules: IValidationRule[] - (optional) list with validation rules.  Instance methods getValueType Gets the type of array elements. Null means that elements may have any type.\n public getValueType(): any\n  returns: any - type of array elements.  performValidation Validates a given value against the schema and configured validation rules.\n protected performValidation(path: string, value: any, results: ValidationResult[]): void\n  path: string - dot notation path to the value. value: any - value to be validated. results: ValidationResult[] - list with validation results.  setValueType Sets the type of array elements. Null means that elements may have any type.\n public setValueType(value: any): void\n  value: any - type of array elements.  Examples let schema = new ArraySchema(TypeCode.String); schema.validate([\u0026#34;A\u0026#34;, \u0026#34;B\u0026#34;, \u0026#34;C\u0026#34;]); // Result: no errors schema.validate([1, 2, 3]); // Result: element type mismatch schema.validate(\u0026#34;A\u0026#34;); // Result: type mismatch  ","description":"Schema to validate arrays.\n","image":null,"permalink":"/node/commons/validate/array_schema/","subtitle":null,"tags":null,"title":"ArraySchema"},{"content":"Implements: Schema\nDescription The ArraySchema class allows you to validate arrays based on a specified validation rule.\nConstructors Creates a new validation rule and sets its values. See TypeCode\n ArraySchema(valueType: Any = None, required: bool = None, rules: List[IValidationRule] = None)\n  valueType: Any - a type of array elements. Null means that elements may have any type. required: bool - (optional) true to always require non-None values. rules: List[IValidationRule] - (optional) a list with validation rules.  Instance methods get_value_type Gets the type of array elements. Null means that elements may have any type.\n get_value_type(): Any\n  returns: Any - the type of array elements.  perform_validation Validates a given value against the schema and configured validation rules.\n _perform_validation(path: str, value: Any, results: List[ValidationResult])\n  path: str - a dot notation path to the value. value: Any - a value to be validated. results: List[ValidationResult] - a list with validation results to add new results.  set_value_type Sets the type of array elements. Null means that elements may have any type.\n set_value_type(value: Any)\n  value: Any - a type of array elements.  Examples schema = ArraySchema(TypeCode.String) schema.validate([\u0026#34;A\u0026#34;, \u0026#34;B\u0026#34;, \u0026#34;C\u0026#34;]) # Result: no errors schema.validate([1, 2, 3]) # Result: element type mismatch schema.validate(\u0026#34;A\u0026#34;) # Result: type mismatch  ","description":"Schema to validate arrays.\n","image":null,"permalink":"/python/commons/validate/array_schema/","subtitle":null,"tags":null,"title":"ArraySchema"},{"content":"Description The AtLeastOneExistsRule class allows you to check that given a set of properties, at least one of them exists.\nConstructors NewAtLeastOneExistsRule Creates a new validation rule and sets its values\n NewAtLeastOneExistsRule(properties \u0026hellip;string) *AtLeastOneExistsRule\n  properties: \u0026hellip;string - list of property names where at least one property must exist  Methods Validate Validates a given value against this rule.\n (c *AtLeastOneExistsRule) Validate(path string, schema ISchema, value interface{}) []*ValidationResult\n  path: string - dot notation path to the value. schema: ISchema - schema this rule is called from value: interface{} - value to be validated. results: []*ValidationResult - list with validation results to add new results.  Examples schema := NewSchema() .WithRule(NewAtLeastOneExistsRule(\u0026#34;field1\u0026#34;, \u0026#34;field2\u0026#34;)); schema.Validate({ field1: 1, field2: \u0026#34;A\u0026#34; }); // Result: no errors schema.Validate({ field1: 1 }); // Result: no errors schema.Validate({ }); // Result: at least one of properties field1, field2 must exist  See also   IValidationRule   ","description":"Validation rule that checks that at least one of the object properties exists.\n","image":null,"permalink":"/golang/commons/validate/at_least_one_exists_rule/","subtitle":null,"tags":null,"title":"AtLeastOneExistsRule"},{"content":"Inherits: IValidationRule\nDescription The AtLeastOneExistsRule class allows you to check that given a set of properties, at least one of them exists.\nConstructors Creates a new validation rule and sets its values\n public AtLeastOneExistsRule(params string[] properties)\n  properties: string[] - list of property names where at least one property must exist  Instance methods Validate Validates a given value against this rule.\n public void Validate(string path, Schema schema, object value, List\u0026lt;ValidationResult\u0026gt; results)\n  path: string - dot notation path to the value. schema: Schema - schema this rule is called from value: object - value to be validated. results: List\u0026lt;ValidationResult\u0026gt; - list with validation results to add new results.  Examples var schema = new Schema().WithRule(new AtLeastOneExistsRule(\u0026#34;field1\u0026#34;, \u0026#34;field2\u0026#34;)); schema.Validate({ field1: 1, field2: \u0026#34;A\u0026#34; }); // Result: no errors schema.Validate({ field1: 1 }); // Result: no errors schema.Validate({ }); // Result: at least one of properties field1, field2 must exist  See also   IValidationRule   ","description":"Validation rule that checks that at least one of the object properties exists.\n","image":null,"permalink":"/net/commons/validate/at_least_one_exists_rule/","subtitle":null,"tags":null,"title":"AtLeastOneExistsRule"},{"content":"Implements: IValidationRule\nDescription The AtLeastOneExistsRule class allows you to check that given a set of properties, at least one of them exists.\nConstructors Creates a new validation rule and sets its values\n public constructor(\u0026hellip;properties: string[])\n  properties: string[] - list of property names where at least one property must exist  Instance methods validate Validates a given value against this rule.\n public validate(path: string, schema: Schema, value: any, results: ValidationResult[]): void\n  path: string - dot notation path to the value. schema: Schema - schema this rule is called from. value: any - value to be validated. results: ValidationResult[] - list with validation results.  Examples let schema = new Schema() .withRule(new AtLeastOneExistsRule(\u0026#34;field1\u0026#34;, \u0026#34;field2\u0026#34;)); schema.validate({ field1: 1, field2: \u0026#34;A\u0026#34; }); // Result: no errors schema.validate({ field1: 1 }); // Result: no errors schema.validate({ }); // Result: at least one of properties field1, field2 must exist  See also   IValidationRule   ","description":"Validation rule that checks that at least one of the object's properties exists.\n","image":null,"permalink":"/node/commons/validate/at_least_one_exists_rule/","subtitle":null,"tags":null,"title":"AtLeastOneExistsRule"},{"content":"Implements: IValidationRule\nDescription The AtLeastOneExistsRule class allows you to check that given a set of properties, at least one of them exists.\nConstructors Creates a new validation rule and sets its values\n AtLeastOneExistsRule(*properties: str)\n  properties: str - a list of property names where at least one property must exist  Instance methods validate Validates a given value against this rule.\n validate(path: str, schema: Schema, value: Any, results: List[ValidationResult])\n  path: str - a dot notation path to the value. schema: Schema - a schema this rule is called from value: Any - a value to be validated. results: List[ValidationResult] - a list with validation results to add new results.  Examples schema = Schema().with_rule(AtLeastOneExistsRule(\u0026#34;field1\u0026#34;, \u0026#34;field2\u0026#34;)) schema.validate({ field1: 1, field2: \u0026#34;A\u0026#34; }) # Result: no errors schema.validate({ field1: 1 }) # Result: no errors schema.validate({ }) # Result: at least one of properties field1, field2 must exist See also   IValidationRule   ","description":"Validation rule that checks that at least one of the object properties exists.\n","image":null,"permalink":"/python/commons/validate/at_least_one_exists_rule/","subtitle":null,"tags":null,"title":"AtLeastOneExistsRule"},{"content":"Implements: IConfigurable, IReferenceable\nDescription The AwsConnectionParams class contains connection parameters used to authenticate against Amazon Web Services (AWS) and connect to specific AWS resources.\nImportant points\n This class is able to compose and parse AWS resource ARNs.  Configuration parameters  access_id: application access id client_id: alternative to access_id access_key: application secret key client_key: alternative to access_key secret_key: alternative to access_key  In addition to standard parameters, CredentialParams may contain any number of custom parameters\nConstructors Creates an new instance of the connection parameters.\n public constructor(values: any = null)\n  values: any - (optional) object to be converted into key-value pairs to initialize this connection.  Instance methods getAccessId Gets the AWS access id.\n public getAccessId(): string\n  returns: string - AWS access id.  getAccessKey Gets the AWS client key.\n public getAccessKey(): string\n  returns: string - AWS client key.  getAccount Gets the AWS account id.\n public getAccount(): string\n  returns: string - AWS account id.  getArn Gets the AWS resource ARN. If the ARN is not defined, it automatically generates it from other properties.\n public getArn(): string\n  returns: string - AWS resource ARN.  getPartition Gets the AWS partition name.\n public getPartition(): string\n  returns: string - AWS partition name.  getRegion Gets the AWS region.\n public getRegion(): string\n  returns: string - AWS region.  getResource Gets the AWS resource id.\n public getResource(): string\n  returns: string - AWS resource id.  getResourceType Gets the AWS resource type.\n public getResourceType(): string\n  returns: string - AWS resource type.  getService Gets the AWS service name.\n public getService(): string\n  returns: string - AWS service name.  setAccessId Sets the AWS access id.\n public setAccessId(value: string)\n  value: string - AWS access id.  setAccessKey Sets the AWS client key.\n public setAccessKey(value: string)\n  value: string - new AWS client key.  setAccount Sets the AWS account id.\n public setAccount(value: string)\n  value: string - AWS account id.  setArn Sets the AWS resource ARN. When it sets the value, it automatically parses the ARN and sets individual parameters.\n public setArn(value: string)\n  value: string - new AWS resource ARN.  setPartition Sets the AWS partition name.\n public setPartition(value: string)\n  value: string - new AWS partition name.  setRegion Sets the AWS region.\n public setRegion(value: string)\n  value: string - new AWS region.  setResource Sets the AWS resource id.\n public setResource(value: string)\n  value: string - new AWS resource id.  setResourceType Sets the AWS resource type.\n public setResourceType(value: string)\n  value: string - new AWS resource type.  setService Sets the AWS service name.\n public setService(value: string)\n  value: string - new AWS service name.  validate Validates this connection parameters\n public validate(correlationId: string)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain.  Static methods fromConfig Retrieves AwsConnectionParams from configuration parameters. The values are retrieved from \u0026ldquo;connection\u0026rdquo; and \u0026ldquo;credential\u0026rdquo; sections.\nSee mergeConfigs\n public static fromConfig(config: ConfigParams): AwsConnectionParams\n  config: ConfigParams - configuration parameters returns: AwsConnectionParams - generated AwsConnectionParams object.  fromString Creates a new AwsConnectionParams object filled with key-value pairs serialized as a string.\nExample: \u0026ldquo;Key1=123;Key2=ABC;Key3=2016-09-16T00:00:00.00Z\u0026rdquo;\n public static fromString(line: string): AwsConnectionParams\n  line: string - string with serialized key-value pairs as \u0026ldquo;key1=value1;key2=value2;\u0026hellip;\u0026rdquo;. returns: AwsConnectionParams - new AwsConnectionParams object.  mergeConfigs Retrieves AwsConnectionParams from multiple configuration parameters. The values are retrieved from \u0026ldquo;connection\u0026rdquo; and \u0026ldquo;credential\u0026rdquo; sections.\n public static mergeConfigs(\u0026hellip;configs: ConfigParams[]): AwsConnectionParams\n  configs: ConfigParams[] - list with configuration parameters. returns: AwsConnectionParams - generated AwsConnectionParams object.  Examples let connection = AwsConnectionParams.fromTuples( \u0026#34;region\u0026#34;, \u0026#34;us-east-1\u0026#34;, \u0026#34;access_id\u0026#34;, \u0026#34;XXXXXXXXXXXXXXX\u0026#34;, \u0026#34;secret_key\u0026#34;, \u0026#34;XXXXXXXXXXXXXXX\u0026#34;, \u0026#34;service\u0026#34;, \u0026#34;s3\u0026#34;, \u0026#34;bucket\u0026#34;, \u0026#34;mybucket\u0026#34; ); let region = connection.getRegion(); // Result: \u0026#34;us-east-1\u0026#34; let accessId = connection.getAccessId(); // Result: \u0026#34;XXXXXXXXXXXXXXX\u0026#34; let secretKey = connection.getAccessKey(); // Result: \u0026#34;XXXXXXXXXXXXXXX\u0026#34; let pin = connection.getAsNullableString(\u0026#34;bucket\u0026#34;); // Result: \u0026#34;mybucket\u0026#34; See also   AwsConnectionResolver   ","description":"Contains connection parameters to authenticate against Amazon Web Services (AWS) and connect to specific AWS resources.\n","image":null,"permalink":"/node/aws/connect/aws_connection_params/","subtitle":null,"tags":null,"title":"AwsConnectionParams"},{"content":"Implements: IConfigurable, IReferenceable\nDescription The AwsConnectionResolver class allows you to retrieve AWS connection and credential parameters, validate them and compose a AwsConnectionParams value.\nConfiguration parameters  connections:  discovery_key: (optional) key to retrieve the connection from IDiscovery region: (optional) AWS region partition: (optional) AWS partition service: (optional) AWS service resource_type: (optional) AWS resource type resource: (optional) AWS resource id arn: (optional) AWS resource ARN   credentials:  store_key: (optional) key to retrieve the credentials from ICredentialStore access_id: AWS access/client id access_key: AWS access/client id    References  *:discovery:*:*:1.0: (optional) IDiscovery services to resolve connection. *:credential-store:*:*:1.0: (optional) credential stores to resolve credentials.  Fields _connectionResolver Connection resolver.\n protected _connectionResolver: ConnectionResolver\n _credentialResolver Credential resolver.\n protected _credentialResolver: CredentialResolver\n  Instance methods configure Configures a component by passing its configuration parameters.\n public configure(config: ConfigParams): void\n  config: ConfigParams - configuration parameters to be set.  resolve Resolves a connection and credential parameters and generates a single AWSConnectionParams value.\n public resolve(correlationId: string): Promise\u0026lt;AwsConnectionParams\u0026gt;\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. returns: Promise\u0026lt;AwsConnectionParams\u0026gt; - receives an AWSConnectionParams value or error.  setReferences Sets references to dependent components.\n public setReferences(references: IReferences): void\n  references: IReferences - references to locate the component\u0026rsquo;s dependencies.  Examples let config = ConfigParams.fromTuples( \u0026#34;connection.region\u0026#34;, \u0026#34;us-east1\u0026#34;, \u0026#34;connection.service\u0026#34;, \u0026#34;s3\u0026#34;, \u0026#34;connection.bucket\u0026#34;, \u0026#34;mybucket\u0026#34;, \u0026#34;credential.access_id\u0026#34;, \u0026#34;XXXXXXXXXX\u0026#34;, \u0026#34;credential.access_key\u0026#34;, \u0026#34;XXXXXXXXXX\u0026#34; ); let connectionResolver = new AwsConnectionResolver(); connectionResolver.configure(config); connectionResolver.setReferences(references); const connectionParams = await connectionResolver.resolve(\u0026#34;123\u0026#34;); See also   ConnectionParams   IDiscovery   ","description":"Helper class used to retrieve AWS connection and credential parameters, validate them and compose a [AwsConnectionParams](../aws_connection_params) value.\n","image":null,"permalink":"/node/aws/connect/aws_connection_resolver/","subtitle":null,"tags":null,"title":"AwsConnectionResolver"},{"content":"Extends: Container\nDescription When handling calls \u0026ldquo;cmd\u0026rdquo; parameter determines which what action shall be called, while other parameters are passed to the action itself.\nContainer configuration for this Azure Function is stored in \u0026quot;./config/config.yml\u0026quot; file. But this path can be overriden by CONFIG_PATH environment variable.\nReferences  *:logger:*:*:1.0: (optional) ILogger components to pass log messages *:counters:*:*:1.0: (optional) ICounters components to pass collected measurements *:service:azure-function:*:1.0: (optional) IAzureFunctionService services to handle action requests. *:service:commandable-azure-function:*:1.0: (optional) IAzureFunctionService services to handle action requests.  Constructors Creates a new instance of this Azure Function.\n public constructor(name?: string, description?: string)\n  name: string - (optional) a container name (accessible via ContextInfo) description: string - (optional) a container description (accessible via ContextInfo)  Instance methods getBody Returns body from Azure Function context. This method can be overloaded in child classes\n protected getBody(context: any): string\n  context: any - Azure Function context. returns: string - Returns body from context.  register Registers all actions in this Azure Function.\n public register(): void\n Examples class MyAzureFunctionFunction extends AzureFunction { public constructor() { base(\u0026#34;mygroup\u0026#34;, \u0026#34;MyGroup Azure Function\u0026#34;); } } let azureFunction = new MyAzureFunctionFunction(); await service.run(); console.log(\u0026#34;MyAzureFunctionFunction is started\u0026#34;); ","description":"Abstract Azure Function, that acts as a container to instantiate and run components and expose them via external entry point. \n","image":null,"permalink":"/node/azure/containers/azure_function/","subtitle":null,"tags":null,"title":"AzureFunction"},{"content":"Description TODO: add description\nFields action Action to be executed\n public action: (context: any) =\u0026gt; Promise\u0026lt;any\u0026gt;\n cmd Command to call the action\n public cmd: string\n schema Schema to validate action parameters\n public schema: Schema\n  ","description":"TODO: add description\n","image":null,"permalink":"/node/azure/services/azure_function_action/","subtitle":null,"tags":null,"title":"AzureFunctionAction"},{"content":"Description TODO: add description\nInstance methods getCorrelationId Returns correlationId from Azure Function context.\n public static getCorrelationId(context: any): string\n  context: any - the Azure Function context. returns: string - returns correlationId from context.  getCommand Returns command from Azure Function context.\n public static getCommand(context: any): string\n  context: any - the Azure Function context. returns: string - returns command from context.  getHttpRequestBody Returns body from Azure Function context http request.\n public static getHttpRequestBody(context: any): string\n  context: any - the Azure Function context. returns: string - returns body from context.  ","description":"TODO: add description\n","image":null,"permalink":"/node/azure/containers/azure_function_context_helper/","subtitle":null,"tags":null,"title":"AzureFunctionContextHelper"},{"content":"Implements: IAzureFunctionService, IOpenable, IConfigurable, IReferenceable\nDescription This service is intended to work inside AzureFunction container that exposes registered actions externally.\nConfiguration parameters  dependencies:  controller: override for Controller dependency    References  *:logger:*:*:1.0: (optional) ILogger components to pass log messages. *:counters:*:*:1.0: (optional) ICounters components to pass collected measurements.  Constructors Creates an instance of this service.\n public constructor(name?: string)\n  name: string - a service name to generate action cmd.  Fields _counters The performance counters.\n protected _counters: CompositeCounters\n _dependencyResolver The dependency resolver.\n protected _dependencyResolver: DependencyResolver\n _logger The dependency resolver.\n protected _logger: CompositeLogger\n _tracer The tracer.\n protected _tracer: CompositeTracer\n  Instance methods act Calls registered action in this Azure Function. \u0026ldquo;cmd\u0026rdquo; parameter in the action parameters determine what action shall be called.\nThis method shall only be used in testing.\n public act(context: any): Promise\u0026lt;any\u0026gt;\n  context: any - the context context. returns: Promise\u0026lt;any\u0026gt; - TODO: add description  applyInterceptors TODO: add description\n protected applyInterceptors(action: (context: any) =\u0026gt; Promise\u0026lt;any\u0026gt;): (context: any) =\u0026gt; Promise\u0026lt;any\u0026gt;\n  action: (context: any) =\u0026gt; Promise\u0026lt;any\u0026gt; - TODO: add description returns: (context: any) =\u0026gt; Promise\u0026lt;any\u0026gt; - TODO: add description  applyValidation TODO: add description\n protected applyValidation(schema: Schema, action: (context: any) =\u0026gt; Promise\u0026lt;any\u0026gt;): (context: any) =\u0026gt; Promise\u0026lt;any\u0026gt;\n  schema: Schema - TODO: add description action: (context: any) =\u0026gt; Promise\u0026lt;any\u0026gt; - TODO: add description returns: (context: any) =\u0026gt; Promise\u0026lt;any\u0026gt; - TODO: add description  close Closes component and frees used resources.\n public close(correlationId: string): Promise\u0026lt;void\u0026gt;\n  correlationId: string - (optional) transaction id to trace execution through call chain.  applyInterceptors Configures component by passing configuration parameters.\n public configure(config: ConfigParams): void\n  config: ConfigParams - configuration parameters to be set.  generateActionCmd TODO: add description\n protected generateActionCmd(name: string): string\n  name: string - TODO: add description returns: string - TODO: add description  getActions Get all actions supported by the service.\n public getActions(): AzureFunctionAction[]\n  returns: AzureFunctionAction[] - an array with supported actions.  getCommand Returns command from Azure Function context.\nThis method can be overloaded in child classes.\n protected getCommand(context: any): string\n  context: any - the context context. returns: string - returns command from context.  getCorrelationId Returns correlationId from Azure Function context.\nThis method can be overloaded in child classes.\n protected getCorrelationId(context: any): string\n  context: any - the context context. returns: string - returns correlationId from context.  instrument Adds instrumentation to log calls and measure call time. It returns a Timing object that is used to end the time measurement.\n protected instrument(correlationId: string, name: string): InstrumentTiming\n  correlationId: string - (optional) transaction id to trace execution through call chain. name: string - a method name. returns: InstrumentTiming - Timing object to end the time measurement.  isOpen Checks if the component is opened.\n public isOpen(): boolean\n  returns: boolean - true if the component has been opened and false otherwise.  open Opens the component.\n public open(correlationId: string): Promise\u0026lt;void\u0026gt;\n  correlationId: string - (optional) transaction id to trace execution through call chain.  registerAction Registers a action in Azure Function function.\n protected registerAction(name: string, schema: Schema, action: (context: any) =\u0026gt; Promise\u0026lt;any\u0026gt;): void\n  name: string - an action name schema: Schema - a validation schema to validate received parameters. action: (context: any) =\u0026gt; Promise\u0026lt;any\u0026gt; - an action function that is called when operation is invoked.  registerActionWithAuth Registers an action with authorization.\n protected registerActionWithAuth(name: string, schema: Schema, authorize: (context: any, next: (context: any) =\u0026gt; Promise\u0026lt;any\u0026gt;) =\u0026gt; Promise\u0026lt;any\u0026gt;, action: (context: any) =\u0026gt; Promise\u0026lt;any\u0026gt;): void\n  name: string - an action name schema: Schema - a validation schema to validate received parameters. authorize: (context: any, next: (context: any) =\u0026gt; Promise\u0026lt;any\u0026gt;) =\u0026gt; Promise\u0026lt;any\u0026gt; - an authorization interceptor action: (context: any) =\u0026gt; Promise\u0026lt;any\u0026gt; - an action function that is called when operation is invoked.  registerInterceptor Registers a middleware for actions in Azure Function service.\n protected registerInterceptor(action: (context: any, next: (context: any) =\u0026gt; Promise\u0026lt;any\u0026gt;) =\u0026gt; Promise\u0026lt;any\u0026gt;): void\n  action: (context: any, next: (context: any) =\u0026gt; Promise\u0026lt;any\u0026gt;) =\u0026gt; Promise\u0026lt;any\u0026gt; - an action function that is called when middleware is invoked.  setReferences Sets references to dependent components.\n public setReferences(references: IReferences): void\n  references: IReferences - references to locate the component dependencies.  Abstract methods register Registers all service routes in HTTP endpoint.\nThis method is called by the service and must be overridden in child classes.\n protected abstract register(): void\n Examples class MyAzureFunctionService extends AzureFunctionService { private _controller: IMyController; ... public constructor() { base(\u0026#39;v1.myservice\u0026#39;); this._dependencyResolver.put( \u0026#34;controller\u0026#34;, new Descriptor(\u0026#34;mygroup\u0026#34;,\u0026#34;controller\u0026#34;,\u0026#34;*\u0026#34;,\u0026#34;*\u0026#34;,\u0026#34;1.0\u0026#34;) ); } public setReferences(references: IReferences): void { base.setReferences(references); this._controller = this._dependencyResolver.getRequired\u0026lt;IMyController\u0026gt;(\u0026#34;controller\u0026#34;); } public register(): void { registerAction(\u0026#34;get_mydata\u0026#34;, null, async (context) =\u0026gt; { let correlationId = context.correlation_id; let id = context.id; return await this._controller.getMyData(correlationId, id); }); ... } } let service = new MyAzureFunctionService(); service.configure(ConfigParams.fromTuples( \u0026#34;connection.protocol\u0026#34;, \u0026#34;http\u0026#34;, \u0026#34;connection.host\u0026#34;, \u0026#34;localhost\u0026#34;, \u0026#34;connection.port\u0026#34;, 8080 )); service.setReferences(References.fromTuples( new Descriptor(\u0026#34;mygroup\u0026#34;,\u0026#34;controller\u0026#34;,\u0026#34;default\u0026#34;,\u0026#34;default\u0026#34;,\u0026#34;1.0\u0026#34;), controller )); service.open(\u0026#34;123\u0026#34;); ","description":"Abstract service that receives remove calls via Azure Function protocol.\n","image":null,"permalink":"/node/azure/services/azure_function_service/","subtitle":null,"tags":null,"title":"AzureFunctionService"},{"content":"Description The BadRequestError class is used to manage errors created by improper user requests. For example, when there are missing or incorrect parameters in the request.\nConstructors NewBadRequestError Creates an error instance and assigns its values.\n NewBadRequestError(correlationId, code, message string) *ApplicationError\n  correlation_id: string - (optional) unique transaction id used to trace execution through the call chain. code: string - (optional) unique error code. Default: \u0026ldquo;UNKNOWN\u0026rdquo; message: string - (optional) a human-readable description of the error.  ","description":"Errors due to improper user requests. \n","image":null,"permalink":"/golang/commons/errors/bad_request_error/","subtitle":null,"tags":null,"title":"BadRequestError"},{"content":"Inherits: ApplicationException\nDescription The BadRequestException class is used to manage errors created by improper user requests. For example, when there are missing or incorrect parameters in the request.\nConstructors Creates an error instance and assigns its values.\n public BadRequestException(string correlationId = null, string code = null, string message = null)\n  correlationId: string - (optional) unique transaction id used to trace execution through the call chain. code: string - (optional) unique error code. Default: \u0026ldquo;UNKNOWN\u0026rdquo; message: string - (optional) human-readable description of the error.  Creates an error instance with an error message.\n public BadRequestException(string message)\n  message: string - human-readable description of the error.  Creates an error instance with a bad request error category and assigns its values.\n public BadRequestException(Exception innerException)\n  innerException: Exception - error object  Creates an error instance.\n protected BadRequestException(SerializationInfo info, StreamingContext context)\n  info: SerializationInfo - serialization information context: StreamingContext - streaming context  ","description":"Errors due to improper user requests. \n","image":null,"permalink":"/net/commons/errors/bad_request_exception/","subtitle":null,"tags":null,"title":"BadRequestException"},{"content":"Extends: ApplicationException\nDescription The BadRequestException class is used to manage errors created by improper user requests. For example, when there are missing or incorrect parameters in the request.\nConstructors Creates an error instance and assigns its values.\n public constructor(correlation_id: string = null, code: string = null, message: string = null)\n  correlation_id: string - (optional) unique transaction id used to trace execution through the call chain. code: string - (optional) unique error code. Default: \u0026ldquo;UNKNOWN\u0026rdquo; message: string - (optional) human-readable description of the error.  ","description":"Errors due to improper user requests. \n","image":null,"permalink":"/node/commons/errors/bad_request_exception/","subtitle":null,"tags":null,"title":"BadRequestException"},{"content":"Implements: ApplicationException\nDescription The BadRequestException class is used to manage errors created by improper user requests. For example, when there are missing or incorrect parameters in the request.\nConstructors Creates an error instance and assigns its values.\n BadRequestException(correlation_id: Optional[str] = None, code: str = None, message: str = None)\n  correlation_id: Optional[str] - (optional) a unique transaction id to trace execution through call chain. code: str - (optional) a unique error code. Default: \u0026ldquo;UNKNOWN\u0026rdquo; message: str - (optional) a human-readable description of the error.  ","description":"Errors due to improper user requests. \n","image":null,"permalink":"/python/commons/errors/bad_request_exception/","subtitle":null,"tags":null,"title":"BadRequestException"},{"content":"Description The BasicAuthManager provides two methods: one to grant access to everyone and another to grant access to authorized users.\nInstance methods Anybody Allows everyone access, even unauthorized users.\n (c *BasicAuthManager) Anybody() func(res http.ResponseWriter, req *http.Request, next http.HandlerFunc)\n  returns: func(res http.ResponseWriter, req *http.Request, next http.HandlerFunc) - returns anybody handler.  Signed Access is granted only to authorized users.\nThrows UnauthorizedException exception if not authorized.\n (c *BasicAuthManager) Signed() func(res http.ResponseWriter, req *http.Request, next http.HandlerFunc)\n  returns: func(res http.ResponseWriter, req *http.Request, next http.HandlerFunc) - returns sign handler.  ","description":"Basic authorizer.\n","image":null,"permalink":"/golang/rpc/auth/basic_auth_manager/","subtitle":null,"tags":null,"title":"BasicAuthManager"},{"content":"Description The BasicAuthorizer provides two methods: one to grant access to everyone and another to grant access to authorized users.\nInstance methods Anybody Allows everyone access, even unauthorized users.\n public Func\u0026lt;HttpRequest, HttpResponse, ClaimsPrincipal, RouteData, Func\u0026lt;Task\u0026gt;, Task\u0026gt; Anybody()\n  returns: Func\u0026lt;HttpRequest, HttpResponse, ClaimsPrincipal, RouteData, Func\u0026lt;Task\u0026gt;, Task\u0026gt; - returns anybody handler.  Signed Access is granted only to authorized users.\nThrows UnauthorizedException exception if not authorized.\n public Func\u0026lt;HttpRequest, HttpResponse, ClaimsPrincipal, RouteData, Func\u0026lt;Task\u0026gt;, Task\u0026gt; Signed()\n  returns: Func\u0026lt;HttpRequest, HttpResponse, ClaimsPrincipal, RouteData, Func\u0026lt;Task\u0026gt;, Task\u0026gt; - returns sign handler.  ","description":"Basic authorizer.\n","image":null,"permalink":"/net/rpc/auth/basic_authorizer/","subtitle":null,"tags":null,"title":"BasicAuthorizer"},{"content":"Description The BasicAuthorizer provides two methods: one to grant access to everyone and another to grant access to authorized users.\nInstance methods anybody Allows everyone access, even unauthorized users.\n public anybody(): (req: any, res: any, next: () =\u0026gt; void) =\u0026gt; void\n  returns: (req: any, res: any, next: () =\u0026gt; void) =\u0026gt; void - returns anybody handler.  signed Access is granted only to authorized users.\nThrows UnauthorizedException exception if not authorized.\n public signed(): (req: any, res: any, next: () =\u0026gt; void) =\u0026gt; void\n  returns: (req: any, res: any, next: () =\u0026gt; void) =\u0026gt; void - returns sign handler.  ","description":"Basic authorizer.\n","image":null,"permalink":"/node/rpc/auth/basic_authorizer/","subtitle":null,"tags":null,"title":"BasicAuthorizer"},{"content":"Description The BasicAuthorizer provides two methods: one to grant access to everyone and another to grant access to authorized users.\nInstance methods anybody Allows everyone access, even unauthorized users.\n anybody(): Callable\n  returns: Callable - returns anybody handler.  signed Access is granted only to authorized users.\nThrows UnauthorizedException exception if not authorized.\n signed(): Callable\n  returns: Callable - returns sign handler.  ","description":"Basic authorizer.\n","image":null,"permalink":"/python/rpc/auth/basic_authorizer/","subtitle":null,"tags":null,"title":"BasicAuthorizer"},{"content":"Keeps list of beacons.\n Server implementations: NodeJS Communication protocols: Direct, Commandable HTTP, Commandable GRPC, GRPC Persistence: Memory, Flat Files, MongoDB, Couchbase Deployment options: Monolith, Process, Docker, AWS Lambda Client implementations: NodeJS  ","description":null,"image":null,"permalink":"/microservices/iot/beacons/","subtitle":null,"tags":null,"title":"Beacons Microservice"},{"content":"Records all documents that attached to a particilar blob. When last document is disattached, the blob gets removed.\n Server implementations: NodeJS, Dart Communication protocols: Direct, Commandable HTTP, Commandable GRPC, GRPC Persistence: Memory, Flat Files, MongoDB, Couchbase Deployment options: Monolith, Process, Docker, AWS Lambda Client implementations: NodeJS, Dart  ","description":null,"image":null,"permalink":"/microservices/content/attachments/","subtitle":null,"tags":null,"title":"Blob Attachments Microservice"},{"content":"Stores large binary blobs, manages references to them from other entities and serves stored content to users. Most often binary blobs are used to store images and document attachments.\n Server implementations: NodeJS, Dart Communication protocols: Direct, Commandable HTTP, Commandable GRPC, GRPC Persistence: Memory, Flat Files, MongoDB, Couchbase, AWS S3 Deployment options: Monolith, Process, Docker, AWS Lambda Client implementations: NodeJS, .NET, Golang, Dart  ","description":null,"image":null,"permalink":"/microservices/infrastructure/blobs/","subtitle":null,"tags":null,"title":"Blobs Microservice"},{"content":"Description The BooleanConverter class allows you to convert different values to boolean values using the following rules:\n  Numbers: \u0026lt;\u0026gt;0 are true, =0 are false\n  Strings: \u0026ldquo;true\u0026rdquo;, \u0026ldquo;yes\u0026rdquo;, \u0026ldquo;T\u0026rdquo;, \u0026ldquo;Y\u0026rdquo;, \u0026ldquo;1\u0026rdquo; are true; \u0026ldquo;false\u0026rdquo;, \u0026ldquo;no\u0026rdquo;, \u0026ldquo;F\u0026rdquo;, \u0026ldquo;N\u0026rdquo; are false\n  DateTime: \u0026lt;\u0026gt;0 total milliseconds are true, =0 are false\n  Methods ToBoolean Converts value into boolean or returns false when conversion is not possible.\n ToBoolean(value interface{}) bool\n  value: interface{} - the value to convert. returns: bool - boolean value or false when conversion is not supported.  ToBooleanWithDefault Converts value into boolean or returns default value when conversion is not possible\n ToBooleanWithDefault(value interface{}, defaultValue bool) bool\n  value: interface{} - value to convert. defaultValue: bool - default value returns: bool - boolean value or default when conversion is not supported.  ToNullableBoolean Converts value into boolean or returns nil when conversion is not possible.\n ToNullableBoolean(value interface{}) *bool\n  value: interface{} - value to convert. returns: *bool - boolean value or nil when convertion is not supported.  Examples value1 := convert.BooleanConverter.ToNullableBoolean(true) value2 := convert.BooleanConverter.ToNullableBoolean(\u0026#34;yes\u0026#34;) value3 := convert.BooleanConverter.ToNullableBoolean(1) value4 := convert.BooleanConverter.ToNullableBoolean(struct{}{}) fmt.Println(*value1) // true fmt.Println(*value2) // true fmt.Println(*value3) // true fmt.Println(value4) // \u0026lt;nil\u0026gt;  ","description":"The BooleanConverter class allows you to convert different values to boolean values using extended conversion rules.\n","image":null,"permalink":"/golang/commons/convert/boolean_converter/","subtitle":null,"tags":null,"title":"BooleanConverter"},{"content":"Description The BooleanConverter class allows you to convert different values to boolean values using the following rules:\n  Numbers: \u0026lt;\u0026gt;0 are true, =0 are false\n  Strings: \u0026ldquo;true\u0026rdquo;, \u0026ldquo;yes\u0026rdquo;, \u0026ldquo;T\u0026rdquo;, \u0026ldquo;Y\u0026rdquo;, \u0026ldquo;1\u0026rdquo; are true; \u0026ldquo;false\u0026rdquo;, \u0026ldquo;no\u0026rdquo;, \u0026ldquo;F\u0026rdquo;, \u0026ldquo;N\u0026rdquo; are false\n  DateTime: \u0026lt;\u0026gt;0 total milliseconds are true, =0 are false\n  Static methods ToBoolean Converts value into boolean or returns false when the conversion is not possible.\n public static boolean ToBoolean(object value)\n  value: object - value to convert. returns: bool - boolean value or false when conversion is not supported.  ToBooleanWithDefault Converts value into boolean or returns default value when the conversion is not possible\n public static bool ToBooleanWithDefault(object value, bool defaultValue)\n  value: object - value to convert. defaultValue: bool - default value returns: bool - boolean value or default when the conversion is not supported.  ToNullableBoolean Converts value into boolean or returns null when the conversion is not possible.\n public static bool toNullableBoolean(object value)\n  value: object - value to convert. returns: bool - boolean value or null when the convertion is not supported.  Examples var value1 = BooleanConverter.ToNullableBoolean(True); // Returns True var value2 = BooleanConverter.ToNullableBoolean(\u0026#34;yes\u0026#34;); // Returns True var value3 = BooleanConverter.ToNullableBoolean(123); // Returns null var value4 = BooleanConverter.ToNullableBoolean({}); // Returns null  var value5 = BooleanConverter.ToBooleanWithDefault(True,\u0026#34;verdadero\u0026#34;); // Returns True var value6 = BooleanConverter.ToBooleanWithDefault(123,\u0026#34;verdadero\u0026#34;); // Returns verdadero  var value7 = BooleanConverter.ToBoolean(\u0026#34;yes\u0026#34;); // Returns True  ","description":"The BooleanConverter class allows you to convert different values to boolean values using extended conversion rules.\n","image":null,"permalink":"/net/commons/convert/boolean_converter/","subtitle":null,"tags":null,"title":"BooleanConverter"},{"content":"Description The BooleanConverter class allows you to convert different values to boolean values using the following rules:\n  Numbers: \u0026lt;\u0026gt;0 are true, =0 are false\n  Strings: \u0026ldquo;true\u0026rdquo;, \u0026ldquo;yes\u0026rdquo;, \u0026ldquo;T\u0026rdquo;, \u0026ldquo;Y\u0026rdquo;, \u0026ldquo;1\u0026rdquo; are true; \u0026ldquo;false\u0026rdquo;, \u0026ldquo;no\u0026rdquo;, \u0026ldquo;F\u0026rdquo;, \u0026ldquo;N\u0026rdquo; are false\n  DateTime: \u0026lt;\u0026gt;0 total milliseconds are true, =0 are false\n  Static methods toBoolean Converts a value into a boolean or returns false when conversion is not possible.\n public static toBoolean(value: any): boolean\n  value: any - value to convert. returns: boolean - boolean value or false when the conversion is not supported.  toBooleanWithDefault Converts a value into a boolean or returns a given default value when the conversion is not possible\n public static toBooleanWithDefault(value: any, defaultValue: boolean = false): boolean\n  value: any - value to convert. defaultValue: boolean - default value returns: boolean - boolean value or given default when the conversion is not supported.  toNullableBoolean Converts a value into boolean or returns null when the conversion is not possible.\n public static toNullableBoolean(value: any): boolean\n  value: any - value to convert. returns: boolean - boolean value or null when the convertion is not supported.  Examples let value1 = BooleanConverter.toNullableBoolean(True) // Returns True let value2 = BooleanConverter.toNullableBoolean(\u0026#34;yes\u0026#34;) // Returns True let value3 = BooleanConverter.toNullableBoolean(123) // Returns null let value4 = BooleanConverter.toNullableBoolean({}) // Returns null  let value5 = BooleanConverter.toBooleanWithDefault(True,\u0026#34;verdadero\u0026#34;) // Returns True let value6 = BooleanConverter.toBooleanWithDefault(123,\u0026#34;verdadero\u0026#34;) // Returns verdadero  let value7 = BooleanConverter.toBoolean(\u0026#34;yes\u0026#34;) // Returns True  ","description":"The BooleanConverter class allows you to convert different values to boolean values using extended conversion rules.\n","image":null,"permalink":"/node/commons/convert/boolean_converter/","subtitle":null,"tags":null,"title":"BooleanConverter"},{"content":"Description The BooleanConverter class allows you to convert different values to boolean values using the following rules:\n  Numbers: \u0026lt;\u0026gt;0 are true, =0 are false\n  Strings: \u0026ldquo;true\u0026rdquo;, \u0026ldquo;yes\u0026rdquo;, \u0026ldquo;T\u0026rdquo;, \u0026ldquo;Y\u0026rdquo;, \u0026ldquo;1\u0026rdquo; are true; \u0026ldquo;false\u0026rdquo;, \u0026ldquo;no\u0026rdquo;, \u0026ldquo;F\u0026rdquo;, \u0026ldquo;N\u0026rdquo; are false\n  DateTime: \u0026lt;\u0026gt;0 total milliseconds are true, =0 are false\n  Static methods to_boolean Converts value into boolean or returns false when conversion is not possible.\n static to_Boolean(value: Any): bool\n  value: Any - the value to convert. returns: bool - boolean value or false when conversion is not supported.  to_boolean_with_default Converts value into boolean or returns default value when conversion is not possible\n static to_boolean_with_default(value: Any, default_value: bool = False): bool\n  value: Any - the value to convert. default_value: bool - the default value returns: bool - boolean value or default when conversion is not supported.  to_nullable_boolean Converts value into boolean or returns None when conversion is not possible.\n static to_nullable_boolean(value: Any): bool\n  value: Any - the value to convert. returns: bool - boolean value or None when convertion is not supported.  Examples value1 = BooleanConverter.to_nullable_boolean(True) # Returns True value2 = BooleanConverter.to_nullable_boolean(\u0026#34;yes\u0026#34;) # Returns True value3 = BooleanConverter.to_nullable_boolean(123) # Returns None value4 = BooleanConverter.to_nullable_boolean({}) # Returns None value5 = BooleanConverter.to_boolean_with_default(True,\u0026#34;verdadero\u0026#34;) # Returns True value6 = BooleanConverter.to_boolean_with_default(123,\u0026#34;verdadero\u0026#34;) # Returns verdadero value7 = BooleanConverter.to_boolean(\u0026#34;yes\u0026#34;) # Returns True ","description":"The BooleanConverter class allows you to convert different values to boolean values using extended conversion rules.\n","image":null,"permalink":"/python/commons/convert/boolean_converter/","subtitle":null,"tags":null,"title":"BooleanConverter"},{"content":"Implements: ReferencesDecorator\nDescription The BuildReferencesDecorator class allows you to create a references decorator that automatically creates missing components using availale component factories upon component retrieval.\nConstructors NewBuildReferencesDecorator Creates a new instance of the decorator.\n NewBuildReferencesDecorator(nextReferences IReferences, topReferences IReferences) *BuildReferencesDecorator\n  nextReferences: IReferences - the next references or decorator in the chain. topReferences: IReferences - the decorator at the top of the chain.  Methods ClarifyLocator Clarifies a component locator by merging two descriptors into one to replace missing fields. That allows to get a more complete descriptor that includes all possible fields.\n (c *BuildReferencesDecorator) ClarifyLocator(locator interface{}, factory build.IFactory) interface{}\n  locator: interface{} - component locator to clarify. factory: build.IFactory - factory that shall create the component. returns: interface{} - clarified component descriptor (locator)  Create Creates a component identified by the given locator.\n (c *BuildReferencesDecorator) Create(locator interface{}, factory build.IFactory) interface{}\n  locator: interface{} - locator used to identify the component to be created. factory: build.IFactory - factory that shall create the component. returns: interface{} - created component.  Find Gets all component references that match the specified locator. Throws a ReferenceException when required is set to True but no references are found.\n (c *BuildReferencesDecorator) Find(locator interface{}, required bool) ([]interface{}, error)\n  locator: interface{} - locator to find a reference by. required: bool - it True, it forces to raise an exception when no reference is found. returns: ([]interface{}, error) - list with matching component references.  FindFactory Finds a factory capable creating a component by given descriptor from the components registered in the references.\n (c *BuildReferencesDecorator) FindFactory(locator interface{}) build.IFactory\n  locator: interface{} - locator of the component to be created. returns: build.IFactory - found factory or nil if no factory was found.  Find Gets all component references that match the specified locator. Throws a ReferenceException when required is set to True but no references were found.\n (c *BuildReferencesDecorator) Find(locator interface{}, required bool) ([]interface{}, error)\n  locator: interface{} - locator to find a reference by. required: bool - if True, it forces to raise an exception when no reference is found. returns: ([]interface{}, error) - list with matching component references.  GetOneOptional Gets an optional component reference that matches the specified locator.\n (c *BuildReferencesDecorator) GetOneOptional(locator interface{}) interface{}\n  locator: interface{} - locator to find references by. returns: interface{} - matching component reference or nil if nothing was found.  GetOneRequired Gets a required component reference that matches the specified locator. Throws a ReferenceException when no references were found.\n (c *BuildReferencesDecorator) GetOneRequired(locator interface{}) (interface{}, error)\n  locator: interface{} - locator to find a reference by. returns: (interface{}, error) - matching component reference.  GetOptional Gets all component references that match the specified locator.\n (c *BuildReferencesDecorator) GetOptional(locator interface{}) []interface{}\n  locator: interface{} - locator to find references by. returns: []interface{} - list with matching component references or empty list if nothing was found.  GetRequired Gets all component references that match the specified locator. At least one component reference must be present. Throws a ReferenceException when no references were found.\n (c *BuildReferencesDecorator) GetRequired(locator interface{}) ([]interface{}, error)\n  locator: interface{} - locator to find references by. returns: ([]interface{}, error) - list with matching component references.  ","description":"References decorator that automatically creates missing components using available component factories upon component retrival.\n","image":null,"permalink":"/golang/container/refer/build_references_decorator/","subtitle":null,"tags":null,"title":"BuildReferencesDecorator"},{"content":"Inherits: ReferencesDecorator\nDescription The BuildReferencesDecorator class allows you to create a references decorator that automatically creates missing components using availale component factories upon component retrieval.\nConstructors Creates a new instance of the decorator.\n public BuildReferencesDecorator(IReferences baseReferences = null, IReferences parentReferences = null)\n  nextReferences: IReferences - the next references or decorator in the chain. topReferences: IReferences - the decorator at the top of the chain.  Instance methods ClarifyLocator Clarifies a component locator by merging two descriptors into one to replace missing fields. That allows to get a more complete descriptor that includes all possible fields.\n public object ClarifyLocator(object locator, IFactory factory)\n  locator: object - component locator to clarify. factory: IFactory - factory that shall create the component. returns: object - clarified component descriptor (locator)  Create Creates a component identified by the given locator.\n public object Create(object locator, IFactory factory)\n  locator: object - locator used to identify the component to be created. factory: IFactory - factory that shall create the component. returns: object - created component.  Find Gets all component references that match the specified locator. Throws a ReferenceException when required is set to True but no references are found.\n public override List\u0026lt;T\u0026gt; Find\u0026lt;T\u0026gt;(object locator, bool required)\n  locator: object - locator to find a reference by. required: bool - it True, it forces to raise an exception when no reference is found. returns: List\u0026lt;T\u0026gt; - list with matching component references.  FindFactory Finds a factory capable creating a component by given descriptor from the components registered in the references.\n public IFactory FindFactory(object locator)\n  locator: object - locator of the component to be created. returns: IFactory - found factory or null if no factory was found.  ","description":"References decorator that automatically creates missing components using available component factories upon component retrival.\n","image":null,"permalink":"/net/container/refer/build_references_decorator/","subtitle":null,"tags":null,"title":"BuildReferencesDecorator"},{"content":"Implements: ReferencesDecorator\nDescription The BuildReferencesDecorator class allows you to create a references decorator that automatically creates missing components using availale component factories upon component retrieval.\nConstructors Creates a new instance of the decorator.\n public constructor(nextReferences: IReferences, topReferences: IReferences)\n  nextReferences: IReferences - the next references or decorator in the chain. topReferences: IReferences - the decorator at the top of the chain.  Instance methods clarifyLocator Clarifies a component locator by merging two descriptors into one to replace missing fields. That allows to get a more complete descriptor that includes all possible fields.\n public clarifyLocator(locator: any, factory: IFactory): any\n  locator: any - component locator to clarify. factory: IFactory - factory that shall create the component. returns: any - clarified component descriptor (locator)  create Creates a component identified by the given locator.\n public create(locator: any, factory: IFactory): any\n  locator: any - locator used to identify the component to be created. factory: IFactory - factory that shall create the component. returns: any - created component.  find Gets all component references that match the specified locator. Throws a ReferenceException when required is set to True but no references are found.\n public find\u0026lt;T\u0026gt;(locator: any, required: boolean): T[]\n  locator: any - locator to find a reference by. required: boolean - it True, it forces to raise an exception when no reference is found. returns: T[] - list with matching component references.  findFactory Finds a factory capable creating a component by given descriptor from the components registered in the references.\n public findFactory(locator: any): IFactory\n  locator: any - locator of the component to be created. returns: IFactory - found factory or null if no factory was found.  ","description":"References decorator that automatically creates missing components using available component factories upon component retrival.\n","image":null,"permalink":"/node/container/refer/build_references_decorator/","subtitle":null,"tags":null,"title":"BuildReferencesDecorator"},{"content":"Implements: ReferencesDecorator\nDescription The BuildReferencesDecorator class allows you to create a references decorator that automatically creates missing components using availale component factories upon component retrieval.\nConstructors Creates a new instance of the decorator.\n BuildReferencesDecorator(next_references: IReferences, top_references: IReferences)\n  next_references: IReferences - the next references or decorator in the chain. top_references: IReferences - the decorator at the top of the chain.  Instance methods clarify_locator Clarifies a component locator by merging two descriptors into one to replace missing fields. That allows to get a more complete descriptor that includes all possible fields.\n clarify_locator(locator: Any, factory: IFactory): Any\n  locator: Any - component locator to clarify. factory: IFactory - factory that shall create the component. returns: Any - clarified component descriptor (locator)  create Creates a component identified by the given locator.\n create(locator: Any, factory: IFactory): Any\n  locator: Any - locator used to identify the component to be created. factory: IFactory - factory that shall create the component. returns: Any - created component.  find Gets all component references that match the specified locator. Throws a ReferenceException when required is set to True but no references are found.\n find(locator: Any, required: bool): List[Any]\n  locator: Any - locator to find a reference by. required: bool - it True, it forces to raise an exception when no reference is found. returns: List[Any] - list with matching component references.  find_factory Finds a factory capable creating a component by given descriptor from the components registered in the references.\n find_factory(locator: Any): Optional[IFactory]\n  locator: Any - locator of the component to be created. returns: Optional[IFactory] - found factory or None if no factory was found.  ","description":"References decorator that automatically creates missing components using available component factories upon component retrival.\n","image":null,"permalink":"/python/container/refer/build_references_decorator/","subtitle":null,"tags":null,"title":"BuildReferencesDecorator"},{"content":"Inherits: IConfigurable, IReconfigurable\nDescription TODO: add description\nProperties Timeout TODO: add description\n public long Timeout{ get; set; }\n Instance methods ReadConfig Configures component by passing configuration parameters.\n public ConfigParams ReadConfig(string correlationId, ConfigParams parameters)\n  correlationId: string - configuration parameters to be set. parameters: ConfigParams - values to parameters the configuration or null to skip parameterization. returns: ConfigParams - ConfigParams configuration.  ","description":"TODO: add description\n","image":null,"permalink":"/net/components/config/cached_config_reader/","subtitle":null,"tags":null,"title":"CachedConfigReader"},{"content":"Description The CachedCounters class allows you to create performace counters that measure and store those values in memory.\nImportant points\n Child classes can implement saving of the counters into various different destinations.  Configuration parameters options:\n interval: interval in milliseconds to save current counters measurements (default: 5 mins) reset_timeout: timeout in milliseconds to reset the counters. 0 disables the reset (default: 0)  Constructors Creates a new CachedCounters object. Inherit cache counters from saver.\n InheritCacheCounters(saver ICachedCountersOverrides) *CachedCounters\n  saver: ICachedCountersOverrides - save ICachedCountersOverrides  Fields interval Default time interval.\n interval: int64 = 300000\n cache A dictionary containing the cached values.\n cache: map[string]*Counter{},\n updated A boolean value that indicates whether the counter has been updated or not.\n updated: bool\n lastDumpTime Time of the last dump.\n lastDumpTime: time.Time\n lastResetTime time of the last reset\n lastResetTime: time.Time\n resetTimeout Timeout to reset timer\n resetTimeout: int64 = 0\n  Methods BeginTiming Begins measurement of execution time interval. It returns *CounterTiming object which has to be called at CounterTiming.EndTiming to end the measurement and update the counter.\n (c *CachedCounters) BeginTiming(name string) *CounterTiming\n  name: string - a counter name of Interval type. returns: *CounterTiming - a callback object to end timing.  Clear Clears (resets) a counter specified by its name.\n (c *CachedCounters) Clear(name string)\n  name: string - a counter name to clear.  ClearAll Clears (resets) all counters.\n (c *CachedCounters) ClearAll()\n Configure Configures component by passing configuration parameters.\n (c *CachedCounters) Configure(config *config.ConfigParams)\n  config: *config.ConfigParams - configuration parameters to be set.  Dump Dumps (saves) the current values of counters.\n (c *CachedCounters) Dump() error\n  returns: error - return error if not dumped  EndTiming Ends measurement of execution elapsed time and updates specified counter.\n (c *CachedCounters) EndTiming(name string, elapsed float32)\n  name: string - a counter name elapsed: float32 - execution elapsed time in milliseconds to update the counter.  Get Gets a counter specified by its name. It counter does not exist or its type doesn\u0026rsquo;t match the specified type it creates a new one.\n (c *CachedCounters) Get(name string, typ int) *Counter\n  name: string - a counter name to retrieve. typ: int - a counter type. returns: Counter - an existing or newly created counter of the specified type.  GetAll Gets all captured counters.\n (c *CachedCounters) GetAll() []*Counter\n  returns: []*Counter - a list with counters.  Increment Increments counter by given value.\n (c *CachedCounters) Increment(name string, value int)\n  name: string - a counter name of Increment type. value: int - a value to add to the counter.  IncrementOne Increments counter by 1.\n (c *CachedCounters) IncrementOne(name string)\n  name: string - a counter name of Increment type.  Last Records the last calculated measurement value. Usually this method is used by metrics calculated externally.\n (c *CachedCounters) Last(name string, value float32)\n  name: string - a counter name of Last type. value: float32 - a last value to record.  Stats Calculates min/average/max statistics based on the current and previous values.\n (c *CachedCounters) Stats(name string, value float32)\n  name: string - a counter name of Statistics type value: float32 - a value to update statistics  Timestamp Records the given timestamp.\n (c *CachedCounters) Timestamp(name string, value time.Time)\n  name: string - a counter name of Timestamp type. value: time.Time - a timestamp to record.  TimestampNow Records the current time as a timestamp.\n (c *CachedCounters) TimestampNow(name string)\n  name: string - a counter name of Timestamp type.  update Makes counter measurements as updated and dumps them when timeout expires.\n (c *CachedCounters) update() error\n ","description":"Class used to create performace counters that measure and store those values in memory.\n","image":null,"permalink":"/golang/components/count/cached_counters/","subtitle":null,"tags":null,"title":"CachedCounters"},{"content":"Inherits: ICounters, IReconfigurable, ICounterTimingCallback\nDescription The CachedCounters class allows you to create performace counters that measure and store those values in memory.\nImportant points\n Child classes can implement saving of the counters into various different destinations.  Configuration parameters options:\n interval: interval in milliseconds to save current counters measurements (default: 5 mins) reset_timeout: timeout in milliseconds to reset the counters. 0 disables the reset (default: 0)  Constructors Creates a new CachedCounters object.\n public CachedCounters()\n Fields _cache A dictionary containing the cached values.\n protected _cache: IDictionary\u0026lt;string, Counter\u0026gt;\n _updated A boolean value that indicates whether the counter has been updated or not.\n protected _updated: bool\n _lastDumpTime Time of the last dump.\n protected _lastDumpTime: long = DateTime.UtcNow.Ticks\n _lastResetTime Last time when was reset timer\n protected _lastResetTime: long = DateTime.UtcNow.Ticks\n _lock TODO add description\n protected _lock: object\n _interval Default time interval.\n protected _interval: long = 300000\n _resetTimeout Timeout to reset timer\n protected _resetTimeout: long = 0\n  Instance methods BeginTiming Begins measurement of execution time interval. It returns CounterTiming object which has to be called at CounterTiming.EndTiming to end the measurement and update the counter.\n public CounterTiming BeginTiming(string name)\n  name: string - a counter name of Interval type. returns: CounterTiming - a callback object to end timing.  Clear Clears (resets) a counter specified by its name.\n public void Clear(string name)\n  name: string - a counter name to clear.  ClearAll Clears (resets) all counters.\n public void ClearAll()\n Configure Configures component by passing configuration parameters.\n public virtual void Configure(ConfigParams config)\n  config: ConfigParams - configuration parameters to be set.  Dump Dumps (saves) the current values of counters.\n public void Dump()\n EndTiming Ends measurement of execution elapsed time and updates specified counter.\n public void EndTiming(string name, double elapsed)\n  name: string - a counter name elapsed: double - execution elapsed time in milliseconds to update the counter.  Get Gets a counter specified by its name. It counter does not exist or its type doesn\u0026rsquo;t match the specified type it creates a new one.\n public Counter Get(string name, CounterType type)\n  name: string - a counter name to retrieve. typ: CounterType - a counter type. returns: Counter - an existing or newly created counter of the specified type.  GetAll Gets all captured counters.\n public IEnumerable\u0026lt;Counter\u0026gt; GetAll()\n  returns: IEnumerable\u0026lt;Counter\u0026gt; - a list with counters.  Increment Increments counter by given value.\n public void Increment(string name, int value)\n  name: string - a counter name of Increment type. value: int - a value to add to the counter.  IncrementOne Increments counter by 1.\n public void IncrementOne(string name)\n  name: string - a counter name of Increment type.  Last Records the last calculated measurement value. Usually this method is used by metrics calculated externally.\n public Last(string name, float value)\n  name: string - a counter name of Last type. value: float - a last value to record.  Stats Calculates min/average/max statistics based on the current and previous values.\n public void Stats(string name, float value)\n  name: string - a counter name of Statistics type value: float - a value to update statistics  Timestamp Records the given timestamp.\n public void Timestamp(string name, DateTime value)\n  name: string - a counter name of Timestamp type. value: DateTime - a timestamp to record.  TimestampNow Records the current time as a timestamp.\n public void TimestampNow(string name)\n  name: string - a counter name of Timestamp type.  Update Makes counter measurements as updated and dumps them when timeout expires.\n protected void Update()\n Abstract methods Save Saves the current counters measurements.\n protected abstarct void Save(IEnumerable\u0026lt;Counter\u0026gt; counters)\n  counters: IEnumerable\u0026lt;Counter\u0026gt; - current counters measurements to be saves.  ","description":"Class used to create performace counters that measure and store those values in memory.\n","image":null,"permalink":"/net/components/count/cached_counters/","subtitle":null,"tags":null,"title":"CachedCounters"},{"content":"Implements: ICounters, IReconfigurable, ICounterTimingCallback\nDescription The CachedCounters class allows you to create performace counters that measure and store those values in memory.\nImportant points\n Child classes can implement saving of the counters into various different destinations.  Configuration parameters options:\n interval: interval in milliseconds to save current counters measurements (default: 5 mins) reset_timeout: timeout in milliseconds to reset the counters. 0 disables the reset (default: 0)  Constructors Creates a new CachedCounters object.\n public constructor()\n Fields _interval Default time interval.\n protected _interval = 300000\n _cache A dictionary containing the cached values.\n protected _cache: { [id: string]: Counter }\n _updated A boolean value that indicates whether the counter has been updated or not.\n protected _updated: boolean\n _lastDumpTime Time of the last dump.\n protected _lastDumpTime: Date\n _lastResetTime Last time when was reset timer\n protected _lastResetTime: Date\n _resetTimeout Timeout to reset timer\n protected _resetTimeout: number\n  Instance methods beginTiming Begins measurement of execution time interval. It returns CounterTiming object which has to be called at CounterTiming.endTiming to end the measurement and update the counter.\n public beginTiming(name: string): CounterTiming\n  name: string - a counter name of Interval type. returns: CounterTiming - a callback object to end timing.  clear Clears (resets) a counter specified by its name.\n public clear(name: string): void\n  name: string - a counter name to clear.  clearAll Clears (resets) all counters.\n public clearAll(): void\n configure Configures component by passing configuration parameters.\n public configure(config: ConfigParams): void\n  config: ConfigParams - configuration parameters to be set.  dump Dumps (saves) the current values of counters.\n public dump(): void\n endTiming Ends measurement of execution elapsed time and updates specified counter.\n public endTiming(name: string, elapsed: number): void\n  name: string - a counter name elapsed: number - execution elapsed time in milliseconds to update the counter.  get Gets a counter specified by its name. It counter does not exist or its type doesn\u0026rsquo;t match the specified type it creates a new one.\n public get(name: string, typ: CounterType): Counter\n  name: string - a counter name to retrieve. typ: CounterType - a counter type. returns: Counter - an existing or newly created counter of the specified type.  getAll Gets all captured counters.\n public getAll(): Counter[]\n  returns: Counter[] - a list with counters.  getInterval Gets the counters dump/save interval.\n public getInterval(): number\n  returns: number - the interval in milliseconds.  increment Increments counter by given value.\n public increment(name: string, value: number): void\n  name: string - a counter name of Increment type. value: number - a value to add to the counter.  incrementOne Increments counter by 1.\n public incrementOne(name: string): void\n  name: string - a counter name of Increment type.  last Records the last calculated measurement value. Usually this method is used by metrics calculated externally.\n public last(name: string, value: number): void\n  name: string - a counter name of Last type. value: number - a last value to record.  setInterval Sets the counters dump/save interval.\n public setInterval(value: number): void\n  value: number - a new interval in milliseconds.  stats Calculates min/average/max statistics based on the current and previous values.\n public stats(name: string, value: number): void\n  name: string - a counter name of Statistics type value: number - a value to update statistics  timestamp Records the given timestamp.\n public timestamp(name: string, value: Date): void\n  name: string - a counter name of Timestamp type. value: Date - a timestamp to record.  timestampNow Records the current time as a timestamp.\n public timestampNow(name: string): void\n  name: string - a counter name of Timestamp type.  update Makes counter measurements as updated and dumps them when timeout expires.\n protected update()\n Abstract methods save Saves the current counters measurements.\n protected abstract save(counters: Counter[]): void\n  counters: Counter[] - current counters measurements to be saved.  ","description":"Class used to create performace counters that measure and store those values in memory.\n","image":null,"permalink":"/node/components/count/cached_counters/","subtitle":null,"tags":null,"title":"CachedCounters"},{"content":"Implements: ICounters, IReconfigurable, ICounterTimingCallback\nDescription The CachedCounters class allows you to create performace counters that measure and store those values in memory.\nImportant points\n Child classes can implement saving of the counters into various different destinations.  Configuration parameters options:\n interval: interval in milliseconds to save current counters measurements (default: 5 mins) reset_timeout: timeout in milliseconds to reset the counters. 0 disables the reset (default: 0)  Constructors Creates a new CachedCounters object.\n CachedCounters()\n Fields _default_interval Default time interval.\n _default_interval = 300000\n _cache A dictionary containing the cached values.\n _cache: dict\n _updated A boolean value that indicates whether the counter has been updated or not.\n _updated: bool\n _last_dump_time Time of the last dump.\n _last_dump_time: float\n _interval Time different between two updates.\n _interval: float\n  Instance methods begin_timing Begins measurement of execution time interval. It returns CounterTiming object which has to be called at CounterTiming.end_timing to end the measurement and update the counter.\n begin_timing(name: str): CounterTiming\n  name: str - a counter name of Interval type. returns: CounterTiming - a callback object to end timing.  clear Clears (resets) a counter specified by its name.\n clear(name: str)\n  name: str - a counter name to clear.  clear_all Clears (resets) all counters.\n clear_all()\n configure Configures component by passing configuration parameters.\n configure(config: ConfigParams)\n  config: ConfigParams - configuration parameters to be set.  dump Dumps (saves) the current values of counters.\n dump()\n end_timing Ends measurement of execution elapsed time and updates specified counter.\n end_timing(name: str, elapsed: float)\n  name: str - a counter name elapsed: float - execution elapsed time in milliseconds to update the counter.  get Gets a counter specified by its name. It counter does not exist or its type doesn\u0026rsquo;t match the specified type it creates a new one.\n get(name: str, typ: CounterType): Counter\n  name: str - a counter name to retrieve. typ: CounterType - a counter type. returns: Counter - an existing or newly created counter of the specified type.  get_all Gets all captured counters.\n get_all(): List[Counter]\n  returns: List[Counter] - a list with counters.  get_interval Gets the counters dump/save interval.\n get_interval(): float\n  returns: float - the interval in milliseconds.  increment Increments counter by given value.\n increment(name: str, value: float)\n  name: str - a counter name of Increment type. value: float - a value to add to the counter.  increment_one Increments counter by 1.\n increment_one(name: str)\n  name: str - a counter name of Increment type.  last Records the last calculated measurement value. Usually this method is used by metrics calculated externally.\n last(name: str, value: float)\n  name: str - a counter name of Last type. value: float - a last value to record.  _save Saves the current counters measurements.\n abstractmethod _save(counters: List[Counter])\n  counters: List[Counter] - current counters measurements to be saved.  set_interval Sets the counters dump/save interval.\n set_interval(value: float)\n  value: float - a new interval in milliseconds.  stats Calculates min/average/max statistics based on the current and previous values.\n stats(name: str, value: float)\n  name: str - a counter name of Statistics type value: float - a value to update statistics  timestamp Records the given timestamp.\n timestamp(name: str, value: datetime.datetime)\n  name: str - a counter name of Timestamp type. value: datetime.datetime - a timestamp to record.  timestamp_now Records the current time as a timestamp.\n timestamp_now(name: str)\n  name: str - a counter name of Timestamp type.  _update Makes counter measurements as updated and dumps them when timeout expires.\n _update()\n ","description":"Class used to create performace counters that measure and store those values in memory.\n","image":null,"permalink":"/python/components/count/cached_counters/","subtitle":null,"tags":null,"title":"CachedCounters"},{"content":"Implements: Logger\nDescription The CachedLogger class allows you to create a logger that caches captured log messages in memory and periodically dumps them.\nImportant points\n Child classes implement saving cached messages to their specified destinations.  Configuration parameters  level: maximum log level to capture source: source (context) name options:  interval: interval (in milliseconds) to save log messages (default: 10 seconds) max_cache_size: maximum number of messages stored in this cache (default: 100)    References  *:context-info:*:*:1.0 - (optional) ContextInfo to detect the context id and specify counters source  Fields Cache List containing log messages.\n Cache: []*LogMessage\n Updated Boolean variable indicating whether there has been an update or not.\n Updated: bool\n Interval Interval (in milliseconds) to save log messages (default: 10 seconds)\n Interval: int\n LastDumpTime Time of the last dump\n LastDumpTime: time.Time\n MaxCacheSize Maximum number of messages stored in the cache (default: 100)\n MaxCacheSize: int\n  Methods Clear Clears (removes) all cached log messages.\n (c *CachedLogger) Clear()\n Configure Configures a component by passing configuration parameters.\n (c *CachedLogger) Configure(cfg *config.ConfigParams\n  cfg: *config.ConfigParams - configuration parameters to be set.  Dump Dumps (writes) the currently cached log messages.\n (c *CachedLogger) Dump() error\n  returns: error - returned error if not dumped.  Update Sets message cache as updated and dumps it when timeout expires.\n (c *CachedLogger) Update()\n Save Saves log messages from the cache.\n Save(messages []*LogMessage) error\n  messages: []*LogMessage - list with log messages. returns: error - returned error if not saved.  See also   Logger   ILogger   LogMessage   ","description":"Logger that caches captured log messages in memory and periodically dumps them.\n","image":null,"permalink":"/golang/components/log/cached_logger/","subtitle":null,"tags":null,"title":"CachedLogger"},{"content":"Inherits: Logger\nDescription The CachedLogger class allows you to create a logger that caches captured log messages in memory and periodically dumps them.\nImportant points\n Child classes implement saving cached messages to their specified destinations.  Configuration parameters  level: maximum log level to capture source: source (context) name options:  interval: interval in milliseconds to save log messages (default: 10 seconds) max_cache_size: maximum number of messages stored in this cache (default: 100)    References  *:context-info:*:*:1.0 - (optional) ContextInfo to detect the context id and specify counters source  Fields _cache List containing log messages.\n protected _cache: List\u0026lt;LogMessage\u0026gt;\n _updated Boolean variable indicating whether there has been an update or not.\n protected _updated: bool = false\n _lastDumpTime Time of the last dump\n protected _lastDumpTime: long = DateTime.UtcNow.Ticks\n _maxCacheSize Maximum number of messages stored in the cache (default: 100)\n protected _maxCacheSize: int = 100\n _interval Interval in milliseconds to save log messages (default: 10 seconds)\n protected _interval: int = 10000\n _lock TODO add description\n protected _lock: object\n  Instance methods Clear Clears (removes) all cached log messages.\n void Clear()\n Configure Configures component by passing configuration parameters.\n public override void Configure(ConfigParams config)\n  config: ConfigParams - configuration parameters to be set.  Dump Dumps (writes) the currently cached log messages.\n public void Dump()\n Update Sets message cache as updated and dumps it when timeout expires.\n protected void Update()\n Write Writes a log message to the logger destination.\n public override void Write(LogLevel level, string correlationId, Exception error, string message)\n  level: LogLevel - a log level. correlationId: string - (optional) transaction id to trace execution through call chain. error: Exception - an error object associated with this message. message: string - a human-readable message to log.  Abstract methods Save Saves log messages from the cache.\n protected abstract Save(List\u0026lt;LogMessage\u0026gt; messages)\n  messages: LogMessage - a list with log messages  See also   Logger   ILogger   LogMessage   ","description":"Logger that caches captured log messages in memory and periodically dumps them.\n","image":null,"permalink":"/net/components/log/cached_logger/","subtitle":null,"tags":null,"title":"CachedLogger"},{"content":"Extends: Logger\nDescription The CachedLogger class allows you to create a logger that caches captured log messages in memory and periodically dumps them.\nImportant points\n Child classes implement saving cached messages to their specified destinations.  Configuration parameters  level: maximum log level to capture source: source (context) name options:  interval: interval in milliseconds to save log messages (default: 10 seconds) max_cache_size: maximum number of messages stored in this cache (default: 100)    References  *:context-info:*:*:1.0 - (optional) ContextInfo to detect the context id and specify counters source  Fields _cache List containing log messages.\n protected _cache: LogMessage[] = []\n _updated Boolean variable indicating whether there has been an update or not.\n protected _updated = false\n _interval Interval in milliseconds to save log messages (default: 10 seconds)\n protected _interval = 10000\n _lastDumpTime Time of the last dump\n protected _lastDumpTime: number\n _maxCacheSize Maximum number of messages stored in the cache (default: 100)\n protected _maxCacheSize: number = 100\n  Instance methods clear Clears (removes) all cached log messages.\n clear(): void\n configure Configures component by passing configuration parameters.\n public configure(config: ConfigParams): void\n  config: ConfigParams - configuration parameters to be set.  dump Dumps (writes) the currently cached log messages.\n public dump(): void\n update Sets message cache as updated and dumps it when timeout expires.\n protected update()\n Abstract methods save Saves log messages from the cache.\n protected abstract save(messages: LogMessage[])\n  messages: LogMessage[] - a list with log messages  See also   Logger   ILogger   LogMessage   ","description":"Logger that caches captured log messages in memory and periodically dumps them.\n","image":null,"permalink":"/node/components/log/cached_logger/","subtitle":null,"tags":null,"title":"CachedLogger"},{"content":"Implements: Logger\nDescription The CachedLogger class allows you to create a logger that caches captured log messages in memory and periodically dumps them.\nImportant points\n Child classes implement saving cached messages to their specified destinations.  Configuration parameters  level: maximum log level to capture source: source (context) name options:  interval: interval in milliseconds to save log messages (default: 10 seconds) max_cache_size: maximum number of messages stored in this cache (default: 100)    References  *:context-info:*:*:1.0 - (optional) ContextInfo to detect the context id and specify counters source  Fields _cache List containing log messages.\n _cache: List[LogMessage] = []\n _updated Boolean variable indicating whether there has been an update or not.\n _updated = False\n _interval Interval in milliseconds to save log messages (default: 10 seconds)\n _interval = 10000\n _last_dump_time Time of the last dump\n _last_dump_time: float\n _max_cache_size Maximum number of messages stored in the cache (default: 100)\n _max_cache_size: int = 100\n  Instance methods clear Clears (removes) all cached log messages.\n clear()\n configure Configures component by passing configuration parameters.\n configure(config: ConfigParams)\n  config: ConfigParams - configuration parameters to be set.  dump Dumps (writes) the currently cached log messages.\n dump()\n _update Sets message cache as updated and dumps it when timeout expires.\n _update()\n _save Saves log messages from the cache.\n _save(messages: List[LogMessage])\n  messages: List[LogMessage] - a list with log messages  See also   Logger   ILogger   LogMessage   ","description":"Logger that caches captured log messages in memory and periodically dumps them.\n","image":null,"permalink":"/python/components/log/cached_logger/","subtitle":null,"tags":null,"title":"CachedLogger"},{"content":"Inherts: MessageQueue, ICleanable\nDescription The CachedMessageQueue class allows you to create message queues that cache received messages in memory, to allow peek operations that may not be supported by the undelying queue.\nImportant points\n This queue is used as a base implementation for other queues.  Constructors Creates a new instance of the persistence component.\n public CachedMessageQueue(string name = null, MessagingCapabilities capabilities = null)\n  name: string - (optional) queue name capabilities: MessagingCapabilities - (optional) capabilities of the message queue  Fields _autoSubscribe Boolean variable indicating whether a message queue auto-subscribes or not.\n protected _autoSubscribe: bool\n _messages List of messages in a queue.\n protected _messages: MessageEnvelope[]\n _receiver Message receiver.\n protected _receiver: IMessageReceiver\n _receiveEvent TODO: add description\n protected _receiveEvent: ManualResetEvent\n  Abstract methods SubscribeAsync Subscribes to the message broker.\n protected abstract Task SubscribeAsync(string correlationId)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain.  UnsubscribeAsync Unsubscribes from the message broker.\n protected abstract Task UnsubscribeAsync(string correlationId)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain.  Instance methods Clear Clears component state.\n public override Task ClearAsync(string correlationId)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain.  Configure Configures a component by passing its configuration parameters.\n public override Configure(ConfigParams config)\n  config: ConfigParams - configuration parameters to be set.  EndListen Ends listening for incoming messages. When this method is called, listen unblocks the thread and execution continues.\n public override void EndListen(string correlationId)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain.  ListenAsync Listens for incoming messages and blocks the current thread until the queue is closed. See IMessageReceiver, Receive\n public override Task ListenAsync(string correlationId, IMessageReceiver receiver)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. receiver: IMessageReceiver - receiver used to receive incoming messages.  OpenAsync Opens the component.\n public override Task OpenAsync(string correlationId)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain.  PeekAsync Peeks a single incoming message from the queue without removing it. If there are no messages available in the queue it returns null.\n public override Task\u0026lt;MessageEnvelope\u0026gt; PeekAsync(string correlationId)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. returns: Task\u0026lt;MessageEnvelope\u0026gt; - peeked message or null.  PeekBatchAsync Peeks multiple incoming messages from the queue without removing them. If there are no messages available in the queue it returns an empty list.\nImportant: This method is not supported by MQTT.\n public override Task\u0026lt;List\u0026lt;MessageEnvelope\u0026gt;\u0026gt; PeekBatchAsync(string correlationId, int messageCount)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. messageCount: int - maximum number of messages to peek. returns: Task\u0026lt;List\u0026lt;MessageEnvelope\u0026gt;\u0026gt; - list with peeked messages.  ReadMessageCountAsync Reads the current number of messages in the queue to be delivered.\n public override Task\u0026lt;long\u0026gt; ReadMessageCountAsync()\n  returns: Task\u0026lt;long\u0026gt; - number of messages in the queue.  ReceiveAsync Receives an incoming message and removes it from the queue.\n public override Task\u0026lt;MessageEnvelope\u0026gt; ReceiveAsync(string correlationId, long waitTimeout)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. waitTimeout: long - timeout in milliseconds to wait for a message to come. returns: Task\u0026lt;MessageEnvelope\u0026gt; - received message or null.  See also   MessageQueue   ","description":"Message queue that caches received messages in memory to allow peek operations that may not be supported by the undelying queue.\n","image":null,"permalink":"/net/messaging/queues/cached_message_queue/","subtitle":null,"tags":null,"title":"CachedMessageQueue"},{"content":"Extends: MessageQueue\nImplements: ICleanable\nDescription The CachedMessageQueue class allows you to create message queues that cache received messages in memory, to allow peek operations that may not be supported by the undelying queue.\nImportant points\n This queue is used as a base implementation for other queues.  Constructors Creates a new instance of the persistence component.\n public constructor(name?: string, capabilities?: MessagingCapabilities)\n  name: string - (optional) queue name capabilities: MessagingCapabilities - (optional) capabilities of the message queue  Fields _autoSubscribe Boolean variable indicating whether a message queue auto-subscribes or not.\n protected _autoSubscribe: boolean\n _messages List of messages in a queue.\n protected _messages: MessageEnvelope[]\n _receiver Message receiver.\n protected _receiver: IMessageReceiver\n  Abstract methods subscribe Subscribes to the message broker.\n public abstract subscribe(correlationId: string): Promise\u0026lt;void\u0026gt;\n  correlationId: string - (optional) transaction id used to trace execution through the call chain.  unsubscribe Unsubscribes from the message broker.\n public abstract unsubscribe(correlationId: string): Promise\u0026lt;void\u0026gt;\n  correlationId: string - (optional) transaction id used to trace execution through the call chain.  Instance methods clear Clears component state.\n public clear(correlationId: string): Promise\u0026lt;void\u0026gt;\n  correlationId: string - (optional) transaction id used to trace execution through the call chain.  configure Configures a component by passing its configuration parameters.\n public configure(config: ConfigParams): void\n  config: ConfigParams - configuration parameters to be set.  endListen Ends listening for incoming messages. When this method is called, listen unblocks the thread and execution continues.\n public endListen(correlationId: string): void\n  correlationId: string - (optional) transaction id used to trace execution through the call chain.  listen Listens for incoming messages and blocks the current thread until the queue is closed. See IMessageReceiver, receive\n public listen(correlationId: string, receiver: IMessageReceiver): void\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. receiver: IMessageReceiver - receiver used to receive incoming messages.  open Opens the component.\n public open(correlationId: string): Promise\u0026lt;void\u0026gt;\n  correlationId: string - (optional) transaction id used to trace execution through the call chain.  peek Peeks a single incoming message from the queue without removing it. If there are no messages available in the queue it returns null.\n public peek(correlationId: string): Promise\u0026lt;MessageEnvelope\u0026gt;\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. returns: Promise\u0026lt;MessageEnvelope\u0026gt; - peeked message or null.  peekBatch Peeks multiple incoming messages from the queue without removing them. If there are no messages available in the queue it returns an empty list.\nImportant: This method is not supported by MQTT.\n public peekBatch(correlationId: string, messageCount: number): Promise\u0026lt;MessageEnvelope[]\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. messageCount: number - maximum number of messages to peek. returns: Promise\u0026lt;MessageEnvelope[]] - list with peeked messages.  readMessageCount Reads the current number of messages in the queue to be delivered.\n public readMessageCount(): Promise\u0026lt;number\u0026gt;\n  returns: number - number of messages in the queue.  receive Receives an incoming message and removes it from the queue.\n public receive(correlationId: string, waitTimeout: number): MessageEnvelope\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. waitTimeout: number - timeout in milliseconds to wait for a message to come. returns: MessageEnvelope - received message or null.  sendMessageToReceiver Sends a message to a receiver.\n protected sendMessageToReceiver(receiver: IMessageReceiver, message: MessageEnvelope): Promise\u0026lt;void\u0026gt;\n  receiver: IMessageReceiver - receiver of the message. message: MessageEnvelope - message to be sent.  See also   MessageQueue   ","description":"Message queue that caches received messages in memory to allow peek operations that may not be supported by the undelying queue.\n","image":null,"permalink":"/node/messaging/queues/cached_message_queue/","subtitle":null,"tags":null,"title":"CachedMessageQueue"},{"content":"Implements: ICleanable, MessageQueue\nDescription The CachedMessageQueue class allows you to create message queues that cache received messages in memory, to allow peek operations that may not be supported by the undelying queue.\nImportant points\n This queue is used as a base implementation for other queues.  Constructors Creates a new instance of the persistence component.\n CachedMessageQueue(name: str = None, capabilities: MessagingCapabilities = None)\n  name: str - (optional) queue name capabilities: MessagingCapabilities - (optional) capabilities of the message queue  Fields _auto_subscribe Boolean variable indicating whether a message queue auto-subscribes or not.\n _auto_subscribe: bool\n _lock Thread lock.\n _lock: threading.Lock\n _event Thread event.\n _event: threading.Event t\n _messages List of messages in a queue.\n _messages: MessageEnvelope[]\n _receiver Message receiver.\n _receiver: IMessageReceiver\n  Abstract methods subscribe Subscribes to the message broker.\n abstractmethod subscribe(correlation_id: Optional[str])\n  correlation_id: Optional[str] - (optional) transaction id used to trace execution through the call chain.  unsubscribe Unsubscribes from the message broker.\n abstractmethod unsubscribe(correlation_id: Optional[str])\n  correlation_id: Optional[str] - (optional) transaction id used to trace execution through the call chain.  Instance methods clear Clears component state.\n clear(correlation_id: Optional[str])\n  correlation_id: Optional[str] - (optional) transaction id used to trace execution through the call chain.  configure Configures a component by passing its configuration parameters.\n configure(config: ConfigParams)\n  config: ConfigParams - configuration parameters to be set.  end_listen Ends listening for incoming messages. When this method is called, listen unblocks the thread and execution continues.\n end_listen(correlation_id: Optional[str])\n  correlation_id: Optional[str] - (optional) transaction id used to trace execution through the call chain.  listen Listens for incoming messages and blocks the current thread until the queue is closed. See IMessageReceiver, receive\n listen(correlation_id: Optional[str], receiver: IMessageReceiver)\n  correlation_id: Optional[str] - (optional) transaction id used to trace execution through the call chain. receiver: IMessageReceiver - receiver used to receive incoming messages.  open Opens the component.\n open(correlation_id: Optional[str])\n  correlation_id: Optional[str] - (optional) transaction id used to trace execution through the call chain.  peek Peeks a single incoming message from the queue without removing it. If there are no messages available in the queue it returns None.\n peek(correlation_id: Optional[str]): MessageEnvelope\n  correlation_id: Optional[str] - (optional) transaction id used to trace execution through the call chain. returns: MessageEnvelope - peeked message or None.  peek_batch Peeks multiple incoming messages from the queue without removing them. If there are no messages available in the queue it returns an empty list.\nImportant: This method is not supported by MQTT.\n peek_batch(correlation_id: Optional[str], message_count: int):List[MessageEnvelope]\n  correlation_id: Optional[str] - (optional) transaction id used to trace execution through the call chain. message_count: int - maximum number of messages to peek. returns: List[MessageEnvelope] - list with peeked messages.  read_message_count Reads the current number of messages in the queue to be delivered.\n read_message_count(): int\n  returns: int - number of messages in the queue.  receive Receives an incoming message and removes it from the queue.\n receive(correlation_id: Optional[str], wait_timeout: int): MessageEnvelope\n  correlation_id: Optional[str] - (optional) transaction id used to trace execution through the call chain. wait_timeout: int - timeout in milliseconds to wait for a message to come. returns: MessageEnvelope - received message or None.  _send_message_to_receiver Sends a message to a receiver.\n _send_message_to_receiver(receiver: IMessageReceiver, message: MessageEnvelope)\n  receiver: IMessageReceiver - receiver of the message. message: MessageEnvelope - message to be sent.  See also   MessageQueue   ","description":"Message queue that caches received messages in memory to allow peek operations that may not be supported by the undelying queue.\n","image":null,"permalink":"/python/messaging/queues/cached_message_queue/","subtitle":null,"tags":null,"title":"CachedMessageQueue"},{"content":"","description":"Message queue that caches received messages in memory to allow peek operations that may not be supported by the undelying queue.\nTODO: this module is not implemented yet\n","image":null,"permalink":"/golang/messaging/queues/cached_message_queue/","subtitle":null,"tags":null,"title":"CachedMessageQueue!"},{"content":"Implements: ITracer, IReconfigurable, IReferenceable\nDescription The CachedTracer class allows you to create a tracer that caches the recorded traces in memory and periodically dumps them.\nImportant points\n Child classes implement saving cached traces to their specified destinations.  Configuration parameters  source: source (context) name options:  interval: interval in milliseconds to save log messages (default: 10 seconds) max_cache_size: maximum number of messages stored in this cache (default: 100)    References  *:context-info:*:*:1.0 - (optional) ContextInfo used to detect the context id and specify a counter\u0026rsquo;s source  Constructors InheritCachedTracer  InheritCachedTracer(saver ICachedTraceSaver) *CachedTracer\n  saver: ICachedTraceSaver - inherited tracer  Fields Cache List of traces\n Cache: []*OperationTrace\n source Source (context) name\n source: string\n updated Boolean variable that indicates whether there has been an update or not.\n updated: bool\n lastDumpTime Time of the last dump\n lastDumpTime: time.Time\n maxCacheSize Maximum number of messages stored in this cache (default: 100)\n maxCacheSize: int\n interval Interval in milliseconds to save log messages (default: 10 seconds)\n interval: int64\n  Methods BeginTrace Begins recording an operation trace.\n (c *CachedTracer) BeginTrace(correlationId string, component string, operation string) *TraceTiming\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. component: string - name of a called component operation: string - name of the executed operation. return: *TraceTiming - trace timing object.  Clear Clears (removes) all cached log messages.\n (c *CachedTracer) Clear()\n Configure Configures component by passing configuration parameters.\n (c *CachedTracer) Configure(config *cconf.ConfigParams)\n  config: *cconf.ConfigParams - configuration parameters to be set.  Dump Dumps (writes) the currently cached log messages.\n (c *CachedTracer) Dump()\n Failure Records an operation failure with its name, duration and error.\n (c *CachedTracer) Failure(correlationId string, component string, operation string, err error, duration int64)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. component: string - name of the called component operation: string - name of the executed operation. err: error - error object associated with this trace. duration: int64 - execution duration in milliseconds.  SetReferences Sets references to dependent components.\n (c *CachedTracer) SetReferences(references cref.IReferences)\n  references: cref.IReferences - references to locate the component dependencies.  Trace Records an operation trace with its name and duration.\n (c *CachedTracer) Trace(correlationId string, component string, operation string, duration int64)\n  correlationId: string - (optional) transaction id to trace execution through a call chain. component: string - name of the called component operation: string - name of the executed operation. duration: int64 - execution duration in milliseconds.  Update Sets trace cache as updated and dumps it when timeout expires.\n (c *CachedTracer) Update()\n Write Writes a log message to the logger destination.\n (c *CachedTracer) Write(correlationId string, component string, operation string, err error, duration int64)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. component: string - name of the called component operation: string - name of the executed operation. err: error - error object associated with this trace. duration: int64 - execution duration in milliseconds.  Save Saves log messages from the cache. Throws error if not done.\n Save(operations []*OperationTrace) error\n  messages: []*OperationTrace - list with log messages  See also   ITracer   OperationTrace   ","description":"Abstract tracer that caches recorded traces in memory and periodically dumps them.\n","image":null,"permalink":"/golang/components/trace/cached_tracer/","subtitle":null,"tags":null,"title":"CachedTracer"},{"content":"Inherits: ITracer, IReconfigurable, IReferenceable\nDescription The CachedTracer class allows you to create a tracer that caches the recorded traces in memory and periodically dumps them.\nImportant points\n Child classes implement saving cached traces to their specified destinations.  Configuration parameters  source: source (context) name options:  interval: interval in milliseconds to save log messages (default: 10 seconds) max_cache_size: maximum number of messages stored in this cache (default: 100)    References  *:context-info:*:*:1.0 - (optional) ContextInfo to detect the context id and specify counters source  Fields _source Source (context) name\n protected _source: string\n _cache List of traces\n protected _cache: IList\u0026lt;OperationTrace\u0026gt;\n _updated Boolean variable that indicates whether there has been an update or not.\n protected _updated: bool\n _lastDumpTime Time of the last dump\n protected _lastDumpTime: long = DateTimeOffset.UtcNow.ToUnixTimeMilliseconds()\n _maxCacheSize Maximum number of messages stored in this cache (default: 100)\n protected _maxCacheSize: int = 100\n _interval Interval in milliseconds to save log messages (default: 10 seconds)\n protected _interval: long = 10000\n  Instance methods BeginTrace Begins recording an operation trace.\n public TraceTiming BeginTrace(string correlationId, string component, string operation)\n  correlationId: string - (optional) transaction id to trace execution through a call chain. component: string - name of a called component operation: string - name of the executed operation. return: TraceTiming - a trace timing object.  Clear Clears (removes) all cached log messages.\n public void Clear()\n Configure Configures component by passing configuration parameters.\n public void Configure(ConfigParams config)\n  config: ConfigParams - configuration parameters to be set.  Dump Dumps (writes) the currently cached log messages.\n public void Dump()\n Failure Records an operation failure with its name, duration and error.\n public void Failure(string correlationId, string component, string operation, Exception error, long duration)\n  correlationId: string - (optional) transaction id to trace execution through a call chain. component: string - name of the called component operation: string - name of the executed operation. error: Exception - an error object associated with this trace. duration: long - execution duration in milliseconds.  SetReferences Sets references to dependent components.\n public void SetReferences(IReferences references)\n  references: IReferences - references to locate the component dependencies.  Trace Records an operation trace with its name and duration.\n public void Trace(string correlationId, string component, string operation, long duration)\n  correlationId: string - (optional) transaction id to trace execution through a call chain. component: string - name of the called component operation: string - name of the executed operation. duration: long - execution duration in milliseconds.  Update Sets trace cache as updated and dumps it when timeout expires.\n protected void Update()\n Write Writes a log message to the logger destination.\n protected void Write(string correlationId, string component, string operation, Exception error, long duration)\n  correlationId: string - (optional) transaction id to trace execution through call chain. component: string - name of the called component operation: string - name of the executed operation. error: Exception - an error object associated with this trace. duration: long - execution duration in milliseconds.  Abstract methods Save Saves log messages from the cache. Throws error if not done.\n protected abstract void Save(IList\u0026lt;OperationTrace\u0026gt; messages)\n  messages: IList\u0026lt;OperationTrace\u0026gt; - a list with log messages  See also   ITracer   OperationTrace   ","description":"Abstract tracer that caches recorded traces in memory and periodically dumps them.\n","image":null,"permalink":"/net/components/trace/cached_tracer/","subtitle":null,"tags":null,"title":"CachedTracer"},{"content":"Implements: ITracer, IReconfigurable, IReferenceable\nDescription The CachedTracer class allows you to create a tracer that caches the recorded traces in memory and periodically dumps them.\nImportant points\n Child classes implement saving cached traces to their specified destinations.  Configuration parameters  source: source (context) name options:  interval: interval in milliseconds to save log messages (default: 10 seconds) max_cache_size: maximum number of messages stored in this cache (default: 100)    References  *:context-info:*:*:1.0 - (optional) ContextInfo to detect the context id and specify counters source  Fields _source Source (context) name\n protected _source: string\n _cache List of traces\n protected _cache: OperationTrace[]\n _updated Boolean variable that indicates whether there has been an update or not.\n protected _updated: bool\n _lastDumpTime Time of the last dump\n protected _lastDumpTime: number\n _maxCacheSize Maximum number of messages stored in this cache (default: 100)\n protected _maxCacheSize = 100\n _interval Interval in milliseconds to save log messages (default: 10 seconds)\n protected _interval = 10000\n  Instance methods beginTrace Begins recording an operation trace.\n public beginTrace(correlationId: string, component: string, operation: string): TraceTiming\n  correlationId: string - (optional) transaction id to trace execution through a call chain. component: string - name of a called component operation: string - name of the executed operation. return: TraceTiming - a trace timing object.  clear Clears (removes) all cached log messages.\n public clear(): void\n configure Configures component by passing configuration parameters.\n public configure(config: ConfigParams): void\n  config: ConfigParams - configuration parameters to be set.  dump Dumps (writes) the currently cached log messages.\n public dump(): void\n failure Records an operation failure with its name, duration and error.\n public failure(correlationId: string, component: string, operation: string, error: Error, duration: number): void\n  correlationId: string - (optional) transaction id to trace execution through a call chain. component: string - name of the called component operation: string - name of the executed operation. error: Error - an error object associated with this trace. duration: number - execution duration in milliseconds.  setReferences Sets references to dependent components.\n public setReferences(references: IReferences): void\n  references: IReferences - references to locate the component dependencies.  trace Records an operation trace with its name and duration.\n public trace(correlationId: string, component: string, operation: string, duration: number): void\n  correlationId: string - (optional) transaction id to trace execution through a call chain. component: string - name of the called component operation: string - name of the executed operation. duration: number - execution duration in milliseconds.  update Sets trace cache as updated and dumps it when timeout expires.\n protected update(): void\n write Writes a log message to the logger destination.\n protected write(correlationId: string, component: string, operation: string, error: Error, duration: number): void\n  correlationId: string - (optional) transaction id to trace execution through call chain. component: string - name of the called component operation: string - name of the executed operation. error: Error - an error object associated with this trace. duration: number - execution duration in milliseconds.  Abstract methods save Saves log messages from the cache. Throws error if not done.\n protected abstract save(messages: OperationTrace[])\n  messages: OperationTrace[] - a list with log messages  See also   ITracer   OperationTrace   ","description":"Abstract tracer that caches recorded traces in memory and periodically dumps them.\n","image":null,"permalink":"/node/components/trace/cached_tracer/","subtitle":null,"tags":null,"title":"CachedTracer"},{"content":"Implements: ITracer, IReconfigurable, IReferenceable\nDescription The CachedTracer class allows you to create a tracer that caches the recorded traces in memory and periodically dumps them.\nImportant points\n Child classes implement saving cached traces to their specified destinations.  Configuration parameters  source: source (context) name options:  interval: interval in milliseconds to save log messages (default: 10 seconds) max_cache_size: maximum number of messages stored in this cache (default: 100)    References  *:context-info:*:*:1.0 - (optional) ContextInfo to detect the context id and specify counters source  Fields _source Source (context) name\n _source: str\n _cache List of traces\n _cache: List[OperationTrace]\n _updated Boolean variable that indicates whether there has been an update or not.\n _updated: bool\n _last_dump_time Time of the last dump\n _last_dump_time: float\n _max_cache_size Maximum number of messages stored in this cache (default: 100)\n _max_cache_size = 100\n _interval Interval in milliseconds to save log messages (default: 10 seconds)\n _interval = 10000\n  Instance methods begin_trace Begins recording an operation trace.\n begin_trace(correlation_id: Optional[str], component: str, operation: str): TraceTiming\n  correlation_id: Optional[str] - (optional) transaction id to trace execution through a call chain. component: str - name of a called component operation: str - name of the executed operation. return: TraceTiming - a trace timing object.  clear Clears (removes) all cached log messages.\n clear()\n configure Configures component by passing configuration parameters.\n configure(config: ConfigParams)\n  config: ConfigParams - configuration parameters to be set.  dump Dumps (writes) the currently cached log messages.\n dump()\n failure Records an operation failure with its name, duration and error.\n failure(correlation_id: Optional[str], component: str, operation: str, error: Exception, duration: float)\n  correlation_id: Optional[str] - (optional) transaction id to trace execution through a call chain. component: str - name of the called component operation: str - name of the executed operation. error: Exception - an error object associated with this trace. duration: float - execution duration in milliseconds.  _save Saves log messages from the cache. Throws error if not done.\n abstractmethod _save(messages: List[OperationTrace])\n  messages: List[OperationTrace] - a list with log messages  set_references Sets references to dependent components.\n set_references(references: IReferences)\n  references: IReferences - references to locate the component dependencies.  trace Records an operation trace with its name and duration.\n trace(correlation_id: Optional[str], component: str, operation: str, duration: float)\n  correlation_id: Optional[str] - (optional) transaction id to trace execution through a call chain. component: str - name of the called component operation: str - name of the executed operation. duration: float - execution duration in milliseconds.  _update Sets trace cache as updated and dumps it when timeout expires.\n _update()\n _write Writes a log message to the logger destination.\n _write(correlation_id: Optional[str], component: str, operation: str, error: Optional[Exception], duration: float)\n  correlation_id: Optional[str] - (optional) transaction id to trace execution through call chain. component: str - name of the called component operation: str - name of the executed operation. error: Optional[Exception] - an error object associated with this trace. duration: float - execution duration in milliseconds.  See also   ITracer   OperationTrace   ","description":"Abstract tracer that caches recorded traces in memory and periodically dumps them.\n","image":null,"permalink":"/python/components/trace/cached_tracer/","subtitle":null,"tags":null,"title":"CachedTracer"},{"content":"Description The CacheEntry class allows you to create a data object that can be used to store cached values with their keys used by MemoryCache.\nConstructors Creates a new instance of the cache entry and assigns its values.\n NewCacheEntry(key string, value interface{}, timeout int64) *CacheEntry\n  key: string - unique key to locate the value. value: interface{} - value to be stored. timeout: int64 - expiration timeout in milliseconds.  Methods Expiration Gets the expiration timeout.\n (c *CacheEntry) Expiration() time.Time\n  returns: time.Time - expiration timeout in milliseconds.  Key Gets the key to locate the cached value.\n (c *CacheEntry) Key() string\n  returns: string - value key.  Value Gets the cached value.\n (c *CacheEntry) Value() interface{}\n  returns: interface{} - value object.  IsExpired Checks if this value has already expired.\n (c *CacheEntry) IsExpired() bool\n  returns: bool - true if the value has already expired and false otherwise.  SetValue Sets a new value and extends its expiration.\n (c *CacheEntry) SetValue(value interface{}, timeout int64)\n  value: interface{} - new cached value. timeout: int64 - expiration timeout in milliseconds.  ","description":"Data object to store cached values with their keys used by [MemoryCache](../memory_cache).\n","image":null,"permalink":"/golang/components/cache/cache_entry/","subtitle":null,"tags":null,"title":"CacheEntry"},{"content":"Description The CacheEntry class allows you to create a data object that can be used to store cached values with their keys used by MemoryCache.\nConstructors Creates a new instance of the cache entry and assigns its values.\n public CacheEntry(string key, object value, long timeout)\n  key: string - a unique key to locate the value. value: object - a value to be stored. timeout: long - expiration timeout in milliseconds.  Properties Key Gets the key to locate the cached value.\n public string Key { get; }\n Value Gets the cached value.\n public object Value [ get, private set ]\n Expiration Gets the expiration timeout.\n public long Expiration [ get, private set ]\n Instance methods IsExpired Checks if this value has already expired.\n public bool IsExpired()\n  returns: bool - true if the value has already expired and false otherwise.  SetValue Sets a new value and extends its expiration.\n public void SetValue(object value, long timeout)\n  value: object - a new cached value. timeout: long - a expiration timeout in milliseconds.  ","description":"Data object to store cached values with their keys used by [MemoryCache](../memory_cache).\n","image":null,"permalink":"/net/components/cache/cache_entry/","subtitle":null,"tags":null,"title":"CacheEntry"},{"content":"Description The CacheEntry class allows you to create a data object that can be used to store cached values with their keys used by MemoryCache.\nConstructors Creates a new instance of the cache entry and assigns its values.\n public constructor(key: string, value: any, timeout: number)\n  key: string - a unique key to locate the value. value: any - a value to be stored. timeout: number - expiration timeout in milliseconds.  Instance methods getExpiration Gets the expiration timeout.\n public getExpiration(): number\n  returns: number - the expiration timeout in milliseconds.  getKey Gets the key to locate the cached value.\n public getKey(): string\n  returns: string - the value key.  getValue Gets the cached value.\n public getValue(): any\n  returns: any - the value object.  isExpired Checks if this value has already expired.\n public isExpired(): boolean\n  returns: boolean - true if the value has already expired and false otherwise.  setValue Sets a new value and extends its expiration.\n public setValue(value: any, timeout: number): void\n  value: any - a new cached value. timeout: number - a expiration timeout in milliseconds.  ","description":"Data object to store cached values with their keys used by [MemoryCache](../memory_cache).\n","image":null,"permalink":"/node/components/cache/cache_entry/","subtitle":null,"tags":null,"title":"CacheEntry"},{"content":"Description The CacheEntry class allows you to create a data object that can be used to store cached values with their keys used by MemoryCache.\nConstructors Creates a new instance of the cache entry and assigns its values.\n CacheEntry(key: str, value: str, timeout: int)\n  key: str - a unique key to locate the value. value: str - a value to be stored. timeout: int - expiration timeout in milliseconds.  Instance methods get_expiration Gets the expiration timeout.\n get_expiration(): int\n  returns: int - the expiration timeout in milliseconds.  get_key Gets the key to locate the cached value.\n get_key(): str\n  returns: str - the value key.  get_value Gets the cached value.\n get_value(): Any\n  returns: Any - the value object.  is_expired Checks if this value has already expired.\n is_expired(): bool\n  returns: bool - true if the value has already expired and false otherwise.  set_value Sets a new value and extends its expiration.\n set_value(value: Any, timeout: int)\n  value: Any - a new cached value. timeout: int - a expiration timeout in milliseconds.  ","description":"Data object to store cached values with their keys used by [MemoryCache](../memory_cache).\n","image":null,"permalink":"/python/components/cache/cache_entry/","subtitle":null,"tags":null,"title":"CacheEntry"},{"content":"Description The CalculationStack class allows you to implement a stack of Variant values.\nProperties length Length\n public length(): number\n  returns: number - TODO: add description  Instance methods pop Removes and returns last value from the list.\n public pop(): Variant\n peekAt Peeks a Variant value located at a specified index.\n public peekAt(index: number): Variant\n peek Peeks a Varian value.\n public peek(): Variant\n ","description":"Implements a stack of Variant values.\n","image":null,"permalink":"/node/expressions/calculator/calculation_stack/","subtitle":null,"tags":null,"title":"CalculationStack"},{"content":"Description The CallbackMessageReceiver class allows you to wrap message callbacks into IMessageReceiver.\nConstructors NewCallbackMessageReceiver Creates an instance of the CallbackMessageReceiver.\n NewCallbackMessageReceiver(callback func(message *MessageEnvelope, queue IMessageQueue) error) *CallbackMessageReceiver\n  callback: func(message *MessageEnvelope, queue IMessageQueue) - a callback function that shall be wrapped into IMessageReceiver  Methods ReceiveMessage Receives an incoming message from the queue.\nSee also MessageEnvelope, IMessageQueue\n (c *CallbackMessageReceiver) ReceiveMessage(message *MessageEnvelope, queue IMessageQueue) (err error)\n  envelope: MessageEnvelope - incoming message. queue: IMessageQueue - queue where the message comes from. returns: error - returns error if not received.  ","description":"Wraps a message callback into [IMessageReceiver](../imessage_receiver)\n","image":null,"permalink":"/golang/messaging/queues/callback_message_receiver/","subtitle":null,"tags":null,"title":"CallbackMessageReceiver"},{"content":"Inherts: IMessageReceiver\nDescription The CallbackMessageReceiver class allows you to wrap message callbacks into IMessageReceiver.\nConstructors Creates an instance of the CallbackMessageReceiver.\n public CallbackMessageReceiver(Func\u0026lt;MessageEnvelope, IMessageQueue, Task\u0026gt; callback)\n  callback: Func\u0026lt;MessageEnvelope, IMessageQueue, Task\u0026gt; - a callback function that shall be wrapped into IMessageReceiver  Instance methods receiveMessage Receives an incoming message from the queue.\nSee also MessageEnvelope, IMessageQueue\n public Task ReceiveMessageAsync(MessageEnvelope envelope, IMessageQueue queue)\n  envelope: MessageEnvelope - incoming message queue: IMessageQueue - queue where the message comes from  ","description":"Wraps a message callback into [IMessageReceiver](../imessage_receiver)\n","image":null,"permalink":"/net/messaging/queues/callback_message_receiver/","subtitle":null,"tags":null,"title":"CallbackMessageReceiver"},{"content":"Implements: IMessageReceiver\nDescription The CallbackMessageReceiver class allows you to wrap message callbacks into IMessageReceiver.\nConstructors Creates an instance of the CallbackMessageReceiver.\n public constructor(callback: (envelope: MessageEnvelope, queue: IMessageQueue) =\u0026gt; Promise\u0026lt;void\u0026gt;)\n  callback: MessageEnvelope, queue: IMessageQueue) =\u0026gt; Promise\u0026lt;void\u0026gt; - a callback function that shall be wrapped into IMessageReceiver  Instance methods receiveMessage Receives an incoming message from the queue.\nSee also MessageEnvelope, IMessageQueue\n public receiveMessage(envelope: MessageEnvelope, queue: IMessageQueue): Promise\u0026lt;void\u0026gt;\n  envelope: MessageEnvelope - incoming message queue: IMessageQueue - queue where the message comes from  ","description":"Wraps a message callback into [IMessageReceiver](../imessage_receiver)\n","image":null,"permalink":"/node/messaging/queues/callback_message_receiver/","subtitle":null,"tags":null,"title":"CallbackMessageReceiver"},{"content":"Implements: IMessageReceiver\nDescription The CallbackMessageReceiver class allows you to wrap message callbacks into IMessageReceiver.\nConstructors Creates an instance of the CallbackMessageReceiver.\n CallbackMessageReceiver(callback: Callable[[MessageEnvelope, IMessageQueue], None])\n  callback: Callable[[MessageEnvelope, IMessageQueue], None] - a callback function that shall be wrapped into IMessageReceiver  Instance methods receive_message Receives an incoming message from the queue.\nSee also MessageEnvelope, IMessageQueue\n receive_message(envelope: MessageEnvelope, queue: IMessageQueue)\n  envelope: MessageEnvelope - incoming message queue: IMessageQueue - queue where the message comes from  ","description":"Wraps a message callback into [IMessageReceiver](../imessage_receiver)\n","image":null,"permalink":"/python/messaging/queues/callback_message_receiver/","subtitle":null,"tags":null,"title":"CallbackMessageReceiver"},{"content":"Description The CCommentState class allows you to create a state that will either delegate to a comment-handling state, or return a token with just a slash in it.\nInstance methods nextToken Either delegate to a comment-handling state, or return a token with just a slash in it.\n public nextToken(scanner: IScanner, tokenizer: ITokenizer): Token\n  scanner: IScanner - textual string to be tokenized. tokenizer: ITokenizer - tokenizer class that controls the process. returns: Token - next token from the top of the stream.  ","description":"This state will either delegate to a comment-handling state, or return a token with just a slash in it.\n","image":null,"permalink":"/node/expressions/tokenizers/generic/c_comment_state/","subtitle":null,"tags":null,"title":"CCommentState"},{"content":"Detects changes made in a particular scope or element of a scope. Intended to implement change detection using simple pull mechanism. For instance: multiple configuration microservices change the scope, and business logic that depends on those configurations periodically reads it to check if anything was changed.\n Server implementations: NodeJS Communication protocols: Direct, Commandable HTTP, Commandable GRPC, GRPC Persistence: Memory, Flat Files, MongoDB, Couchbase Deployment options: Monolith, Process, Docker, AWS Lambda Client implementations: NodeJS, .NET  ","description":null,"image":null,"permalink":"/microservices/infrastructure/change_scopes/","subtitle":null,"tags":null,"title":"Change Scopes Microservice"},{"content":"Description The CharReferenceInterval allows you to represent a character interval that keeps a reference. Important points\n This class is internal and used by CharReferenceMap.  Constructors Creates a new instance of the CharReferenceInterval class.\n public constructor(start: number, end: number, reference: T)\n  start: number - start of the interval end: number - end of the interval reference: T - reference  Properties end End of the interval\n public end(): number\n  returns: number - end of the interval  reference Reference\n public reference(): T\n  returns: T - reference  start Start of the interval\n public start(): number\n  returns: number - start of the interval  Instance methods inRange Determines if a symbol is within a range\n public inRange(symbol: number): boolean\n  symbol: number - symbol returns: boolean - true if it is within the range and false otherwise.  ","description":"Represents a character interval that keeps a reference.\n","image":null,"permalink":"/node/expressions/tokenizers/utilities/char_reference_interval/","subtitle":null,"tags":null,"title":"CharReferenceInterval\u003cT\u003e"},{"content":"Description The CharReferenceMap class allows you to keep references associated with specific characters.\nConstructors Creates a new instance of this class.\n public constructor()\n Instance methods addDefaultInterval Adds a default interval.\n public addDefaultInterval(reference: T): void\n  reference: T - reference  addInterval Adds an interval.\n public addInterval(start: number, end: number, reference: T)\n  start: number - start of the interval end: number - end of the interval reference: T - reference  clear Clears up the intervals.\n public clear(): void\n lookup Looks up for a specified symbol.\n public lookup(symbol: number): T\n  symbol: number - symbol returns: T - reference  ","description":"This class keeps references associated with specific characters\n","image":null,"permalink":"/node/expressions/tokenizers/utilities/char_reference_map/","subtitle":null,"tags":null,"title":"CharReferenceMap\u003cT\u003e"},{"content":"Description The CharValidator class allows you to validate characters that are processed by tokenizers.\nConstructors Default contructor to prevent creation of a class instance.\n public constructor()\n Properties Eof EOF\n public static Eof: number = 0xffff\n Zero Zero\n public static Zero: number = \u0026lsquo;0\u0026rsquo;.charCodeAt(0)\n Nine Nine\n public static Nine: number = \u0026lsquo;9\u0026rsquo;.charCodeAt(0)\n Static methods isEof Checks if a character is an EOF.\n public static isEof(value: number): boolean\n  value: number - value to check returns: boolean - validation result  isEol Checks if a character is an EOL.\n public static isEol(value: number): boolean\n  value: number - value to check returns: boolean - validation result  isDigit Checks if a character is a digit.\n public static isDigit(value: number): boolean\n  value: number - value to check returns: boolean - validation result  ","description":"Validates characters that are processed by tokenizers.\n","image":null,"permalink":"/node/expressions/tokenizers/utilities/char_validator/","subtitle":null,"tags":null,"title":"CharValidator"},{"content":"Description The Cleaner class allows you to clear the state of components.\nMethods Clear Clears state of multiple components.\nTo be cleaned, state components must implement the ICleanable interface. If they don\u0026rsquo;t, the call to this method has no effect.\n (c *TCleaner) Clear(correlationId string, components []interface{}) error\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. components: []interface{} - list of components that are to be cleaned. returns: error - return error if not cleared  СlearOne Clears state of specific component. To be cleaned, state components must implement the ICleanable interface. If they don\u0026rsquo;t the call to this method has no effect.\n (c *TCleaner) ClearOne(correlationId string, component interface{}) error\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. component: interface{} - component that is to be cleaned. returns: error - return error if not cleared  See also   ICleanable   ","description":"Helper class that allows you to clear the state of components.\n","image":null,"permalink":"/golang/commons/run/cleaner/","subtitle":null,"tags":null,"title":"Cleaner"},{"content":"Description The Cleaner class allows you to clear the state of components.\nStatic methods ClearAsync Clears the state of multiple components.\nTo be cleaned state components must implement the ICleanable interface. If they don\u0026rsquo;t, the call to this method has no effect.\n public static Task ClearAsync(string correlationId, IEnumerable components)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. components: IEnumerable - list of components that are to be cleaned.  ClearOneAsync Clears the state of a specific component. To be cleaned. state components must implement the ICleanable interface. If they don\u0026rsquo;t, the call to this method has no effect.\n public static Task ClearOneAsync(string correlationId, object component)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. component: object - component that is to be cleaned.  See also   ICleanable   ","description":"Helper class that allows you to clear the states of components.\n","image":null,"permalink":"/net/commons/run/cleaner/","subtitle":null,"tags":null,"title":"Cleaner"},{"content":"Description The Cleaner class allows you to clear the state of components.\nStatic methods clear Clears state of multiple components.\nTo be cleaned, state components must implement the ICleanable interface. If they don\u0026rsquo;t, the call to this method has no effect.\n public static clear(correlationId: string, components: any[]): Promise\u0026lt;void\u0026gt;\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. components: any[] - list of components that are to be cleaned.  clearOne Clears the state of a specific component. To be cleaned, state components must implement ICleanable interface. If they don\u0026rsquo;t, the call to this method has no effect.\n public static clearOne(correlationId: string, component: any): Promise\u0026lt;void\u0026gt;\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. component: any - component that is to be cleaned.  See also   ICleanable   ","description":"Helper class that allows you to clear the state of components.\n","image":null,"permalink":"/node/commons/run/cleaner/","subtitle":null,"tags":null,"title":"Cleaner"},{"content":"Description The Cleaner class allows you to clear the state of components.\nStatic methods clear Clears the state of multiple components.\nTo be cleaned state components must implement ICleanable interface. If they don\u0026rsquo;t the call to this method has no effect.\n static clear(correlation_id: Optional[str], components: List[Any])\n  correlation_id: Optional[str] - (optional) transaction id to trace execution through call chain. components: List[Any] - the list of components that are to be cleaned.  clear_one Clears the state of a specific component. To be cleaned state components must implement ICleanable interface. If they don\u0026rsquo;t the call to this method has no effect.\n static clearOne(correlation_id: Optional[str], component: Any)\n  correlation_id: Optional[str] - (optional) transaction id to trace execution through call chain. component: Any - the component that is to be cleaned.  See also   ICleanable   ","description":"Helper class that allows you to clear the state of components.\n","image":null,"permalink":"/python/commons/run/cleaner/","subtitle":null,"tags":null,"title":"Cleaner"},{"content":"Description The Closer class allows you to close one or multiple components at the same time.\nMethods Close Closes multiple components.\nTo be closed components must implement IClosable interface. If they don\u0026rsquo;t the call to this method has no effect.\n (c *TCloser) Close(correlationId string, components []interface{}) error\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. components: []interface{} - list of components that are to be closed. returns: error - return error if not closed  CloseOne Closes specific component. The components to be closed must implement the IClosable interface. If they don\u0026rsquo;t the call to this method has no effect.\n (c *TCloser) CloseOne(correlationId string, component interface{}) error\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. component: interface{} - component that is to be closed. returns: error - return error if not closed  See also   IClosable   ","description":"Helper class that allows you to close one or multiple components at the same time.\n","image":null,"permalink":"/golang/commons/run/closer/","subtitle":null,"tags":null,"title":"Closer"},{"content":"Description The Closer class allows you to close one or multiple components at the same time.\nStatic methods CloseAsync Closes multiple components.\nTo be closed, the components must implement the IClosable interface. If they don\u0026rsquo;t, the call to this method has no effect.\n public static Task CloseAsync(string correlationId, IEnumerable components)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. components: IEnumerable - list of components that are to be closed.  CloseOneAsync Closes a specific component. To be closed, components must implement the IClosable interface. If they don\u0026rsquo;t, the call to this method has no effect.\n public static Task CloseOneAsync(string correlationId, object component)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. component: object - component that is to be closed.  See also   IClosable   ","description":"Helper class that allows you to close one or multiple components at the same time.\n","image":null,"permalink":"/net/commons/run/closer/","subtitle":null,"tags":null,"title":"Closer"},{"content":"Description The Closer class allows you to close one or multiple components at the same time.\nStatic methods close Closes multiple components.\nTo be closed, components must implement the IClosable interface. If they don\u0026rsquo;t, the call to this method has no effect.\n public static close(correlationId: string, components: any[]): Promise\u0026lt;void\u0026gt;\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. components: any[] - list of components that are to be closed.  closeOne Closes a specific component. To be closed, components must implement the IClosable interface. If they don\u0026rsquo;t, the call to this method has no effect.\n public static closeOne(correlationId: string, component: any): Promise\u0026lt;void\u0026gt;\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. component: any - component that is to be closed.  See also   IClosable   ","description":"Helper class that allows you to close one or multiple components at the same time.\n","image":null,"permalink":"/node/commons/run/closer/","subtitle":null,"tags":null,"title":"Closer"},{"content":"Description The Closer class allows you to close one or multiple components at the same time.\nStatic methods close Closes multiple components.\nTo be closed components must implement IClosable interface. If they don\u0026rsquo;t, then a call to this method has no effect.\n static close(correlation_id: Optional[str], components: List[Any])\n  correlation_id: Optional[str] - (optional) transaction id to trace execution through a call chain. components: List[Any] - the list of components that are to be closed.  close_one Closes a specific component. To be closed components must implement IClosable interface. If they don\u0026rsquo;t the call to this method has no effect.\n static close_one(correlation_id: Optional[str], component: Any)\n  correlation_id: Optional[str] - (optional) transaction id to trace execution through call chain. component: Any - the component that is to be closed.  See also   IClosable   ","description":"Helper class that allows you to close one or multiple components at the same time.\n","image":null,"permalink":"/python/commons/run/closer/","subtitle":null,"tags":null,"title":"Closer"},{"content":"Implements: IConfigurable, IReferenceable\nExtends: CachedCounters\nDescription The CloudWatchCounters class allows you to create performance counters taht periodically dump counters to AWS Cloud Watch Metrics.\nConfiguration parameters  connections:  discovery_key: (optional) key to retrieve the connection from IDiscovery region: (optional) AWS region   credentials:  store_key: (optional) key to retrieve the credentials from ICredentialStore access_id: AWS access/client id access_key: AWS access/client id   options:  interval: interval in milliseconds to save current counters measurements (default: 5 mins) reset_timeout: timeout in milliseconds to reset the counters. 0 disables the reset (default: 0)    References  *:context-info:*:*:1.0: (optional) ContextInfo to detect the context id and specify counters source *:discovery:*:*:1.0: (optional) IDiscovery services to resolve connections *:credential-store:*:*:1.0: (optional) credential stores to resolve credentials requests  Constructors Creates a new instance of this counters.\n public constructor()\n Instance methods close Closes component and frees used resources.\n public close(correlationId: string): Promise\u0026lt;void\u0026gt;\n  correlationId: string - (optional) transaction id used to trace execution through the call chain.  configure Configures a component by passing configuration parameters.\n public configure(config: ConfigParams): void\n  config: ConfigParams - configuration parameters to be set.  isOpen Checks if the component is open.\n public isOpen(): boolean\n  returns: boolean - true if the component has been opened and false otherwise.  open Opens the component.\n public open(correlationId: string): Promise\u0026lt;void\u0026gt;\n  correlationId: string - (optional) transaction id used to trace execution through the call chain.  save Saves the current counters measurements.\n protected save(counters: Counter[]): Promise\u0026lt;void\u0026gt;\n  counters: Counter[] - current counters measurements to be saved.  setReferences Sets references to dependent components.\n public setReferences(references: IReferences): void\n  references: IReferences - references to locate the component\u0026rsquo;s dependencies.  Examples let counters = new CloudWatchCounters(); counters.config(ConfigParams.fromTuples( \u0026#34;connection.region\u0026#34;, \u0026#34;us-east-1\u0026#34;, \u0026#34;connection.access_id\u0026#34;, \u0026#34;XXXXXXXXXXX\u0026#34;, \u0026#34;connection.access_key\u0026#34;, \u0026#34;XXXXXXXXXXX\u0026#34; )); counters.setReferences(References.fromTuples( new Descriptor(\u0026#34;pip-services\u0026#34;, \u0026#34;logger\u0026#34;, \u0026#34;console\u0026#34;, \u0026#34;default\u0026#34;, \u0026#34;1.0\u0026#34;), new ConsoleLogger() )); await counters.open(\u0026#34;123\u0026#34;); counters.increment(\u0026#34;mycomponent.mymethod.calls\u0026#34;); let timing = counters.beginTiming(\u0026#34;mycomponent.mymethod.exec_time\u0026#34;); try { ... } finally { timing.endTiming(); } counters.dump(); See also   Counter   CachedCounters   CompositeLogger   ","description":"Performance counters that periodically dumps counters to AWS Cloud Watch Metrics.\n","image":null,"permalink":"/node/aws/count/cloud_watch_counters/","subtitle":null,"tags":null,"title":"CloudWatchCounters"},{"content":"Implements: IConfigurable, IReferenceable\nExtends: CachedLogger\nDescription The CloudWatchLogger class allows you to create loggers that write log messages to AWS Cloud Watch Log.\nConfiguration parameters  stream: (optional) Cloud Watch Log stream (default: context name) group: (optional) Cloud Watch Log group (default: context instance ID or hostname) connections:  discovery_key: (optional) key to retrieve the connection from IDiscovery region: (optional) AWS region   credentials:  store_key: (optional) key to retrieve the credentials from ICredentialStore access_id: AWS access/client id access_key: AWS access/client id   options:  interval: interval in milliseconds to save current counters measurements (default: 5 mins) reset_timeout: timeout in milliseconds to reset the counters. 0 disables the reset (default: 0)    References  *:context-info:*:*:1.0: (optional) ContextInfo to detect the context id and specify the counters source *:discovery:*:*:1.0: (optional) IDiscovery services to resolve connections *:credential-store:*:*:1.0: (optional) credential stores used to resolve credentials requests  Constructors Creates a new instance of this logger.\n public constructor()\n Instance methods close Closes a component and frees used resources.\n public close(correlationId: string): Promise\u0026lt;void\u0026gt;\n  correlationId: string - (optional) transaction id used to trace execution through the call chain.  configure Configures a component by passing configuration parameters.\n public configure(config: ConfigParams): void\n  config: ConfigParams - configuration parameters to be set.  isOpen Checks if the component is open.\n public isOpen(): boolean\n  returns: boolean - true if the component has been opened and false otherwise.  open Opens the component.\n public open(correlationId: string): Promise\u0026lt;void\u0026gt;\n  correlationId: string - (optional) transaction id used to trace execution through the call chain.  save Saves the current counters' measurements.\n protected save(messages: LogMessage[]): Promise\u0026lt;void\u0026gt;\n  messages: LogMessage[] - current counters' measurements to be saves.  setReferences Sets references to dependent components.\n public setReferences(references: IReferences): void\n  references: IReferences - references to locate the component dependencies.  write Writes a log message to the logger destination.\n protected write(level: LogLevel, correlationId: string, ex: Error, message: string): void\n  level: LogLevel - log level. correlationId: string - (optional) transaction id used to trace execution through the call chain. ex: Error - error object associated with this message. message: string - human-readable message to log.  Examples let logger = new Logger(); logger.config(ConfigParams.fromTuples( \u0026#34;stream\u0026#34;, \u0026#34;mystream\u0026#34;, \u0026#34;group\u0026#34;, \u0026#34;mygroup\u0026#34;, \u0026#34;connection.region\u0026#34;, \u0026#34;us-east-1\u0026#34;, \u0026#34;connection.access_id\u0026#34;, \u0026#34;XXXXXXXXXXX\u0026#34;, \u0026#34;connection.access_key\u0026#34;, \u0026#34;XXXXXXXXXXX\u0026#34; )); logger.setReferences(References.fromTuples( new Descriptor(\u0026#34;pip-services\u0026#34;, \u0026#34;logger\u0026#34;, \u0026#34;console\u0026#34;, \u0026#34;default\u0026#34;, \u0026#34;1.0\u0026#34;), new ConsoleLogger() )); await logger.open(\u0026#34;123\u0026#34;); logger.setLevel(LogLevel.debug); logger.error(\u0026#34;123\u0026#34;, ex, \u0026#34;Error occured: %s\u0026#34;, ex.message); logger.debug(\u0026#34;123\u0026#34;, \u0026#34;Everything is OK.\u0026#34;); See also   Counter   CachedCounters   CompositeLogger   ","description":"Logger that writes log messages to AWS Cloud Watch Log.\n","image":null,"permalink":"/node/aws/log/cloud_watch_logger/","subtitle":null,"tags":null,"title":"CloudWatchLogger"},{"content":"Extends: LambdaFunction\nDescription The CloudWatchUnit class contains constans used to determine cloud watch units.\nFields Seconds  public static Seconds = \u0026ldquo;Seconds\u0026rdquo;;\n Microseconds  public static Microseconds = \u0026ldquo;Microseconds\u0026rdquo;;\n Milliseconds  public static Milliseconds = \u0026ldquo;Milliseconds\u0026rdquo;;\n Bytes  public static Bytes = \u0026ldquo;Bytes\u0026rdquo;;\n Kilobytes  public static Kilobytes = \u0026ldquo;Kilobytes\u0026rdquo;;\n Megabytes  public static Megabytes = \u0026ldquo;Megabytes\u0026rdquo;;\n Gigabytes  public static Gigabytes = \u0026ldquo;Gigabytes\u0026rdquo;;\n Terabytes  public static Terabytes = \u0026ldquo;Terabytes\u0026rdquo;;\n Bits  public static Bits = \u0026ldquo;Bits\u0026rdquo;;\n Kilobits  public static Kilobits = \u0026ldquo;Kilobits\u0026rdquo;;\n Megabits  public static Megabits = \u0026ldquo;Megabits\u0026rdquo;;\n Gigabits  public static Gigabits = \u0026ldquo;Gigabits\u0026rdquo;;\n Terabits  public static Terabits = \u0026ldquo;Terabits\u0026rdquo;;\n Percent  public static Percent = \u0026ldquo;Percent\u0026rdquo;;\n Count  public static Count = \u0026ldquo;Count\u0026rdquo;;\n Bytes_Second  public static Bytes_Second = \u0026ldquo;Bytes/Second\u0026rdquo;;\n Kilobytes_Second  public static Kilobytes_Second = \u0026ldquo;Kilobytes/Second\u0026rdquo;;\n Megabytes_Second  public static Megabytes_Second = \u0026ldquo;Megabytes/Second\u0026rdquo;;\n Gigabytes_Second  public static Gigabytes_Second = \u0026ldquo;Gigabytes/Second\u0026rdquo;;\n Terabytes_Second  public static Terabytes_Second = \u0026ldquo;Terabytes/Second\u0026rdquo;;\n Bits_Second  public static Bits_Second = \u0026ldquo;Bits/Second\u0026rdquo;;\n Kilobits_Second  public static Kilobits_Second = \u0026ldquo;Kilobits/Second\u0026rdquo;;\n Megabits_Second  public static Megabits_Second = \u0026ldquo;Megabits/Second\u0026rdquo;;\n Gigabits_Second  public static Gigabits_Second = \u0026ldquo;Gigabits/Second\u0026rdquo;;\n Terabits_Second  public static Terabits_Second = \u0026ldquo;Terabits/Second\u0026rdquo;;\n Count_Second  public static Count_Second = \u0026ldquo;Count/Second\u0026rdquo;;\n None  public static None = \u0026ldquo;None\u0026rdquo;;\n  ","description":"Constants that determine cloud watch units.\n","image":null,"permalink":"/node/aws/count/cloud_watch_unit/","subtitle":null,"tags":null,"title":"CloudWatchUnit"},{"content":"Keeps list of working clusters.\n Server implementations: NodeJS Communication protocols: Direct, Commandable HTTP, Commandable GRPC, GRPC Persistence: Memory, Flat Files, MongoDB, Couchbase Deployment options: Monolith, Process, Docker, AWS Lambda Client implementations: NodeJS  ","description":null,"image":null,"permalink":"/microservices/infrastructure/clusters/","subtitle":null,"tags":null,"title":"Clusters Microservice"},{"content":"Description The Command class allows you to call a method or a function.\nConstructors NewCommand Creates a new command object and assigns it\u0026rsquo;s parameters.\n NewCommand(name string, schema validate.ISchema, action func(correlationId string, args *run.Parameters) (interface{}, error)) *Command\n  name: string - the command name. schema: Schema - the schema to validate command arguments. action: func(correlationId string, args *run.Parameters) (interface{}, error) - the function to be executed by this command.  Methods Execute Executes the command. Before execution it validates args using the defined schema.\nRaise ApplicationException when execution fails for whatever reason.\nSee Parameters\n (c *Command) Execute(correlationId string, args *run.Parameters) (interface{}, error)\n  correlationId: string - (optional) transaction id to trace execution through call chain. args: *run.Parameters - the parameters (arguments) to pass to this command for execution. returns: (interface{}, error) - the execution result  Name Gets the command name.\n (c *Command) Name() string\n  returns: string - the name of this command.  Validate Validates the command args before execution using the defined schema.\n (c *Command) Validate(args *run.Parameters) [][*validate.ValidationResul]t(../../validate/validation_result)\n  args: *run.Parameters - the parameters (arguments) to validate using this command\u0026rsquo;s schema. returns: [][*validate.ValidationResul]t(../../validate/validation_result) - an array of ValidationResults or an empty array (if no schema is set).  Examples command := NewCommand(\u0026#34;add\u0026#34;, nil, func (correlationId string, args *run.Parameters)(interface{}, err) { param1 := args.getAsFloat(\u0026#34;param1\u0026#34;); param2 := args.getAsFloat(\u0026#34;param2\u0026#34;); return (param1 + param2), nil; }); result, err := command.Execute(\u0026#34;123\u0026#34;, Parameters.NewParametersFromTuples(\u0026#34;param1\u0026#34;, 2, \u0026#34;param2\u0026#34;, 2)) if (err) { fmt.Println(err) } else { fmt.Println(\u0026#34;2 + 2 = \u0026#34; + result) } // Console output: 2 + 2 = 4  See also   ICommand   CommandSet   ","description":"Command allows to call a method or a function.\n","image":null,"permalink":"/golang/commons/commands/command/","subtitle":null,"tags":null,"title":"Command"},{"content":"Inherits: ICommand\nDescription The Command class allows you to call a method or a function.\nConstructors Creates a new command object and assigns it\u0026rsquo;s parameters.\n public Command(string name, Schema schema, ExecutableDelegate function)\n  name: string - command name. schema: Schema - schema to validate command arguments. action: ExecutableDelegate - function to be executed by this command.  Properties Name Gets the command name.\n public string Name { get; }\n Schema Gets the command schema.\n public Schema Schema { get; }\n Instance methods ExecuteAsync Executes the command. Before execution it validates args using the defined schema.\nRaise ApplicationException when execution fails for whatever reason.\nSee Parameters\n public Task\u0026lt;object\u0026gt; ExecuteAsync(string correlationId, Parameters args)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. args: Parameters - parameters (arguments) used to pass to this command for execution. returns: Task\u0026lt;object\u0026gt; - execution result  validate Validates the command args before execution using the defined schema.\n public IList\u0026lt;ValidationResult\u0026gt; validate(Parameters args)\n  args: Parameters - parameters (arguments) used to validate using this command\u0026rsquo;s schema. returns: IList\u0026lt;ValidationResult\u0026gt; - array of ValidationResults or an empty array (if no schema is set).  Examples var command = new Command(\u0026#34;add\u0026#34;, null, async(args) =\u0026gt; { var param1 = args.GetAsFloat(\u0026#34;param1\u0026#34;); var param2 = args.GetAsFloat(\u0026#34;param2\u0026#34;); return param1 + param2; }); var result = command.ExecuteAsync(\u0026#34;123\u0026#34;, Parameters.FromTuples( \u0026#34;param1\u0026#34;, 2, \u0026#34;param2\u0026#34;, 2 )); Console.WriteLine(result.ToString()); // Console output: 4  See also   ICommand   CommandSet   ","description":"Command allows you to call a method or a function.\n","image":null,"permalink":"/net/commons/commands/command/","subtitle":null,"tags":null,"title":"Command"},{"content":"Implements: ICommand\nDescription The Command class allows you to call a method or a function.\nConstructors Creates a new command object and assigns it\u0026rsquo;s parameters.\n public constructor(name: string, schema: Schema, action: IExecutable | CommandAction)\n  name: string - command name. schema: Schema - schema to validate command arguments. action: IExecutable - function to be executed by this command.  Instance methods execute Executes the command. Before execution it validates args using the defined schema.\nRaise ApplicationException when execution fails for whatever reason.\nSee Parameters\n public execute(correlationId: string, args: Parameters): Promise\u0026lt;any\u0026gt;\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. args: Parameters - parameters (arguments) to pass to this command for execution. returns: Promise\u0026lt;any\u0026gt; - execution result  getName Gets the command name.\n public getName(): string\n  returns: string - name of this command.  validate Validates the command args before execution using the defined schema.\n public validate(args: Parameters): ValidationResult[]\n  args: Parameters - parameters (arguments) to validate using this command\u0026rsquo;s schema. returns: ValidationResult[] - array of ValidationResults or an empty array (if no schema is set).  Examples let command = new Command(\u0026#34;add\u0026#34;, null, async (correlationId, args) =\u0026gt; { let param1 = args.getAsFloat(\u0026#34;param1\u0026#34;); let param2 = args.getAsFloat(\u0026#34;param2\u0026#34;); let result = param1 + param2; return result; }); * result = await command.execute( \u0026#34;123\u0026#34;, Parameters.fromTuples( \u0026#34;param1\u0026#34;, 2, \u0026#34;param2\u0026#34;, 2 ) ); console.log(\u0026#34;2 + 2 = \u0026#34; + result); // Console output: 2 + 2 = 4  See also   ICommand   CommandSet   ","description":"The Command class allows calling a method or a function.\n","image":null,"permalink":"/node/commons/commands/command/","subtitle":null,"tags":null,"title":"Command"},{"content":"Implements: ICommand\nDescription The Command class allows you to call a method or a function.\nConstructors Creates a new command object and assigns it\u0026rsquo;s parameters.\n Command(name: str, schema: Schema, function: Union[Callable, IExecutable])\n  name: str - the command name. schema: Schema - the schema to validate command arguments. action: IExecutable - the function to be executed by this command.  Instance methods execute Executes the command. Before execution it validates args using the defined schema.\nRaise ApplicationException when execution fails for whatever reason.\nSee Parameters\n execute(correlation_id: Optional[str], args: Parameters): Any\n  correlation_id: Optional[str] - (optional) transaction id to trace execution through call chain. args: Parameters - the parameters (arguments) to pass to this command for execution. returns: Any - the execution result  get_name Gets the command name.\n get_name(): str\n  returns: str - the name of this command.  validate Validates the command args before execution using the defined schema.\n validate(args: Parameters): List[ValidationResult]\n  args: Parameters - the parameters (arguments) to validate using this command\u0026rsquo;s schema. returns: List[ValidationResult] - an array of ValidationResults or an empty array (if no schema is set).  Examples def handler(*args): param1 = args.getAsFloat(\u0026#34;param1\u0026#34;) param2 = args.getAsFloat(\u0026#34;param2\u0026#34;) return param1 + param2 command = Command(\u0026#34;add\u0026#34;, None, handler) result = command.execute(\u0026#34;123\u0026#34;, Parameters.fromTuples(\u0026#34;param1\u0026#34;, 2, \u0026#34;param2\u0026#34;, 2)) print result.__str__() See also   ICommand   CommandSet   ","description":"Command allows to call a method or a function.\n","image":null,"permalink":"/python/commons/commands/command/","subtitle":null,"tags":null,"title":"Command"},{"content":"Extends: AzureFunction\nDescription All actions are automatically generated for commands defined in ICommandable components. Each command is exposed as an action defined by \u0026ldquo;cmd\u0026rdquo; parameter.\nContainer configuration for this Azure Function is stored in \u0026quot;./config/config.yml\u0026quot; file. But this path can be overridden by CONFIG_PATH environment variable.\n Note: This component has been deprecated. Use Azure FunctionService instead.  References  *:logger:*:*:1.0: (optional) ILogger components to pass log messages *:counters:*:*:1.0: (optional) ICounters components to pass collected measurements *:service:azure-function:*:1.0: (optional) IAzureFunctionService services to handle action requests. *:service:commandable-azure-function:*:1.0: (optional) IAzureFunctionService services to handle action requests.  Constructors  public constructor(name: string, description?: string)\n  name: string - (optional) a container name (accessible via ContextInfo) description: string - (optional) a container description (accessible via ContextInfo)  Instance methods getCorrelationId Returns correlationId from Azure Function context.\n public static getCorrelationId(context: any): string\n  context: any - the Azure Function context. returns: string - returns correlationId from context.  getCommand Returns command from Azure Function context.\n public static getCommand(context: any): string\n  context: any - the Azure Function context. returns: string - returns command from context.  getHttpRequestBody Returns body from Azure Function context http request.\n public static getHttpRequestBody(context: any): string\n  context: any - the Azure Function context. returns: string - returns body from context.  Examples class MyAzureFunctionFunction extends CommandableAzureFunction { private _controller: IMyController; ... public constructor() { base(\u0026#34;mygroup\u0026#34;, \u0026#34;MyGroup AzureFunction\u0026#34;); this._dependencyResolver.put( \u0026#34;controller\u0026#34;, new Descriptor(\u0026#34;mygroup\u0026#34;,\u0026#34;controller\u0026#34;,\u0026#34;*\u0026#34;,\u0026#34;*\u0026#34;,\u0026#34;1.0\u0026#34;) ); } } let azureFunction = new MyAzureFunctionFunction(); await service.run(); console.log(\u0026#34;MyAzureFunction is started\u0026#34;); ","description":"Abstract Azure Function function, that acts as a container to instantiate and run components and expose them via external entry point.\n","image":null,"permalink":"/node/azure/containers/commandable_azure_function/","subtitle":null,"tags":null,"title":"CommandableAzureFunction"},{"content":"Extends: AzureFunctionService\nDescription Each command is exposed as invoke method that receives command name and parameters.\nCommandable services require only 3 lines of code to implement a robust external Azure Function-based remote interface.\nThis service is intended to work inside Azure Function container that exploses registered actions externally.\nConfiguration parameters  dependencies:  controller: override for Controller dependency    References  *:logger:*:*:1.0: (optional) ILogger components to pass log messages. *:counters:*:*:1.0: (optional) ICounters components to pass collected measurements.  Constructors  public constructor(name: string)\n  name: string - a service name.  Instance methods getBody Returns body from Azure Function context.\nThis method can be overloaded in child classes.\n protected getBody(context: any): string\n  context: any - Azure Function context returns: string - Returns body from context  register Registers all actions in Azure Function.\n public register(): void\n Examples class MyCommandableAzureFunctionService extends CommandableAzureFunctionService { public constructor() { base(); this._dependencyResolver.put( \u0026#34;controller\u0026#34;, new Descriptor(\u0026#34;mygroup\u0026#34;,\u0026#34;controller\u0026#34;,\u0026#34;*\u0026#34;,\u0026#34;*\u0026#34;,\u0026#34;1.0\u0026#34;) ); } } let service = new MyCommandableAzureFunctionService(); service.setReferences(References.fromTuples( new Descriptor(\u0026#34;mygroup\u0026#34;,\u0026#34;controller\u0026#34;,\u0026#34;default\u0026#34;,\u0026#34;default\u0026#34;,\u0026#34;1.0\u0026#34;), controller )); await service.open(\u0026#34;123\u0026#34;); console.log(\u0026#34;The Azure Function service is running\u0026#34;); ","description":"Abstract service that receives commands via Azure Function protocol to operations automatically generated for commands defined in [ICommandable components](../../../commons/commands/icommandable).\n","image":null,"permalink":"/node/azure/services/commandable_azure_function_service/","subtitle":null,"tags":null,"title":"CommandableAzureFunctionService"},{"content":"Implements: GrpcClient\nDescription The CommandableGrpcClient class allows you to create clients that call a commandable GRPC service.\nImportant points\n Commandable services are generated automatically for ICommandable. Each command is exposed as an Invoke method that receives all parameters as args.  Configuration parameters  connection(s):  discovery_key: (optional) a key to retrieve the connection from IDiscovery protocol: connection protocol: http or https host: host name or IP address port: port number uri: resource URI or connection string with all parameters in it   options:  retries: number of retries (default: 3) connect_timeout: connection timeout in milliseconds (default: 10 sec) timeout: invocation timeout in milliseconds (default: 10 sec)    References  *:discovery:*:*:1.0 - (optional) IDiscovery services *:logger:*:*:1.0 - (optional) ILogger components to pass log messages *:counters:*:*:1.0 - (optional) ICounters components to pass collected measurements and specify the counter\u0026rsquo;s source.  Constructors NewCommandableGrpcClient Creates a new instance of the client.\n NewCommandableGrpcClient(name string) *CommandableGrpcClient\n  name: string - service name.  Fields Name A service name.\n Name: string\n  Instance methods CallCommand Calls a remote method via the GRPC commadable protocol. The call is made via Invoke method and all parameters are sent in args object. The complete route to remote method is defined as serviceName + \u0026lsquo;.\u0026rsquo; + name.\n (c *CommandableGrpcClient) CallCommand(prototype reflect.Type, name string, correlationId string, params *cdata.AnyValueMap) (result interface{}, err error)\n  prototype: reflect.Type - a prototype for properly convert result name: string - name of the command to call. correlationId: string - (optional) transaction id used to trace execution through the call chain. params: *cdata.AnyValueMap - command parameters. returns: (result interface{}, err error) - feature that receives the result  Examples type MyCommandableGrpcClient struct { *CommandableGrpcClient ... } func (c * MyCommandableGrpcClient) GetData(correlationId string, id string) (result *MyData, err error params := cdata.NewEmptyStringValueMap() params.Put(\u0026#34;id\u0026#34;, id) calValue, calErr := c.CallCommand(MyDataType, \u0026#34;get_mydata_by_id\u0026#34;, correlationId, params) if calErr != nil { return nil, calErr } result, _ = calValue.(*tdata.MyData) return result, err } ... client := NewMyCommandableGrpcClient(); client.Configure(cconf.NewConfigParamsFromTuples( \u0026#34;connection.protocol\u0026#34;, \u0026#34;http\u0026#34;, \u0026#34;connection.host\u0026#34;, \u0026#34;localhost\u0026#34;, \u0026#34;connection.port\u0026#34;, 8080, )); result, err := client.GetData(\u0026#34;123\u0026#34;, \u0026#34;1\u0026#34;) ... ","description":"Abstract client that calls a commandable GRPC service.\n","image":null,"permalink":"/golang/grpc/clients/commandable_grpc_client/","subtitle":null,"tags":null,"title":"CommandableGrpcClient"},{"content":"Inherits: GrpcClient\nDescription The CommandableGrpcClient class allows you to create clients that call a commandable GRPC service.\nImportant points\n Commandable services are generated automatically for ICommandable. Each command is exposed as an Invoke method that receives all parameters as args.  Configuration parameters  connection(s):  discovery_key: (optional) a key to retrieve the connection from IDiscovery protocol: connection protocol: http or https host: host name or IP address port: port number uri: resource URI or connection string with all parameters in it   options:  retries: number of retries (default: 3) connect_timeout: connection timeout in milliseconds (default: 10 sec) timeout: invocation timeout in milliseconds (default: 10 sec)    References  *:discovery:*:*:1.0 - (optional) IDiscovery services *:logger:*:*:1.0 - (optional) ILogger components to pass log messages *:counters:*:*:1.0 - (optional) ICounters components to pass collected measurements and specify the counter\u0026rsquo;s source.  Constructors Creates a new instance of the client.\n public CommandableGrpcClient(string name)\n  name: string - service name.  Creates a new instance of the client.\n public CommandableGrpcClient()\n Fields name A service name.\n protected name: string\n  Instance methods callCommand Calls a remote method via the GRPC commadable protocol. The call is made via Invoke method and all parameters are sent in args object. The complete route to remote method is defined as serviceName + \u0026lsquo;.\u0026rsquo; + name.\n public Task\u0026lt;T\u0026gt; CallCommandAsync\u0026lt;T\u0026gt;(string name, string correlationId, object requestEntity)\n  name: string - name of the command to call. correlationId: string - (optional) transaction id used to trace execution through the call chain. requestEntity: object - command parameters. returns: Task\u0026lt;T\u0026gt; - feature that receives the result  Examples class MyCommandableHttpClient: CommandableHttpClient, IMyClient { ... public MyData GetData(string correlationId, string id) { return await CallCommandAsync\u0026lt;DataPage\u0026lt;MyData\u0026gt;\u0026gt;( \u0026#34;get_data\u0026#34;, correlationId, new {mydata.id = id} ); } ... } var client = new MyCommandableHttpClient(); client.Configure(ConfigParams.FromTuples( \u0026#34;connection.protocol\u0026#34;, \u0026#34;http\u0026#34;, \u0026#34;connection.host\u0026#34;, \u0026#34;localhost\u0026#34;, \u0026#34;connection.port\u0026#34;, 8080 )); var data = client.GetData(\u0026#34;123\u0026#34;, \u0026#34;1\u0026#34;); ... ","description":"Abstract client that calls a commandable GRPC service.\n","image":null,"permalink":"/net/grpc/clients/commandable_grpc_client/","subtitle":null,"tags":null,"title":"CommandableGrpcClient"},{"content":"Extends: GrpcClient\nDescription The CommandableGrpcClient class allows you to create clients that call a commandable GRPC service.\nImportant points\n Commandable services are generated automatically for ICommandable. Each command is exposed as an Invoke method that receives all parameters as args.  Configuration parameters  connection(s):  discovery_key: (optional) a key to retrieve the connection from IDiscovery protocol: connection protocol: http or https host: host name or IP address port: port number uri: resource URI or connection string with all parameters in it   options:  retries: number of retries (default: 3) connect_timeout: connection timeout in milliseconds (default: 10 sec) timeout: invocation timeout in milliseconds (default: 10 sec)    References  *:discovery:*:*:1.0 - (optional) IDiscovery services *:logger:*:*:1.0 - (optional) ILogger components to pass log messages *:counters:*:*:1.0 - (optional) ICounters components to pass collected measurements and specify the counter\u0026rsquo;s source.  Constructors Creates a new instance of the client.\n public constructor(name: string)\n  name: string - service name.  Fields name A service name.\n protected name: string\n  Instance methods callCommand Calls a remote method via the GRPC commadable protocol. The call is made via Invoke method and all parameters are sent in args object. The complete route to remote method is defined as serviceName + \u0026lsquo;.\u0026rsquo; + name.\n protected callCommand(name: string, correlationId: string, params: any): Promise\u0026lt;any\u0026gt;\n  name: string - name of the command to call. correlationId: string - (optional) transaction id used to trace execution through the call chain. params: any - command parameters. returns: any - feature that receives the result  Examples class MyCommandableGrpcClient extends CommandableGrpcClient implements IMyClient { ... public async getData(correlationId: string, id: string): Promise\u0026lt;MyData\u0026gt; { return await this.callCommand( \u0026#34;get_data\u0026#34;, correlationId, { id: id } ); } ... } let client = new MyCommandableGrpcClient(); client.configure(ConfigParams.fromTuples( \u0026#34;connection.protocol\u0026#34;, \u0026#34;http\u0026#34;, \u0026#34;connection.host\u0026#34;, \u0026#34;localhost\u0026#34;, \u0026#34;connection.port\u0026#34;, 8080 )); let result = await client.getData(\u0026#34;123\u0026#34;, \u0026#34;1\u0026#34;); ","description":"Abstract client that calls a commandable GRPC service.\n","image":null,"permalink":"/node/grpc/clients/commandable_grpc_client/","subtitle":null,"tags":null,"title":"CommandableGrpcClient"},{"content":"Implements: GrpcClient\nDescription The CommandableGrpcClient class allows you to create clients that call a commandable GRPC service.\nImportant points\n Commandable services are generated automatically for ICommandable. Each command is exposed as an Invoke method that receives all parameters as args.  Configuration parameters  connection(s):  discovery_key: (optional) a key to retrieve the connection from IDiscovery protocol: connection protocol: http or https host: host name or IP address port: port number uri: resource URI or connection string with all parameters in it   options:  retries: number of retries (default: 3) connect_timeout: connection timeout in milliseconds (default: 10 sec) timeout: invocation timeout in milliseconds (default: 10 sec)    References  *:discovery:*:*:1.0 - (optional) IDiscovery services *:logger:*:*:1.0 - (optional) ILogger components to pass log messages *:counters:*:*:1.0 - (optional) ICounters components to pass collected measurements and specify the counter\u0026rsquo;s source.  Constructors Creates a new instance of the client.\n CommandableGrpcClient(name: str)\n  name: str - service name.  Fields _name A service name.\n _name: str\n  Instance methods call_command Calls a remote method via the GRPC commadable protocol. The call is made via Invoke method and all parameters are sent in args object. The complete route to remote method is defined as serviceName + \u0026lsquo;.\u0026rsquo; + name.\n call_command(name: str, correlation_id: Optional[str], params: Any): Any\n  name: str - name of the command to call. correlation_id: Optional[str] - (optional) transaction id used to trace execution through the call chain. params: Any - command parameters. returns: Any - feature that receives the result  Examples class MyCommandableGrpcClient(CommandableGrpcClient, IMyClient): ... def get_data(self, correlation_id, id): return self.call_command( \u0026#34;get_data\u0026#34;, correlation_id, { \u0026#39;id\u0026#39;: id } ) client = new MyCommandableGrpcClient() client.configure(ConfigParams.from_tuples( \u0026#34;connection.protocol\u0026#34;, \u0026#34;http\u0026#34;, \u0026#34;connection.host\u0026#34;, \u0026#34;localhost\u0026#34;, \u0026#34;connection.port\u0026#34;, 8080 )) result = client.get_data(\u0026#34;123\u0026#34;, \u0026#34;1\u0026#34;) ","description":"Abstract client that calls a commandable GRPC service.\n","image":null,"permalink":"/python/grpc/clients/commandable_grpc_client/","subtitle":null,"tags":null,"title":"CommandableGrpcClient"},{"content":"Implements: GrpcClient\nDescription Abstract service that receives commands via GRPC protocol to operations automatically generated for commands defined in ICommandable.\nImportant points\n Each command is exposed as an Invoke method that receives a command name and parameters. Commandable services require only 3 lines of code to implement a robust external GRPC-based remote interface.  Configuration parameters  dependencies:  endpoint: override for HTTP Endpoint dependency controller: override for Controller dependency   connection(s):  discovery_key: (optional) key to retrieve the connection from IDiscovery protocol: connection protocol: http or https host: host name or IP address port: port number uri: resource URI or connection string with all parameters in it    References  *:discovery:*:*:1.0 - (optional) IDiscovery services *:logger:*:*:1.0 - (optional) ILogger components to pass log messages *:counters:*:*:1.0 - (optional) ICounters components to pass collected measurements as specified by the counter\u0026rsquo;s source. *:endpoint:grpc:*:1.0 - (optional) GrpcEndpoint reference  Constructors InheritCommandableGrpcService Creates a new instance of the service.\n InheritCommandableGrpcService(overrides IGrpcServiceOverrides, name string) *CommandableGrpcService\n  overrides: IGrpcServiceOverrides - TODO: add description name: string - service name.  Instance methods register Registers all service routes in a gRPC endpoint.\n (c *CommandableGrpcService) Register()\n Examples type MyCommandableGrpcService struct { *CommandableGrpcService } func NewCommandableGrpcService() *CommandableGrpcService { c := DummyCommandableGrpcService{} c.CommandableGrpcService = grpcservices.NewCommandableGrpcService(\u0026#34;myservice\u0026#34;) c.DependencyResolver.Put(\u0026#34;controller\u0026#34;, cref.NewDescriptor(\u0026#34;mygroup\u0026#34;, \u0026#34;controller\u0026#34;, \u0026#34;default\u0026#34;, \u0026#34;*\u0026#34;, \u0026#34;*\u0026#34;)) return \u0026amp;c } service := NewMyCommandableGrpcService(); service.Configure(cconf.NewConfigParamsFromTuples( \u0026#34;connection.protocol\u0026#34;, \u0026#34;http\u0026#34;, \u0026#34;connection.host\u0026#34;, \u0026#34;localhost\u0026#34;, \u0026#34;connection.port\u0026#34;, \u0026#34;8080\u0026#34;, )); service.SetReferences(cref.NewReferencesFromTuples( cref.NewDescriptor(\u0026#34;mygroup\u0026#34;,\u0026#34;controller\u0026#34;,\u0026#34;default\u0026#34;,\u0026#34;default\u0026#34;,\u0026#34;1.0\u0026#34;), controller )); opnErr:= service.Open(\u0026#34;123\u0026#34;) if opnErr == nil { console.log(\u0026#34;The GRPC service is running on port 8080\u0026#34;); } See also   CommandableGrpcClient   GrpcService   ","description":"Abstract service that receives commands via the GRPC protocol.\n","image":null,"permalink":"/golang/grpc/services/commandable_grpc_service/","subtitle":null,"tags":null,"title":"CommandableGrpcService"},{"content":"Inherits: GrpcClient\nDescription Abstract service that receives commands via GRPC protocol to operations automatically generated for commands defined in ICommandable.\nImportant points\n Each command is exposed as an Invoke method that receives a command name and parameters. Commandable services require only 3 lines of code to implement a robust external GRPC-based remote interface.  Configuration parameters  dependencies:  endpoint: override for HTTP Endpoint dependency controller: override for Controller dependency   connection(s):  discovery_key: (optional) key to retrieve the connection from IDiscovery protocol: connection protocol: http or https host: host name or IP address port: port number uri: resource URI or connection string with all parameters in it    References  *:discovery:*:*:1.0 - (optional) IDiscovery services *:logger:*:*:1.0 - (optional) ILogger components to pass log messages *:counters:*:*:1.0 - (optional) ICounters components to pass collected measurements as specified by the counter\u0026rsquo;s source. *:endpoint:grpc:*:1.0 - (optional) GrpcEndpoint reference  Constructors Creates a new instance of the service.\n public CommandableGrpcService(string name = null)\n  name: string - service name.  Instance methods TODO: add description\n protected Task\u0026lt;InvokeReply\u0026gt; InvokeAsync(InvokeRequest request, ServerCallContext context)\n  request: InvokeRequest - TODO: add description context: ServerCallContext - TODO: add description  OnRegister Registers all service routes in gRPC endpoint.\n protected override void OnRegister()\n Examples class MyCommandableHttpService: CommandableHttpService { public MyCommandableHttpService() { base(); this._dependencyResolver.Put( \u0026#34;controller\u0026#34;, new Descriptor(\u0026#34;mygroup\u0026#34;, \u0026#34;controller\u0026#34;, \u0026#34;*\u0026#34;, \u0026#34;*\u0026#34;, \u0026#34;1.0\u0026#34;) ); } } var service = new MyCommandableHttpService(); service.Configure(ConfigParams.FromTuples( \u0026#34;connection.protocol\u0026#34;, \u0026#34;http\u0026#34;, \u0026#34;connection.host\u0026#34;, \u0026#34;localhost\u0026#34;, \u0026#34;connection.port\u0026#34;, 8080 )); service.SetReferences(References.FromTuples( new Descriptor(\u0026#34;mygroup\u0026#34;,\u0026#34;controller\u0026#34;,\u0026#34;default\u0026#34;,\u0026#34;default\u0026#34;,\u0026#34;1.0\u0026#34;), controller )); service.Open(\u0026#34;123\u0026#34;); Console.Out.WriteLine(\u0026#34;The REST service is running on port 8080\u0026#34;); See also   CommandableGrpcClient   GrpcService   ","description":"Abstract service that receives commands via the GRPC protocol.\n","image":null,"permalink":"/net/grpc/services/commandable_grpc_service/","subtitle":null,"tags":null,"title":"CommandableGrpcService"},{"content":"Extends: GrpcClient\nSee also CommandableGrpcClient, GrpcService\nDescription Abstract service that receives commands via GRPC protocol to operations automatically generated for commands defined in ICommandable.\nImportant points\n Each command is exposed as an Invoke method that receives a command name and parameters. Commandable services require only 3 lines of code to implement a robust external GRPC-based remote interface.  Configuration parameters  dependencies:  endpoint: override for HTTP Endpoint dependency controller: override for Controller dependency   connection(s):  discovery_key: (optional) key to retrieve the connection from IDiscovery protocol: connection protocol: http or https host: host name or IP address port: port number uri: resource URI or connection string with all parameters in it    References  *:discovery:*:*:1.0 - (optional) IDiscovery services *:logger:*:*:1.0 - (optional) ILogger components to pass log messages *:counters:*:*:1.0 - (optional) ICounters components to pass collected measurements as specified by the counter\u0026rsquo;s source. *:endpoint:grpc:*:1.0 - (optional) GrpcEndpoint reference  Constructors Creates a new instance of the service.\n public constructor(name: string)\n  name: string - service name.  Instance methods register Registers all service routes in a gRPC endpoint.\n public register()\n registerCommandableMethod Registers a commandable method in this objects GRPC server (service) by the given name.,\n protected registerCommandableMethod(method: string, schema: Schema, action: (correlationId: string, data: any) =\u0026gt; Promise\u0026lt;any\u0026gt;): void\n  method: string - the GRPC method name. schema: Schema - the schema to use for parameter validation. action: (correlationId: string, data: any) =\u0026gt; Promise\u0026lt;any\u0026gt; - the action to perform at the given route.  Examples class MyCommandableGrpcService extends CommandableGrpcService { public constructor() { base(); this._dependencyResolver.put( \u0026#34;controller\u0026#34;, new Descriptor(\u0026#34;mygroup\u0026#34;,\u0026#34;controller\u0026#34;,\u0026#34;*\u0026#34;,\u0026#34;*\u0026#34;,\u0026#34;1.0\u0026#34;) ); } } let service = new MyCommandableGrpcService(); service.configure(ConfigParams.fromTuples( \u0026#34;connection.protocol\u0026#34;, \u0026#34;http\u0026#34;, \u0026#34;connection.host\u0026#34;, \u0026#34;localhost\u0026#34;, \u0026#34;connection.port\u0026#34;, 8080 )); service.setReferences(References.fromTuples( new Descriptor(\u0026#34;mygroup\u0026#34;,\u0026#34;controller\u0026#34;,\u0026#34;default\u0026#34;,\u0026#34;default\u0026#34;,\u0026#34;1.0\u0026#34;), controller )); await service.open(\u0026#34;123\u0026#34;); console.log(\u0026#34;The GRPC service is running on port 8080\u0026#34;); See also   CommandableGrpcClient   GrpcService   ","description":"Abstract service that receives commands via the GRPC protocol.\n","image":null,"permalink":"/node/grpc/services/commandable_grpc_service/","subtitle":null,"tags":null,"title":"CommandableGrpcService"},{"content":"Implements: GrpcClient\nSee also CommandableGrpcClient, GrpcService\nDescription Abstract service that receives commands via GRPC protocol to operations automatically generated for commands defined in ICommandable.\nImportant points\n Each command is exposed as an Invoke method that receives a command name and parameters. Commandable services require only 3 lines of code to implement a robust external GRPC-based remote interface.  Configuration parameters  dependencies:  endpoint: override for HTTP Endpoint dependency controller: override for Controller dependency   connection(s):  discovery_key: (optional) key to retrieve the connection from IDiscovery protocol: connection protocol: http or https host: host name or IP address port: port number uri: resource URI or connection string with all parameters in it    References  *:discovery:*:*:1.0 - (optional) IDiscovery services *:logger:*:*:1.0 - (optional) ILogger components to pass log messages *:counters:*:*:1.0 - (optional) ICounters components to pass collected measurements as specified by the counter\u0026rsquo;s source. *:endpoint:grpc:*:1.0 - (optional) GrpcEndpoint reference  Constructors Creates a new instance of the service.\n CommandableGrpcService(name: str)\n  name: str - service name.  Instance methods register Registers all service routes in a gRPC endpoint.\n register()\n Examples class MyCommandableGrpcService(CommandableGrpcService): def __init__(self): super().__init__() self._dependency_resolver.put( \u0026#34;controller\u0026#34;, Descriptor(\u0026#34;mygroup\u0026#34;,\u0026#34;controller\u0026#34;,\u0026#34;*\u0026#34;,\u0026#34;*\u0026#34;,\u0026#34;1.0\u0026#34;) ) service = MyCommandableGrpcService() service.configure(ConfigParams.from_tuples( \u0026#34;connection.protocol\u0026#34;, \u0026#34;http\u0026#34;, \u0026#34;connection.host\u0026#34;, \u0026#34;localhost\u0026#34;, \u0026#34;connection.port\u0026#34;, 8080 )) service.set_references(References.from_tuples( Descriptor(\u0026#34;mygroup\u0026#34;,\u0026#34;controller\u0026#34;,\u0026#34;default\u0026#34;,\u0026#34;default\u0026#34;,\u0026#34;1.0\u0026#34;), controller )) service.open(\u0026#34;123\u0026#34;) See also   CommandableGrpcClient   GrpcService   ","description":"Abstract service that receives commands via the GRPC protocol.\n","image":null,"permalink":"/python/grpc/services/commandable_grpc_service/","subtitle":null,"tags":null,"title":"CommandableGrpcService"},{"content":"Implements: RestClient\nDescription The CommandableHttpClient class allows you to create commandable services. Commandable services are generated automatically for ICommandable objects.\nImportant points\n Each command is exposed as a POST operation that receives all parameters in the body object.  Configuration parameters   base_route: base route for a remote URI\n  connection(s):\n discovery_key: (optional) key to retrieve the connection from IDiscovery protocol: connection protocol (http or https) host: host name or IP address port: port number uri: resource URI or connection string with all parameters in it    options:\n retries: number of retries (default: 3) connect_timeout: connection timeout in milliseconds (default: 10 sec) timeout: invocation timeout in milliseconds (default: 10 sec)    References  *:logger:*:*:1.0 - (optional) ILogger components to pass log messages *:counters:*:*:1.0 - (optional) ICounters components to pass collected measurements *:traces:*:*:1.0 - (optional) ITracer components to record traces *:discovery:*:*:1.0 - (optional) IDiscovery services to resolve a connection  Constructors Creates a new instance of the client.\n NewCommandableHttpClient(baseRoute string) *CommandableHttpClient\n  baseRoute: string - base route for a remote service.  Methods CallCommand Calls a remote method via the HTTP commadable protocol. The call is made via a POST operation and all parameters are sent in the body object. The complete route to the remote method is defined as baseRoute + \u0026ldquo;/\u0026rdquo; + name.\n (c *CommandableHttpClient) CallCommand(prototype reflect.Type, name string, correlationId string, params *cdata.AnyValueMap) (result interface{}, err error)\n  prototype: reflect.Type - type of returned data name: string - name of the command to call. correlationId: string - (optional) transaction id used to trace execution through a call chain. params: *cdata.AnyValueMap - command parameters. returns: (result interface{}, err error) - result of the command.  Examples type MyCommandableHttpClient struct{ *CommandableHttpClient prototype reflect.Type // type of operation data  ... } result, err := func (c * MyCommandableHttpClient) GetData(correlationId string, id string)(result MyData, err error){ params:= cdata.NewEmptyStringValueMap() params.Set(\u0026#34;id\u0026#34;,id) res, err := c.CallCommand( prototype \u0026#34;get_data\u0026#34;, correlationId, params) ... // convert response to MyData  ... return result, err } client = NewMyCommandableHttpClient(); client.Configure(cconf.NewConfigParamsFromTuples( \u0026#34;connection.protocol\u0026#34;, \u0026#34;http\u0026#34;, \u0026#34;connection.host\u0026#34;, \u0026#34;localhost\u0026#34;, \u0026#34;connection.port\u0026#34;, 8080 )); result, err := client.GetData(\u0026#34;123\u0026#34;, \u0026#34;1\u0026#34;) ... ","description":"Commandable services are generated automatically for [ICommandable](../../../commons/commands/icommandable)\n","image":null,"permalink":"/golang/rpc/clients/commandable_http_client/","subtitle":null,"tags":null,"title":"CommandableHttpClient"},{"content":"Inherits: RestClient\nDescription The CommandableHttpClient class allows you to create commandable services. Commandable services are generated automatically for ICommandable objects.\nImportant points\n Each command is exposed as a POST operation that receives all parameters in the body object.  Configuration parameters  base_route: base route for a remote URI connection(s):  discovery_key: (optional) key to retrieve the connection from IDiscovery protocol: connection protocol (http or https) host: host name or IP address port: port number uri: resource URI or connection string with all parameters in it   options:  retries: number of retries (default: 3) connect_timeout: connection timeout in milliseconds (default: 10 sec) timeout: invocation timeout in milliseconds (default: 10 sec)    References  *:logger:*:*:1.0 - (optional) ILogger components to pass log messages *:counters:*:*:1.0 - (optional) ICounters components to pass collected measurements *:traces:*:*:1.0 - (optional) ITracer components to record traces *:discovery:*:*:1.0 - (optional) IDiscovery services to resolve a connection  Constructors Creates a new instance of the client.\n public CommandableHttpClient(string baseRoute)\n  baseRoute: string - base route for a remote service.  Instance methods CallCommand Calls a remote method via the HTTP commadable protocol. The call is made via a POST operation and all parameters are sent in the body object. The complete route to the remote method is defined as baseRoute + \u0026ldquo;/\u0026rdquo; + name.\n protected Task\u0026lt;T\u0026gt; CallCommandAsync\u0026lt;T\u0026gt;(string route, string correlationId, object requestEntity)\n  route: string - a name of the command to call. correlationId: string - (optional) transaction id used to trace execution through a call chain. requestEntity: object - body object. returns: Task\u0026lt;T\u0026gt; - result of the command.  Examples class MyCommandableHttpClient: CommandableHttpClient, IMyClient { ... public MyData GetData(string correlationId, string id) { return await CallCommandAsync\u0026lt;DataPage\u0026lt;MyData\u0026gt;\u0026gt;( \u0026#34;get_data\u0026#34;, correlationId, new {mydata.id = id} ); } ... } var client = new MyCommandableHttpClient(); client.Configure(ConfigParams.fromTuples( \u0026#34;connection.protocol\u0026#34;, \u0026#34;http\u0026#34;, \u0026#34;connection.host\u0026#34;, \u0026#34;localhost\u0026#34;, \u0026#34;connection.port\u0026#34;, 8080 )); var data = client.GetData(\u0026#34;123\u0026#34;, \u0026#34;1\u0026#34;); ... ","description":"Commandable services are generated automatically for [ICommandable](../../../commons/commands/icommandable)\n","image":null,"permalink":"/net/rpc/clients/commandable_http_client/","subtitle":null,"tags":null,"title":"CommandableHttpClient"},{"content":"Extends: RestClient\nDescription The CommandableHttpClient class allows you to create commandable services. Commandable services are generated automatically for ICommandable objects.\nImportant points\n Each command is exposed as a POST operation that receives all parameters in the body object.  Configuration parameters  base_route: base route for a remote URI connection(s):  discovery_key: (optional) key to retrieve the connection from IDiscovery protocol: connection protocol (http or https) host: host name or IP address port: port number uri: resource URI or connection string with all parameters in it   options:  retries: number of retries (default: 3) connect_timeout: connection timeout in milliseconds (default: 10 sec) timeout: invocation timeout in milliseconds (default: 10 sec)    References  *:logger:*:*:1.0 - (optional) ILogger components to pass log messages *:counters:*:*:1.0 - (optional) ICounters components to pass collected measurements *:traces:*:*:1.0 - (optional) ITracer components to record traces *:discovery:*:*:1.0 - (optional) IDiscovery services to resolve a connection  Constructors Creates a new instance of the client.\n public constructor(baseRoute: string)\n  baseRoute: string - base route for a remote service.  Instance methods callCommand Calls a remote method via the HTTP commadable protocol. The call is made via a POST operation and all parameters are sent in the body object. The complete route to the remote method is defined as baseRoute + \u0026ldquo;/\u0026rdquo; + name.\n protected callCommand\u0026lt;T\u0026gt;(name: string, correlationId: string, params: any): Promise\u0026lt;T\u0026gt;\n  name: string - name of the command to call. correlationId: string - (optional) transaction id used to trace execution through a call chain. params: any - command parameters. returns: Promise\u0026lt;T\u0026gt; - result of the command.  Examples class MyCommandableHttpClient extends CommandableHttpClient implements IMyClient { ... public async getData(correlationId: string, id: string): Promise\u0026lt;MyData\u0026gt; { return await this.callCommand( \u0026#34;get_data\u0026#34;, correlationId, { id: id } ); } ... } let client = new MyCommandableHttpClient(); client.configure(ConfigParams.fromTuples( \u0026#34;connection.protocol\u0026#34;, \u0026#34;http\u0026#34;, \u0026#34;connection.host\u0026#34;, \u0026#34;localhost\u0026#34;, \u0026#34;connection.port\u0026#34;, 8080 )); let result = await client.getData(\u0026#34;123\u0026#34;, \u0026#34;1\u0026#34;); ... ","description":"Commandable services are generated automatically for [ICommandable](../../../commons/commands/icommandable)\n","image":null,"permalink":"/node/rpc/clients/commandable_http_client/","subtitle":null,"tags":null,"title":"CommandableHttpClient"},{"content":"Implements: RestClient\nDescription The CommandableHttpClient class allows you to create commandable services. Commandable services are generated automatically for ICommandable objects.\nImportant points\n Each command is exposed as a POST operation that receives all parameters in the body object.  Configuration parameters  base_route: base route for a remote URI connection(s):  discovery_key: (optional) key to retrieve the connection from IDiscovery protocol: connection protocol (http or https) host: host name or IP address port: port number uri: resource URI or connection string with all parameters in it   options:  retries: number of retries (default: 3) connect_timeout: connection timeout in milliseconds (default: 10 sec) timeout: invocation timeout in milliseconds (default: 10 sec)    References  *:logger:*:*:1.0 - (optional) ILogger components to pass log messages *:counters:*:*:1.0 - (optional) ICounters components to pass collected measurements *:traces:*:*:1.0 - (optional) ITracer components to record traces *:discovery:*:*:1.0 - (optional) IDiscovery services to resolve a connection  Constructors Creates a new instance of the client.\n CommandableHttpClient(base_route: str)\n  base_route: str - base route for a remote service.  Instance methods call_command Calls a remote method via the HTTP commadable protocol. The call is made via a POST operation and all parameters are sent in the body object. The complete route to the remote method is defined as baseRoute + \u0026ldquo;/\u0026rdquo; + name.\n call_command(name: str, correlation_id: Optional[str], params: Any): Any\n  name: str - name of the command to call. correlation_id: Optional[str] - (optional) transaction id used to trace execution through a call chain. params: Any - command parameters. returns: Any - result of the command.  Examples class MyCommandableHttpClient(CommandableHttpClient, IMyClient): # ... def get_data(self, correlation_id, id): return self.call_command(\u0026#34;get_data\u0026#34;, correlation_id, MyData(id)) # ... client = MyCommandableHttpClient() client.configure(ConfigParams.from_tuples(\u0026#34;connection.protocol\u0026#34;, \u0026#34;http\u0026#34;, \u0026#34;connection.host\u0026#34;, \u0026#34;localhost\u0026#34;, \u0026#34;connection.port\u0026#34;, 8080)) data = client.getData(\u0026#34;123\u0026#34;, \u0026#34;1\u0026#34;) # ... ","description":"Commandable services are generated automatically for [ICommandable](../../../commons/commands/icommandable)\n","image":null,"permalink":"/python/rpc/clients/commandable_http_client/","subtitle":null,"tags":null,"title":"CommandableHttpClient"},{"content":"Implements: RestService\nDescription The CommandableHttpService class allows you to create services that receive remote calls via the HTTP/REST protocol to operations automatically generated for commands defined in ICommandable components.\nImportant points\n Each command is exposed as POST operation that receives all parameters in the body object. Commandable services require only three lines of code to implement a robust external HTTP-based remote interface.  Configuration parameters  base_route: base route for remote URI dependencies:  endpoint: override for HTTP Endpoint dependency controller: override for Controller dependency   connection(s):  discovery_key: (optional) a key to retrieve the connection from IDiscovery protocol: connection protocol: http or https host: host name or IP address port: port number uri: resource URI or connection string with all parameters in it    References  *:logger:*:*:1.0 - (optional) ILogger components to pass log messages *:counters:*:*:1.0 - (optional) ICounters components to pass collected measurements *:traces:*:*:1.0 - (optional) ITracer components to record traces *:discovery:*:*:1.0 - (optional) IDiscovery services to resolve connection  Constructors InheritCommandableHttpService Creates a new instance of the service.\n InheritCommandableHttpService(overrides IRestServiceOverrides, baseRoute string) *CommandableHttpService\n  overrides: IRestServiceOverrides - references to child class that overrides virtual methods. baseRoute: string - a service base route.  Fields commandSet Set of commands.\n commandSet: CommandSet\n SwaggerAuto Boolean variable that defines whether the configuration of Swagger is autogenerated or not.\n SwaggerAuto: bool = True\n  Methods Configure Configures a component by passing configuration parameters.\n (c *CommandableHttpService) Configure(config *cconf.ConfigParams)\n  config: *cconf.ConfigParams - configuration parameters to be set.  Register Registers all service routes in the HTTP endpoint.\n (c *CommandableHttpService) Register()\n Examples type MyCommandableHttpService struct { *CommandableHttpService } func NewMyCommandableHttpService() *MyCommandableHttpService { c := MyCommandableHttpService{ CommandableHttpService: services.NewCommandableHttpService(\u0026#34;dummies\u0026#34;), } c.DependencyResolver.Put(\u0026#34;controller\u0026#34;, cref.NewDescriptor(\u0026#34;pip-services-dummies\u0026#34;, \u0026#34;controller\u0026#34;, \u0026#34;default\u0026#34;, \u0026#34;*\u0026#34;, \u0026#34;*\u0026#34;)) return \u0026amp;c service := NewMyCommandableHttpService(); service.Configure(cconf.NewConfigParamsFromTuples( \u0026#34;connection.protocol\u0026#34;, \u0026#34;http\u0026#34;, \u0026#34;connection.host\u0026#34;, \u0026#34;localhost\u0026#34;, \u0026#34;connection.port\u0026#34;, 8080, )); service.SetReferences(cref.NewReferencesFromTuples( cref.NewDescriptor(\u0026#34;mygroup\u0026#34;,\u0026#34;controller\u0026#34;,\u0026#34;default\u0026#34;,\u0026#34;default\u0026#34;,\u0026#34;1.0\u0026#34;), controller )); opnErr:=service.Open(\u0026#34;123\u0026#34;) if opnErr == nil { fmt.Println(\u0026#34;The REST service is running on port 8080\u0026#34;); } See also   RestService   CommandableHttpClient   ","description":"Abstract service that receives remote calls via HTTP/REST protocol to operations automatically generated for commands defined in ICommandable components. \n","image":null,"permalink":"/golang/rpc/services/commandable_http_service/","subtitle":null,"tags":null,"title":"CommandableHttpService"},{"content":"Extends: RestService\nSee also RestService, CommandableHttpClient\nDescription The CommandableHttpService class allows you to create services that receive remote calls via the HTTP/REST protocol to operations automatically generated for commands defined in ICommandable components.\nImportant points\n Each command is exposed as POST operation that receives all parameters in the body object. Commandable services require only three lines of code to implement a robust external HTTP-based remote interface.  Configuration parameters  base_route: base route for remote URI dependencies:  endpoint: override for HTTP Endpoint dependency controller: override for Controller dependency   connection(s):  discovery_key: (optional) a key to retrieve the connection from IDiscovery protocol: connection protocol: http or https host: host name or IP address port: port number uri: resource URI or connection string with all parameters in it    References  *:logger:*:*:1.0 - (optional) ILogger components to pass log messages *:counters:*:*:1.0 - (optional) ICounters components to pass collected measurements *:traces:*:*:1.0 - (optional) ITracer components to record traces *:discovery:*:*:1.0 - (optional) IDiscovery services to resolve connection  Constructors Creates a new instance of the service.\n public CommandableHttpService(baseRoute: string)\n  baseRoute: string - a service base route.  Fields _swaggerAuto Boolean variable that defines whether the configuration of Swagger is autogenerated or not.\n protected _swaggerAuto: bool = True\n  Instance methods Configure Configures a component by passing configuration parameters.\n public override void Configure(ConfigParams config)\n  config: ConfigParams - configuration parameters to be set.  Register Registers all service routes in the HTTP endpoint.\n public override void Register()\n Examples class MyCommandableHttpService: CommandableHttpService { public MyCommandableHttpService() { base(); this._dependencyResolver.put( \u0026#34;controller\u0026#34;, new Descriptor(\u0026#34;mygroup\u0026#34;, \u0026#34;controller\u0026#34;, \u0026#34;*\u0026#34;, \u0026#34;*\u0026#34;, \u0026#34;1.0\u0026#34;) ); } } var service = new MyCommandableHttpService(); service.Configure(ConfigParams.FromTuples( \u0026#34;connection.protocol\u0026#34;, \u0026#34;http\u0026#34;, \u0026#34;connection.host\u0026#34;, \u0026#34;localhost\u0026#34;, \u0026#34;connection.port\u0026#34;, 8080 )); service.SetReferences(References.fromTuples( new Descriptor(\u0026#34;mygroup\u0026#34;,\u0026#34;controller\u0026#34;,\u0026#34;default\u0026#34;,\u0026#34;default\u0026#34;,\u0026#34;1.0\u0026#34;), controller ) ); service.Open(\u0026#34;123\u0026#34;); Console.Out.WriteLine(\u0026#34;The REST service is running on port 8080\u0026#34;); See also   RestService   CommandableHttpClient   ","description":"Abstract service that receives remote calls via HTTP/REST protocol to operations automatically generated for commands defined in ICommandable components. \n","image":null,"permalink":"/net/rpc/services/commandable_http_service/","subtitle":null,"tags":null,"title":"CommandableHttpService"},{"content":"Extends: RestService\nSee also RestService, CommandableHttpClient\nDescription The CommandableHttpService class allows you to create services that receive remote calls via the HTTP/REST protocol to operations automatically generated for commands defined in ICommandable components.\nImportant points\n Each command is exposed as POST operation that receives all parameters in the body object. Commandable services require only three lines of code to implement a robust external HTTP-based remote interface.  Configuration parameters  base_route: base route for remote URI dependencies:  endpoint: override for HTTP Endpoint dependency controller: override for Controller dependency   connection(s):  discovery_key: (optional) a key to retrieve the connection from IDiscovery protocol: connection protocol: http or https host: host name or IP address port: port number uri: resource URI or connection string with all parameters in it    References  *:logger:*:*:1.0 - (optional) ILogger components to pass log messages *:counters:*:*:1.0 - (optional) ICounters components to pass collected measurements *:traces:*:*:1.0 - (optional) ITracer components to record traces *:discovery:*:*:1.0 - (optional) IDiscovery services to resolve connection  Constructors Creates a new instance of the service.\n public constructor(baseRoute: string)\n  baseRoute: string - a service base route.  Fields _commandSet Set of commands.\n protected _commandSet: CommandSet\n _swaggerAuto Boolean variable that defines whether the configuration of Swagger is autogenerated or not.\n protected _swaggerAuto: boolean = True\n  Instance methods configure Configures a component by passing configuration parameters.\n public configure(config: ConfigParams): void\n  config: ConfigParams - configuration parameters to be set.  register Registers all service routes in the HTTP endpoint.\n public register(): void\n Examples class MyCommandableHttpService extends CommandableHttpService { public constructor() { base(); this._dependencyResolver.put( \u0026#34;controller\u0026#34;, new Descriptor(\u0026#34;mygroup\u0026#34;,\u0026#34;controller\u0026#34;,\u0026#34;*\u0026#34;,\u0026#34;*\u0026#34;,\u0026#34;1.0\u0026#34;) ); } } let service = new MyCommandableHttpService(); service.configure(ConfigParams.fromTuples( \u0026#34;connection.protocol\u0026#34;, \u0026#34;http\u0026#34;, \u0026#34;connection.host\u0026#34;, \u0026#34;localhost\u0026#34;, \u0026#34;connection.port\u0026#34;, 8080 )); service.setReferences(References.fromTuples( new Descriptor(\u0026#34;mygroup\u0026#34;,\u0026#34;controller\u0026#34;,\u0026#34;default\u0026#34;,\u0026#34;default\u0026#34;,\u0026#34;1.0\u0026#34;), controller )); await service.open(\u0026#34;123\u0026#34;); console.log(\u0026#34;The REST service is running on port 8080\u0026#34;); See also   RestService   CommandableHttpClient   ","description":"Abstract service that receives remote calls via HTTP/REST protocol to operations automatically generated for commands defined in ICommandable components. \n","image":null,"permalink":"/node/rpc/services/commandable_http_service/","subtitle":null,"tags":null,"title":"CommandableHttpService"},{"content":"Implements: RestService\nSee also RestService, CommandableHttpClient\nDescription The CommandableHttpService class allows you to create services that receive remote calls via the HTTP/REST protocol to operations automatically generated for commands defined in ICommandable components.\nImportant points\n Each command is exposed as POST operation that receives all parameters in the body object. Commandable services require only three lines of code to implement a robust external HTTP-based remote interface.  Configuration parameters  base_route: base route for remote URI dependencies:  endpoint: override for HTTP Endpoint dependency controller: override for Controller dependency   connection(s):  discovery_key: (optional) a key to retrieve the connection from IDiscovery protocol: connection protocol: http or https host: host name or IP address port: port number uri: resource URI or connection string with all parameters in it    References  *:logger:*:*:1.0 - (optional) ILogger components to pass log messages *:counters:*:*:1.0 - (optional) ICounters components to pass collected measurements *:traces:*:*:1.0 - (optional) ITracer components to record traces *:discovery:*:*:1.0 - (optional) IDiscovery services to resolve connection  Constructors Creates a new instance of the service.\n CommandableHttpService(base_route: str)\n  base_route: str - a service base route.  Fields _connection_resolver Create connection resolver.\n _connection_resolver: ConnectionResolver = ConnectionResolver()\n _command_set Set of commands.\n _command_set: CommandSet\n _swagger_auto Boolean variable that defines whether the configuration of Swagger is autogenerated or not.\n _swagger_auto: bool = True\n _base_route Base route for a remote URI\n _base_route: str\n  Instance methods configure Configures a component by passing configuration parameters.\n configure(config: ConfigParams)\n  config: ConfigParams - configuration parameters to be set.  register Registers all service routes in the HTTP endpoint.\n register()\n Examples class MyCommandableHttpService(CommandableHttpService): def __init__(self): super(MyCommandableHttpService, self).__init__() self._dependencyResolver.put(\u0026#34;controller\u0026#34;, Descriptor(\u0026#34;mygroup\u0026#34;,\u0026#34;controller\u0026#34;,\u0026#34;*\u0026#34;,\u0026#34;*\u0026#34;,\u0026#34;1.0\u0026#34;)) # ... service = MyCommandableHttpService() service.configure(ConfigParams.from_tuples(\u0026#34;connection.protocol\u0026#34;, \u0026#34;http\u0026#34;, \u0026#34;connection.host\u0026#34;, \u0026#34;localhost\u0026#34;, \u0026#34;connection.port\u0026#34;, 8080)) service.set_references(References.from_tuples(Descriptor(\u0026#34;mygroup\u0026#34;,\u0026#34;controller\u0026#34;,\u0026#34;default\u0026#34;,\u0026#34;default\u0026#34;,\u0026#34;1.0\u0026#34;), controller)) service.open(\u0026#34;123\u0026#34;) # ... See also   RestService   CommandableHttpClient   ","description":"Abstract service that receives remote calls via HTTP/REST protocol to operations automatically generated for commands defined in ICommandable components. \n","image":null,"permalink":"/python/rpc/services/commandable_http_service/","subtitle":null,"tags":null,"title":"CommandableHttpService"},{"content":"Extends: LambdaClient\nDescription Commandable services are generated automatically for ICommandable. Each command is exposed as action determined by \u0026ldquo;cmd\u0026rdquo; parameter.\nConfiguration parameters  connections:  discovery_key: (optional) a key to retrieve the connection from IDiscovery region: (optional) AWS region   credentials:  store_key: (optional) a key to retrieve the credentials from ICredentialStore access_id: AWS access/client id access_key: AWS access/client id    References  *:logger:*:*:1.0: (optional) ILogger components to pass log messages. *:counters:*:*:1.0: (optional) ICounters components to pass collected measurements. *:discovery:*:*:1.0: (optional) IDiscovery services to resolve connection. *:credential-store:*:*:1.0: (optional) Credential stores to resolve credentials.  Constructors Creates a new instance of this client.\n public constructor(name: string)\n  name: string - a service name.  Instance methods callCommand Calls a remote action in AWS Lambda function. The name of the action is added as \u0026ldquo;cmd\u0026rdquo; parameter to the action parameters.\n public callCommand(cmd: string, correlationId: string, params: any): Promise\u0026lt;any\u0026gt;\n  cmd: string - an action name correlationId: string - (optional) transaction id to trace execution through call chain. params: any - command parameters. returns: Promise\u0026lt;any\u0026gt; - action result.  Examples class MyLambdaClient extends CommandableLambdaClient implements IMyClient { ... public async getData(correlationId: string, id: string): Promise\u0026lt;any\u0026gt; { return this.callCommand(\u0026#34;get_data\u0026#34;, correlationId, { id: id }); } ... } let client = new MyLambdaClient(); client.configure(ConfigParams.fromTuples( \u0026#34;connection.region\u0026#34;, \u0026#34;us-east-1\u0026#34;, \u0026#34;connection.access_id\u0026#34;, \u0026#34;XXXXXXXXXXX\u0026#34;, \u0026#34;connection.access_key\u0026#34;, \u0026#34;XXXXXXXXXXX\u0026#34;, \u0026#34;connection.arn\u0026#34;, \u0026#34;YYYYYYYYYYYYY\u0026#34; )); const result = await client.getData(\u0026#34;123\u0026#34;, \u0026#34;1\u0026#34;); ... See also   LambdaFunction   ","description":"Abstract client that calls commandable AWS Lambda Functions.\n","image":null,"permalink":"/node/aws/clients/commandable_lambda_client/","subtitle":null,"tags":null,"title":"CommandableLambdaClient"},{"content":"Extends: LambdaFunction\nDescription The CommandableLambdaFunction class allows you to create AWS Lambda function that acts as a container to instantiate and run components and expose them via external entry point.\nImportant points\n  All actions are automatically generated for commands defined in ICommandable components. Each command is exposed as an action defined by \u0026ldquo;cmd\u0026rdquo; parameter.\n  Container configuration for this Lambda function is stored in \u0026quot;./config/config.yml\u0026quot; file. But this path can be overriden by CONFIG_PATH environment variable.\n  Note: This component has been deprecated. Use LambdaService instead.\n  References  *:logger:*:*:1.0: (optional) ILogger components to pass log messages. *:counters:*:*:1.0: (optional) ICounters components to pass collected measurements. *:service:lambda:*:1.0: (optional) ILambdaService services to handle action requests *:service:commandable-lambda:*:1.0: (optional) ILambdaService services to handle action requests  Constructors Creates a new instance of this lambda function.\n public constructor(name: string, description?: string)\n  name: string - (optional) container name (accessible via ContextInfo). description: string - (optional) container description (accessible via ContextInfo).  Instance methods register Registers all actions in this lambda function.\n public register(): void\n Examples class MyLambdaFunction extends CommandableLambdaFunction { private _controller: IMyController; ... public constructor() { base(\u0026#34;mygroup\u0026#34;, \u0026#34;MyGroup lambda function\u0026#34;); this._dependencyResolver.put( \u0026#34;controller\u0026#34;, new Descriptor(\u0026#34;mygroup\u0026#34;,\u0026#34;controller\u0026#34;,\u0026#34;*\u0026#34;,\u0026#34;*\u0026#34;,\u0026#34;1.0\u0026#34;) ); } } let lambda = new MyLambdaFunction(); * await service.run(); console.log(\u0026#34;MyLambdaFunction is started\u0026#34;); See also   LambdaClient   ","description":"Abstract AWS Lambda function that acts as a container to instantiate and run components and expose them via external entry point.\n","image":null,"permalink":"/node/aws/containers/commandable_lambda_function/","subtitle":null,"tags":null,"title":"CommandableLambdaFunction"},{"content":"Extends: LambdaService\nDescription Commandable services require only 3 lines of code to implement a robust external Lambda-based remote interface.\nThis service is intended to work inside a LambdaFunction container that exploses registered actions externally.\nConfiguration parameters  dependencies:  controller: override for Controller dependency    References  *:logger:*:*:1.0: (optional) ILogger components to pass log messages. *:counters:*:*:1.0: (optional) ICounters components to pass collected measurements.  Constructors Creates a new instance of the service.\n public constructor(name: string)\n  name: string - service name.  Instance methods register Registers all actions in AWS Lambda function.\n public register(): void\n Examples class MyCommandableLambdaService extends CommandableLambdaService { public constructor() { base(); this._dependencyResolver.put( \u0026#34;controller\u0026#34;, new Descriptor(\u0026#34;mygroup\u0026#34;,\u0026#34;controller\u0026#34;,\u0026#34;*\u0026#34;,\u0026#34;*\u0026#34;,\u0026#34;1.0\u0026#34;) ); } } let service = new MyCommandableLambdaService(); service.setReferences(References.fromTuples( new Descriptor(\u0026#34;mygroup\u0026#34;,\u0026#34;controller\u0026#34;,\u0026#34;default\u0026#34;,\u0026#34;default\u0026#34;,\u0026#34;1.0\u0026#34;), controller )); await service.open(\u0026#34;123\u0026#34;); console.log(\u0026#34;The AWS Lambda service is running\u0026#34;); See also   CommandableLambdaClient   LambdaService   ","description":"Abstract service that receives commands via AWS Lambda protocol to operations automatically generated for commands defined in [ICommandable components](../../../commons/commands/icommandable). Each command is exposed as an invoke method that receives command name and parameters.\n","image":null,"permalink":"/node/aws/services/commandable_lambda_service/","subtitle":null,"tags":null,"title":"CommandableLambdaService"},{"content":"Description The CommandableSwaggerDocument class allows you to generate Swagger code that describes created REST API methods and their parameters.\nConstructors NewCommandableSwaggerDocument Creates a new instance of the service.\n NewCommandableSwaggerDocument(baseRoute string, config *cconf.ConfigParams, commands []ccomands.ICommand) *CommandableSwaggerDocument\n  baseRoute: string - base route of the service config: *cconf.ConfigParams - configuration parameters commands: []ccomands.ICommand - list of commmands.  Fields Commands List of commmands.\n Commands: []ICommand[]\n Version Version number.\n Version: string\n BaseRoute Base route.\n BaseRoute: string\n InfoTitle Title.\n InfoTitle: string\n InfoDescription API description\n InfoDescription: string\n InfoVersion API version\n InfoVersion: string\n InfoTermsOfService Terms of service information.\n InfoTermsOfService: string\n InfoContactName Contact name.\n InfoContactName: string\n InfoContactUrl Contact URL.\n InfoContactUrl: string\n InfoContactEmail Contact email.\n InfoContactEmail: string\n InfoLicenseName License name.\n InfoLicenseName: string\n InfoLicenseUrl License information URL.\n InfoLicenseUrl: string\n  Methods GetCorrelationId GetCorrelationId method returns CorrelationId from request\n (c *HttpEndpoint) GetCorrelationId(req *http.Request) string\n  req: *http.Request - an HTTP request returns: string - correlation_id or empty string  GetSpaces Returns a string with spaces.\n (c *CommandableSwaggerDocument) GetSpaces(length int) string\n  length: int - determines the length of the string with spaces. returns: string - string containing spaces.  ToString Returns string with Swagger code that describe service methods.\n (c *CommandableSwaggerDocument) ToString() string\n  returns: string - string with the API information.  typeToString Returns a string with the type name.\n (c *CommandableSwaggerDocument) typeToString(tp cconv.TypeCode) string\n  tp: cconv.TypeCode - type (e.g. Integer) returns: string - name of the type (e.g. \u0026lsquo;integer\u0026rsquo;)  writeArrayItem Writes an array item to Swagger code.\n (c *CommandableSwaggerDocument) writeArrayItem(indent int, name string, isObjectItem bool)\n  indent: int - number of spaces name: string - item\u0026rsquo;s name isObjectItem: bool - True is the item is an object. false otherwise.  writeAsObject Adds a property and its value.\n (c *CommandableSwaggerDocument) writeAsObject(indent int, name string, value interface{})\n  indent: int - number of spaces name: string - name of the property value: interface{} - value of the property  writeAsString Adds a string property and its string value.\n (c *CommandableSwaggerDocument) writeAsString(indent int, name string, value interface{})\n  indent: int - number of spaces name: string - name of the property value: string - value of the property  WriteData Adds data to the Swagger code.\n (c *CommandableSwaggerDocument) WriteData(indent int, data map[string]interface{})\n  indent: int - number of spaces name: string - name data: map[string]interface{} - data to be added  WriteName Write a property or object name.\n (c *CommandableSwaggerDocument) WriteName(indent int, name string)\n  indent: int - number of spaces name: string - string with added identation  ","description":"Class used to generate Swagger code that describes created REST API methods and their parameters. \n","image":null,"permalink":"/golang/rpc/services/commandable_swagger_document/","subtitle":null,"tags":null,"title":"CommandableSwaggerDocument"},{"content":"Description The CommandableSwaggerDocument class allows you to generate Swagger code that describes created REST API methods and their parameters.\nConstructors Creates a new instance of the service.\n public CommandableSwaggerDocument(string baseRoute, ConfigParams config, List\u0026lt;ICommand\u0026gt; commands)\n  baseRoute: string - base route of the service config: ConfigParams - configuration parameters commands: List\u0026lt;ICommand\u0026gt; - list of commmands.  Properties Commands List of commmands.\n public List\u0026lt;ICommand\u0026gt; Commands { get; set; }\n Version Version number.\n public string Version { get; set; } = \u0026ldquo;3.0.2\u0026rdquo;\n BaseRoute Base route.\n public string BaseRoute { get; set; }\n InfoTitle Title.\n public string InfoTitle { get; set; }\n InfoDescription API description\n public string InfoDescription { get; set; }\n InfoVersion API version\n public string InfoVersion { get; set; } = \u0026ldquo;1\u0026rdquo;\n InfoTermsOfService Terms of service information.\n public string InfoTermsOfService { get; set; }\n InfoContactName Contact name.\n public string InfoContactName { get; set; }\n InfoContactUrl Contact URL.\n public string InfoContactUrl { get; set; }\n InfoContactEmail Contact email.\n public string InfoContactEmail { get; set; }\n InfoLicenseName License name.\n public string InfoLicenseName { get; set; }\n InfoLicenseUrl License information URL.\n public string InfoLicenseUrl { get; set; }\n Instance methods GetSpaces Returns a string with spaces.\n protected string GetSpaces(int length)\n  length: int - determines the length of the string with spaces. returns: string - string containing spaces.  ToString Returns string with Swagger code that describe service methods.\n public override string ToString()\n  returns: string - string with the API information.  WriteArrayItem Writes an array item to Swagger code.\n protected void WriteArrayItem(int indent, string name, bool isObjectItem = false)\n  indent: int - number of spaces name: string - item\u0026rsquo;s name isObjectItem: bool - True is the item is an object. false otherwise.  WriteAsObject Adds a property and its value.\n protected void WriteAsObject(int indent, string name, object value)\n  indent: int - number of spaces name: string - name of the property value: object - value of the property  WriteAsString Adds a string property and its string value.\n protected void WriteAsString(int indent, string name, string value)\n  indent: int - number of spaces name: string - name of the property value: string - value of the property  WriteData Adds data to the Swagger code.\n protected void WriteData(int indent, Dictionary\u0026lt;string, object\u0026gt; data)\n  indent: int - number of spaces name: string - name data: Dictionary\u0026lt;string, object\u0026gt; - data to be added  WriteName Write a property or object name.\n protected void WriteName(int indent, string name)\n  indent: int - number of spaces name: string - string with added identation  ","description":"Class used to generate Swagger code that describes created REST API methods and their parameters. \n","image":null,"permalink":"/net/rpc/services/commandable_swagger_document/","subtitle":null,"tags":null,"title":"CommandableSwaggerDocument"},{"content":"Description The CommandableSwaggerDocument class allows you to generate Swagger code that describes created REST API methods and their parameters.\nConstructors Creates a new instance of the service.\n public constructor(baseRoute: string, config: ConfigParams, commands: ICommand[])\n  baseRoute: string - base route of the service config: ConfigParams - configuration parameters commands: ICommand[] - list of commmands.  Fields commands List of commmands.\n commands: ICommand[]\n version Version number.\n version: string\n baseRoute Base route.\n baseRoute: string\n infoTitle Title.\n infoTitle: string\n infoDescription API description\n infoDescription: string\n infoVersion API version\n infoVersion: string\n infoTermsOfService Terms of service information.\n infoTermsOfService: string\n infoContactName Contact name.\n infoContactName: string\n infoContactUrl Contact URL.\n infoContactUrl: string\n infoContactEmail Contact email.\n infoContactEmail: string\n infoLicenseName License name.\n infoLicenseName: string\n infoLicenseUrl License information URL.\n infoLicenseUrl: string\n  Instance methods getSpaces Returns a string with spaces.\n protected getSpaces(length: number): string\n  length: number - determines the length of the string with spaces. returns: string - string containing spaces.  toString Returns string with Swagger code that describe service methods.\n public toString(): string\n  returns: string - string with the API information.  typeToString Returns a string with the type name.\n protected typeToString(type: any): string\n  type: any - type (e.g. Integer) returns: string - name of the type (e.g. \u0026lsquo;integer\u0026rsquo;)  writeArrayItem Writes an array item to Swagger code.\n protected writeArrayItem(indent: number, name: string, isObjectItem: boolean = false): void\n  indent: number - number of spaces name: string - item\u0026rsquo;s name isObjectItem: bool - True is the item is an object. false otherwise.  writeAsObject Adds a property and its value.\n protected writeAsObject(indent: number, name: string, value: any): void\n  indent: number - number of spaces name: string - name of the property value: any - value of the property  writeAsString Adds a string property and its string value.\n protected writeAsString(indent: number, name: string, value: string)\n  indent: number - number of spaces name: string - name of the property value: string - value of the property  writeData Adds data to the Swagger code.\n protected writeData(indent: number, data: Map\u0026lt;string, any\u0026gt;): void\n  indent: number - number of spaces name: string - name data: Map\u0026lt;string, any\u0026gt; - data to be added  writeName Write a property or object name.\n protected writeName(indent: number, name: string); void\n  indent: number - number of spaces name: string - string with added identation  ","description":"Class used to generate Swagger code that describes created REST API methods and their parameters. \n","image":null,"permalink":"/node/rpc/services/commandable_swagger_document/","subtitle":null,"tags":null,"title":"CommandableSwaggerDocument"},{"content":"Description The CommandableSwaggerDocument class allows you to generate Swagger description language that represents the created REST API methods and their parameters.\nConstructors Creates a new instance of the service.\n CommandableHttpService(base_route: str, config: ConfigParams, commands: List[ICommand])\n  base_route: str - base route of the service config: ConfigParams - configuration parameters commands: List[ICommand] - list of commands  Fields commands List of commmands.\n commands: List[ICommand]\n version Version number.\n version: str\n base_route Base route.\n base_route: str\n info_title Title.\n info_title: str\n info_description API description\n info_description: str\n info_version API version\n info_version: str\n info_terms_of_service Terms of service information.\n info_terms_of_service: Optional[str]\n info_contact_name Contact name.\n info_contact_name: Optional[str]\n info_contact_url Contact URL.\n info_contact_url: Optional[str]\n info_contact_email Contact email.\n info_contact_email: Optional[str]\n info_license_name License name.\n info_license_name: Optional[str]\n info_license_url License information URL.\n info_license_url: Optional[str]\n  Instance methods _get_spaces Returns a string with spaces.\n _get_spaces(length: int): str\n  length: int - determines the length of the string with spaces. returns: str - string containing spaces.  to_string Returns a string with Swagger description language that represents the service methods.\n to_string(): str\n  returns: str - string with the API information.  _type_to_string Returns a string with the type name.\n _type_to_string(type: Any): str\n  type: Any - type (e.g. Integer) returns: str - name of the type (e.g. \u0026lsquo;integer\u0026rsquo;)  _write_array_item Writes an array item into the Swagger description.\n _write_array_item(indent: int, name: str, is_object_item: bool = False)\n  indent: int - number of spaces name: str - item\u0026rsquo;s name is_object_item: bool - True is the item is an object. False otherwise.  _write_as_object Adds a property and its value.\n _write_as_object(indent: int, name: str, value: Any)\n  indent: int - number of spaces name: str - name of the property value: Any - value of the property  _write_as_string Adds a string property and its string value.\n _write_as_string(indent: int, name: str, value: str)\n  indent: int - number of spaces name: str - name of the property value: str - value of the property  _write_data Adds data to the Swagger description.\n _write_data(indent: int, data: Dict[str, Any])\n  indent: int - number of spaces name: str - name data: Dict[str, Any] - data to be added  _write_name Writes a property or object name.\n _write_name(indent: int, name: str)\n  indent: int - number of spaces name: str - string with added identation  ","description":"Class used to generate Swagger description language that represents the created REST API methods and their parameters. \n","image":null,"permalink":"/python/rpc/services/commandable_swagger_document/","subtitle":null,"tags":null,"title":"CommandableSwaggerDocument"},{"content":"Description The CommandSet class allows you to create a set of commands and events supported by a commandable object. In addition, it supports command interceptors and command call chains.\nImportant points\n CommandSets can be used as an alternative commandable interface to a business object. This class can be used to auto generate multiple external services for a business object.  Constructors NewCommandSet Creates an empty CommandSet object.\n NewCommandSet() *CommandSet\n Methods AddCommand Adds a command to this command set.\nSee ICommand\n (c *CommandSet) AddCommand(command ICommand)\n  command: ICommand - command to add.  AddCommandSet Adds all of the commands and events from specified command set into this one.\n (c *CommandSet) AddCommandSet(commandSet *CommandSet)\n  commandSet: *CommandSet - CommandSet to add.  AddCommands Adds multiple commands to this command set.\nSee ICommand\n (c *CommandSet) AddCommands(commands []ICommand)\n  commands: []ICommand - array of commands to add.  AddEvent Adds an event to this command set.\nSee IEvent\n (c *CommandSet) AddEvent(event IEvent)\n  event: IEvent - event to add.  AddEvents Adds multiple events to this command set.\nSee IEvent\n (c [*CommandSet]) AddEvents(events []IEvent)\n  event: []IEvent - array of events to add.  AddInterceptor Adds a command interceptor to this command set.\n (c *CommandSet) AddInterceptor(interceptor ICommandInterceptor)\n  interceptor: ICommandInterceptor the interceptor to add.  AddListener Adds a listener to receive notifications on fired events.\nSee IEventListener\n (c *CommandSet) AddListener(listener IEventListener)\n  listener: IEventListener - the listener to add.  Execute Executes a command specificed by its name.\nSee ICommand, Parameters\n (c *CommandSet) Execute(correlationId string, commandName string, args *run.Parameters) (result interface{}, err error)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. commandName: string - name of that command to be executed. args: *run.Parameters - parameters (arguments) to pass to the command for execution. returns:  result interface{} - execution result err: error    FindCommand Searches for a command by its name.\nSee ICommand\n (c *CommandSet) FindCommand(commandName string) ICommand\n  commandName: ICommand - name of the command to search for. returns: ICommand - command, whose name matches the provided name.  FindEvent Searches for an event by its name in this command set.\n (c *CommandSet) FindEvent(eventName string) IEvent\n  eventName: string - name of the event to search for. returns: IEvent - event, whose name matches the provided name.  Commands Gets all commands registered in this command set.\nSee ICommand\n (c *CommandSet) Commands() []ICommand\n  returns: []ICommand - list of commands.  Events Gets all events registred in this command set.\nSee IEvent\n (c *CommandSet) Events() []IEvent\n  returns: []IEvent - list of events.  Notify Fires an event specified by its name and notifies all registered listeners\n (c *CommandSet) Notify(correlationId string, eventName string, args *run.Parameters)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. eventName: string - name of the event that is to be fired. args: *run.Parameters - event\u0026rsquo;s arguments (parameters).  RemoveListener Removes previosly added listener.\nSee IEventListener\n (c *CommandSet) RemoveListener(listener IEventListener)\n  listener: IEventListener - listener to remove.  Validate Validates args for command specified by its name using defined schema. If validation schema is not defined, then the methods returns no errors. It returns validation error if the command is not found.\n (c *CommandSet) Validate(commandName string, args *run.Parameters) []*validate.ValidationResult\n  commandName: string - name of the command for which the \u0026lsquo;args\u0026rsquo; must be validated. args: *run.Parameters - parameters (arguments) to validate. returns: []*validate.ValidationResult - array of ValidationResults. If no command is found by the given name, then the returned array of ValidationResults will contain a single entry, whose type will be ValidationResultType.Error.  Examples type MyDataCommandSet { CommandSet _controller IMyDataController } func (dcs * MyDataCommandSet) CreateMyDataCommandSet(controller IMyDataController) { // Any data controller interface  dcs._controller = controller dcs.addCommand(dcs.makeGetMyDataCommand()) } func (dcs * MyDataCommandSet) makeGetMyDataCommand() ICommand { return NewCommand( \u0026#34;get_mydata\u0026#34;, nil, (correlationId: string, args: Parameters, func (correlationId string, args *run.Parameters)(interface{}, err) { let param = args.getAsString(\u0026#34;param\u0026#34;); return dcs._controller.getMyData(correlationId, param,); } ); } See also   Command   ICommandable   Event   ","description":"Contains a set of commands and events supported by a [commandable](../icommandable) object. The CommandSet supports command interceptors and command call chains.\n","image":null,"permalink":"/golang/commons/commands/command_set/","subtitle":null,"tags":null,"title":"CommandSet"},{"content":"Description The CommandSet class allows you to create a set of commands and events supported by a commandable object. In addition, it supports command interceptors and command call chains.\nImportant points\n CommandSets can be used as an alternative commandable interface to a business object. This class can be used to auto generate multiple external services for a business object.  Constructors Creates an empty CommandSet object.\n CommandSet()\n Properties Commands Gets all commands registered in this command set. See ICommand.\n public List\u0026lt;ICommand\u0026gt; Commands { get; }\n Events Gets all events registred in this command set.\nSee IEvent\n public List\u0026lt;IEvent\u0026gt; Events { get; }\n Instance methods AddCommand Adds a command to this command set.\nSee ICommand\n public void AddCommand(ICommand command)\n  command: ICommand - the command to add.  AddCommandSet Adds all of the commands and events from specified command set into this one.\n public void AddCommandSet(CommandSet commandSet)\n  commandSet: CommandSet - CommandSet to add.  AddCommands Adds multiple commands to this command set.\nSee ICommand\n public void AddCommands(IEnumerable\u0026lt;ICommand\u0026gt; commands)\n  commands: IEnumerable\u0026lt;ICommand\u0026gt; - array of commands to add.  AddEvent Adds an event to this command set.\nSee IEvent\n public void AddEvent(IEvent ev)\n  ev: IEvent - event to add.  AddEvents Adds multiple events to this command set.\nSee IEvent\n public void AddEvents(IEnumerable\u0026lt;IEvent\u0026gt; events)\n  events: IEnumerable\u0026lt;IEvent\u0026gt; - array of events to add.  AddInterceptor Adds a command interceptor to this command set.\n public void AddInterceptor(ICommandInterceptor intercepter)\n  intercepter: ICommandInterceptor the interceptor to add.  AddListener Adds a listener to receive notifications on fired events.\nSee IEventListener\n public void AddListener(IEventListener listener)\n  listener: IEventListener - listener to add.  ExecuteAsync Executes a command specificed by its name.\nSee ICommand, Parameters\n public Task\u0026lt;\\object\u0026gt; ExecuteAsync(string correlationId, string command, Parameters args)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. command: string - name of that command that is to be executed. args: Parameters - parameters (arguments) to pass to the command for execution. returns: Task\u0026lt;\\object\u0026gt; - execution result  FindCommand Searches for a command by its name. See ICommand\n public ICommand FindCommand(string command)\n  command: ICommand - name of the command to search for. returns: ICommand - command, whose name matches the provided name.  FindEvent Searches for an event by its name in this command set.\n public IEvent FindEvent(string ev)\n  ev: string - name of the event to search for. returns: IEvent - event whose name matches the provided name.  NotifyAsync Fires event specified by its name and notifies all registered listeners\n public Task NotifyAsync(correlationId: string, ev: string, args: Parameters)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. ev: string - name of the event that is to be fired. args: Parameters - event arguments (parameters).  RemoveListener Removes previosly added listener.\nSee IEventListener\n public void RemoveListener(IEventListener listener)\n  listener: IEventListener - listener to remove.  validate Validates args for command specified by its name using a defined schema. If the validation schema is not defined, then the methods returns no errors. It returns a validation error if the command is not found.\n IList\u0026lt;ValidationResult\u0026gt; validate(string command, Parameters args)\n  command: string - name of the command for which the \u0026lsquo;args\u0026rsquo; must be validated. args: Parameters - parameters (arguments) to validate. returns: IList\u0026lt;ValidationResult\u0026gt; - array of ValidationResults. If no command is found by the given name, then the returned array of ValidationResults will contain a single entry, whose type will be ValidationResultType.Error.  Examples public class MyDataCommandSet: CommandSet { private IMyDataController _controller; ///  public MyDataCommandSet(IMyDataController controller) // Any data controller interface  { base(); this._controller = controller; this.addCommand(this.MakeGetMyDataCommand()); } private ICommand MakeGetMyDataCommand() { return new Command( \u0026#34;get_mydata\u0026#34;, null, async(correlationId, args)=\u0026gt; { String param = args.getAsString(\u0026#34;param\u0026#34;); return this._controller.getMyData(correlationId, param); }); } } See also   Command   ICommandable   Event   ","description":"Contains a set of commands and events supported by a [commandable](../icommandable) object. The CommandSet supports command interceptors and command call chains.\n","image":null,"permalink":"/net/commons/commands/command_set/","subtitle":null,"tags":null,"title":"CommandSet"},{"content":"Description The CommandSet class allows you to create a set of commands and events supported by a commandable object. In addition, it supports command interceptors and command call chains.\nImportant points\n CommandSets can be used as an alternative commandable interface to a business object. This class can be used to auto generate multiple external services for a business object.  Constructors Creates an empty CommandSet object.\n public constructor()\n Instance methods addCommand Adds a command to this command set.\nSee ICommand\n public addCommand(command: ICommand): void\n  command: ICommand - command to add.  addCommandSet Adds all of the commands and events from a specified command set into this one.\n public addCommandSet(commandSet: CommandSet): void\n  commandSet: CommandSet - CommandSet to add.  addCommands Adds multiple commands to this command set.\nSee ICommand\n public addCommands(commands: ICommand[]): void\n  commands: ICommand[] - array of commands to add.  addEvent Adds an event to this command set.\nSee IEvent\n public addEvent(event: IEvent): void\n  event: IEvent - event to add.  addEvents Adds multiple events to this command set.\nSee IEvent\n public addEvents(events: IEvent[]): void\n  event: IEvent[] - array of events to add.  addInterceptor Adds a command interceptor to this command set.\n public addInterceptor(interceptor: ICommandInterceptor): void\n  interceptor: ICommandInterceptor interceptor to add.  addListener Adds a listener to receive notifications on fired events.\nSee IEventListener\n public addListener(listener: IEventListener): void\n  listener: IEventListener - listener to add.  execute Executes a command specificed by its name.\nSee ICommand, Parameters\n public execute(correlationId: string, commandName: string, args: Parameters): Promise\u0026lt;any\u0026gt;\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. commandName: string - name of the command that is to be executed. args: Parameters - parameters (arguments) to pass to the command for execution. returns: Promise\u0026lt;any\u0026gt; - execution result  findCommand Searches for a command by its name.\nSee ICommand\n public findCommand(commandName: string): ICommand\n  commandName: ICommand - name of the command to search for. returns: ICommand - command, whose name matches the provided name.  findEvent Searches for an event by its name in this command set.\n public findEvent(eventName: string): IEvent\n  eventName: string - name of the event to search for. returns: IEvent - event, whose name matches the provided name.  getCommands Gets all commands registered in this command set.\nSee ICommand\n public getCommands(): ICommand[]\n  returns: ICommand[] - list of commands.  getEvents Gets all events registred in this command set.\nSee IEvent\n public getEvents(): IEvent[]\n  returns: IEvent[] - list of events.  notify Fires an event specified by its name and notifies all registered listeners\n public notify(correlationId: string, eventName: string, args: Parameters): void\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. eventName: string - name of the event that is to be fired. args: Parameters - event arguments (parameters).  removeListener Removes a previosly added listener.\nSee IEventListener\n public removeListener(listener: IEventListener): void\n  listener: IEventListener - listener to remove.  validate Validates the args for a command specified by its name using a defined schema. If the validation schema is not defined, then the methods returns no errors. It returns a validation error if the command is not found.\n public validate(commandName: string, args: Parameters): ValidationResult[]\n  commandName: string - name of the command for which the \u0026lsquo;args\u0026rsquo; must be validated. args: Parameters - parameters (arguments) to validate. returns: ValidationResult[] - array of ValidationResults. If no command is found by the given name, then the returned array of ValidationResults will contain a single entry, whose type will be ValidationResultType.Error.  Examples export class MyDataCommandSet extends CommandSet { private _controller: IMyDataController; constructor(controller: IMyDataController) { // Any data controller interface  super(); this._controller = controller; this.addCommand(this.makeGetMyDataCommand()); } private makeGetMyDataCommand(): ICommand { return new Command( \u0026#39;get_mydata\u0026#39;, null, async (correlationId: string, args: Parameters) =\u0026gt; Promise\u0026lt;any\u0026gt; { let param = args.getAsString(\u0026#39;param\u0026#39;); return await this._controller.getMyData(correlationId, param); } ); } } See also   Command   ICommandable   Event   ","description":"Contains a set of commands and events supported by a [commandable](../icommandable) object. The CommandSet supports command interceptors and command call chains.\n","image":null,"permalink":"/node/commons/commands/command_set/","subtitle":null,"tags":null,"title":"CommandSet"},{"content":"Description The CommandSet class allows you to create a set of commands and events supported by a commandable object. In addition, it supports command interceptors and command call chains.\nImportant points\n CommandSets can be used as an alternative commandable interface to a business object. This class can be used to auto generate multiple external services for a business object.  Constructors Creates an empty CommandSet object.\n CommandSet()\n Instance methods add_command Adds a command to this command set.\nSee ICommand\n add_command(command: ICommand)\n  command: ICommand - the command to add.  add_command_set Adds all of the commands and events from specified command set into this one.\n add_command_set(command_set: CommandSet)\n  command_set: CommandSet - the CommandSet to add.  add_commands Adds multiple commands to this command set.\nSee ICommand\n add_commands(commands: List[ICommand])\n  commands: List[ICommand] - the array of commands to add.  add_event Adds an event to this command set.\nSee IEvent\n add_event(event: IEvent)\n  event: IEvent - the event to add.  add_events Adds multiple events to this command set.\nSee IEvent\n add_events(events: List[IEvent])\n  event: List[IEvent] - the array of events to add.  add_interceptor Adds a command interceptor to this command set.\n add_interceptor(interceptor: ICommandInterceptor)\n  interceptor: ICommandInterceptor the interceptor to add.  add_listener Adds a listener to receive notifications on fired events.\nSee IEventListener\n add_listener(listener: IEventListener)\n  listener: IEventListener - the listener to add.  execute Executes a command specificed by its name.\nSee ICommand, Parameters\n execute(correlation_id: Optional[str], command: str, args: Parameters): Any\n  correlation_id: Optional[str] - (optional) transaction id to trace execution through call chain. command_name: str - the name of that command that is to be executed. args: Parameters - the parameters (arguments) to pass to the command for execution. returns: Any - the execution result  find_command Searches for a command by its name.\nSee ICommand\n find_command(command_name: str): ICommand\n  command_name: ICommand - the name of the command to search for. returns: ICommand - the command, whose name matches the provided name.  find_event Searches for an event by its name in this command set.\n find_event(event_name: str): Optional[IEvent]\n  event_name: str - the name of the event to search for. returns: Optional[IEvent] - the event, whose name matches the provided name.  get_commands Gets all commands registered in this command set.\nSee ICommand\n get_commands(): List[ICommand]\n  returns: List[ICommand] - a list of commands.  get_events Gets all events registred in this command set.\nSee IEvent\n get_events(): List[IEvent]\n  returns: List[IEvent] - a list of events.  notify Fires event specified by its name and notifies all registered listeners\n notify(correlation_id: Optional[str], event_name: str, args: Parameters)\n  correlation_id: Optional[str] - (optional) transaction id to trace execution through call chain. event_name: str - the name of the event that is to be fired. args: Parameters - the event arguments (parameters).  remove_listener Removes previosly added listener.\nSee IEventListener\n remove_listener(listener: IEventListener)\n  listener: IEventListener - the listener to remove.  validate Validates args for command specified by its name using defined schema. If validation schema is not defined than the methods returns no errors. It returns validation error if the command is not found.\n validate(command_name: str, args: Parameters): List[ValidationResult]\n  command_name: str - the name of the command for which the \u0026lsquo;args\u0026rsquo; must be validated. args: Parameters - the parameters (arguments) to validate. returns: List[ValidationResult] - an array of ValidationResults. If no command is found by the given name, then the returned array of ValidationResults will contain a single entry, whose type will be ValidationResultType.Error.  Examples class MyDataCommandSet(CommandSet): _controller = None def __init__(self, controller): super(MyDataCommandSet, self).__init__() self._controller = controller self.add_command(self._make_get_my_data_command()) def _make_get_my_data_command(self): def handler(correlation_id, args): param = args.get_as_string(\u0026#39;param\u0026#39;) return self._controller.get_my_data(correlation_id, param) return Command( \u0026#34;get_mydata\u0026#34;, None, handler ) See also   Command   ICommandable   Event   ","description":"Contains a set of commands and events supported by a [commandable](../icommandable) object. The CommandSet supports command interceptors and command call chains.\n","image":null,"permalink":"/python/commons/commands/command_set/","subtitle":null,"tags":null,"title":"CommandSet"},{"content":"Inherits: IConfigurable, IReferenceable\nDescription The component class allows you to create components that support configurable dependencies, logging, and performance counters.\nConfiguration parameters  dependencies:  [dependency name 1]: Dependency 1 locator (descriptor) \u0026hellip; [dependency name N]: Dependency N locator (descriptor)    References  *:counters:*:*:1.0 - (optional) ICounters components to pass collected measurements *:logger:*:*:1.0 - (optional) ILogger components to pass log messages *:tracer:*:*:1.0 - (optional) ITracer components to trace executed operations \u0026hellip; References must match configured dependencies.  Fields _logger Components to pass log messages\n protected _logger: CompositeLogger\n _counters Components to pass collected measurements\n protected _counters: CompositeCounters\n _dependencyResolver A dependency resolver\n protected _dependencyResolver: DependencyResolver\n _tracer Components to record traces\n protected _tracer: CompositeTracer\n  Instance methods Configure Configures component by passing configuration parameters.\n public void Configure(ConfigParams config)\n  config: ConfigParams - configuration parameters to be set.  SetReferences Sets references to dependent components.\n public void SetReferences(IReferences references)\n  references: IReferences - references to locate the component dependencies.  ","description":"Component that supports configurable dependencies, logging and performance counters.\n","image":null,"permalink":"/net/components/component/","subtitle":null,"tags":null,"title":"Component"},{"content":"Implements: IConfigurable, IReferenceable\nDescription The component class allows you to create components that support configurable dependencies, logging, and performance counters.\nConfiguration parameters  dependencies:  [dependency name 1]: Dependency 1 locator (descriptor) \u0026hellip; [dependency name N]: Dependency N locator (descriptor)    References  *:counters:*:*:1.0 - (optional) ICounters components to pass collected measurements *:logger:*:*:1.0 - (optional) ILogger components to pass log messages *:tracer:*:*:1.0 - (optional) ITracer components to trace executed operations \u0026hellip; References must match configured dependencies.  Fields _logger Components to pass log messages\n protected _logger: CompositeLogger\n _counters Components to pass collected measurements\n protected _counters: CompositeCounters\n _dependencyResolver A dependency resolver\n protected _dependencyResolver: DependencyResolver\n _tracer Components to record traces\n protected _tracer: CompositeTracer\n  Instance methods configure Configures component by passing configuration parameters.\n public configure(config: ConfigParams): void\n  config: ConfigParams - configuration parameters to be set.  setReferences Sets references to dependent components.\n public setReferences(references: IReferences): void\n  references: IReferences - references to locate the component dependencies.  ","description":"Component that supports configurable dependencies, logging and performance counters.\n","image":null,"permalink":"/node/components/component/","subtitle":null,"tags":null,"title":"Component"},{"content":"Implements: IConfigurable, IReferenceable\nDescription The component class allows you to create components that support configurable dependencies, logging, and performance counters.\nConfiguration parameters  dependencies:  [dependency name 1]: Dependency 1 locator (descriptor) \u0026hellip; [dependency name N]: Dependency N locator (descriptor)    References  *:counters:*:*:1.0 - (optional) ICounters components to pass collected measurements *:logger:*:*:1.0 - (optional) ILogger components to pass log messages *:tracer:*:*:1.0 - (optional) ITracer components to trace executed operations \u0026hellip; References must match configured dependencies.  Fields _logger Components to pass log messages\n _logger: CompositeLogger\n _counters Components to pass collected measurements\n _counters: CompositeCounters\n _dependency_resolver A dependency resolver\n _dependency_resolver: DependencyResolver\n _tracer Components to record traces\n _tracer: CompositeTracer\n  Instance methods configure Configures component by passing configuration parameters.\n configure(config: ConfigParams)\n  config: ConfigParams - configuration parameters to be set.  set_references Sets references to dependent components.\n set_references(references: IReferences)\n  references: IReferences - references to locate the component dependencies.  ","description":"Component that supports configurable dependencies, logging and performance counters.\n","image":null,"permalink":"/python/components/component/","subtitle":null,"tags":null,"title":"Component"},{"content":"Description The ComponentConfig class allows you to configure a component residing inside a container.\nImportant points\n The configuration includes the type of information or descriptor and component configuration parameters.  Fields Descriptor Component\u0026rsquo;s descriptor (locator).\n Descriptor: Descriptor\n Type Component\u0026rsquo;s type descriptor.\n Type: TypeDescriptor\n Config Component\u0026rsquo;s configuration parameters.\n Config: ConfigParams\n  Constructors NewComponentConfigFromType Creates a new instance of the configuration component.\n NewComponentConfigFromType(typ *reflect.TypeDescriptor, config *config.ConfigParams) *config.ConfigParams\n  typ: *reflect.TypeDescriptor - (optional) component\u0026rsquo;s type descriptor. config: *config.ConfigParams - (optional) component\u0026rsquo;s configuration parameters.  NewComponentConfigFromDescriptor Creates a new instance of the configuration component.\n NewComponentConfigFromDescriptor(descriptor *refer.Descriptor, config *config.ConfigParams) *ComponentConfig\n  descriptor: *refer.Descriptor - (optional) component\u0026rsquo;s descriptor (locator). config: *config.ConfigParams - (optional) component\u0026rsquo;s configuration parameters.  Methods ReadComponentConfigFromConfig Creates a new instance of ComponentConfig based on a section from a container configuration. Throws ConfigException when neither component descriptor or type is found.\n ReadComponentConfigFromConfig(config *config.ConfigParams) (result *ComponentConfig, err error)\n  config: *config.ConfigParams - component\u0026rsquo;s parameters from a container configuration. returns: (result *ComponentConfig, err error) - created ComponentConfig or error.  ","description":"Configuration of a component inside a container.\n","image":null,"permalink":"/golang/container/config/component_config/","subtitle":null,"tags":null,"title":"ComponentConfig"},{"content":"Description The ComponentConfig class allows you to configure a component residing inside a container.\nImportant points\n The configuration includes the type of information or descriptor and component configuration parameters.  Properties Descriptor Component\u0026rsquo;s descriptor (locator).\n public Descriptor Descriptor { get; set; }\n Type Component\u0026rsquo;s type descriptor.\n public TypeDescriptor Type { get; set; }\n Config Component\u0026rsquo;s configuration parameters.\n public ConfigParams Config { get; set; }\n Constructors Creates a new instance of the configuration component.\n public ComponentConfig(Descriptor descriptor, TypeDescriptor type, ConfigParams config)\n  descriptor: Descriptor - (optional) component\u0026rsquo;s descriptor (locator). type: TypeDescriptor - (optional) component\u0026rsquo;s type descriptor. config: ConfigParams - (optional) component\u0026rsquo;s configuration parameters.  Static methods FromConfig Creates a new instance of ComponentConfig based on a section from a container configuration. Throws ConfigException when neither component descriptor or type is found.\n public static ComponentConfig FromConfig(ConfigParams config)\n  config: ConfigParams - component\u0026rsquo;s parameters from a container configuration. returns: ComponentConfig - created ComponentConfig.  ","description":"Configuration of a component inside a container.\n","image":null,"permalink":"/net/container/config/component_config/","subtitle":null,"tags":null,"title":"ComponentConfig"},{"content":"Description The ComponentConfig class allows you to configure a component residing inside a container.\nImportant points\n The configuration includes the type of information or descriptor and component configuration parameters.  Fields descriptor Component\u0026rsquo;s descriptor (locator).\n public descriptor: Descriptor\n type Component\u0026rsquo;s type descriptor.\n public type: TypeDescriptor\n config Component\u0026rsquo;s configuration parameters.\n public config: ConfigParams\n  Constructors Creates a new instance of the configuration component.\n public constructor(descriptor?: Descriptor, type?: TypeDescriptor, config?: ConfigParams)\n  descriptor: Descriptor - (optional) component\u0026rsquo;s descriptor (locator). type: TypeDescriptor - (optional) component\u0026rsquo;s type descriptor. config: ConfigParams - (optional) component\u0026rsquo;s configuration parameters.  Static methods fromConfig Creates a new instance of ComponentConfig based on a section from a container configuration. Throws ConfigException when neither component descriptor or type is found.\n public static fromConfig(config: ConfigParams): ComponentConfig\n  config: ConfigParams - component\u0026rsquo;s parameters from a container configuration. returns: ComponentConfig - created ComponentConfig.  ","description":"Configuration of a component inside a container.\n","image":null,"permalink":"/node/container/config/component_config/","subtitle":null,"tags":null,"title":"ComponentConfig"},{"content":"Description The ComponentConfig class allows you to configure a component residing inside a container.\nImportant points\n The configuration includes the type of information or descriptor and component configuration parameters.  Fields descriptor Component\u0026rsquo;s descriptor (locator).\n descriptor: Descriptor\n type Component\u0026rsquo;s type descriptor.\n type: TypeDescriptor\n config Component\u0026rsquo;s configuration parameters.\n config: ConfigParams\n  Constructors Creates a new instance of the configuration component.\n ComponentConfig(descriptor: Descriptor = None, type: TypeDescriptor = None, config: ConfigParams = None)\n  descriptor: Descriptor - (optional) component\u0026rsquo;s descriptor (locator). type: TypeDescriptor - (optional) component\u0026rsquo;s type descriptor. config: ConfigParams - (optional) component\u0026rsquo;s configuration parameters.  Static methods from_config Creates a new instance of ComponentConfig based on a section from a container configuration. Throws ConfigException when neither component descriptor or type is found.\n static from_config(config: ConfigParams): ComponentConfig\n  config: ConfigParams - component\u0026rsquo;s parameters from a container configuration. returns: ComponentConfig - created ComponentConfig.  ","description":"Configuration of a component inside a container.\n","image":null,"permalink":"/python/container/config/component_config/","subtitle":null,"tags":null,"title":"ComponentConfig"},{"content":"Description The CompositeConnectionResolver class allows you to resolve connection and credential parameters, validate them and generates connection options.\nConfiguration parameters connection(s):\n discovery_key: (optional) key to retrieve the connection from IDiscovery protocol: communication protocol host: host name or IP address port: port number uri: resource URI or connection string with all parameters in it  credential(s):\n store_key: (optional) key to retrieve the credentials from ICredentialStore username: user name password: user password  References  *:discovery:*:*:1.0 - (optional) IDiscovery services to resolve connections *:credential-store:*:*:1.0 - (optional) Credential stores to resolve credentials ICredentialStore  Fields Options Connection options\n Options: ConfigParams\n ConnectionResolver Connections resolver.\n ConnectionResolver: ConnectionResolver\n CredentialResolver Credentials resolver.\n CredentialResolver: CredentialResolver\n ClusterSupported Cluster support (multiple connections)\n ClusterSupported: bool\n DefaultProtocol Default protocol\n DefaultProtocol: string\n DefaultPort Default port\n DefaultPort: number\n SupportedProtocols List of supported protocols\n SupportedProtocols: []string\n  Methods Compose Composes Composite connection options from connection and credential parameters.\n (c *CompositeConnectionResolver) Compose(correlationId string, connections []*ConnectionParams, credential *auth.CredentialParams, parameters *config.ConfigParams) (options *config.ConfigParams, err error)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. connections: []*ConnectionParams - connection parameters credential: *auth.CredentialParams - credential parameters parameters: *config.ConfigParams - optional parameters returns: (options *config.ConfigParams, err error) - resolved options or error.  ComposeOptions A composite of several merger options\n (c *CompositeConnectionResolver) ComposeOptions(connections []*ConnectionParams, credential *auth.CredentialParams, parameters *config.ConfigParams) *config.ConfigParams\n  connections: []*ConnectionParams - connection parameters credential: *auth.CredentialParams - credential parameters parameters: *config.ConfigParams - optional parameters returns: *config.ConfigParams - resolved options or error  Configure Configures component by passing configuration parameters.\n (c *CompositeConnectionResolver) Configure(config *config.ConfigParams)\n  config: *config.ConfigParams - configuration parameters to be set.  FinalizeOptions Finalize merged options. This method can be overriden in child classes.\n (c *CompositeConnectionResolver) FinalizeOptions(options *config.ConfigParams) *config.ConfigParams\n  options: *config.ConfigParams - options: connection options returns: *config.ConfigParams - finalized connection options  MergeConnection Merges connection options with connection parameters. This method can be overriden in child classes.\n (c *CompositeConnectionResolver) MergeConnection(options *config.ConfigParams, connection *ConnectionParams) *config.ConfigParams\n  options: ConfigParams - connection options connection: *ConnectionParams - connection parameters to be merged returns: *config.ConfigParams - merged connection options.  MergeCredential Merges connection options with credential parameters. This method can be overriden in child classes.\n (c *CompositeConnectionResolver) MergeCredential(options *config.ConfigParams, credential *auth.CredentialParams) *config.ConfigParams\n  options: ConfigParams - connection options credential: *auth.CredentialParams - credential parameters to be merged returns: *config.ConfigParams - merged connection options.  MergeOptional Merges connection options with optional parameters. This method can be overriden in child classes.\n (c *CompositeConnectionResolver) MergeOptional(options *config.ConfigParams, parameters *config.ConfigParams) *config.ConfigParams\n  options: *config.ConfigParams - connection options parameters: *config.ConfigParams - optional parameters to be merged returns: *config.ConfigParams - merged connection options.  Resolve Resolves connection options from connection and credential parameters.\n (c *CompositeConnectionResolver) Resolve(correlationId string) (options *config.ConfigParams, err error)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. returns: (options *config.ConfigParams, err error) - resolved options or error  SetReferences Sets references to dependent components.\n (c *CompositeConnectionResolver) SetReferences(references refer.IReferences)\n  references: refer.IReferences - references to locate the component dependencies.  ValidateConnection Validates connection parameters. Throws error if validation failed. This method can be overriden in child classes.\n (c *CompositeConnectionResolver) ValidateConnection(correlationId string, connection *ConnectionParams) error\n  correlationId: string - (optional) transaction id usedd to trace execution through the call chain. connection: *ConnectionParams - connection parameters to be validated returns: error - returns error if validation failed  ValidateCredential Validates credential parameters. This method can be overriden in child classes.\n (c *CompositeConnectionResolver) ValidateCredential(correlationId string, credential *auth.CredentialParams) error\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. credential: *auth.CredentialParams - credential parameters to be validated returns: error - returns error if validation failed  ","description":"Helper class that resolves connection and credential parameters, validates them and generates connection options.\n","image":null,"permalink":"/golang/components/connect/composite_connection_resolver/","subtitle":null,"tags":null,"title":"CompositeConnectionResolver"},{"content":"Inherits: IConfigurable, IReferenceable\nDescription The CompositeConnectionResolver class allows you to resolve connection and credential parameters, validate them and generate connection options.\nConfiguration parameters connection(s):\n discovery_key: (optional) a key to retrieve the connection from IDiscovery protocol: communication protocol host: host name or IP address port: port number uri: resource URI or connection string with all parameters in it  credential(s):\n store_key: (optional) a key to retrieve the credentials from ICredentialStore username: user name password: user password  References  *:discovery:*:*:1.0 - (optional) IDiscovery services to resolve connections *:credential-store:*:*:1.0 - (optional) Credential stores to resolve credentials ICredentialStore  Fields _options The connection options\n protected _options: ConfigParams\n _connectionResolver The connections resolver.\n protected _connectionResolver: ConnectionResolver\n _credentialResolver The credentials resolver.\n protected _credentialResolver: CredentialResolver\n _clusterSupported The cluster support (multiple connections)\n protected _clusterSupported: bool\n _defaultProtocol The default protocol\n protected _defaultProtocol: string\n _defaultPort The default port\n protected _defaultPort: int\n _supported_protocols The list of supported protocols\n protected _supportedProtocols: IList\u0026lt;string\u0026gt;\n  Instance methods Compose Composes Composite connection options from connection and credential parameters.\n public ConfigParams Compose(string correlationId, IList\u0026lt;ConnectionParams\u0026gt; connections, CredentialParams credential, ConfigParams parameters)\n  correlationId: string - (optional) transaction id to trace execution through a call chain. connections: IList\u0026lt;ConnectionParams\u0026gt; - connection parameters credential: CredentialParams - credential parameters parameters: ConfigParams - optional parameters returns: ConfigParams - resolved options or error.  ComposeOptions A composite of several merger options\n protected ConfigParams ComposeOptions(IList\u0026lt;ConnectionParams\u0026gt; connections, CredentialParams credential, ConfigParams parameters)\n  connections: ConnectionParams[] - connection parameters credential: CredentialParams - credential parameters parameters: IList\u0026lt;ConnectionParams\u0026gt; - optional parameters returns: ConfigParams - resolved options or error  Configure Configures component by passing configuration parameters.\n public void Configure(ConfigParams config)\n  config: ConfigParams - configuration parameters to be set.  FinalizeOptions Finalize merged options. This method can be overriden in child classes.\n protected ConfigParams FinalizeOptions(ConfigParams options)\n  options: ConfigParams - options: connection options returns: ConfigParams - finalized connection options  MergeConnection Merges connection options with connection parameters. This method can be overriden in child classes.\n protected ConfigParams MergeConnection(ConfigParams options, ConnectionParams connection)\n  options: ConfigParams - connection options connection: ConnectionParams - connection parameters to be merged returns: ConfigParams - merged connection options.  MergeCredential Merges connection options with credential parameters. This method can be overriden in child classes.\n protected ConfigParams MergeCredential(ConfigParams options, CredentialParams credential)\n  options: ConfigParams - connection options credential: CredentialParams - credential parameters to be merged returns: ConfigParams - merged connection options.  MergeOptional Merges connection options with optional parameters. This method can be overriden in child classes.\n protected ConfigParams MergeOptional(ConfigParams options, ConfigParams parameters)\n  options: ConfigParams - connection options parameters: CredentialParams - optional parameters to be merged returns: ConfigParams - merged connection options.  ResolveAsync Resolves connection options from connection and credential parameters.\n public Task\u0026lt;ConfigParams\u0026gt; ResolveAsync(string correlationId):\n  correlationId: string - (optional) transaction id to trace execution through call chain. returns: Task\u0026lt;ConfigParams\u0026gt; - resolved options or error  SetReferences Sets references to dependent components.\n public void SetReferences(references: IReferences)\n  references: IReferences - references to locate the component dependencies.  ValidateConnection Validates connection parameters. Throws error if validation failed. This method can be overriden in child classes.\n protected void ValidateConnection(string correlationId, ConnectionParams) connection)\n  correlationId: string - (optional) transaction id to trace execution through a call chain. connection: ConnectionParams - connection parameters to be validated  ValidateCredential Validates credential parameters. This method can be overriden in child classes.\n protected void ValidateCredential(string correlationId, CredentialParams credential)\n  correlationId: string - (optional) transaction id to trace execution through call chain. credential: CredentialParams - credential parameters to be validated  ","description":"Helper class that resolves connection and credential parameters, validates them and generates connection options.\n","image":null,"permalink":"/net/components/connect/composite_connection_resolver/","subtitle":null,"tags":null,"title":"CompositeConnectionResolver"},{"content":"Implements: IConfigurable, IReferenceable\nDescription The CompositeConnectionResolver class allows you to resolve connection and credential parameters, validate them and generate connection options.\nConfiguration parameters connection(s):\n discovery_key: (optional) a key to retrieve the connection from IDiscovery protocol: communication protocol host: host name or IP address port: port number uri: resource URI or connection string with all parameters in it  credential(s):\n store_key: (optional) a key to retrieve the credentials from ICredentialStore username: user name password: user password  References  *:discovery:*:*:1.0 - (optional) IDiscovery services to resolve connections *:credential-store:*:*:1.0 - (optional) Credential stores to resolve credentials ICredentialStore  Fields _options The connection options\n protected _options: ConfigParams\n _connectionResolver The connections resolver.\n protected _connectionResolver: ConnectionResolver\n _credentialResolver The credentials resolver.\n protected _credentialResolver: CredentialResolver\n _clusterSupported The cluster support (multiple connections)\n protected _clusterSupported: boolean\n _defaultProtocol The default protocol\n protected _defaultProtocol: string\n _defaultPort The default port\n protected _defaultPort: number\n _supported_protocols The list of supported protocols\n protected _supportedProtocols: string[]\n  Instance methods compose Composes Composite connection options from connection and credential parameters.\n public compose(correlationId: string, connections: ConnectionParams[], credential: CredentialParams, parameters: ConfigParams): ConfigParams\n  correlationId: string - (optional) transaction id to trace execution through a call chain. connections: ConnectionParams[] - connection parameters credential: CredentialParams - credential parameters parameters: ConfigParams - optional parameters returns: ConfigParams - resolved options or error.  composeOptions A composite of several merger options\n protected composeOptions(connections: ConnectionParams[], credential: CredentialParams, parameters: ConfigParams): ConfigParams\n  connections: ConnectionParams[] - connection parameters credential: CredentialParams - credential parameters parameters: ConfigParams - optional parameters returns: ConfigParams - resolved options or error  configure Configures component by passing configuration parameters.\n public configure(config: ConfigParams): void\n  config: ConfigParams - configuration parameters to be set.  finalizeOptions Finalize merged options. This method can be overriden in child classes.\n protected finalizeOptions(options: ConfigParams): ConfigParams\n  options: ConfigParams - options: connection options returns: ConfigParams - finalized connection options  mergeConnection Merges connection options with connection parameters. This method can be overriden in child classes.\n protected mergeConnection( options: ConfigParams, connection: ConnectionParams): ConfigParams\n  options: ConfigParams - connection options connection: ConnectionParams - connection parameters to be merged returns: ConfigParams - merged connection options.  mergeCredential Merges connection options with credential parameters. This method can be overriden in child classes.\n protected mergeCredential(options: ConfigParams, credential: CredentialParams): ConfigParams\n  options: ConfigParams - connection options credential: CredentialParams - credential parameters to be merged returns: ConfigParams - merged connection options.  mergeOptional Merges connection options with optional parameters. This method can be overriden in child classes.\n protected mergeOptional(options: ConfigParams, parameters: ConfigParams): ConfigParams\n  options: ConfigParams - connection options parameters: CredentialParams - optional parameters to be merged returns: ConfigParams - merged connection options.  resolve Resolves connection options from connection and credential parameters.\n public resolve(correlationId: string): Promise\u0026lt;ConfigParams\u0026gt;\n  correlationId: string - (optional) transaction id to trace execution through call chain. returns: Promise\u0026lt;ConfigParams\u0026gt; - resolved options or error  setReferences Sets references to dependent components.\n public setReferences(references: IReferences): void\n  references: IReferences - references to locate the component dependencies.  validateConnection Validates connection parameters. Throws error if validation failed. This method can be overriden in child classes.\n protected validateConnection(correlationId: string, connection: ConnectionParams): void\n  correlationId: string - (optional) transaction id to trace execution through a call chain. connection: ConnectionParams - connection parameters to be validated  validateCredential Validates credential parameters. This method can be overriden in child classes.\n protected validateCredential(correlationId: string, credential: CredentialParams): void\n  correlationId: string - (optional) transaction id to trace execution through call chain. credential: CredentialParams - credential parameters to be validated  ","description":"Helper class that resolves connection and credential parameters, validates them and generates connection options.\n","image":null,"permalink":"/node/components/connect/composite_connection_resolver/","subtitle":null,"tags":null,"title":"CompositeConnectionResolver"},{"content":"Implements: IConfigurable, IReferenceable\nDescription The CompositeConnectionResolver class allows you to resolve connection and credential parameters, validate them and generate connection options.\nConfiguration parameters connection(s):\n discovery_key: (optional) a key to retrieve the connection from IDiscovery protocol: communication protocol host: host name or IP address port: port number uri: resource URI or connection string with all parameters in it  credential(s):\n store_key: (optional) a key to retrieve the credentials from ICredentialStore username: user name password: user password  References  *:discovery:*:*:1.0 - (optional) IDiscovery services to resolve connections *:credential-store:*:*:1.0 - (optional) Credential stores to resolve credentials ICredentialStore  Fields _options The connection options\n _options: ConfigParams\n _connection_resolver The connections resolver.\n _connection_resolver: ConnectionResolver\n _credential_resolver The credentials resolver.\n _credential_resolver: CredentialResolver\n _cluster_supported The cluster support (multiple connections)\n _cluster_supported: bool\n _default_protocol The default protocol\n _default_protocol: str\n _default_port The default port\n _default_port: int\n _supported_protocols The list of supported protocols\n _supported_protocols: List[str]\n  Instance methods compose Composes Composite connection options from connection and credential parameters.\n compose(correlation_id: Optional[str], connections: List[ConnectionParams], credential: CredentialParams, parameters: ConfigParams): ConfigParams\n  correlation_id: Optional[str] - (optional) transaction id to trace execution through a call chain. connections: List[ConnectionParams] - connection parameters credential: CredentialParams - credential parameters parameters: ConfigParams - optional parameters returns: ConfigParams - resolved options or error.  _compose_options A composite of several merger options\n _compose_options(connections: List[ConnectionParams], credential: CredentialParams, parameters: ConfigParams): ConfigParams\n  connections: List[ConnectionParams] - connection parameters credential: CredentialParams - credential parameters parameters: ConfigParams - optional parameters returns: ConfigParams - resolved options or error  configure Configures component by passing configuration parameters.\n configure(config: ConfigParams)\n  config: ConfigParams - configuration parameters to be set.  _finalize_options Finalize merged options. This method can be overriden in child classes.\n _finalize_options(options: ConfigParams): ConfigParams\n  options: ConfigParams - options: connection options returns: ConfigParams - finalized connection options  _merge_connection Merges connection options with connection parameters. This method can be overriden in child classes.\n _merge_connection(options: ConfigParams, connection: ConnectionParams): ConfigParams\n  options: ConfigParams - connection options connection: ConnectionParams - connection parameters to be merged returns: ConfigParams - merged connection options.  _merge_credential Merges connection options with credential parameters. This method can be overriden in child classes.\n _merge_credential(options: ConfigParams, credential: CredentialParams): ConfigParams\n  options: ConfigParams - connection options credential: CredentialParams - credential parameters to be merged returns: ConfigParams - merged connection options.  _merge_optional Merges connection options with optional parameters. This method can be overriden in child classes.\n _merge_optional(options: ConfigParams, parameters: ConfigParams): ConfigParams\n  options: ConfigParams - connection options parameters: CredentialParams - optional parameters to be merged returns: ConfigParams - merged connection options.  resolve Resolves connection options from connection and credential parameters.\n resolve(correlation_id: Optional[str]): ConfigParams\n  correlation_id: Optional[str] - (optional) transaction id to trace execution through call chain. returns: ConfigParams - resolved options or error  set_references Sets references to dependent components.\n set_references(references: IReferences)\n  references: IReferences - references to locate the component dependencies.  _validate_connection Validates connection parameters. Throws error if validation failed. This method can be overriden in child classes.\n _validate_connection(correlation_id: Optional[str], connection: ConnectionParams)\n  correlation_id: Optional[str] - (optional) transaction id to trace execution through a call chain. connection: ConnectionParams - connection parameters to be validated  _validate_credential Validates credential parameters. This method can be overriden in child classes.\n _validate_credential(correlation_id: Optional[str], credential: CredentialParams)\n  correlation_id: Optional[str] - (optional) transaction id to trace execution through call chain. credential: CredentialParams - credential parameters to be validated  ","description":"Helper class that resolves connection and credential parameters, validates them and generates connection options.\n","image":null,"permalink":"/python/components/connect/composite_connection_resolver/","subtitle":null,"tags":null,"title":"CompositeConnectionResolver"},{"content":"Description The CompositeCounters allows you to aggregate all counters from different component references into a single one.\nImportant points\n It allows to capture metrics and conveniently send them to multiple destinations.  References  *:counters:*:*:1.0 - (optional) ICounters components to pass collected measurements  Constructors NewCompositeCountersFromReferences Creates a new instance of the counters.\n NewCompositeCountersFromReferences(references refer.IReferences) *CompositeCounters\n  references: refer.IReferences - references to locate the component dependencies.  NewCompositeCounters Creates a new instance of the counters.\n NewCompositeCounters() *CompositeCounters\n Fields counters List containig the aggregated counters.\n counters: []ICounters\n  Methods BeginTiming Begins measurement of execution time interval. It returns *CounterTiming object which has to be called at CounterTiming.EndTiming to end the measurement and update the counter.\n (c *CompositeCounters) BeginTiming(name string) *CounterTiming\n  name: string - counter name of Interval type. returns: *CounterTiming - a callback object to end timing.  EndTiming Ends measurement of execution elapsed time and updates specified counter.\n (c *CompositeCounters) EndTiming(name string, elapsed float32)\n  name: string - counter name elapsed: float32 - execution elapsed time in milliseconds to update the counter.  Increment Increments counter by given value.\n (c *CompositeCounters) Increment(name string, value int)\n  name: string - a counter name of Increment type. value: int - a value to add to the counter.  IncrementOne Increments counter by 1.\n (c *CompositeCounters) IncrementOne(name string)\n  name: string - counter name of Increment type.  Last Records the last calculated measurement value. Usually this method is used by metrics calculated externally.\n (c *CompositeCounters) Last(name string, value float32)\n  name: string - counter name of Last type. value: float32 - last value to record.  SetReferences Sets references to dependent components.\n (c *CompositeCounters) SetReferences(references refer.IReferences)\n  references: refer.IReferences - references to locate the component\u0026rsquo;s dependencies.  Stats Calculates min/average/max statistics based on the current and previous values.\n (c *CompositeCounters) Stats(name string, value float32)\n  name: string - counter name of Statistics type value: float32 - value to update statistics  Timestamp Records a given timestamp.\n (c *CompositeCounters) Timestamp(name string, value time.Time)\n  name: string - counter name of Timestamp type. value: time.Time - timestamp to record.  TimestampNow Records the current time as a timestamp.\n (c *CompositeCounters) TimestampNow(name string)\n  name: string - counter name of Timestamp type.  Examples type MyComponent { _counters CompositeCounters = make(CompositeCounters) } func (mc * MyConponent)setReferences(references: IReferences) { mc._counters.SetReferences(references); } func (mc * MyConponent) myMethod() { mc._counters.Increment(\u0026#34;mycomponent.mymethod.calls\u0026#34;) timing := mc._counters.BeginTiming(\u0026#34;mycomponent.mymethod.exec_time\u0026#34;) defer timing.EndTiming(); // do something } var mc MyComponent{} mc._counters = NewCompositeCounters() See also   ICounters   ","description":"Aggregates all counters from component references into a single one.\n","image":null,"permalink":"/golang/components/count/composite_counters/","subtitle":null,"tags":null,"title":"CompositeCounters"},{"content":"Inherits: ICounters, IReconfigurable, ICounterTimingCallback\nDescription The CompositeCounters allows you to aggregate all counters from different component references into a single one.\nImportant points\n It allows to capture metrics and conveniently send them to multiple destinations.  References  *:counters:*:*:1.0 - (optional) ICounters components to pass collected measurements  Constructors Creates a new instance of the counters.\n public CompositeCounters(IReferences references = null)\n  references: IReferences - references to locate the component dependencies.  Fields _counters A list containig the aggregated counters.\n protected _counters: List\u0026lt;ICounters\u0026gt;\n  Instance methods BeginTiming Begins measurement of execution time interval. It returns CounterTiming object which has to be called at CounterTiming.EndTiming to end the measurement and update the counter.\n public CounterTiming BeginTiming(string name)\n  name: string - a counter name of Interval type. returns: CounterTiming - a callback object to end timing.  EndTiming Ends measurement of execution elapsed time and updates specified counter.\n public void EndTiming(string name, double elapsed)\n  name: string - a counter name elapsed: double - execution elapsed time in milliseconds to update the counter.  increment Increments counter by given value.\n public int Increment(string name, int value)\n  name: string - a counter name of Increment type. value: int - a value to add to the counter.  IncrementOne Increments counter by 1.\n public void IncrementOne(string name)\n  name: string - a counter name of Increment type.  Last Records the last calculated measurement value. Usually this method is used by metrics calculated externally.\n public void Last(string name, float value)\n  name: string - a counter name of Last type. value: float - last value to record.  SetReferences Sets references to dependent components.\n public virtual void SetReferences(IReferences references)\n  references: IReferences - references to locate the component dependencies.  Stats Calculates min/average/max statistics based on the current and previous values.\n public void Stats(string name, float value)\n  name: string - a counter name of Statistics type value: float - a value to update statistics  timestamp Records the given timestamp.\n public void Timestamp(string name, DateTime value)\n  name: string - a counter name of Timestamp type. value: DateTime - a timestamp to record.  TimestampNow Records the current time as a timestamp.\n public TimestampNow(string name)\n  name: string - a counter name of Timestamp type.  Examples class MyComponent: IReferenceable { CompositeCounters _counters = new CompositeCounters(); public void SetReferences(IReferences references) { this._counters.SetReferences(references); ... } public void MyMethod() { this._counters.Increment(\u0026#34;mycomponent.mymethod.calls\u0026#34;); var timing = this._counters.BeginTiming(\u0026#34;mycomponent.mymethod.exec_time\u0026#34;); try { ... } finally { timing.EndTiming(); } } } See also   ICounters   ","description":"Aggregates all counters from component references into a single one.\n","image":null,"permalink":"/net/components/count/composite_counters/","subtitle":null,"tags":null,"title":"CompositeCounters"},{"content":"Implements: ICounters, IReconfigurable, ICounterTimingCallback\nDescription The CompositeCounters allows you to aggregate all counters from different component references into a single one.\nImportant points\n It allows to capture metrics and conveniently send them to multiple destinations.  References  *:counters:*:*:1.0 - (optional) ICounters components to pass collected measurements  Constructors Creates a new instance of the counters.\n public constructor(references: IReferences = null)\n  references: IReferences - references to locate the component dependencies.  Fields _counters A list containig the aggregated counters.\n protected _counters: ICounters[] = []\n  Instance methods beginTiming Begins measurement of execution time interval. It returns CounterTiming object which has to be called at CounterTiming.endTiming to end the measurement and update the counter.\n public beginTiming(name: string): CounterTiming\n  name: string - a counter name of Interval type. returns: CounterTiming - a callback object to end timing.  endTiming Ends measurement of execution elapsed time and updates specified counter.\n public endTiming(name: string, elapsed: number): void\n  name: string - a counter name elapsed: number - execution elapsed time in milliseconds to update the counter.  increment Increments counter by given value.\n public increment(name: string, value: number): void\n  name: string - a counter name of Increment type. value: number - a value to add to the counter.  incrementOne Increments counter by 1.\n public incrementOne(name: string): void\n  name: string - a counter name of Increment type.  last Records the last calculated measurement value. Usually this method is used by metrics calculated externally.\n public last(name: string, value: number): void\n  name: string - a counter name of Last type. value: number - last value to record.  setReferences Sets references to dependent components.\n public setReferences(references: IReferences): void\n  references: IReferences - references to locate the component dependencies.  stats Calculates min/average/max statistics based on the current and previous values.\n public stats(name: string, value: number): void\n  name: string - a counter name of Statistics type value: number - a value to update statistics  timestamp Records the given timestamp.\n public timestamp(name: string, value: Date)\n  name: string - a counter name of Timestamp type. value: Date - a timestamp to record.  timestampNow Records the current time as a timestamp.\n public timestampNow(name: string)\n  name: string - a counter name of Timestamp type.  Examples class MyComponent implements IReferenceable { private _counters: CompositeCounters = new CompositeCounters(); public setReferences(references: IReferences): void { this._counters.setReferences(references); ... } public myMethod(): void { this._counters.increment(\u0026#34;mycomponent.mymethod.calls\u0026#34;); var timing = this._counters.beginTiming(\u0026#34;mycomponent.mymethod.exec_time\u0026#34;); try { ... } finally { timing.endTiming(); } } } See also   ICounters   ","description":"Aggregates all counters from component references into a single one.\n","image":null,"permalink":"/node/components/count/composite_counters/","subtitle":null,"tags":null,"title":"CompositeCounters"},{"content":"Implements: ICounters, IReconfigurable, ICounterTimingCallback\nDescription The CompositeCounters allows you to aggregate all counters from different component references into a single one.\nImportant points\n It allows to capture metrics and conveniently send them to multiple destinations.  References  *:counters:*:*:1.0 - (optional) ICounters components to pass collected measurements  Constructors Creates a new instance of the counters.\n CompositeCounters(references: IReferences = None)\n  references: IReferences - references to locate the component dependencies.  Fields _counters A list containig the aggregated counters.\n _counters: List[ICounters] = []\n  Instance methods begin_timing Begins measurement of execution time interval. It returns CounterTiming object which has to be called at CounterTiming.end_timing to end the measurement and update the counter.\n begin_timing(name: str): CounterTiming\n  name: str - a counter name of Interval type. returns: CounterTiming - a callback object to end timing.  end_timing Ends measurement of execution elapsed time and updates specified counter.\n end_timing(name: str, elapsed: float)\n  name: str - a counter name elapsed: float - execution elapsed time in milliseconds to update the counter.  increment Increments counter by given value.\n increment(name: str, value: float)\n  name: str - a counter name of Increment type. value: float - a value to add to the counter.  increment_one Increments counter by 1.\n increment_one(name: str)\n  name: str - a counter name of Increment type.  last Records the last calculated measurement value. Usually this method is used by metrics calculated externally.\n last(name: str, value: float)\n  name: str - a counter name of Last type. value: float - last value to record.  set_references Sets references to dependent components.\n set_references(references: IReferences)\n  references: IReferences - references to locate the component dependencies.  stats Calculates min/average/max statistics based on the current and previous values.\n stats(name: str, value: float)\n  name: str - a counter name of Statistics type value: float - a value to update statistics  timestamp Records the given timestamp.\n timestamp(name: str, value: datetime.datetime)\n  name: str - a counter name of Timestamp type. value: float - a timestamp to record.  timestamp_now Records the current time as a timestamp.\n timestamp_now(name: str)\n  name: str - a counter name of Timestamp type.  class MyComponent(IReferenceable): _counters: CompositeCounters = CompositeCounters() def setReferences(self, references: IReferences): self._counters.set_references(references) ... def myMethod(self): this._counters.increment(\u0026#34;mycomponent.mymethod.calls\u0026#34;) var timing = this._counters.begin_timing(\u0026#34;mycomponent.mymethod.exec_time\u0026#34;) try: ... except: timing.end_timing() See also   ICounters   ","description":"Aggregates all counters from component references into a single one.\n","image":null,"permalink":"/python/components/count/composite_counters/","subtitle":null,"tags":null,"title":"CompositeCounters"},{"content":"Description The CompositeFactory class allows you to aggregate multiple factories into a single factory component.\nImportant points\n When a new component is requested, it iterates through factories to locate the one able to create the requested component. Usually used to keep all supported factories in a single place.  Constructors NewCompositeFactoryFromFactories Creates a new instance of the factory.\n NewCompositeFactoryFromFactories(factories \u0026hellip;IFactory) *CompositeFactory\n  factories: \u0026hellip;IFactory - list of factories to embed into this factory.  NewCompositeFactory  NewCompositeFactory() *CompositeFactory\n Methods Add Adds a factory into the list of embedded factories.\n (c *CompositeFactory) Add(factory IFactory)\n  factory: IFactory - factory to be added.  CanCreate Checks if this factory is able to create a component by a given locator.\nThis method searches for all registered components and returns a locator for component it is able to create that matches the given locator. If the factory is not able to create a requested component it returns nil.\n (c *CompositeFactory) CanCreate(locator interface{}) interface{}\n  locator: interface{} - a locator to identify component to be created. returns: interface{} - a locator for a component that the factory is able to create.  Create Creates a component identified by given locator.\n (c *CompositeFactory) Create(locator interface{}) (interface{}, error)\n  locator: interface{} - locator to identify component to be created. returns: (interface{}, error) - created component.  Remove Removes a factory from the list of embedded factories.\n (c *CompositeFactory) Remove(factory IFactory)\n  factory: IFactory - factory to remove.  Examples factory := NewCompositeFactory(); factory.Add(NewDefaultLoggerFactory()); factory.Add(NewDefaultCountersFactory()); loggerLocator := NewDescriptor(\u0026#34;*\u0026#34;, \u0026#34;logger\u0026#34;, \u0026#34;*\u0026#34;, \u0026#34;*\u0026#34;, \u0026#34;1.0\u0026#34;); factory.CanCreate(loggerLocator); // Result: Descriptor(\u0026#34;pip-service\u0026#34;, \u0026#34;logger\u0026#34;, \u0026#34;null\u0026#34;, \u0026#34;default\u0026#34;, \u0026#34;1.0\u0026#34;) factory.Create(loggerLocator); // Result: created NullLogger ","description":"Aggregates multiple factories into a single factory component.\n","image":null,"permalink":"/golang/components/build/composite_factory/","subtitle":null,"tags":null,"title":"CompositeFactory"},{"content":"Inherits: IFactory\nDescription The CompositeFactory class allows you to aggregate multiple factories into a single factory component.\nImportant points\n When a new component is requested, it iterates through factories to locate the one able to create the requested component. Usually used to keep all supported factories in a single place.  Constructors Creates a new instance of the factory.\n public CompositeFactory(params IFactory[] factories)\n  factories: IFactory[] - a list of factories to embed into this factory.  Creates a new instance of the factory.\n public CompositeFactory()\n Instance methods Add Adds a factory into the list of embedded factories.\n public void Add(IFactory factory)\n  factory: IFactory - a factory to be added.  CanCreate Checks if this factory is able to create component by a given locator.\nThis method searches for all registered components and returns a locator for component it is able to create that matches the given locator. If the factory is not able to create a requested component it returns null.\n public object CanCreate(object locator)\n  locator: object - a locator to identify component to be created. returns: object - a locator for a component that the factory is able to create.  Create Creates a component identified by given locator.\n public object Create(object locator)\n  locator: object - a locator to identify component to be created. returns: object - the created component.  Remove Removes a factory from the list of embedded factories.\n public void Remove(IFactory factory)\n  factory: IFactory - the factory to remove.  Examples var factory = new CompositeFactory(); factory.Add(new DefaultLoggerFactory()); factory.Add(new DefaultCountersFactory()); var loggerLocator = new Descriptor(\u0026#34;*\u0026#34;, \u0026#34;logger\u0026#34;, \u0026#34;*\u0026#34;, \u0026#34;*\u0026#34;, \u0026#34;1.0\u0026#34;); factory.CanCreate(loggerLocator); // Result: Descriptor(\u0026#34;pip-service\u0026#34;, \u0026#34;logger\u0026#34;, \u0026#34;null\u0026#34;, \u0026#34;default\u0026#34;, \u0026#34;1.0\u0026#34;) factory.Create(loggerLocator); // Result: created NullLogger ","description":"Aggregates multiple factories into a single factory component.\n","image":null,"permalink":"/net/components/build/composite_factory/","subtitle":null,"tags":null,"title":"CompositeFactory"},{"content":"Implements: IFactory\nDescription The CompositeFactory class allows you to aggregate multiple factories into a single factory component.\nImportant points\n When a new component is requested, it iterates through factories to locate the one able to create the requested component. Usually used to keep all supported factories in a single place.  Constructors Creates a new instance of the factory.\n public constructor(\u0026hellip;factories: IFactory[])\n  factories: IFactory[] - a list of factories to embed into this factory.  Instance methods add Adds a factory into the list of embedded factories.\n public add(factory: IFactory): void\n  factory: IFactory - a factory to be added.  canCreate Checks if this factory is able to create component by a given locator.\nThis method searches for all registered components and returns a locator for component it is able to create that matches the given locator. If the factory is not able to create a requested component it returns null.\n public canCreate(locator: any): any\n  locator: any - a locator to identify component to be created. returns: any - a locator for a component that the factory is able to create.  create Creates a component identified by given locator.\n public create(locator: any): any\n  locator: any - a locator to identify component to be created. returns: any - the created component.  remove Removes a factory from the list of embedded factories.\n public remove(factory: IFactory): void\n  factory: IFactory - the factory to remove.  Examples let factory = new CompositeFactory(); factory.add(new DefaultLoggerFactory()); factory.add(new DefaultCountersFactory()); let loggerLocator = new Descriptor(\u0026#34;*\u0026#34;, \u0026#34;logger\u0026#34;, \u0026#34;*\u0026#34;, \u0026#34;*\u0026#34;, \u0026#34;1.0\u0026#34;); factory.canCreate(loggerLocator); // Result: Descriptor(\u0026#34;pip-service\u0026#34;, \u0026#34;logger\u0026#34;, \u0026#34;null\u0026#34;, \u0026#34;default\u0026#34;, \u0026#34;1.0\u0026#34;) factory.create(loggerLocator); // Result: created NullLogger ","description":"Aggregates multiple factories into a single factory component.\n","image":null,"permalink":"/node/components/build/composite_factory/","subtitle":null,"tags":null,"title":"CompositeFactory"},{"content":"Implements: IFactory\nDescription The CompositeFactory class allows you to aggregate multiple factories into a single factory component.\nImportant points\n When a new component is requested, it iterates through factories to locate the one able to create the requested component. Usually used to keep all supported factories in a single place.  Constructors Creates a new instance of the factory.\n CompositeFactory(*factories: IFactory)\n  factories: IFactory - a list of factories to embed into this factory.  Instance methods add Adds a factory into the list of embedded factories.\n add(factory: IFactory)\n  factory: IFactory - a factory to be added.  can_create Checks if this factory is able to create component by a given locator.\nThis method searches for all registered components and returns a locator for component it is able to create that matches the given locator. If the factory is not able to create a requested component it returns None.\n can_create(locator: Any): Any\n  locator: Any - a locator to identify component to be created. returns: Any - a locator for a component that the factory is able to create.  create Creates a component identified by given locator.\n create(locator: Any): Any\n  locator: Any - a locator to identify component to be created. returns: Any - the created component.  remove Removes a factory from the list of embedded factories.\n remove(factory: IFactory)\n  factory: IFactory - the factory to remove.  Examples factory = CompositeFactory() factory.add(new DefaultLoggerFactory()) factory.add(new DefaultCountersFactory()) loggerLocator = Descriptor(\u0026#34;*\u0026#34;, \u0026#34;logger\u0026#34;, \u0026#34;*\u0026#34;, \u0026#34;*\u0026#34;, \u0026#34;1.0\u0026#34;) factory.can_create(loggerLocator) # Result: Descriptor(\u0026#34;pip-service\u0026#34;, \u0026#34;logger\u0026#34;, \u0026#34;None\u0026#34;, \u0026#34;default\u0026#34;, \u0026#34;1.0\u0026#34;) factory.create(loggerLocator) # Result: created NullLogger ","description":"Aggregates multiple factories into a single factory component.\n","image":null,"permalink":"/python/components/build/composite_factory/","subtitle":null,"tags":null,"title":"CompositeFactory"},{"content":"Implements: Logger\nDescription The CompositeLogger class allows you to aggregate loggers from component references into a single component.\nImportant points\n It allows to log messages and conveniently send them to multiple destinations.  References  *:logger:*:*:1.0 - (optional) ILogger components to pass log messages  Constructors NewCompositeLoggerFromReferences Creates a new instance of the logger.\n NewCompositeLoggerFromReferences(references refer.IReferences) *CompositeLogger\n  references: refer.IReferences - references to locate the component dependencies.  NewCompositeLogger Creates a new instance of the logger.\n NewCompositeLogger() *CompositeLogger\n Methods SetReferences Sets references to dependent components.\n (c *CompositeLogger) SetReferences(references refer.IReferences)\n  references: refer.IReferences - references to locate the component dependencies.  Write Writes a log message to the logger destination.\n (c *CompositeLogger) Write(level int, correlationId string, err error, message string)\n  level: int - log level. correlationId: string - (optional) transaction id used to trace execution through the call chain. err: error - error object associated with this message. message: string - human-readable message to log.  Examples type MyComponent { _logger CompositeLogger } func (mc* MyComponent) Configure(config: ConfigParams): void { mc._logger.Configure(config); ... } func (mc* MyComponent) SetReferences(references: IReferences): void { mc._logger.SetReferences(references); ... } func (mc* MyComponent)myMethod(string correlationId): void { mc._logger.Debug(correlationId, \u0026#34;Called method mycomponent.mymethod\u0026#34;); ... } var mc MyComponent = MyComponent{} mc._logger = NewCompositeLogger(); See also   ILogger   ","description":"Aggregates all loggers from component references under a single component.\n","image":null,"permalink":"/golang/components/log/composite_logger/","subtitle":null,"tags":null,"title":"CompositeLogger"},{"content":"Inherits: IReferenceable, Logger\nDescription The CompositeLogger class allows you to aggregate loggers from component references into a single component.\nImportant points\n It allows to log messages and conveniently send them to multiple destinations.  References  *:logger:*:*:1.0 - (optional) ILogger components to pass log messages  Constructors Creates a new instance of the logger.\n public CompositeLogger(IReferences references = null)\n  references: IReferences - references to locate the component dependencies.  Fields _loggers  protected _loggers: List\u0026lt;ILogger\u0026gt; = new List\u0026lt;ILogger\u0026gt;()\n  Instance methods SetReferences Sets references to dependent components.\n public override void SetReferences(IReferences references)\n  references: IReferences - references to locate the component dependencies.  Write Writes a log message to the logger destination.\n protected override void Write(LogLevel level, string correlationId, Exception error, string message)\n  level: LogLevel - a log level. correlationId: string - (optional) transaction id to trace execution through call chain. error: Exception - an error object associated with this message. message: string - a human-readable message to log.  Examples class MyComponent: IConfigurable, IReferenceable { CompositeLogger _logger = new CompositeLogger(); public void Configure(ConfigParams config) { this._logger.Configure(config); ... } public void SetReferences(IReferences references) { this._logger.SetReferences(references); ... } public void MyMethod(String correlationId) { this._logger.Debug(correlationId, \u0026#34;Called method mycomponent.mymethod\u0026#34;); ... } } See also   ILogger   ","description":"Aggregates all loggers from component references under a single component.\n","image":null,"permalink":"/net/components/log/composite_logger/","subtitle":null,"tags":null,"title":"CompositeLogger"},{"content":"Implements: IReferenceable\nExtends: Logger\nDescription The CompositeLogger class allows you to aggregate loggers from component references into a single component.\nImportant points\n It allows to log messages and conveniently send them to multiple destinations.  References  *:logger:*:*:1.0 - (optional) ILogger components to pass log messages  Constructors Creates a new instance of the logger.\n public constructor(references: IReferences = null)\n  references: IReferences - references to locate the component dependencies.  Instance methods setReferences Sets references to dependent components.\n public setReferences(references: IReferences): void\n  references: IReferences - references to locate the component dependencies.  write Writes a log message to the logger destination.\n protected write(level: LogLevel, correlationId: string, error: Error, message: string): void\n  level: LogLevel - a log level. correlationId: string - (optional) transaction id to trace execution through call chain. error: Error - an error object associated with this message. message: string - a human-readable message to log.  Examples class MyComponent implements IConfigurable, IReferenceable { private _logger: CompositeLogger = new CompositeLogger(); public configure(config: ConfigParams): void { this._logger.configure(config); ... } public setReferences(references: IReferences): void { this._logger.setReferences(references); ... } public myMethod(string correlationId): void { this._logger.debug(correlationId, \u0026#34;Called method mycomponent.mymethod\u0026#34;); ... } } See also   ILogger   ","description":"Aggregates all loggers from component references under a single component.\n","image":null,"permalink":"/node/components/log/composite_logger/","subtitle":null,"tags":null,"title":"CompositeLogger"},{"content":"Implements: Logger, IReferenceable\nDescription The CompositeLogger class allows you to aggregate loggers from component references into a single component.\nImportant points\n It allows to log messages and conveniently send them to multiple destinations.  References  *:logger:*:*:1.0 - (optional) ILogger components to pass log messages  Constructors Creates a new instance of the logger.\n CompositeLogger(references: IReferences = None)\n  references: IReferences - references to locate the component dependencies.  Instance methods set_references Sets references to dependent components.\n set_references(references: IReferences)\n  references: IReferences - references to locate the component dependencies.  _write Writes a log message to the logger destination.\n _write(level: LogLevel, correlation_id: Optional[str], error: Optional[Exception], message: Optional[str])\n  level: LogLevel - a log level. correlation_id: Optional[str] - (optional) transaction id to trace execution through call chain. error: Optional[Exception] - an error object associated with this message. message: Optional[str] - a human-readable message to log.  Examples class MyComponent(IConfigurable, IReferenceable): __logger = CompositeLogger() def configure(self, config): self.__logger.configure(config) def set_references(self, references): self.__logger.set_references(references) def my_method(self, correlation_id): self.__logger.debug(correlation_id, \u0026#34;Called method mycomponent.mymethod\u0026#34;) See also   ILogger   ","description":"Aggregates all loggers from component references under a single component.\n","image":null,"permalink":"/python/components/log/composite_logger/","subtitle":null,"tags":null,"title":"CompositeLogger"},{"content":"Description The CompositeTracer class allows you to aggregate all tracers from component references under a single component.\nReferences  *:tracer:*:*:1.0 - (optional) ITracer components to pass operation tracessource  Constructors NewCompositeTracer Creates a new instance of the tracer.\n NewCompositeTracer(references cref.IReferences) *CompositeTracer\n  references: cref.IReferences - references to locate the component dependencies.  Fields Tracers List of tracers\n Tracers: []ITracer\n  Methods BeginTrace Begings recording an operation trace\n (c *CompositeTracer) BeginTrace(correlationId string, component string, operation string) *TraceTiming\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. component: string - name of the called component operation: string - name of the executed operation. return: *TraceTiming - trace timing object.  Failure Records an operation failure with its name, duration and error\n (c *CompositeTracer) Failure(correlationId string, component string, operation string, err error, duration int64)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. component: string - name of the called component operation: string - name of the executed operation. err: error - error object associated with this trace. duration: int64 - execution duration in milliseconds.  SetReferences Sets references to dependent components.\n (c *CompositeTracer) SetReferences(references cref.IReferences\n  references: cref.IReferences - references to locate the component\u0026rsquo;s dependencies.  Trace Records an operation trace with its name and duration\n (c *CompositeTracer) Trace(correlationId string, component string, operation string, duration int64)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. component: string - name of the called component operation: string - name of the executed operation. duration: int64 - execution duration in milliseconds.  Examples type MyComponent struct { tracer CompositeTracer } func NewMyComponent() *MyComponent{ return \u0026amp;MyComponent{ tracer: NewCompositeTracer(nil); } } func (c* MyComponent) SetReferences(references IReferences) { c.tracer.SetReferences(references) ... } func (c* MyComponent) MyMethod(correlatonId string) { timing := c.tracer.BeginTrace(correlationId, \u0026#34;mycomponent\u0026#34;, \u0026#34;mymethod\u0026#34;); ... timing.EndTrace(); if err != nil { timing.EndFailure(err); } } See also   ITracer   ","description":"Aggregates all tracers from component references under a single component.\nIt allows to record traces and conveniently send them to multiple destinations. \n","image":null,"permalink":"/golang/components/trace/composite_tracer/","subtitle":null,"tags":null,"title":"CompositeTracer"},{"content":"Inherits: ITracer, IReferenceable\nDescription The CompositeTracer class allows you to aggregate all tracers from component references under a single component.\nReferences  *:tracer:*:*:1.0 - (optional) ITracer components to pass operation tracessource  Constructors Creates a new instance of the tracer.\n public CompositeTracer(IReferences references = null)\n  references: IReferences - references to locate the component dependencies.  Fields _tracers List of tracers\n protected _tracers: IList\u0026lt;ITracer\u0026gt; = new List\u0026lt;ITracer\u0026gt;()\n  Instance methods BeginTrace Begings recording an operation trace\n public TraceTiming BeginTrace(string correlationId, string component, string operation)\n  correlationId: string - (optional) transaction id to trace execution through call chain. component: string - name of the called component operation: string - name of the executed operation. return: TraceTiming - a trace timing object.  Failure Records an operation failure with its name, duration and error\n public void Failure(string correlationId, string component, string operation, Exception error, long duration)\n  correlationId: string - (optional) transaction id to trace execution through call chain. component: string - name of the called component operation: string - name of the executed operation. error: Exception - an error object associated with this trace. duration: long - execution duration in milliseconds.  SetReferences Sets references to dependent components.\n public void SetReferences(references: IReferences)\n  references: IReferences - references to locate the component dependencies.  Trace Records an operation trace with its name and duration\n public void Trace(string correlationId, string component, string operation, long duration)\n  correlationId: string - (optional) transaction id to trace execution through call chain. component: string - a name of called component operation: string - a name of the executed operation. duration: long - execution duration in milliseconds.  Examples class MyComponent: IReferenceable { private CompositeTracer _tracer = new CompositeTracer(); public void SetReferences(IReferences references) { _tracer.SetReferences(references); ... } public void MyMethod(string correlatonId) { var timing = this._tracer.BeginTrace(correlationId, \u0026#34;mycomponent\u0026#34;, \u0026#34;mymethod\u0026#34;); try { ... timing.EndTrace(); } catch { timing.EndFailure(err); } } } See also   ITracer   ","description":"Aggregates all tracers from component references under a single component.\nIt allows to record traces and conveniently send them to multiple destinations. \n","image":null,"permalink":"/net/components/trace/composite_tracer/","subtitle":null,"tags":null,"title":"CompositeTracer"},{"content":"Implements: ITracer, IReferenceable\nDescription The CompositeTracer class allows you to aggregate all tracers from component references under a single component.\nReferences  *:tracer:*:*:1.0 - (optional) ITracer components to pass operation tracessource  Constructors Creates a new instance of the tracer.\n public constructor(references: IReferences = null)\n  references: IReferences - references to locate the component dependencies.  Fields _tracers List of tracers\n protected _tracers: ITracer[]\n  Instance methods beginTrace Begings recording an operation trace\n public beginTrace(correlationId: string, component: string, operation: string): TraceTiming\n  correlationId: string - (optional) transaction id to trace execution through call chain. component: string - name of the called component operation: string - name of the executed operation. return: TraceTiming - a trace timing object.  failure Records an operation failure with its name, duration and error\n public failure(correlationId: string, component: string, operation: string, error: Error, duration: number)\n  correlationId: string - (optional) transaction id to trace execution through call chain. component: string - name of the called component operation: string - name of the executed operation. error: Error - an error object associated with this trace. duration: number - execution duration in milliseconds.  setReferences Sets references to dependent components.\n public setReferences(references: IReferences)\n  references: IReferences - references to locate the component dependencies.  trace Records an operation trace with its name and duration\n public trace(correlationId: string, component: string, operation: string, duration: number)\n  correlationId: string - (optional) transaction id to trace execution through call chain. component: string - a name of called component operation: string - a name of the executed operation. duration: number - execution duration in milliseconds.  Examples class MyComponent implements IReferenceable { private _tracer: CompositeTracer = new CompositeTracer(); public setReferences(references: IReferences): void { this._tracer.setReferences(references); ... } public myMethod(correlatonId: string): void { var timing = this._tracer.beginTrace(correlationId, \u0026#34;mycomponent\u0026#34;, \u0026#34;mymethod\u0026#34;); try { ... timing.endTrace(); } catch (err) { timing.endFailure(err); } } } See also   ITracer   ","description":"Aggregates all tracers from component references under a single component.\nIt allows to record traces and conveniently send them to multiple destinations. \n","image":null,"permalink":"/node/components/trace/composite_tracer/","subtitle":null,"tags":null,"title":"CompositeTracer"},{"content":"Implements: ITracer, IReferenceable\nDescription The CompositeTracer class allows you to aggregate all tracers from component references under a single component.\nReferences  *:tracer:*:*:1.0 - (optional) ITracer components to pass operation tracessource  Constructors Creates a new instance of the tracer.\n CompositeTracer(references: IReferences = None)\n  references: IReferences - references to locate the component dependencies.  Fields _TRACERS List of tracers\n _TRACERS: List[ITracer] = []\n  Instance methods begin_trace Begings recording an operation trace\n begin_trace(correlation_id: Optional[str], component: str, operation: str): TraceTiming\n  correlation_id: Optional[str] - (optional) transaction id to trace execution through call chain. component: str - name of the called component operation: str - name of the executed operation. return: TraceTiming - a trace timing object.  failure Records an operation failure with its name, duration and error\n failure(correlation_id: Optional[str], component: str, operation: str, error: Exception, duration: float)\n  correlation_id: Optional[str] - (optional) transaction id to trace execution through call chain. component: str - name of the called component operation: str - name of the executed operation. error: Exception - an error object associated with this trace. duration: float - execution duration in milliseconds.  set_references Sets references to dependent components.\n set_references(references: IReferences)\n  references: IReferences - references to locate the component dependencies.  trace Records an operation trace with its name and duration\n trace(correlation_id: Optional[str], component: str, operation: str, duration: float)\n  correlation_id: Optional[str] - (optional) transaction id to trace execution through call chain. component: str - a name of called component operation: str - a name of the executed operation. duration: float - execution duration in milliseconds.  Examples class MyComponent(IReferenceable): def __init__(self): self.__tracer = CompositeTracer() def set_references(self, references: IReferences): self.__tracer.set_references(references) ... def my_method(self, correlaton_id): timing = self.__tracer.begin_trace(correlaton_id, \u0026#34;mycomponent\u0026#34;, \u0026#34;mymethod\u0026#34;) try: ... timing.end_trace() except Exception as err: timing.end_failure(err) See also   ITracer   ","description":"Aggregates all tracers from component references under a single component.\nIt allows to record traces and conveniently send them to multiple destinations. \n","image":null,"permalink":"/python/components/trace/composite_tracer/","subtitle":null,"tags":null,"title":"CompositeTracer"},{"content":"Description The Configerror is used to manage errors related to mistakes in a microservice\u0026rsquo;s user-defined configurations.\nConstructors NewConfigError Creates an error instance and assigns its values.\n NewConfigError(correlationId, code, message string) *ApplicationError\n  correlationId: string - (optional) unique transaction id used to trace execution through the call chain. code: string - (optional) unique error code. Default: \u0026ldquo;UNKNOWN\u0026rdquo; message: string - (optional) a human-readable description of the error.  ","description":"Errors related to mistakes in microservice's user-defined configurations.\n","image":null,"permalink":"/golang/commons/errors/config_error/","subtitle":null,"tags":null,"title":"Configerror"},{"content":"Inherits: ApplicationException\nDescription The ConfigException is used to manage errors related to mistakes in microservice\u0026rsquo;s user-defined configurations.\nConstructors Creates an error instance and assigns its values.\n public ConfigException(string correlationId = null, string code = null, string message = null)\n  correlationId: string - (optional) unique transaction id used to trace execution through the call chain. code: string - (optional) unique error code. Default: \u0026ldquo;UNKNOWN\u0026rdquo; message: string - (optional) human-readable description of the error.  Creates an error instance with an error message.\n public ConfigException(string message)\n  message: string - human-readable description of the error.  Creates an error instance with a misconfiguration error category and assigns its values.\n public ConfigException(Exception innerException)\n  innerException: Exception - error object  Creates an error instance by processing native C# Exceptions.\n protected ConfigException(SerializationInfo info, StreamingContext context)\n  info: SerializationInfo - serialized information containing the serialized object data about the exception being thrown. context: StreamingContext - streaming context containing contextual information about the source or destination.  ","description":"Errors related to mistakes in microservice's user-defined configurations.\n","image":null,"permalink":"/net/commons/errors/config_exception/","subtitle":null,"tags":null,"title":"ConfigException"},{"content":"Extends: ApplicationException\nDescription The ConfigException is used to manage errors related to mistakes in microservice\u0026rsquo;s user-defined configurations.\nConstructors Creates an error instance and assigns its values.\n public constructor(correlation_id: string = null, code: string = null, message: string = null)\n  correlation_id: string - (optional) unique transaction id used to trace execution through the call chain. code: string - (optional) unique error code. Default: \u0026ldquo;UNKNOWN\u0026rdquo;. message: string - (optional) human-readable description of the error.  ","description":"Errors related to mistakes in microservice's user-defined configurations.\n","image":null,"permalink":"/node/commons/errors/config_exception/","subtitle":null,"tags":null,"title":"ConfigException"},{"content":"Implements: ApplicationException\nDescription The ConfigException is used to manage errors related to mistakes in microservice\u0026rsquo;s user-defined configurations.\nConstructors Creates an error instance and assigns its values.\n ConfigException(correlation_id: Optional[str] = None, code: str = None, message: str = None)\n  correlation_id: Optional[str] - (optional) a unique transaction id to trace execution through call chain. code: str - (optional) a unique error code. Default: \u0026ldquo;UNKNOWN\u0026rdquo; message: str - (optional) a human-readable description of the error.  ","description":"Errors related to mistakes in microservice's user-defined configurations.\n","image":null,"permalink":"/python/commons/errors/config_exception/","subtitle":null,"tags":null,"title":"ConfigException"},{"content":"Implements: StringValueMap\nSee also IConfigurable, StringValueMap\nDescription The ConfigParams class contains a key-value map with configuration parameters. It allows you to define configuration parameters that can be used, for example, to define access control credentials.\nImportant points:\n In general, ConfigParams is used to pass configurations to IConfigurable objects. It also serves as a basis for more concrete configurations, such as ConnectionParams or CredentialParams. This class stores all values as strings. These values can be serialized as JSON or string forms. When retrieved the values can be automatically converted using GetAsXXX methods. The keys are case-sensitive, so it is recommended to use consistent C-style, such as “my_param”. Configuration parameters can be broken into sections and subsections using dot notation, such as “section1.subsection1.param1”. Using GetSection method all parameters from the specified section can be extracted from a ConfigMap. The ConfigParams class supports serialization from/to plain strings as: “key1=123;key2=ABC;key3=2016-09-16T00:00:00.00Z”  Constructors Creates a new empty ConfigParams object. See StringValueMap.constructors\n NewEmptyConfigParams() *ConfigParams\n Creates a new ConfigParams from a map.\n NewConfigParams(values map[string]string) *ConfigParams\n  values: map[string]string - map with key-value pairs  Creates a new ConfigParams object filled with key-value pairs from specified object.\n NewConfigParamsFromValue(value interface{}) *ConfigParams\n  values: interface{} - object with key-value pairs used to initialize a new ConfigParams.  Creates a new ConfigParams object filled with provided key-value pairs called tuples. Tuples parameters contain a sequence of key1, value1, key2, value2, \u0026hellip; pairs.\n NewConfigParamsFromTuples(tuples \u0026hellip;interface{}) *ConfigParams\n  values: \u0026hellip;interface{} - the tuples to fill a new ConfigParams object.  Creates a new StringValueMap from a list of key-value pairs called tuples. The method is similar to fromTuples but tuples are passed as an array instead of as parameters.\n NewConfigParamsFromTuplesArray(tuples []interface{}) *ConfigParams\n  values: []interface{} - list of values where odd elements are keys and the following even elements are values  Creates a new ConfigParams object filled with key-value pairs serialized as a string.\nExample: \u0026ldquo;Key1=123;Key2=ABC;Key3=2016-09-16T00:00:00.00Z\u0026rdquo;\n NewConfigParamsFromString(line string) *ConfigParams\n  line: string - a string with serialized key-value pairs as \u0026ldquo;key1=value1;key2=value2;\u0026hellip;\u0026quot;  Creates a new ConfigParams by merging two or more maps. Maps defined later in the list override values from previously defined maps.\n NewConfigParamsFromMaps(maps \u0026hellip;map[string]string) *ConfigParams\n  maps: \u0026hellip;map[string]string - an array of maps to be merged  Methods AddSection Adds parameters into this ConfigParams under specified section. Keys for the new parameters are appended with section dot prefix.\n (c *ConfigParams) AddSection(section string, sectionParams *ConfigParams)\n  section: string - name of the section where add new parameters sectionParams: *ConfigParams - new parameters to be added.  GetSection Gets parameters from specific section stored in this ConfigMap. The section name is removed from parameter keys.\n (c *ConfigParams) GetSection(section string) *ConfigParams\n  section: string - name of the section to retrieve configuration parameters from. returns: *ConfigParams - all configuration parameters that belong to the section named \u0026lsquo;section\u0026rsquo;.  GetSectionNames Gets a list with all 1st level section names.\n (c *ConfigParams) GetSectionNames() []string\n  returns: string[] - list of section names stored in this ConfigMap.  Override Overrides parameters with new values from specified ConfigParams and returns a new ConfigParams object.\n (c *ConfigParams) Override(configParams *ConfigParams) *ConfigParams\n  configParams: *ConfigParams - ConfigMap with parameters to override the current values. returns: *ConfigParams - new ConfigParams object.  SetDefaults Set default values from specified ConfigParams and returns a new ConfigParams object.\n (c *ConfigParams) SetDefaults(defaults *ConfigParams) *ConfigParams\n  defaults: *ConfigParams - ConfigMap with default parameter values. returns: *ConfigParams - new ConfigParams object.  Examples config := NewConfigParamsFromTuples( \u0026#34;section1.key1\u0026#34;, \u0026#34;AAA\u0026#34;, \u0026#34;section1.key2\u0026#34;, 123, \u0026#34;section2.key1\u0026#34;, true ); config.GetAsString(\u0026#34;section1.key1\u0026#34;); // Result: AAA config.GetAsInteger(\u0026#34;section1.key1\u0026#34;); // Result: 0  section1 = config.GetSection(\u0026#34;section2\u0026#34;); section1.GetAsString(\u0026#34;key1\u0026#34;); // Result: true  See also   IConfigurable   StringValueMap   ","description":"Contains a key-value map with configuration parameters. \n\n \n","image":null,"permalink":"/golang/commons/config/config_params/","subtitle":null,"tags":null,"title":"ConfigParams"},{"content":"Inherits: StringValueMap\nSee also IConfigurable, StringValueMap\nDescription The ConfigParams class contains a key-value map with configuration parameters. It allows you to define configuration parameters that can be used, for example, to define access control credentials.\nImportant points:\n In general, ConfigParams is used to pass configurations to IConfigurable objects. It also serves as a basis for more concrete configurations, such as ConnectionParams or CredentialParams. This class stores all values as strings. These values can be serialized as JSON or string forms. When retrieved the values can be automatically converted using GetAsXXX methods. The keys are case-sensitive, so it is recommended to use consistent C-style, such as “my_param”. Configuration parameters can be broken into sections and subsections using dot notation, such as “section1.subsection1.param1”. Using GetSection method all parameters from the specified section can be extracted from a ConfigMap. The ConfigParams class supports serialization from/to plain strings, such as: “key1=123;key2=ABC;key3=2016-09-16T00:00:00.00Z”  Constructors Creates a new ConfigParams and fills it with values. See StringValueMap.constructors\n public ConfigParams(IDictionary\u0026lt;string, string\u0026gt; content)\n  content: IDictionary\u0026lt;string, string\u0026gt; - (optional) object to be converted into key-value pairs to initialize this config map.  Instance Methods AddSection Adds parameters into this ConfigParams under a specified section. Keys for the new parameters are appended with section dot prefix.\n public void AddSection(string section, ConfigParams sectionParams)\n  section: string - name of the section where add new parameters sectionParams: ConfigParams - new parameters to be added.  IsShadowName Detect commented sections. \u0026ldquo;Shadow\u0026rdquo; section names starts with # or !.\n protected bool IsShadowName(string name)\n  name: bool - true if is the \u0026ldquo;shadow\u0026rdquo; section  GetSection Gets parameters from specific section stored in this ConfigMap. The section name is removed from parameter keys.\n public ConfigParams GetSection(string section)\n  section: string - name of the section to retrieve configuration parameters from. returns: ConfigParams - all configuration parameters that belong to the section named \u0026lsquo;section\u0026rsquo;.  GetSectionNames Gets a list with all 1st level section names.\n public IEnumerable\u0026lt;string\u0026gt; GetSectionNames()\n  returns: IEnumerable\u0026lt;string\u0026gt; - list of section names stored in this ConfigMap.  Override Overrides parameters with new values from specified ConfigParams and returns a new ConfigParams object.\n public ConfigParams Override(ConfigParams configParams)\n  configParams: ConfigParams - ConfigMap with parameters to override the current values. returns: ConfigParams - new ConfigParams object.  SetDefaults Set default values from specified ConfigParams and returns a new ConfigParams object.\n public ConfigParams SetDefaults(ConfigParams defaultConfigParams)\n  defaultConfigParams: ConfigParams - ConfigMap with default parameter values. returns: ConfigParams - new ConfigParams object.  Static methods FromString Creates a new ConfigParams object filled with key-value pairs serialized as a string.\n public static ConfigParams FromString(line: string)\n  line: string - string with serialized key-value pairs as \u0026ldquo;key1=value1;key2=value2;\u0026hellip;\u0026rdquo;\nExample: \u0026ldquo;Key1=123;Key2=ABC;Key3=2016-09-16T00:00:00.00Z\u0026rdquo; returns: ConfigParams - new ConfigParams object.  FromTuples Creates a new ConfigParams object filled with provided key-value pairs called tuples. Tuples parameters contain a sequence of key1, value1, key2, value2, \u0026hellip; pairs.\nSee StringValueMap.fromTuplesArray\n public static ConfigParams FromTuples(params object[] tuples)\n  tuples: object[] - tuples to fill a new ConfigParams object. returns: ConfigParams - new ConfigParams object.  FromValue Creates a new ConfigParams object filled with key-value pairs from the specified object.\n public static ConfigParams FromValue(object value)\n  value: object - object with key-value pairs used to initialize a new ConfigParams. returns: ConfigParams - new ConfigParams object.  MergeConfigs Merges two or more ConfigParams into one. The following ConfigParams override previously defined parameters.\nSee StringValueMap.fromMaps\n public static ConfigParams MergeConfigs(params IDictionary\u0026lt;string, string\u0026gt;[] configs)\n  configs: IDictionary\u0026lt;string, string\u0026gt;[] - list of ConfigParams objects to be merged. returns: ConfigParams - new ConfigParams object.  Examples // Create a ConfigParams object from a tuple var config = ConfigParams.FromTuples(\u0026#34;section1.key1\u0026#34;, \u0026#34;AAA\u0026#34;, \u0026#34;section1.key2\u0026#34;, 123, \u0026#34;section2.key1\u0026#34;, true); // Create a ConfigParams object from a string config = ConfigParams.FromTuples(\u0026#34;section1.key1=AAA;section1.key2=123;section2.key1=True\u0026#34;); // Create a ConfigParams object from a value var obj = {\u0026#34;section1.key1\u0026#34;: \u0026#34;AAA\u0026#34;, \u0026#34;section1.key2\u0026#34;: 123, \u0026#34;section2.key1\u0026#34;: true}; // Create a object config = ConfigParams.FromValue(obj); // Create the ConfigParams object using the object  // Add a new section config.AddSection(\u0026#34;section3\u0026#34;, ConfigParams.FromTuples(\u0026#34;key1\u0026#34;, \u0026#34;ABCDE\u0026#34;)); // Get a section let section1 = config.GetSection(\u0026#34;section1\u0026#34;) // Returns {\u0026#39;key1\u0026#39;: \u0026#39;AAA\u0026#39;, \u0026#39;key2\u0026#39;: \u0026#39;123\u0026#39;}  // Get the section names config.GetSectionNames(); // Returns [\u0026#39;section1\u0026#39;, \u0026#39;section2\u0026#39;]  // Change the value of section1.key1 to BBB config.Override(ConfigParams.FromTuples(\u0026#34;section1.key1\u0026#34;, \u0026#34;BBB\u0026#34;)); See also   IConfigurable   StringValueMap   ","description":"Contains a key-value map with configuration parameters. \n\n \n","image":null,"permalink":"/net/commons/config/config_params/","subtitle":null,"tags":null,"title":"ConfigParams"},{"content":"Extends: StringValueMap\nSee also IConfigurable, StringValueMap\nDescription The ConfigParams class contains a key-value map with configuration parameters. It allows you to define configuration parameters that can be used, for example, to define access control credentials.\nImportant points:\n In general, ConfigParams is used to pass configurations to IConfigurable objects. It also serves as a basis for more concrete configurations, such as ConnectionParams or CredentialParams. This class stores all values as strings. These values can be serialized as JSON or string forms. When retrieved the values can be automatically converted using GetAsXXX methods. The keys are case-sensitive, so it is recommended to use consistent C-style notation, such as “my_param”. Configuration parameters can be broken into sections and subsections using dot notation, such as “section1.subsection1.param1”. Using GetSection method all parameters from the specified section can be extracted from a ConfigMap. The ConfigParams class supports serialization from/to plain strings as: “key1=123;key2=ABC;key3=2016-09-16T00:00:00.00Z”  Constructors Creates a new ConfigParams and fills it with values. See StringValueMap.constructors\n public constructor(values: any = null)\n  values: any - (optional) object to be converted into key-value pairs to initialize this config map.  Instance Methods addSection Adds parameters into this ConfigParams under a specified section. Keys for the new parameters are appended with section dot prefix.\n public addSection(section: string, sectionParams: ConfigParams): void\n  section: string - name of the section where add new parameters sectionParams: ConfigParams - new parameters to be added.  getSection Gets parameters from specific section stored in this ConfigMap. The section name is removed from parameter keys.\n public getSection(section: string): ConfigParams\n  section: string - name of the section to retrieve configuration parameters from. returns: ConfigParams - all configuration parameters that belong to the section named \u0026lsquo;section\u0026rsquo;.  getSectionNames Gets a list with all 1st level section names.\n public getSectionNames(): string[]\n  returns: string[] - list of section names stored in this ConfigMap.  override Overrides parameters with new values from a specified ConfigParams object and returns a new ConfigParams object.\n public override(configParams: ConfigParams): ConfigParams\n  configParams: ConfigParams - ConfigMap with parameters to override the current values. returns: ConfigParams - new ConfigParams object.  setDefaults Set default values from a specified ConfigParams object and returns a new ConfigParams object.\n public setDefaults(defaultConfigParams: ConfigParams): ConfigParams\n  defaultConfigParams: ConfigParams - ConfigMap object with default parameter values. returns: ConfigParams - new ConfigParams object.  Static methods fromString Creates a new ConfigParams object filled with key-value pairs serialized as a string.\n public static fromString(line: string): ConfigParams\n  line: string - string with serialized key-value pairs as \u0026ldquo;key1=value1;key2=value2;\u0026hellip;\u0026rdquo;\nExample: \u0026ldquo;Key1=123;Key2=ABC;Key3=2016-09-16T00:00:00.00Z\u0026rdquo; returns: ConfigParams - new ConfigParams object.  fromTuples Creates a new ConfigParams object filled with provided key-value pairs called tuples. Tuples parameters contain a sequence of key1, value1, key2, value2, \u0026hellip; pairs.\nSee StringValueMap.fromTuplesArray\n public static fromTuples(\u0026hellip;tuples: any[]): ConfigParams\n  tuples: any[] - tuples to fill a new ConfigParams object. returns: ConfigParams - new ConfigParams object.  fromValue Creates a new ConfigParams object filled with key-value pairs from specified object.\n public static fromValue(value: any): ConfigParams\n  value: any - object with key-value pairs used to initialize a new ConfigParams. returns: ConfigParams - new ConfigParams object.  mergeConfigs Merges two or more ConfigParams into one. The following ConfigParams override previously defined parameters.\nSee StringValueMap.fromMaps\n public static mergeConfigs(\u0026hellip;configs: ConfigParams[]): ConfigParams\n  configs: ConfigParams[] - list of ConfigParams objects to be merged. returns: ConfigParams - new ConfigParams object.  Examples // Create a ConfigParams object from a tuple let config = ConfigParams.fromTuples(\u0026#34;section1.key1\u0026#34;, \u0026#34;AAA\u0026#34;, \u0026#34;section1.key2\u0026#34;, 123, \u0026#34;section2.key1\u0026#34;, true); // Create a ConfigParams object from a string config = ConfigParams.fromString(\u0026#34;section1.key1=AAA;section1.key2=123;section2.key1=True\u0026#34;); // Create a ConfigParams object from a value let obj = {\u0026#34;section1.key1\u0026#34;: \u0026#34;AAA\u0026#34;, \u0026#34;section1.key2\u0026#34;: 123, \u0026#34;section2.key1\u0026#34;: true}; // Create a object config = ConfigParams.fromValue(obj); // Create the ConfigParams object using the object  // Add a new section config.addSection(\u0026#34;section3\u0026#34;, ConfigParams.fromTuples(\u0026#34;key1\u0026#34;, \u0026#34;ABCDE\u0026#34;)); // Get a section let section1 = config.getSection(\u0026#34;section1\u0026#34;) // Returns {\u0026#39;key1\u0026#39;: \u0026#39;AAA\u0026#39;, \u0026#39;key2\u0026#39;: \u0026#39;123\u0026#39;}  // Get the section names config.getSectionNames(); // Returns [\u0026#39;section1\u0026#39;, \u0026#39;section2\u0026#39;]  // Change the value of section1.key1 to BBB config.override(ConfigParams.fromTuples(\u0026#34;section1.key1\u0026#34;, \u0026#34;BBB\u0026#34;)); See also   IConfigurable   StringValueMap   ","description":"Contains a key-value map with configuration parameters. \n\n \n","image":null,"permalink":"/node/commons/config/config_params/","subtitle":null,"tags":null,"title":"ConfigParams"},{"content":"Description The ConfigParams class contains a key-value map with configuration parameters. It allows you to define configuration parameters that can be used, for example, to define access control credentials.\nImportant points:\n In general, ConfigParams is used to pass configurations to IConfigurable objects. It also serves as a basis for more concrete configurations, such as ConnectionParams or CredentialParams. This class stores all values as strings. These values can be serialized as JSON or string forms. When retrieved the values can be automatically converted using GetAsXXX methods. The keys are case-sensitive, so it is recommended to use consistent C-style, such as “my_param”. Configuration parameters can be broken into sections and subsections using dot notation, such as “section1.subsection1.param1”. Using GetSection method all parameters from the specified section can be extracted from a ConfigMap. The ConfigParams class supports serialization from/to plain strings as: “key1=123;key2=ABC;key3=2016-09-16T00:00:00.00Z”  Implements: StringValueMap\nConstructors Creates a new ConfigParams and fills it with values. See StringValueMap.constructors\n ConfigParams(values: Any = None): ConfigParams\n  values: Any - (optional) an object to be converted into key-value pairs to initialize this config map.  Instance Methods add_section Adds parameters into this ConfigParams under specified section. Keys for the new parameters are appended with section dot prefix.\n add_section(section: str, section_params: ConfigParams)\n  section: str - name of the section where the new parameters will be added. section_params: ConfigParams - new parameters to be added.  get_section Gets parameters from specific section stored in this ConfigMap. The section name is removed from parameter keys.\n get_section(section: str): ConfigParams\n  section: str - name of the section to retrieve configuration parameters from. returns: ConfigParams - all configuration parameters that belong to the section named \u0026lsquo;section\u0026rsquo;.  get_section_names Gets a list with all 1st level section names.\n get_section_names(): List[str]\n  returns: List[str] - a list of section names stored in this ConfigMap.  override Overrides parameters with new values from specified ConfigParams and returns a new ConfigParams object.\n override(config_params: ConfigParams): ConfigParams\n  config_params: ConfigParams - ConfigMap with parameters to override the current values. returns: ConfigParams - a new ConfigParams object.  set_defaults Set default values from specified ConfigParams and returns a new ConfigParams object.\n set_defaults(default_config_params: ConfigParams): ConfigParams\n  default_config_params: ConfigParams - ConfigMap with default parameter values. returns: ConfigParams - a new ConfigParams object.  Static methods from_string Creates a new ConfigParams object filled with key-value pairs serialized as a string.\n static from_string(line: str): ConfigParams\n  line: str - a string with serialized key-value pairs as \u0026ldquo;key1=value1;key2=value2;\u0026hellip;\u0026rdquo;\nExample: \u0026ldquo;Key1=123;Key2=ABC;Key3=2016-09-16T00:00:00.00Z\u0026rdquo; returns: ConfigParams - a new ConfigParams object.  from_tuples Creates a new ConfigParams object filled with provided key-value pairs called tuples. Tuples parameters contain a sequence of key1, value1, key2, value2, \u0026hellip; pairs.\nSee StringValueMap.fromTuplesArray\n static from_tuples(*tuples: Any): ConfigParams\n  tuples: Any - the tuples to fill a new ConfigParams object. returns: ConfigParams - a new ConfigParams object.  from_value Creates a new ConfigParams object filled with key-value pairs from specified object.\n static from_value(value: Any): ConfigParams\n  value: Any - an object with key-value pairs used to initialize a new ConfigParams. returns: ConfigParams - a new ConfigParams object.  merge_configs Merges two or more ConfigParams into one. The following ConfigParams override previously defined parameters.\nSee StringValueMap.fromMaps\n static merge_configs(*configs: ConfigParams): ConfigParams\n  configs: ConfigParams - a list of ConfigParams objects to be merged. returns: ConfigParams - a new ConfigParams object.  Examples # Create a ConfigParams object from a tuple config = ConfigParams.from_tuples(\u0026#34;section1.key1\u0026#34;, \u0026#34;AAA\u0026#34;, \u0026#34;section1.key2\u0026#34;, 123, \u0026#34;section2.key1\u0026#34;, True) # Create a ConfigParams object from a string config = ConfigParams.from_string(\u0026#34;section1.key1=AAA;section1.key2=123;section2.key1=True\u0026#34;) # Create a ConfigParams object from a value dict = {\u0026#34;section1.key1\u0026#34;: \u0026#34;AAA\u0026#34;, \u0026#34;section1.key2\u0026#34;: 123, \u0026#34;section2.key1\u0026#34;: True} # Create a dictionary configD = ConfigParams. from_value(dict) # Create the ConfigParams object using the dictionary # Add a new section  config.add_section(\u0026#34;section3\u0026#34;, ConfigParams.from_tuples(\u0026#34;key1\u0026#34;, \u0026#34;ABCDE\u0026#34;)) # Get a section  section1 = config.get_section(\u0026#34;section1\u0026#34;) # Returns {\u0026#39;key1\u0026#39;: \u0026#39;AAA\u0026#39;, \u0026#39;key2\u0026#39;: \u0026#39;123\u0026#39;}  # Get the section names config.get_section_names() # Returns [\u0026#39;section1\u0026#39;, \u0026#39;section2\u0026#39;] # Change the value of section1.key1 to BBB config.override(ConfigParams.from_tuples(\u0026#34;section1.key1\u0026#34;, \u0026#34;BBB\u0026#34;)) See also   IConfigurable   StringValueMap   ","description":"Contains a key-value map with configuration parameters. \n\n \n","image":null,"permalink":"/python/commons/config/config_params/","subtitle":null,"tags":null,"title":"ConfigParams"},{"content":"Description The ConfigReader class allows you to create config readers that support configuration parameterization.\nConfiguration parameters  parameters: this entire section is used as template parameters.  \u0026hellip;    Constructors NewConfigReader Creates a new instance of the config reader.\n NewConfigReader() *ConfigReader\n Methods Configure Configures a component by passing its configuration parameters.\n (c *ConfigReader) Configure(config *cconfig.ConfigParams)\n  cconfig: *cconfig.ConfigParams - configuration parameters to be set.  Parameterize Parameterized configuration template given as string with dynamic parameters.\n (c *ConfigReader) Parameterize(config string, parameters *cconfig.ConfigParams) (string, error)\n  cconfig: string - string with a configuration template to be parameterized parameters: *cconfig.ConfigParams - dynamic parameters to inject into the template returns: (string, error) - parameterized configuration string.  See also   IConfigReader   ","description":"Abstract config reader that supports configuration parameterization.\n","image":null,"permalink":"/golang/components/config/config_reader/","subtitle":null,"tags":null,"title":"ConfigReader"},{"content":"Inherits: IConfigurable\nDescription The ConfigReader class allows you to create config readers that support configuration parameterization.\nConfiguration parameters  parameters: this entire section is used as template parameters  \u0026hellip;    Instance methods Configure Configures component by passing configuration parameters.\n public void Configure(ConfigParams config)\n  config: ConfigParams - configuration parameters to be set.  Parameterize Parameterized configuration template given as string with dynamic parameters.\n protected string Parameterize(string config, ConfigParams parameters)\n  config: string - a string with configuration template to be parameterized parameters: ConfigParams - dynamic parameters to inject into the template returns: string - a parameterized configuration string.  Abstract methods ReadConfig Reads configuration and parameterizes it with given values.\n public abstract ConfigParams ReadConfig(string correlationId, ConfigParams parameters)\n  correlationId: string - (optional) transaction id to trace execution through call chain. parameters: ConfigParams - values to parameters of the configuration or null to skip parameterization. returns: ConfigParams - ConfigParams configuration.  See also   IConfigReader   ","description":"Abstract config reader that supports configuration parameterization.\n","image":null,"permalink":"/net/components/config/config_reader/","subtitle":null,"tags":null,"title":"ConfigReader"},{"content":"Implements: IConfigurable\nDescription The ConfigReader class allows you to create config readers that support configuration parameterization.\nConfiguration parameters  parameters: this entire section is used as template parameters  \u0026hellip;    Instance methods configure Configures component by passing configuration parameters.\n public configure(config: ConfigParams): void\n  config: ConfigParams - configuration parameters to be set.  parameterize Parameterized configuration template given as string with dynamic parameters.\n protected parameterize(config: string, parameters: ConfigParams): string\n  config: string - a string with configuration template to be parameterized parameters: ConfigParams - dynamic parameters to inject into the template returns: string - a parameterized configuration string.  Abstract methods readConfig Reads configuration and parameterizes it with given values.\n public abstract readConfig(correlationId: string, parameters: ConfigParams) Promise\u0026lt;ConfigParams\u0026gt;\n  correlationId: string - (optional) transaction id to trace execution through call chain. parameters: ConfigParams - values to parameters of the configuration or null to skip parameterization. returns: Promise\u0026lt;ConfigParams\u0026gt; - ConfigParams configuration.  See also   IConfigReader   ","description":"Abstract config reader that supports configuration parameterization.\n","image":null,"permalink":"/node/components/config/config_reader/","subtitle":null,"tags":null,"title":"ConfigReader"},{"content":"Implements: IConfigurable\nDescription The ConfigReader class allows you to create config readers that support configuration parameterization.\nConfiguration parameters  parameters: this entire section is used as template parameters  \u0026hellip;    Instance methods configure Configures component by passing configuration parameters.\n configure(config: ConfigParams)\n  config: ConfigParams - configuration parameters to be set.  _parameterize Parameterized configuration template given as string with dynamic parameters.\n _parameterize(config: str, parameters: ConfigParams): str\n  config: str - a string with configuration template to be parameterized parameters: ConfigParams - dynamic parameters to inject into the template returns: str - a parameterized configuration string.  Abstract methods _read_config Reads configuration and parameterizes it with given values.\n abstractmethod _read_config(correlation_id: Optional[str], parameters: ConfigParams): ConfigParams\n  correlation_id: Optional[str] - (optional) transaction id to trace execution through call chain. parameters: ConfigParams - values to parameters of the configuration or None to skip parameterization. returns: ConfigParams - ConfigParams configuration.  See also   IConfigReader   ","description":"Abstract config reader that supports configuration parameterization.\n","image":null,"permalink":"/python/components/config/config_reader/","subtitle":null,"tags":null,"title":"ConfigReader"},{"content":"Description The Conflicterror class is used to manage errors raised by conflicts between object versions that were posted by the user and those that are stored on the server\nConstructors NewConflictError Creates an error instance and assigns its values.\n NewConflictError(correlationId, code, message string) *ApplicationError\n  correlation_id: string - (optional) unique transaction id used to trace execution through the call chain. code: string - (optional) unique error code. Default: \u0026ldquo;UNKNOWN\u0026rdquo; message: string - (optional) a human-readable description of the error.  ","description":"Errors raised by conflicts between object versions that were posted by the user and those that are stored on the server.\n","image":null,"permalink":"/golang/commons/errors/conflict_error/","subtitle":null,"tags":null,"title":"Conflicterror"},{"content":"Inherits: ApplicationException\nDescription The ConflictException class is used to manage errors raised by conflicts between object versions that were posted by the user and those that are stored on the server\nConstructors Creates an error instance and assigns its values.\n public ConflictException(string correlationId = null, string code = null, string message = null)\n  correlationId: string - (optional) unique transaction id used to trace execution through the call chain. code: string - (optional) unique error code. Default: \u0026ldquo;UNKNOWN\u0026rdquo; message: string - (optional) human-readable description of the error.  Creates an error instance with an error message\n public ConflictException(string message)\n  message: string - human-readable description of the error.  Creates an error instance with a conflict error category and assigns its values.\n public ConflictException(Exception innerException)\n  innerException: Exception - error object  Creates an error instance by processing native C# Exceptions.\n protected ConflictException(SerializationInfo info, StreamingContext context)\n  info: SerializationInfo - serialized information containing the serialized object data about the exception being thrown. context: StreamingContext - streaming context containing contextual information about the source or destination.  ","description":"Errors raised by conflicts between object versions that were posted by the user and those that are stored on the server.\n","image":null,"permalink":"/net/commons/errors/conflict_exception/","subtitle":null,"tags":null,"title":"ConflictException"},{"content":"Extends: ApplicationException\nDescription The ConflictException class is used to manage errors raised by conflicts between object versions that were posted by the user and those that are stored on the server\nConstructors Creates an error instance and assigns its values.\n public constructor(correlation_id: string = null, code: string = null, message: string = null)\n  correlation_id: string - (optional) unique transaction id used to trace execution through the call chain. code: string - (optional) unique error code. Default: \u0026ldquo;UNKNOWN\u0026rdquo;. message: string - (optional) human-readable description of the error.  ","description":"Errors raised by conflicts between object versions that were posted by the user and those that are stored on the server.\n","image":null,"permalink":"/node/commons/errors/conflict_exception/","subtitle":null,"tags":null,"title":"ConflictException"},{"content":"Implements: ApplicationException\nDescription The ConflictException class is used to manage errors raised by conflicts between object versions that were posted by the user and those that are stored on the server\nConstructors Creates an error instance and assigns its values.\n ConflictException(correlation_id: Optional[str] = None, code: str = None, message: str = None)\n  correlation_id: Optional[str] - (optional) a unique transaction id to trace execution through call chain. code: str - (optional) a unique error code. Default: \u0026ldquo;UNKNOWN\u0026rdquo; message: str - (optional) a human-readable description of the error.  ","description":"Errors raised by conflicts between object versions that were posted by the user and those that are stored on the server.\n","image":null,"permalink":"/python/commons/errors/conflict_exception/","subtitle":null,"tags":null,"title":"ConflictException"},{"content":"Description The Connectionerror class is used to manage errors that occur during a connection to a remote service. These errors can be related to misconfiguration, network issues, or the remote service itself.\nConstructors NewConnectionError Creates an error instance and assigns its values.\n NewConnectionError(correlationId, code, message string) *ApplicationError\n  correlation_id: string - (optional) unique transaction id used to trace execution through the call chain. code: string - (optional) unique error code. Default: \u0026ldquo;UNKNOWN\u0026rdquo; message: string - (optional) a human-readable description of the error.  ","description":"Errors that occur during connections to remote services.\n","image":null,"permalink":"/golang/commons/errors/connection_error/","subtitle":null,"tags":null,"title":"Connectionerror"},{"content":"Inherits: ApplicationException\nDescription The ConnectionException class is used to manage errors that occur during a connection to a remote service. These errors can be related to misconfiguration, network issues, or the remote service itself.\nConstructors Creates an error instance and assigns its values.\n public ConnectionException(string correlationId = null, string code = null, string message = null)\n  correlationId: string - (optional) unique transaction id used to trace execution through the call chain. code: string - (optional) unique error code. Default: \u0026ldquo;UNKNOWN\u0026rdquo; message: string - (optional) human-readable description of the error.  Creates an error instance with error message\n public ConnectionException(string message)\n  message: string - human-readable description of the error.  Creates an error instance with a noresponse error category and assigns its values.\n public ConnectionException(Exception innerException)\n  innerException: Exception - error object  Creates an error instance by processing native C# Exceptions.\n protected ConnectionException(SerializationInfo info, StreamingContext context)\n  info: SerializationInfo - serialized information containing the serialized object data about the exception being thrown. context: StreamingContext - streaming context containing contextual information about the source or destination.  ","description":"Errors that occur during connections to remote services.\n","image":null,"permalink":"/net/commons/errors/connection_exception/","subtitle":null,"tags":null,"title":"ConnectionException"},{"content":"Extends: ApplicationException\nDescription The ConnectionException class is used to manage errors that occur during a connection to a remote service. These errors can be related to misconfiguration, network issues, or the remote service itself.\nConstructors Creates an error instance and assigns its values.\n public constructor(correlation_id: string = null, code: string = null, message: string = null)\n  correlation_id: string - (optional) unique transaction id used to trace execution through the call chain. code: string - (optional) unique error code. Default: \u0026ldquo;UNKNOWN\u0026rdquo;. message: string - (optional) human-readable description of the error.  ","description":"Errors that occur during connections to remote services.\n","image":null,"permalink":"/node/commons/errors/connection_exception/","subtitle":null,"tags":null,"title":"ConnectionException"},{"content":"Implements: ApplicationException\nDescription The ConnectionException class is used to manage errors that occur during a connection to a remote service. These errors can be related to misconfiguration, network issues, or the remote service itself.\nConstructors Creates an error instance and assigns its values.\n ConnectionException(correlation_id: Optional[str] = None, code: str = None, message: str = None)\n  correlation_id: Optional[str] - (optional) a unique transaction id to trace execution through call chain. code: str - (optional) a unique error code. Default: \u0026ldquo;UNKNOWN\u0026rdquo; message: str - (optional) a human-readable description of the error.  ","description":"Errors that occur during connections to remote services.\n","image":null,"permalink":"/python/commons/errors/connection_exception/","subtitle":null,"tags":null,"title":"ConnectionException"},{"content":"Implements: ConfigParams\nDescription The ConnectionParams class allows you to create connection parameters used to connect to external services.\nImportant points\n Usually, connection parameters are used together with credential parameters, but are stored separately from these more protected and sensitive values.  Configuration parameters  discovery_key: key to retrieve parameters from a discovery service protocol: connection protocol like http, https, tcp, udp host: host name or IP address port: port number uri: resource URI or connection string with all parameters in it  In addition to standard parameters ConnectionParams may contain any number of custom parameters.\nConstructors NewConnectionParams Creates a new ConnectionParams object and fills it with values.\n NewConnectionParams(values map[string]string) *ConnectionParams\n  map: map[string]string - (optional) object to be converted into key-value pairs to initialize this connection.  NewEmptyConnectionParams Creates a new ConnectionParams object and fills it with values.\n NewEmptyConnectionParams() *ConnectionParams\n NewManyConnectionParamsFromConfig Retrieves a single ConnectionParams from configuration parameters from \u0026ldquo;connection\u0026rdquo; section. If \u0026ldquo;connections\u0026rdquo; section is present instead, then it returns only the first connection element.\n NewManyConnectionParamsFromConfig(config *config.ConfigParams) []*ConnectionParams\n  config: *config.ConfigParams - ConnectionParams, containing a section named \u0026ldquo;connection(s)\u0026rdquo;. returns: []*ConnectionParams - generated ConnectionParams object.  NewConnectionParamsFromString Creates a new ConnectionParams object filled with key-value pairs serialized as a string.\n NewConnectionParamsFromString(line string) *ConnectionParams\n   line: string - a string with serialized key-value pairs as \u0026ldquo;key1=value1;key2=value2;\u0026hellip;\u0026quot; Example: \u0026ldquo;Key1=123;Key2=ABC;Key3=2016-09-16T00:00:00.00Z\u0026rdquo;\n  returns: *ConnectionParams - new ConnectionParams object.\n  NewConnectionParamsFromTuples Creates a new ConnectionParams object filled with provided key-value pairs called tuples. Tuples parameters contain a sequence of key1, value1, key2, value2, \u0026hellip; pairs.\n NewConnectionParamsFromTuples(tuples \u0026hellip;interface{}) *ConnectionParams\n   tuples: \u0026hellip;interface{} - the tuples to fill a new ConnectionParams object.\n  returns: *ConnectionParams - new ConnectionParams object.\n  NewManyConnectionParamsFromConfig Retrieves all ConnectionParams from configuration parameters from \u0026ldquo;connections\u0026rdquo; section. If \u0026ldquo;connection\u0026rdquo; section is present instead, then it returns a list with only one ConnectionParams.\n NewManyConnectionParamsFromConfig(config *config.ConfigParams) []*ConnectionParams\n   config: *config.ConfigParams - configuration parameters to retrieve connections\n  returns: []*ConnectionParams - list of retrieved ConnectionParams\n  Methods DiscoveryKey Gets the key to retrieve this connection from DiscoveryService. If this key is nil, then all parameters are already present.\n (c *ConnectionParams) DiscoveryKey() string\n  returns: string - resolved options or error.  Host Gets the host name or IP address.\n (c *ConnectionParams) Host() string\n  returns: string - host name or IP address.  Port Gets the port number.\n (c *ConnectionParams) Port() int\n  returns: int - port number.  PortWithDefault Gets the port number with default value.\n (c *ConnectionParams) PortWithDefault(defaultValue int) int\n  defaultPort: int - default port number. returns: int - port number.  Protocol Gets the connection protocol.\n (c *ConnectionParams) Protocol() string\n  returns: string - connection protocol or the default value if it\u0026rsquo;s not set.  ProtocolWithDefault Gets the connection protocol with default value.\n (c *ConnectionParams) ProtocolWithDefault(defaultValue string) string\n  defaultValue: string - (optional) default protocol returns: string - connection protocol or the default value if it\u0026rsquo;s not set.  Uri Gets the resource URI or connection string. Usually it includes all connection parameters in it.\n (c *ConnectionParams) Uri() string\n  returns: string - resource URI or connection string.  SetDiscoveryKey Sets the key to retrieve these parameters from DiscoveryService.\n (c *ConnectionParams) SetDiscoveryKey(value string)\n  value: string - new key to retrieve connection.  SetHost Sets the host name or IP address.\n (c *ConnectionParams) SetHost(value string)\n  value: string - new host name or IP address.  SetPort Sets the port number.\n (c *ConnectionParams) SetPort(value int)\n  value: int - new port number.  SetProtocol Sets the connection protocol.\n (c *ConnectionParams) SetProtocol(value string)\n  value: string - new connection protocol.  SetUri Sets the resource URI or connection string.\n (c *ConnectionParams) SetUri(value string)\n  value: string - new resource URI or connection string.  UseDiscovery Checks if these connection parameters shall be retrieved from DiscoveryService. The connection parameters are redirected to DiscoveryService when discovery_key parameter is set.\n (c *ConnectionParams) UseDiscovery() bool\n  returns: bool - true if the connection shall be retrieved from DiscoveryService  Examples connection := NewConnectionParamsFromTuples( \u0026#34;protocol\u0026#34;, \u0026#34;http\u0026#34;, \u0026#34;host\u0026#34;, \u0026#34;10.1.1.100\u0026#34;, \u0026#34;port\u0026#34;, \u0026#34;8080\u0026#34;, \u0026#34;cluster\u0026#34;, \u0026#34;mycluster\u0026#34; ); host := connection.Host(); // Result: \u0026#34;10.1.1.100\u0026#34; port := connection.Port(); // Result: 8080 cluster := connection.GetAsNullableString(\u0026#34;cluster\u0026#34;); // Result: \u0026#34;mycluster\u0026#34; See also   ConfigParams   CredentialParams   ConnectionResolver   IDiscovery   ","description":"Contains connection parameters used to connect to external services.\n","image":null,"permalink":"/golang/components/connect/connection_params/","subtitle":null,"tags":null,"title":"ConnectionParams"},{"content":"Inherits: ConfigParams\nDescription The ConnectionParams class allows you to create connection parameters used to connect to external services.\nImportant points\n Usually, connection parameters are used together with credential parameters, but are stored separately from these more protected and sensitive values.  Configuration parameters  discovery_key: key to retrieve parameters from discovery service protocol: connection protocol like http, https, tcp, udp host: host name or IP address port: port number uri: resource URI or connection string with all parameters in it  In addition to standard parameters ConnectionParams may contain any number of custom parameters.\nConstructors Creates a new connection parameters and fills it with values.\n public ConnectionParams(IDictionary\u0026lt;string, string\u0026gt; map)\n  map: IDictionary\u0026lt;string, string\u0026gt; - (optional) an object to be converted into key-value pairs to initialize this connection.  Creates a new connection parameters and fills it with values.\n public ConnectionParams(IDictionary\u0026lt;string, string\u0026gt; map)\n Properties UseDiscovery Checks if these connection parameters shall be retrieved from DiscoveryService.The connection parameters are redirected to DiscoveryService when discovery_key parameter is set.\n public bool UseDiscovery { get; }\n DiscoveryKey Gets or sets the key to retrieve this connection from DiscoveryService.\n public string DiscoveryKey { get; set; }\n Protocol Gets or sets the connection protocol\n public string Protocol { get; set; }\n Host Gets or sets the service host name or IP address.\n public string Host { get; set; }\n Port Gets or sets the service port number\n public int Port { get; set; }\n Uri Gets the resource URI or connection string. Usually it includes all connection parameters in it.\n public string Uri { get; set; }\n Instance methods GetPort Gets the port number.\n public int GetPort()\n  returns: int - the port number.  GetPortWithDefault Gets the port number with default value.\n public int GetPortWithDefault(int defaultPort)\n  defaultPort: int - a default port number. returns: int - the port number.  GetProtocol Gets the connection protocol.\n public string GetProtocol()\n  returns: string - the connection protocol or the default value if it\u0026rsquo;s not set.  GetProtocolWithDefault Gets the connection protocol with default value.\n public string GetProtocolWithDefault(string defaultValue)\n  defaultValue: string - (optional) the default protocol returns: string - the connection protocol or the default value if it\u0026rsquo;s not set.  Static methods FromConfig Retrieves a single ConnectionParams from configuration parameters from \u0026ldquo;connection\u0026rdquo; section. If \u0026ldquo;connections\u0026rdquo; section is present instead, then it returns only the first connection element.\n public static ConnectionParams FromConfig(ConfigParams config, bool configAsDefault = True)\n   config: ConfigParams - ConnectionParams, containing a section named \u0026ldquo;connection(s)\u0026rdquo;.\n  configAsDefault: bool - boolean parameter for default configuration. If \u0026ldquo;true\u0026rdquo; the default value will be added to the result.\n  returns: ConnectionParams - the generated ConnectionParams object.\n  FromString Creates a new ConnectionParams object filled with key-value pairs serialized as a string.\n public static ConnectionParams FromString(string line)\n   line: string - a string with serialized key-value pairs as \u0026ldquo;key1=value1;key2=value2;\u0026hellip;\u0026quot; Example: \u0026ldquo;Key1=123;Key2=ABC;Key3=2016-09-16T00:00:00.00Z\u0026rdquo;\n  returns: ConnectionParams - a new ConnectionParams object.\n  FromTuples! TODO: this method is not realized yet for this language\nCreates a new ConnectionParams object filled with provided key-value pairs called tuples. Tuples parameters contain a sequence of key1, value1, key2, value2, \u0026hellip; pairs.\n public static ConnectionParams FromTuples(params object[] tuples)\n   tuples: object[] - the tuples to fill a new ConnectionParams object.\n  returns: ConnectionParams - a new ConnectionParams object.\n  ManyFromConfig Retrieves all ConnectionParams from configuration parameters from \u0026ldquo;connections\u0026rdquo; section. If \u0026ldquo;connection\u0026rdquo; section is present instead, then it returns a list with only one ConnectionParams.\n public static List\u0026lt;ConnectionParams\u0026gt; ManyFromConfig(ConfigParams config, bool configAsDefault = true)\n   config: ConfigParams - a configuration parameters to retrieve connections\n  returns: List\u0026lt;ConnectionParams\u0026gt; - a list of retrieved ConnectionParams\n  Examples //Example ConnectionParams object usage: var connection = ConnectionParams.FromTuples( \u0026#34;protocol\u0026#34;, \u0026#34;http\u0026#34;, \u0026#34;host\u0026#34;, \u0026#34;10.1.1.100\u0026#34;, \u0026#34;port\u0026#34;, \u0026#34;8080\u0026#34;, \u0026#34;cluster\u0026#34;, \u0026#34;mycluster\u0026#34; ); var host = connection.Host; // Result: \u0026#34;10.1.1.100\u0026#34; var port = connection.Port; // Result: 8080 var cluster = connection.GetAsNullableString(\u0026#34;cluster\u0026#34;); // Result: \u0026#34;mycluster\u0026#34; See also   ConfigParams   CredentialParams   ConnectionResolver   IDiscovery   ","description":"Contains connection parameters used to connect to external services.\n","image":null,"permalink":"/net/components/connect/connection_params/","subtitle":null,"tags":null,"title":"ConnectionParams"},{"content":"Extends: ConfigParams\nDescription The ConnectionParams class allows you to create connection parameters used to connect to external services.\nImportant points\n Usually, connection parameters are used together with credential parameters, but are stored separately from these more protected and sensitive values.  Configuration parameters  discovery_key: key to retrieve parameters from discovery service protocol: connection protocol like http, https, tcp, udp host: host name or IP address port: port number uri: resource URI or connection string with all parameters in it  In addition to standard parameters ConnectionParams may contain any number of custom parameters.\nConstructors Creates a new connection parameters and fills it with values.\n public constructor(map: any = null)\n  map: any - (optional) an object to be converted into key-value pairs to initialize this connection.  Instance methods getDiscoveryKey Gets the key to retrieve this connection from DiscoveryService. If this key is null, then all parameters are already present.\n public get_discovery_key(): string\n  returns: string - resolved options or error.  getHost Gets the host name or IP address.\n public getHost(): string\n  returns: string - the host name or IP address.  getPort Gets the port number.\n public getPort(): number\n  returns: number - the port number.  getPortWithDefault Gets the port number with default value.\n public getPortWithDefault(defaultPort: number): number\n  defaultPort: number - a default port number. returns: number - the port number.  getProtocol Gets the connection protocol.\n public getProtocol(): string\n  returns: string - the connection protocol or the default value if it\u0026rsquo;s not set.  getProtocolWithDefault Gets the connection protocol with default value.\n public getProtocolWithDefault(defaultValue: string = null): string\n  defaultValue: string - (optional) the default protocol returns: string - the connection protocol or the default value if it\u0026rsquo;s not set.  getUri Gets the resource URI or connection string. Usually it includes all connection parameters in it.\n public getUri(): string\n  returns: string - the resource URI or connection string.  setDiscoveryKey Sets the key to retrieve these parameters from DiscoveryService.\n public setDiscoveryKey(value: string): void\n  value: string - a new key to retrieve connection.  setHost Sets the host name or IP address.\n public setHost(value: string): void\n  value: string - a new host name or IP address.  setPort Sets the port number.\n public setPort(value: number): void\n  value: number - a new port number.  setProtocol Sets the connection protocol.\n public setProtocol(value: string): void\n  value: string - a new connection protocol.  setUri Sets the resource URI or connection string.\n public setUri(value: string): void\n  value: string - a new resource URI or connection string.  useDiscovery Checks if these connection parameters shall be retrieved from DiscoveryService. The connection parameters are redirected to DiscoveryService when discovery_key parameter is set.\n public useDiscovery(): boolean\n  returns: boolean - true if connection shall be retrieved from DiscoveryService  Static methods fromConfig Retrieves a single ConnectionParams from configuration parameters from \u0026ldquo;connection\u0026rdquo; section. If \u0026ldquo;connections\u0026rdquo; section is present instead, then it returns only the first connection element.\n public static fromConfig(config: ConfigParams): ConnectionParams\n  config: ConfigParams - ConnectionParams, containing a section named \u0026ldquo;connection(s)\u0026rdquo;. returns: ConnectionParams - the generated ConnectionParams object.  fromString Creates a new ConnectionParams object filled with key-value pairs serialized as a string.\n public static fromString(line: string): ConnectionParams\n   line: string - a string with serialized key-value pairs as \u0026ldquo;key1=value1;key2=value2;\u0026hellip;\u0026quot; Example: \u0026ldquo;Key1=123;Key2=ABC;Key3=2016-09-16T00:00:00.00Z\u0026rdquo;\n  returns: ConnectionParams - a new ConnectionParams object.\n  fromTuples Creates a new ConnectionParams object filled with provided key-value pairs called tuples. Tuples parameters contain a sequence of key1, value1, key2, value2, \u0026hellip; pairs.\n public static from_tuples(\u0026hellip;tuples: any[]): ConnectionParams\n   tuples: any[] - the tuples to fill a new ConnectionParams object.\n  returns: ConnectionParams - a new ConnectionParams object.\n  manyFromConfig Retrieves all ConnectionParams from configuration parameters from \u0026ldquo;connections\u0026rdquo; section. If \u0026ldquo;connection\u0026rdquo; section is present instead, then it returns a list with only one ConnectionParams.\n public static manyFromConfig(config: ConfigParams): ConnectionParams[]\n   config: ConfigParams - a configuration parameters to retrieve connections\n  returns: ConnectionParams[] - a list of retrieved ConnectionParams\n  Examples let connection = ConnectionParams.fromTuples( \u0026#34;protocol\u0026#34;, \u0026#34;http\u0026#34;, \u0026#34;host\u0026#34;, \u0026#34;10.1.1.100\u0026#34;, \u0026#34;port\u0026#34;, \u0026#34;8080\u0026#34;, \u0026#34;cluster\u0026#34;, \u0026#34;mycluster\u0026#34; ); let host = connection.getHost(); // Result: \u0026#34;10.1.1.100\u0026#34; let port = connection.getPort(); // Result: 8080 let cluster = connection.getAsNullableString(\u0026#34;cluster\u0026#34;); // Result: \u0026#34;mycluster\u0026#34; See also   ConfigParams   CredentialParams   ConnectionResolver   IDiscovery   ","description":"Contains connection parameters used to connect to external services.\n","image":null,"permalink":"/node/components/connect/connection_params/","subtitle":null,"tags":null,"title":"ConnectionParams"},{"content":"Implements: ConfigParams\nDescription The ConnectionParams class allows you to create connection parameters used to connect to external services.\nImportant points\n Usually, connection parameters are used together with credential parameters, but are stored separately from these more protected and sensitive values.  Configuration parameters  discovery_key: key to retrieve parameters from discovery service protocol: connection protocol like http, https, tcp, udp host: host name or IP address port: port number uri: resource URI or connection string with all parameters in it  In addition to standard parameters ConnectionParams may contain any number of custom parameters.\nConstructors Creates a new connection parameters and fills it with values.\n ConnectionParams(map: Any = None)\n  map: Any - (optional) an object to be converted into key-value pairs to initialize this connection.  Instance methods get_discovery_key Gets the key to retrieve this connection from DiscoveryService. If this key is None, then all parameters are already present.\n get_discovery_key(): str\n  returns: str - resolved options or error.  get_host Gets the host name or IP address.\n get_host(): str\n  returns: str - the host name or IP address.  get_port Gets the port number.\n get_port(): int\n  returns: int - the port number.  get_port_with_default Gets the port number with default value.\n get_port_with_default(default_port: int): int\n  default_port: int - a default port number. returns: int - the port number.  get_protocol Gets the connection protocol.\n get_protocol(): str\n  returns: str - the connection protocol or the default value if it\u0026rsquo;s not set.  get_protocol_with_default Gets the connection protocol with default value.\n get_protocol_with_default(default_value: str = None): str\n  default_value: str - (optional) the default protocol returns: str - the connection protocol or the default value if it\u0026rsquo;s not set.  get_uri Gets the resource URI or connection string. Usually it includes all connection parameters in it.\n get_uri(): str\n  returns: str - the resource URI or connection string.  set_discovery_key Sets the key to retrieve these parameters from DiscoveryService.\n set_discovery_key(value: str)\n  value: str - a new key to retrieve connection.  set_host Sets the host name or IP address.\n set_host(value: str)\n  value: str - a new host name or IP address.  set_port Sets the port number.\n set_port(value: int)\n  value: int - a new port number.  set_protocol Sets the connection protocol.\n set_protocol(value: str)\n  value: str - a new connection protocol.  set_uri Sets the resource URI or connection string.\n set_uri(value: str)\n  value: str - a new resource URI or connection string.  use_discovery Checks if these connection parameters shall be retrieved from DiscoveryService. The connection parameters are redirected to DiscoveryService when discovery_key parameter is set.\n use_discovery(): bool\n  returns: bool - true if connection shall be retrieved from DiscoveryService  Static methods from_config Retrieves a single ConnectionParams from configuration parameters from \u0026ldquo;connection\u0026rdquo; section. If \u0026ldquo;connections\u0026rdquo; section is present instead, then it returns only the first connection element.\n static from_config(config: ConfigParams): ConnectionParams\n  config: ConfigParams - ConnectionParams, containing a section named \u0026ldquo;connection(s)\u0026rdquo;. returns: ConnectionParams - the generated ConnectionParams object.  from_string Creates a new ConnectionParams object filled with key-value pairs serialized as a string.\n static from_string(line: str): ConnectionParams\n   line: string - a string with serialized key-value pairs as \u0026ldquo;key1=value1;key2=value2;\u0026hellip;\u0026quot; Example: \u0026ldquo;Key1=123;Key2=ABC;Key3=2016-09-16T00:00:00.00Z\u0026rdquo;\n  returns: ConnectionParams - a new ConnectionParams object.\n  from_tuples Creates a new ConnectionParams object filled with provided key-value pairs called tuples. Tuples parameters contain a sequence of key1, value1, key2, value2, \u0026hellip; pairs.\n static from_tuples(*tuples: Any): ConnectionParams\n   tuples: Any - the tuples to fill a new ConnectionParams object.\n  returns: ConnectionParams - a new ConnectionParams object.\n  many_from_config Retrieves all ConnectionParams from configuration parameters from \u0026ldquo;connections\u0026rdquo; section. If \u0026ldquo;connection\u0026rdquo; section is present instead, then it returns a list with only one ConnectionParams.\n static many_from_config(config: ConfigParams): List[ConnectionParams]\n   config: ConfigParams - a configuration parameters to retrieve connections\n  returns: List[ConnectionParams] - a list of retrieved ConnectionParams\n  Examples connection = ConnectionParams.from_tuples(\u0026#34;protocol\u0026#34;, \u0026#34;http\u0026#34;, \u0026#34;host\u0026#34;, \u0026#34;10.1.1.100\u0026#34;, \u0026#34;port\u0026#34;, \u0026#34;8080\u0026#34;, \u0026#34;cluster\u0026#34;, \u0026#34;mycluster\u0026#34;) host = connection.get_host() # Result: \u0026#34;10.1.1.100\u0026#34; port = connection.get_port() # Result: 8080 cluster = connection.get_as_nullable_string(\u0026#34;cluster\u0026#34;) # Result: \u0026#34;mycluster\u0026#34; See also   ConfigParams   CredentialParams   ConnectionResolver   IDiscovery   ","description":"Contains connection parameters used to connect to external services.\n","image":null,"permalink":"/python/components/connect/connection_params/","subtitle":null,"tags":null,"title":"ConnectionParams"},{"content":"Description The ConnectionResolver class is used to retrieve a component\u0026rsquo;s connections.\nImportant points\n If the connections are configured to be retrieved from IDiscovery, the connection resolver will automatically locate IDiscovery in component references and retrieve the connections from there using the discovery_key parameter.  Configuration parameters connection:\n discovery_key: (optional) key used to retrieve the connection from IDiscovery \u0026hellip; : other connection parameters  connections: alternative to connection\n [connection params 1]: first connection parameters  \u0026hellip; : connection parameters for key 1   [connection params N]: Nth connection parameters  \u0026hellip; : connection parameters for key N    References  *:discovery:*:*:1.0 - (optional) IDiscovery services to resolve connections  Constructors NewConnectionResolver Creates a new instance of ConnectionResolver.\n NewConnectionResolver(config *config.ConfigParams, references refer.IReferences) *ConnectionResolver\n  config: *config.ConfigParams - (optional) component configuration parameters references: refer.IReferences - (optional) component references  NewEmptyConnectionResolver Creates a new instance of ConnectionResolver.\n NewEmptyConnectionResolver() *ConnectionResolver\n Methods Add Adds a new connection to component connections.\n (c *ConnectionResolver) Add(connection *ConnectionParams)\n  connection: *ConnectionParams - new connection parameters to be added  Configure Configures component by passing configuration parameters.\n (c *ConnectionResolver) Configure(config *config.ConfigParams)\n  config: *config.ConfigParams - configuration parameters to be set.  GetAll Gets all connections configured in component configuration. Redirect to Discovery services is not done at this point. If you need fully fleshed connection use the resolve method instead.\n (c *ConnectionResolver) GetAll() []*ConnectionParams\n  returns: []*ConnectionParams - list with connection parameters  Register Registers the given connection in all referenced discovery services. This method can be used for dynamic service discovery.\n (c *ConnectionResolver) Register(correlationId string, connection *ConnectionParams) error\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. connection: *ConnectionParams - connection to a register. returns: error - returned error if not registered.  Resolve Resolves a single component connection. If connections are configured to be retrieved from Discovery service it finds a IDiscovery and resolves the connection there.\n (c *ConnectionResolver) Resolve(correlationId string) (*ConnectionParams, error)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. returns: (*ConnectionParams, error) - resolved connection parameters or nil if nothing was found.  ResolveAll Resolves all component connection. If connections are configured to be retrieved from Discovery service it finds a IDiscovery and resolves the connection there.\n (c *ConnectionResolver) ResolveAll(correlationId string) ([]*ConnectionParams, error)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. returns: ([]*ConnectionParams, error) - list of resolved connections.  SetReferences Sets references to dependent components.\n (c *ConnectionResolver) SetReferences(references refer.IReferences)\n  references: refer.IReferences - references to locate the component dependencies.  Examples config = NewConfigParamsFromTuples( \u0026#34;connection.host\u0026#34;, \u0026#34;10.1.1.100\u0026#34;, \u0026#34;connection.port\u0026#34;, 8080 ); connectionResolver := NewConnectionResolver(); connectionResolver.Configure(config); connectionResolver.SetReferences(references); res, err := connectionResolver.Resolve(\u0026#34;123\u0026#34;); See also   IDiscovery   ConnectionParams   ","description":"Helper class used to retrieve component's connections.\n","image":null,"permalink":"/golang/components/connect/connection_resolver/","subtitle":null,"tags":null,"title":"ConnectionResolver"},{"content":"Description The ConnectionResolver class is used to retrieve component connections.\nImportant points\n If the connections are configured to be retrieved from IDiscovery, the connection resolver will automatically locate IDiscovery in component references and retrieve the connections from there using the discovery_key parameter.  Configuration parameters connection:\n discovery_key: (optional) a key to retrieve the connection from IDiscovery \u0026hellip; : other connection parameters  connections: alternative to connection\n [connection params 1]: first connection parameters  \u0026hellip; : connection parameters for key 1   [connection params N]: Nth connection parameters  \u0026hellip; : connection parameters for key N    References  *:discovery:*:*:1.0 - (optional) IDiscovery services to resolve connections  Constructors Creates a new instance of connection resolver.\n public ConnectionResolver(ConfigParams config = null, IReferences references = null)\n  config: ConfigParams - (optional) component configuration parameters references: IReferences - (optional) component references  Instance methods Add Adds a new connection to component connections\n public void Add(ConnectionParams connection)\n  connection: ConnectionParams - new connection parameters to be added  Configure Configures component by passing configuration parameters.\n public void Configure(config: ConfigParams)\n  config: ConfigParams - configuration parameters to be set.  GetAll Gets all connections configured in component configuration. Redirect to Discovery services is not done at this point. If you need fully fleshed connection use Resolve method instead.\n public List\u0026lt;ConnectionParams\u0026gt; GetAll()\n  returns: List\u0026lt;ConnectionParams\u0026gt; - a list with connection parameters  RegisterAsync Registers the given connection in all referenced discovery services. This method can be used for dynamic service discovery.\n public Task\u0026lt;void\u0026gt; RegisterAsync(string correlationId, ConnectionParams connection)\n  correlationId: string - (optional) transaction id to trace execution through call chain. connection: ConnectionParams - a connection to register.  ResolveAsync Resolves a single component connection. If connections are configured to be retrieved from Discovery service it finds a IDiscovery and resolves the connection there.\n public Task\u0026lt;ConnectionParams\u0026gt; ResolveAsync(string correlationId)\n  correlationId: string - (optional) transaction id to trace execution through call chain. returns: Task\u0026lt;ConnectionParams\u0026gt; - resolved connection parameters or null if nothing was found.  ResolveAllAsync Resolves all component connection. If connections are configured to be retrieved from Discovery service it finds a IDiscovery and resolves the connection there.\n public Task\u0026lt;List\u0026lt;ConnectionParams\u0026gt;\u0026gt; ResolveAllAsync(string correlationId)\n  correlationId: string - (optional) transaction id to trace execution through call chain. returns: Task\u0026lt;List\u0026lt;ConnectionParams\u0026gt;\u0026gt; - a list of resolved connections.  SetReferences Sets references to dependent components.\n public void SetReferences(IReferences references)\n  references: IReferences - references to locate the component dependencies.  Examples var config = ConfigParams.FromTuples( \u0026#34;connection.host\u0026#34;, \u0026#34;10.1.1.100\u0026#34;, \u0026#34;connection.port\u0026#34;, 8080 ); var connectionResolver = new ConnectionResolver(); connectionResolver.Configure(config); connectionResolver.SetReferences(references); connectionResolver.ResolveAsync(\u0026#34;123\u0026#34;); See also   IDiscovery   ConnectionParams   ","description":"Helper class used to retrieve component connections.\n","image":null,"permalink":"/net/components/connect/connection_resolver/","subtitle":null,"tags":null,"title":"ConnectionResolver"},{"content":"Description The ConnectionResolver class is used to retrieve component connections.\nImportant points\n If the connections are configured to be retrieved from IDiscovery, the connection resolver will automatically locate IDiscovery in component references and retrieve the connections from there using the discovery_key parameter.  Configuration parameters connection:\n discovery_key: (optional) a key to retrieve the connection from IDiscovery \u0026hellip; : other connection parameters  connections: alternative to connection\n [connection params 1]: first connection parameters  \u0026hellip; : connection parameters for key 1   [connection params N]: Nth connection parameters  \u0026hellip; : connection parameters for key N    References  *:discovery:*:*:1.0 - (optional) IDiscovery services to resolve connections  Constructors Creates a new instance of connection resolver.\n public constructor(config: ConfigParams = null, references: IReferences = null)\n  config: ConfigParams - (optional) component configuration parameters references: IReferences - (optional) component references  Instance methods add Adds a new connection to component connections\n public add(connection: ConnectionParams): void\n  connection: ConnectionParams - new connection parameters to be added  configure Configures component by passing configuration parameters.\n public configure(config: ConfigParams): void\n  config: ConfigParams - configuration parameters to be set.  getAll Gets all connections configured in component configuration. Redirect to Discovery services is not done at this point. If you need fully fleshed connection use resolve method instead.\n public getAll(): ConnectionParams[]\n  returns: ConnectionParams[] - a list with connection parameters  register Registers the given connection in all referenced discovery services. This method can be used for dynamic service discovery.\n public register(correlationId: string, connection: ConnectionParams): Promise\u0026lt;void\u0026gt;\n  correlationId: string - (optional) transaction id to trace execution through call chain. connection: ConnectionParams - a connection to register.  resolve Resolves a single component connection. If connections are configured to be retrieved from Discovery service it finds a IDiscovery and resolves the connection there.\n public resolve(correlationId: string): Promise\u0026lt;ConnectionParams\u0026gt;\n  correlationId: string - (optional) transaction id to trace execution through call chain. returns: Promise\u0026lt;ConnectionParams\u0026gt; - resolved connection parameters or null if nothing was found.  resolveAll Resolves all component connection. If connections are configured to be retrieved from Discovery service it finds a IDiscovery and resolves the connection there.\n public resolveAll(correlationId: string): Promise\u0026lt;ConnectionParams[]\u0026gt;\n  correlationId: string - (optional) transaction id to trace execution through call chain. returns: Promise\u0026lt;ConnectionParams[]\u0026gt; - a list of resolved connections.  setReferences Sets references to dependent components.\n public setReferences(references: IReferences)\n  references: IReferences - references to locate the component dependencies.  Examples let config = ConfigParams.fromTuples( \u0026#34;connection.host\u0026#34;, \u0026#34;10.1.1.100\u0026#34;, \u0026#34;connection.port\u0026#34;, 8080 ); let connectionResolver = new ConnectionResolver(); connectionResolver.configure(config); connectionResolver.setReferences(references); let connection = await connectionResolver.resolve(\u0026#34;123\u0026#34;); // Now use connection... See also   IDiscovery   ConnectionParams   ","description":"Helper class used to retrieve component connections.\n","image":null,"permalink":"/node/components/connect/connection_resolver/","subtitle":null,"tags":null,"title":"ConnectionResolver"},{"content":"Description The ConnectionResolver class is used to retrieve component connections.\nImportant points\n If the connections are configured to be retrieved from IDiscovery, the connection resolver will automatically locate IDiscovery in component references and retrieve the connections from there using the discovery_key parameter.  Configuration parameters connection:\n discovery_key: (optional) a key to retrieve the connection from IDiscovery \u0026hellip; : other connection parameters  connections: alternative to connection\n [connection params 1]: first connection parameters  \u0026hellip; : connection parameters for key 1   [connection params N]: Nth connection parameters  \u0026hellip; : connection parameters for key N    References  *:discovery:*:*:1.0 - (optional) IDiscovery services to resolve connections  Constructors Creates a new instance of connection resolver.\n ConnectionResolver(config: ConfigParams = None, references: IReferences = None)\n  config: ConfigParams - (optional) component configuration parameters references: IReferences - (optional) component references  Instance methods add Adds a new connection to component connections\n add(connection: ConnectionParams)\n  connection: ConnectionParams - new connection parameters to be added  configure Configures component by passing configuration parameters.\n configure(config: ConfigParams)\n  config: ConfigParams - configuration parameters to be set.  get_all Gets all connections configured in component configuration. Redirect to Discovery services is not done at this point. If you need fully fleshed connection use resolve method instead.\n get_all(): List[ConnectionParams]\n  returns: List[ConnectionParams] - a list with connection parameters  register Registers the given connection in all referenced discovery services. This method can be used for dynamic service discovery.\n register(correlation_id: Optional[str], connection: ConnectionParams)\n  correlation_id: Optional[str] - (optional) transaction id to trace execution through call chain. connection: ConnectionParams - a connection to register.  resolve Resolves a single component connection. If connections are configured to be retrieved from Discovery service it finds a IDiscovery and resolves the connection there.\n resolve(correlation_id: Optional[str]): Optional[ConnectionParams]\n  correlation_id: Optional[str] - (optional) transaction id to trace execution through call chain. returns: Optional[ConnectionParams] - resolved connection parameters or None if nothing was found.  resolve_all Resolves all component connection. If connections are configured to be retrieved from Discovery service it finds a IDiscovery and resolves the connection there.\n resolve_all(correlation_id: Optional[str]): List[ConnectionParams]\n  correlation_id: Optional[str] - (optional) transaction id to trace execution through call chain. returns: List[ConnectionParams] - a list of resolved connections.  set_references Sets references to dependent components.\n set_references(references: IReferences)\n  references: IReferences - references to locate the component dependencies.  Examples config = ConfigParams.from_tuples(\u0026#34;connection.host\u0026#34;, \u0026#34;10.1.1.100\u0026#34;, \u0026#34;connection.port\u0026#34;, 8080) connectionResolver = ConnectionResolver() connectionResolver.configure(config) connectionResolver.set_references(references) connectionResolver.resolve(\u0026#34;123\u0026#34;) See also   IDiscovery   ConnectionParams   ","description":"Helper class used to retrieve component connections.\n","image":null,"permalink":"/python/components/connect/connection_resolver/","subtitle":null,"tags":null,"title":"ConnectionResolver"},{"content":"Description The ConnectionUtils class provides a set of utility functions used to process connection parameters.\nMethods ComposeUri Composes URI from config parameters. The result URI will be in the following form:\nprotocol://username@password@host1:port1,host2:port2,\u0026hellip;?param1=abc\u0026amp;param2=xyz\u0026amp;\u0026hellip;\n (c *TConnectionUtils) ComposeUri(options *config.ConfigParams, defaultProtocol string, defaultPort int) string\n  options: *config.ConfigParams - configuration parameters defaultProtocol: string - default protocol defaultPort: int - default port returns: string - composed URI  Concat Concatinates two options by combining duplicated properties into comma-separated list\n (c *TConnectionUtils) Concat(options1 *config.ConfigParams, options2 *config.ConfigParams, keys \u0026hellip;string) *config.ConfigParams\n  options1: *config.ConfigParams - first options to merge options2: *config.ConfigParams - second options to merge keys: \u0026hellip;string - when defined, it limits only to specific keys returns: *config.ConfigParams - new connection parameters to be added  Exclude Excludes specified keys from the config parameters.\n (c *TConnectionUtils) Exclude(options *config.ConfigParams, keys \u0026hellip;string) *config.ConfigParams\n  options: *config.ConfigParams - configuration parameters to be processed. keys: \u0026hellip;string - list of keys to be excluded. returns: *config.ConfigParams - processed config parameters.  Include Includes specified keys from the config parameters.\n (c *TConnectionUtils) Include(options *config.ConfigParams, keys \u0026hellip;string) *config.ConfigParams\n  options: *config.ConfigParams - configuration parameters to be processed. keys: \u0026hellip;string - list of keys to be included. returns: *config.ConfigParams - processed config parameters.  ParseUri Parses URI into config parameters. The URI shall be in the following form: protocol://username@password@host1:port1,host2:port2,...?param1=abc\u0026amp;param2=xyz\u0026amp;...\n (c *TConnectionUtils) ParseUri(uri string, defaultProtocol string, defaultPort int) *config.ConfigParams\n  uri: string - URI to be parsed defaultProtocol: string - default protocol defaultPort: string - default port returns: *config.ConfigParams - configuration parameters with URI elements  ","description":"A set of utility functions used to process connection parameters\n","image":null,"permalink":"/golang/components/connect/connection_utils/","subtitle":null,"tags":null,"title":"ConnectionUtils"},{"content":"Description The ConnectionUtils class provides a set of utility functions used to process connection parameters.\nStatic methods ComposeUri Composes URI from config parameters. The result URI will be in the following form: protocol://username@password@host1:port1,host2:port2,\u0026hellip;?param1=abc\u0026amp;param2=xyz\u0026amp;\u0026hellip;\n public static string ComposeUri(ConfigParams options, string defaultProtocol, int defaultPort)\n  options: ConfigParams - configuration parameters defaultProtocol: string - a default protocol defaultPort: int - a default port returns: string - a composed URI  Concat Concatinates two options by combining duplicated properties into comma-separated list\n public static ConfigParams Concat(ConfigParams options1, ConfigParams options2, params string[] keys)\n  options1: ConfigParams - first options to merge options2: ConfigParams - second options to merge keys: string[] - when defined, it limits only to specific keys returns: ConfigParams - new connection parameters to be added  Exclude Excludes specified keys from the config parameters.\n public static ConfigParams Exclude(ConfigParams options, params string[] keys)\n  options: ConfigParams - configuration parameters to be processed. keys: string[] - a list of keys to be excluded. returns: ConfigParams - a processed config parameters.  Include Includes specified keys from the config parameters.\n public static ConfigParams Include(ConfigParams options, params string[] keys)\n  options: ConfigParams - configuration parameters to be processed. keys: string[] - a list of keys to be included. returns: ConfigParams - a processed config parameters.  ParseUri Parses URI into config parameters. The URI shall be in the following form: protocol://username@password@host1:port1,host2:port2,...?param1=abc\u0026amp;param2=xyz\u0026amp;...\n public static ConfigParams ParseUri(string uri, string defaultProtocol, string defaultPort)\n  uri: string - the URI to be parsed defaultProtocol: string - a default protocol defaultPort: string - a default port returns: ConfigParams - a configuration parameters with URI elements  ","description":"A set of utility functions used to process connection parameters\n","image":null,"permalink":"/net/components/connect/connection_utils/","subtitle":null,"tags":null,"title":"ConnectionUtils"},{"content":"Description The ConnectionUtils class provides a set of utility functions used to process connection parameters.\nStatic methods composeUri Composes URI from config parameters. The result URI will be in the following form: protocol://username@password@host1:port1,host2:port2,\u0026hellip;?param1=abc\u0026amp;param2=xyz\u0026amp;\u0026hellip;\n public static composeUri(options: ConfigParams, defaultProtocol: string, defaultPort: number): string\n  options: ConfigParams - configuration parameters defaultProtocol: string - a default protocol defaultPort: number - a default port returns: string - a composed URI  concat Concatinates two options by combining duplicated properties into comma-separated list\n public static concat(options1: ConfigParams, options2: ConfigParams, \u0026hellip;keys: string): ConfigParams\n  options1: ConfigParams - first options to merge options2: ConfigParams - second options to merge keys: string - when defined, it limits only to specific keys returns: ConfigParams - new connection parameters to be added  exclude Excludes specified keys from the config parameters.\n public static exclude(options: ConfigParams, \u0026hellip;keys: string[]): ConfigParams\n  options: ConfigParams - configuration parameters to be processed. keys: string[] - a list of keys to be excluded. returns: ConfigParams - a processed config parameters.  include Includes specified keys from the config parameters.\n public static include(options: ConfigParams, \u0026hellip;keys: string[]): ConfigParams\n  options: ConfigParams - configuration parameters to be processed. keys: string[] - a list of keys to be included. returns: ConfigParams - a processed config parameters.  parseUri Parses URI into config parameters. The URI shall be in the following form: protocol://username@password@host1:port1,host2:port2,...?param1=abc\u0026amp;param2=xyz\u0026amp;...\n public static parseUri(uri: string, defaultProtocol: string, defaultPort: string): ConfigParams\n  uri: string - the URI to be parsed defaultProtocol: string - a default protocol defaultPort: string - a default port returns: ConfigParams - a configuration parameters with URI elements  ","description":"A set of utility functions used to process connection parameters\n","image":null,"permalink":"/node/components/connect/connection_utils/","subtitle":null,"tags":null,"title":"ConnectionUtils"},{"content":"Description The ConnectionUtils class provides a set of utility functions used to process connection parameters.\nStatic methods compose_uri Composes URI from config parameters. The result URI will be in the following form: protocol://username@password@host1:port1,host2:port2,\u0026hellip;?param1=abc\u0026amp;param2=xyz\u0026amp;\u0026hellip;\n static compose_uri(options: ConfigParams, default_protocol: str, default_port: int): str\n  options: ConfigParams - configuration parameters default_protocol: str - a default protocol default_port: int - a default port returns: str - a composed URI  concat Concatinates two options by combining duplicated properties into comma-separated list\n static concat(options1: ConfigParams, options2: ConfigParams, *keys: str): ConfigParams\n  options1: ConfigParams - first options to merge options2: ConfigParams - second options to merge keys: str - when defined, it limits only to specific keys returns: ConfigParams - new connection parameters to be added  exclude Excludes specified keys from the config parameters.\n static exclude(options: ConfigParams, *keys: str): ConfigParams\n  options: ConfigParams - configuration parameters to be processed. keys: str - a list of keys to be excluded. returns: ConfigParams - a processed config parameters.  include Includes specified keys from the config parameters.\n static include(options: ConfigParams, *keys: str): ConfigParams\n  options: ConfigParams - configuration parameters to be processed. keys: str - a list of keys to be included. returns: ConfigParams - a processed config parameters.  parse_uri Parses URI into config parameters. The URI shall be in the following form: protocol://username@password@host1:port1,host2:port2,...?param1=abc\u0026amp;param2=xyz\u0026amp;...\n static parse_uri(uri: str, default_protocol: str, default_port: str): ConfigParams\n  uri: str - the URI to be parsed default_protocol: str - a default protocol default_port: str - a default port returns: ConfigParams - a configuration parameters with URI elements  ","description":"A set of utility functions used to process connection parameters\n","image":null,"permalink":"/python/components/connect/connection_utils/","subtitle":null,"tags":null,"title":"ConnectionUtils"},{"content":"Implements: Logger\nDescription The ConsoleLogger class provides a logger that writes log messages to a console.\nImportant points\n Errors are written to a standard err stream and all other messages to a standard out stream.  Configuration parameters  level: maximum log level to capture source: source (context) name  References  *:context-info:*:*:1.0 - (optional) ContextInfo to detect the context id and specify counters source  Methods Write Writes a log message to the logger destination.\n (c *ConsoleLogger) Write(level int, correlationId string, err error, message string)\n  level: int - log level. correlation_id: string - (optional) transaction id used to trace execution through the call chain. err: error - error object associated with this message. message: string - human-readable message to log.  Examples logger = NewConsoleLogger(); logger.SetLevel(LogLevel.Debug); logger.Error(\u0026#34;123\u0026#34;, ex, \u0026#34;Error occured: %s\u0026#34;, ex.message); logger.Debug(\u0026#34;123\u0026#34;, \u0026#34;Everything is OK.\u0026#34;); See also   Logger   ","description":"Logger that writes log messages to a console.\n","image":null,"permalink":"/golang/components/log/console_logger/","subtitle":null,"tags":null,"title":"ConsoleLogger"},{"content":"Inherits: Logger\nDescription The ConsoleLogger class provides a logger that writes log messages to console.\nImportant points\n Errors are written to standard err stream and all other messages to standard out stream.  Configuration parameters  level: maximum log level to capture source: source (context) name  References  *:context-info:*:*:1.0 - (optional) ContextInfo to detect the context id and specify counters source  Instance methods Write Writes a log message to the logger destination.\n public override void Write(LogLevel level, string correlation_id, Exception error, string message)\n  level: LogLevel - a log level. correlation_id: string - (optional) transaction id to trace execution through call chain. error: Exception - an error object associated with this message. message: string - a human-readable message to log.  Examples var logger = new ConsoleLogger(); logger.SetLevel(LogLevel.debug); logger.Error(\u0026#34;123\u0026#34;, ex, \u0026#34;Error occured: %s\u0026#34;, ex.message); logger.Debug(\u0026#34;123\u0026#34;, \u0026#34;Everything is OK.\u0026#34;); See also   Logger   ","description":"Logger that writes log messages to console.\n","image":null,"permalink":"/net/components/log/console_logger/","subtitle":null,"tags":null,"title":"ConsoleLogger"},{"content":"Extends: Logger\nDescription The ConsoleLogger class provides a logger that writes log messages to console.\nImportant points\n Errors are written to standard err stream and all other messages to standard out stream.  Configuration parameters  level: maximum log level to capture source: source (context) name  References  *:context-info:*:*:1.0 - (optional) ContextInfo to detect the context id and specify counters source  Instance methods write Writes a log message to the logger destination.\n public write(level: LogLevel, correlation_id: string, error: Error, message: string): void\n  level: LogLevel - a log level. correlation_id: string - (optional) transaction id to trace execution through call chain. error: Error - an error object associated with this message. message: string - a human-readable message to log.  Examples let logger = new ConsoleLogger(); logger.setLevel(LogLevel.debug); logger.error(\u0026#34;123\u0026#34;, ex, \u0026#34;Error occured: %s\u0026#34;, ex.message); logger.debug(\u0026#34;123\u0026#34;, \u0026#34;Everything is OK.\u0026#34;); See also   Logger   ","description":"Logger that writes log messages to console.\n","image":null,"permalink":"/node/components/log/console_logger/","subtitle":null,"tags":null,"title":"ConsoleLogger"},{"content":"Implements: Logger\nDescription The ConsoleLogger class provides a logger that writes log messages to console.\nImportant points\n Errors are written to standard err stream and all other messages to standard out stream.  Configuration parameters  level: maximum log level to capture source: source (context) name  References  *:context-info:*:*:1.0 - (optional) ContextInfo to detect the context id and specify counters source  Instance methods _write Writes a log message to the logger destination.\n _write(level: LogLevel, correlation_id: Optional[str], error: Optional[Exception], message: Optional[str])\n  level: LogLevel - a log level. correlation_id: Optional[str] - (optional) transaction id to trace execution through call chain. error: Optional[Exception] - an error object associated with this message. message: Optional[str] - a human-readable message to log.  Examples logger = ConsoleLogger() logger.set_level(LogLevel.debug) logger.error(\u0026#34;123\u0026#34;, ex, \u0026#34;Error occured: %s\u0026#34;, ex.message) logger.debug(\u0026#34;123\u0026#34;, \u0026#34;Everything is OK.\u0026#34;) See also   Logger   ","description":"Logger that writes log messages to console.\n","image":null,"permalink":"/python/components/log/console_logger/","subtitle":null,"tags":null,"title":"ConsoleLogger"},{"content":"Description The Container class allows you to create an inversion of control (IoC) container that creates components and manages their lifecycle.\nImportant points\n The container is driven by configuration, which is usually stored in a JSON or YAML file. The configuration contains a list of components identified by their type or locator, followed by their configuration. On start, a container performs the following actions:  Creates components using their types or calls registered factories to create them using their locators. Configures components that implement IConfigurable interface and passes them their configuration parameters. Sets references to components that implement IReferenceable interface and passes them references of all components in the container. Opens components that implement IOpenable interface.   On stop, a container reverses the orden of its actions:  Closes components that implement IClosable interface Unsets references in components that implement IUnreferenceable interface Destroys components in the container.    Configuration parameters  name: context (container or process) name description: human-readable description of the context properties: section of additional descriptive properties  \u0026hellip;    Constructors NewContainer Creates a new instance of the container.\n NewContainer(name string, description string) *Container\n  name: string - (optional) container\u0026rsquo;s name (accessible via ContextInfo) description: string - (optional) container\u0026rsquo;s description (accessible via ContextInfo)  NewEmptyContainer Creates a new empty instance of the container.\n NewEmptyContainer() *Container\n InheritContainer Creates a new instance of the container inherit from reference.\n InheritContainer(name string, description string, referenceable IReferenceable) *Container\n  name: string - a container name (accessible via ContextInfo) description: string - a container description (accessible via ContextInfo) referenceable: IReferenceable - referenceble object for inherit  Fields config Configuration of the container\n config: ContainerConfig\n references Container\u0026rsquo;s references\n references: ContainerReferences\n logger Logger.\n logger: ILogger\n info Container\u0026rsquo;s information.\n info: ContextInfo\n factories Default factories.\n factories: DefaultContainerFactory\n  Methods AddFactory Adds a factory to the container. The factory is used to create components added to the container by their locators (descriptors).\n (c *Container) AddFactory(factory IFactory)\n  factory: IFactory - component factory to be added.  Close Closes the component and frees used resources.\n (c *Container) Close(correlationId string) error\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. returns: error - returns error if not closed  Configure Configures the component by passing its configuration parameters.\n (c *Container) Configure(conf *ConfigParams)\n  conf: *ConfigParams - configuration parameters to be set.  IsOpen Checks if the component is open.\n (c *Container) IsOpen() bool\n  returns: bool - True if the component is open and false otherwise.  Open Opens the component.\n (c *Container) Open(correlationId string) error\n  correlationId: string - (optional) transaction id to trace execution through call chain. returns: error - returns error if not opened  ReadConfigFromFile Reads the container\u0026rsquo;s configuration from a JSON or YAML file and parameterizes it with the given values.\n (c *Container) ReadConfigFromFile(correlationId string, path string, parameters *ConfigParams) error\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. path: string - path to the configuration file parameters: ConfigParams - configuration parameters or nil to skip parameterization. returns: error - returns error if not readed  Examples ======= config.yaml ======== - descriptor: mygroup:mycomponent1:default:default:1.0 param1: 123 param2: ABC - type: mycomponent2,mypackage param1: 321 param2: XYZ ============================ container := NewEmptyContainer() container.AddFactory(newMyComponentFactory()) parameters := NewConfigParamsFromValue(process.env) container.ReadConfigFromFile(\u0026#34;123\u0026#34;, \u0026#34;./config/config.yml\u0026#34;, parameters) err := container.Open(\u0026#34;123\u0026#34;) ftm.Println(\u0026#34;Container is opened\u0026#34;) ... err = container.Close(\u0026#34;123\u0026#34;) fmt.Println(\u0026#34;Container is closed\u0026#34;) See also   IConfigurable interface   IReferenceable interface   IUnreferenceable interface   IOpenable interface   ","description":"Inversion of control (IoC) container that creates components and manages their lifecycle.\n","image":null,"permalink":"/golang/container/containers/container/","subtitle":null,"tags":null,"title":"Container"},{"content":"Inherits: IConfigurable, IReferenceable, IUnreferenceable, IOpenable\nDescription The Container class allows you to create an inversion of control (IoC) container that creates components and manages their lifecycle.\nImportant points\n The container is driven by configuration, which is usually stored in a JSON or YAML file. The configuration contains a list of components identified by their type or locator, followed by their configuration. On start, a container performs the following actions:  Creates components using their types or calls registered factories to create them using their locators. Configures components that implement IConfigurable interface and passes them their configuration parameters. Sets references to components that implement IReferenceable interface and passes them references of all components in the container. Opens components that implement IOpenable interface.   On stop, a container reverses the orden of its actions:  Closes components that implement IClosable interface Unsets references in components that implement IUnreferenceable interface Destroys components in the container.    Configuration parameters  name: context (container or process) name description: human-readable description of the context properties: section of additional descriptive properties  \u0026hellip;    Constructors Creates a new instance of the container.\n public Container(string name = null, string description = null)\n  name: string - (optional) container\u0026rsquo;s name (accessible via ContextInfo) description: string - (optional) container\u0026rsquo;s description (accessible via ContextInfo)  Fields _config Configuration of the container\n protected _config: ContainerConfig\n _references Container\u0026rsquo;s references\n protected _references: ContainerReferences\n _logger Logger.\n protected _logger: ILogger\n _info Container\u0026rsquo;s information.\n protected _info: ContextInfo\n _factories Default factories.\n protected _factories: DefaultContainerFactory\n  Instance methods AddFactory Adds a factory to the container. The factory is used to create components added to the container by their locators (descriptors).\n public void AddFactory(IFactory factory)\n  factory: IFactory - component factory to be added.  Close Closes the component and frees used resources.\n public Task CloseAsync(string correlationId)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain.  Configure Configures the component by passing its configuration parameters.\n public virtual void Configure(ConfigParams config)\n  config: ConfigParams - configuration parameters to be set.  IsOpen Checks if the component is open.\n public virtual bool IsOpen()\n  returns: bool - True if the component is open and false otherwise.  Open Opens the component.\n public Task OpenAsync(string correlationId)\n  correlationId: string - (optional) transaction id to trace execution through call chain.  ReadConfigFromFile Reads the container\u0026rsquo;s configuration from a JSON or YAML file and parameterizes it with the given values.\n public void ReadConfigFromFile(string correlationId, string path, ConfigParams parameters)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. path: string - path to the configuration file parameters: ConfigParams - configuration parameters or null to skip parameterization.  SetReferences Sets references to dependent components.\n public virtual void SetReferences(IReferences references)\n  references: IReferences - references to locate the component dependencies.  UnsetReferences Unsets (clears) previously set references to dependent components.\n public virtual void UnsetReferences()\n Examples ======= config.yaml ======== - descriptor: mygroup:mycomponent1:default:default:1.0 param1: 123 param2: ABC - type: mycomponent2,mypackage param1: 321 param2: XYZ ============================ var container = new Container(); container.AddFactory(new MyComponentFactory()); var parameters = ConfigParams.fromValue(process.env); container.ReadConfigFromFile(\u0026#34;123\u0026#34;, \u0026#34;./config/config.yml\u0026#34;, parameters); container.Open(\u0026#34;123\u0026#34;); Console.Out.WriteLine(\u0026#34;Container is opened\u0026#34;); ... container.Close(\u0026#34;123\u0026#34;); Console.Out.WriteLine(\u0026#34;Container is closed\u0026#34;); See also   IConfigurable interface   IReferenceable interface   IUnreferenceable interface   IOpenable interface   ","description":"Inversion of control (IoC) container that creates components and manages their lifecycle.\n","image":null,"permalink":"/net/container/containers/container/","subtitle":null,"tags":null,"title":"Container"},{"content":"Implements: IConfigurable interface, IReferenceable interface, IUnreferenceable interface, IOpenable interface\nDescription The Container class allows you to create an inversion of control (IoC) container that creates components and manages their lifecycle.\nImportant points\n The container is driven by configuration, which is usually stored in a JSON or YAML file. The configuration contains a list of components identified by their type or locator, followed by their configuration. On start, a container performs the following actions:  Creates components using their types or calls registered factories to create them using their locators. Configures components that implement IConfigurable interface and passes them their configuration parameters. Sets references to components that implement IReferenceable interface and passes them references of all components in the container. Opens components that implement IOpenable interface.   On stop, a container reverses the orden of its actions:  Closes components that implement IClosable interface Unsets references in components that implement IUnreferenceable interface Destroys components in the container.    Configuration parameters  name: context (container or process) name description: human-readable description of the context properties: section of additional descriptive properties  \u0026hellip;    Constructors Creates a new instance of the container.\n public constructor(name?: string, description?: string)\n  name: string - (optional) container\u0026rsquo;s name (accessible via ContextInfo) description: string - (optional) container\u0026rsquo;s description (accessible via ContextInfo)  Fields _config Configuration of the container\n protected _config: ContainerConfig\n _references Container\u0026rsquo;s references\n protected _references: ContainerReferences\n _logger Logger.\n protected _logger: ILogger\n _info Container\u0026rsquo;s information.\n protected _info: ContextInfo\n _factories Default factories.\n protected _factories: DefaultContainerFactory\n  Instance methods addFactory Adds a factory to the container. The factory is used to create components added to the container by their locators (descriptors).\n public addFactory(factory: IFactory): void\n  factory: IFactory - component factory to be added.  close Closes the component and frees used resources.\n public close(correlationId: string): Promise\u0026lt;void\u0026gt;\n  correlationId: string - (optional) transaction id used to trace execution through the call chain.  configure Configures the component by passing its configuration parameters.\n public configure(config: ConfigParams): void\n  config: ConfigParams - configuration parameters to be set.  isOpen Checks if the component is open.\n public isOpen(): boolean\n  returns: boolean - True if the component is open and false otherwise.  open Opens the component.\n public open(correlationId: string): Promise\u0026lt;void\u0026gt;\n  correlationId: string - (optional) transaction id to trace execution through call chain.  readConfigFromFile Reads the container\u0026rsquo;s configuration from a JSON or YAML file and parameterizes it with the given values.\n public readConfigFromFile(correlationId: string, path: string, parameters: ConfigParams): void\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. path: string - path to the configuration file parameters: ConfigParams - configuration parameters or null to skip parameterization.  setReferences Sets references to dependent components.\n public setReferences(references: IReferences): void\n  references: IReferences - references to locate the component dependencies.  unsetReferences Unsets (clears) previously set references to dependent components.\n public unsetReferences()\n Examples ======= config.yaml ======== - descriptor: mygroup:mycomponent1:default:default:1.0 param1: 123 param2: ABC - type: mycomponent2,mypackage param1: 321 param2: XYZ ============================ let container = new Container(); container.addFactory(new MyComponentFactory()); let parameters = ConfigParams.fromValue(process.env); container.readConfigFromFile(\u0026#34;123\u0026#34;, \u0026#34;./config/config.yml\u0026#34;, parameters); await container.open(\u0026#34;123\u0026#34;); console.log(\u0026#34;Container is opened\u0026#34;); ... await container.close(\u0026#34;123\u0026#34;); console.log(\u0026#34;Container is closed\u0026#34;); See also   IConfigurable interface   IReferenceable interface   IUnreferenceable interface   IOpenable interface   ","description":"Inversion of control (IoC) container that creates components and manages their lifecycle.\n","image":null,"permalink":"/node/container/containers/container/","subtitle":null,"tags":null,"title":"Container"},{"content":"Implements: IConfigurable interface, IReferenceable interface, IUnreferenceable interface, IOpenable interface\nDescription The Container class allows you to create an inversion of control (IoC) container that creates components and manages their lifecycle.\nImportant points\n The container is driven by configuration, which is usually stored in a JSON or YAML file. The configuration contains a list of components identified by their type or locator, followed by their configuration. On start, a container performs the following actions:  Creates components using their types or calls registered factories to create them using their locators. Configures components that implement IConfigurable interface and passes them their configuration parameters. Sets references to components that implement IReferenceable interface and passes them references of all components in the container. Opens components that implement IOpenable interface.   On stop, a container reverses the orden of its actions:  Closes components that implement IClosable interface Unsets references in components that implement IUnreferenceable interface Destroys components in the container.    Configuration parameters  name: context (container or process) name description: human-readable description of the context properties: section of additional descriptive properties  \u0026hellip;    Constructors Creates a new instance of the container.\n Container(name: str = None, description: str = None)\n  name: str - (optional) container\u0026rsquo;s name (accessible via ContextInfo) description: str - (optional) container\u0026rsquo;s description (accessible via ContextInfo)  Fields _config Configuration of the container\n _config: ContainerConfig\n _references Container\u0026rsquo;s references\n _references: ContainerReferences\n _logger Logger.\n _logger: ILogger\n _info Container\u0026rsquo;s information.\n _info: ContextInfo\n _factories Default factories.\n _factories: DefaultContainerFactory\n  Instance methods add_factory Adds a factory to the container. The factory is used to create components added to the container by their locators (descriptors).\n add_factory(factory: IFactory)\n  factory: IFactory - component factory to be added.  close Closes the component and frees used resources.\n close(correlation_id: Optional[str])\n  correlation_id: Optional[str] - (optional) transaction id used to trace execution through the call chain.  configure Configures the component by passing its configuration parameters.\n configure(config: ConfigParams)\n  config: ConfigParams - configuration parameters to be set.  is_open Checks if the component is open.\n is_open(): bool\n  returns: bool - True if the component is open and false otherwise.  open Opens the component.\n open(correlation_id: Optional[str])\n  correlation_id: Optional[str] - (optional) transaction id to trace execution through call chain.  read_config_from_file Reads the container\u0026rsquo;s configuration from a JSON or YAML file and parameterizes it with the given values.\n read_config_from_file(correlation_id: Optional[str], path: str, parameters: ConfigParams)\n  correlation_id: Optional[str] - (optional) transaction id used to trace execution through the call chain. path: str - path to the configuration file parameters: ConfigParams - configuration parameters or None to skip parameterization.  set_references Sets references to dependent components.\n set_references(references: IReferences)\n  references: IReferences - references to locate the component dependencies.  unset_referencesf Unsets (clears) previously set references to dependent components.\n unset_referencesf()\n Examples ======= config.yaml ======== - descriptor: mygroup:mycomponent1:default:default:1.0 param1: 123 param2: ABC - type: mycomponent2,mypackage param1: 321 param2: XYZ ============================ container = Container() container.add_factory(MyComponentFactory()) parameters = ConfigParams.from_value(os.env) container.read_config_from_file(\u0026#34;123\u0026#34;, \u0026#34;./config/config.yml\u0026#34;, parameters) container.open(\u0026#34;123\u0026#34;) print \u0026#34;Container is opened\u0026#34; # process... container.close(\u0026#34;123\u0026#34;) print \u0026#34;Container is closed\u0026#34; See also   IConfigurable interface   IReferenceable interface   IUnreferenceable interface   IOpenable interface   ","description":"Inversion of control (IoC) container that creates components and manages their lifecycle.\n","image":null,"permalink":"/python/container/containers/container/","subtitle":null,"tags":null,"title":"Container"},{"content":"Implements: []ComponentConfig\nDescription The ContainerConfig class allows you to create a container configuration as a list of component configurations.\nConstructors NewContainerConfig Creates a new instance of ContainerConfig.\n NewContainerConfig(components \u0026hellip;*ComponentConfig) ContainerConfig\n  components: \u0026hellip;*ComponentConfig - (optional) list of component configurations.  NewContainerConfigFromValue Creates a new ContainerConfig object filled with key-value pairs from a specified object. The value is converted into ConfigParams object which is used to create the new object.\n NewContainerConfigFromValue(value interface{}) ContainerConfig\n  value: interface{} - object with key-value pairs used to initialize a new ContainerConfig. returns: ContainerConfig - created ContainerConfig object.  Methods ReadContainerConfigFromConfig Creates a new ContainerConfig object based on configuration parameters. Each section in the configuration parameters is converted into a component configuration.\n ReadContainerConfigFromConfig(config *config.ConfigParams) (ContainerConfig, error)\n  config: ConfigParams - object with key-value pairs used to initialize a new ContainerConfig. returns: ContainerConfig - created ContainerConfig object or error.  ","description":"Container configuration defined as a list of component configurations.\n","image":null,"permalink":"/golang/container/config/container_config/","subtitle":null,"tags":null,"title":"ContainerConfig"},{"content":"Inherits: List\u0026lt;ComponentConfig\u0026gt;\nDescription The ContainerConfig class allows you to create a container configuration as a list of component configurations.\nConstructors Creates a new instance of ContainerConfig.\n public ContainerConfig(IEnumerable\u0026lt;ComponentConfig\u0026gt; components)\n  components: IEnumerable\u0026lt;ComponentConfig\u0026gt; - (optional) list of component configurations.  Creates a new instance of container configuration.\n public ContainerConfig()\n Static methods FromConfig Creates a new ContainerConfig object based on configuration parameters. Each section in the configuration parameters is converted into a component configuration.\n public static ContainerConfig FromConfig([ConfigParams](../../../commons/config/config_params config)\n  config: ConfigParams - object with key-value pairs used to initialize a new ContainerConfig. returns: ContainerConfig - created ContainerConfig object.  FromObject Creates a new ContainerConfig object filled with key-value pairs from a specified object. The value is converted into ConfigParams object which is used to create the new object.\n public static ContainerConfig FromObject(object value)\n  value: object - object with key-value pairs used to initialize a new ContainerConfig. returns: ContainerConfig - created ContainerConfig object.  ","description":"Container configuration defined as a list of component configurations.\n","image":null,"permalink":"/net/container/config/container_config/","subtitle":null,"tags":null,"title":"ContainerConfig"},{"content":"Implements: Array\u0026lt;ComponentConfig\u0026gt;\nDescription The ContainerConfig class allows you to create a container configuration as a list of component configurations.\nConstructors Creates a new instance of ContainerConfig.\n public constructor(components?: ComponentConfig[])\n  components: ComponentConfig[] - (optional) list of component configurations.  Static methods fromConfig Creates a new ContainerConfig object based on configuration parameters. Each section in the configuration parameters is converted into a component configuration.\n public static fromConfig(config: ConfigParams): ContainerConfig\n  config: ConfigParams - object with key-value pairs used to initialize a new ContainerConfig. returns: ContainerConfig - created ContainerConfig object.  fromValue Creates a new ContainerConfig object filled with key-value pairs from a specified object. The value is converted into ConfigParams object which is used to create the new object.\n public static fromValue(value: any): ContainerConfig\n  value: any - object with key-value pairs used to initialize a new ContainerConfig. returns: ContainerConfig - created ContainerConfig object.  ","description":"Container configuration defined as a list of component configurations.\n","image":null,"permalink":"/node/container/config/container_config/","subtitle":null,"tags":null,"title":"ContainerConfig"},{"content":"Implements: list\nDescription The ContainerConfig class allows you to create a container configuration as a list of component configurations.\nConstructors Creates a new instance of ContainerConfig.\n ComponentConfig(components: Sequence[ComponentConfig] = None)\n  components: Sequence[ComponentConfig] - (optional) list of component configurations.  Static methods from_config Creates a new ContainerConfig object based on configuration parameters. Each section in the configuration parameters is converted into a component configuration.\n static from_config(config: ConfigParams): ContainerConfig\n  config: ConfigParams - object with key-value pairs used to initialize a new ContainerConfig. returns: ContainerConfig - created ContainerConfig object.  from_value Creates a new ContainerConfig object filled with key-value pairs from a specified object. The value is converted into ConfigParams object which is used to create the new object.\n static from_value(value: any): ContainerConfig\n  value: any - object with key-value pairs used to initialize a new ContainerConfig. returns: ContainerConfig - created ContainerConfig object.  ","description":"Container configuration defined as a list of component configurations.\n","image":null,"permalink":"/python/container/config/container_config/","subtitle":null,"tags":null,"title":"ContainerConfig"},{"content":"Description The ContainerConfigReader class allows you to read a container\u0026rsquo;s configuration from a JSON or YAML file.\nMethods ReadFromFile Reads a container\u0026rsquo;s configuration from JSON or YAML file. The type of the file is determined by the file extension.\n (c *TContainerConfigReader) ReadFromFile(correlationId string, path string, parameters *config.ConfigParams) (ContainerConfig, error)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. path: string - path to the component\u0026rsquo;s configuration file. parameters: *config.ConfigParams - configuration parameters or nil to skip parameterization. returns: ContainerConfig - read container configuration  ReadFromJsonFile Reads a container\u0026rsquo;s configuration from a JSON file.\n (c *TContainerConfigReader) ReadFromJsonFile(correlationId string, path string, parameters *config.ConfigParams) (ContainerConfig, error)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. path: string - path to the component\u0026rsquo;s configuration file. parameters: *config.ConfigParams - configuration parameters or nil to skip parameterization. returns: ContainerConfig - read container configuration  ReadFromYamlFile Reads container configuration from a YAML file.\n (c *TContainerConfigReader) ReadFromYamlFile(correlationId string, path string, parameters *config.ConfigParams) (ContainerConfig, error)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. path: string - path to the component\u0026rsquo;s configuration file. parameters: *config.ConfigParams - configuration parameters or nil to skip parameterization. returns: ContainerConfig - read container configuration  ","description":"Helper class that reads a container's configuration from a JSON or YAML file.\n","image":null,"permalink":"/golang/container/config/container_config_reader/","subtitle":null,"tags":null,"title":"ContainerConfigReader"},{"content":"Description The ContainerConfigReader class allows you to read a container\u0026rsquo;s configuration from a JSON or YAML file.\nStatic methods ReadFromFile Reads a container\u0026rsquo;s configuration from JSON or YAML file. The type of the file is determined by the file extension.\n public static ContainerConfig ReadFromFile(string correlationId, string path, ConfigParams parameters)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. path: string - path to the component\u0026rsquo;s configuration file. parameters: ConfigParams - configuration parameters or null to skip parameterization. returns: ContainerConfig - read container configuration  ReadFromJsonFile Reads a container\u0026rsquo;s configuration from a JSON file.\n public static ContainerConfig ReadFromJsonFile(string correlationId, string path, ConfigParams parameters)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. path: string - path to the component\u0026rsquo;s configuration file. parameters: ConfigParams - configuration parameters or null to skip parameterization. returns: ContainerConfig - read container configuration  ReadFromYamlFile Reads container configuration from a YAML file.\n public static ContainerConfig ReadFromYamlFile(string correlationId, string path, ConfigParams parameters)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. path: string - path to the component\u0026rsquo;s configuration file. parameters: ConfigParams - configuration parameters or null to skip parameterization. returns: ContainerConfig - read container configuration  ","description":"Helper class that reads a container's configuration from a JSON or YAML file.\n","image":null,"permalink":"/net/container/config/container_config_reader/","subtitle":null,"tags":null,"title":"ContainerConfigReader"},{"content":"Description The ContainerConfigReader class allows you to read a container\u0026rsquo;s configuration from a JSON or YAML file.\nStatic methods readFromFile Reads a container\u0026rsquo;s configuration from JSON or YAML file. The type of the file is determined by the file extension.\n public static readFromFile(correlationId: string, path: string, parameters: ConfigParams): ContainerConfig\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. path: string - path to the component\u0026rsquo;s configuration file. parameters: ConfigParams - configuration parameters or null to skip parameterization. returns: ContainerConfig - read container configuration  readFromJsonFile Reads a container\u0026rsquo;s configuration from a JSON file.\n public static readFromJsonFile(correlationId: string, path: string, parameters: ConfigParams): ContainerConfig\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. path: string - path to the component\u0026rsquo;s configuration file. parameters: ConfigParams - configuration parameters or null to skip parameterization. returns: ContainerConfig - read container configuration  readFromYamlFile Reads container configuration from a YAML file.\n public static readFromYamlFile(correlationId: string, path: string, parameters: ConfigParams): ContainerConfig\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. path: string - path to the component\u0026rsquo;s configuration file. parameters: ConfigParams - configuration parameters or null to skip parameterization. returns: ContainerConfig - read container configuration  ","description":"Helper class that reads a container's configuration from a JSON or YAML file.\n","image":null,"permalink":"/node/container/config/container_config_reader/","subtitle":null,"tags":null,"title":"ContainerConfigReader"},{"content":"Description The ContainerConfigReader class allows you to read a container\u0026rsquo;s configuration from a JSON or YAML file.\nStatic methods read_from_file Reads a container\u0026rsquo;s configuration from JSON or YAML file. The type of the file is determined by the file extension.\n static read_from_file(correlation_id: Optional[str], path: str, parameters: ConfigParams): ContainerConfig\n  correlation_id: Optional[str] - (optional) transaction id used to trace execution through the call chain. path: str - path to the component\u0026rsquo;s configuration file. parameters: ConfigParams - configuration parameters or None to skip parameterization. returns: ContainerConfig - read container configuration  read_from_json_file Reads a container\u0026rsquo;s configuration from a JSON file.\n static read_from_json_file(correlation_id: Optional[str], path: str, parameters: ConfigParams): ContainerConfig\n  correlation_id: Optional[str] - (optional) transaction id used to trace execution through the call chain. path: str - path to the component\u0026rsquo;s configuration file. parameters: ConfigParams - configuration parameters or None to skip parameterization. returns: ContainerConfig - read container configuration  read_from_yalm_file Reads container configuration from a YAML file.\n static read_from_yaml_file(correlation_id: Optional[str], path: str, parameters: ConfigParams): ContainerConfig\n  correlation_id: Optional[str] - (optional) transaction id used to trace execution through the call chain. path: str - path to the component\u0026rsquo;s configuration file. parameters: ConfigParams - configuration parameters or None to skip parameterization. returns: ContainerConfig - read container configuration  ","description":"Helper class that reads a container's configuration from a JSON or YAML file.\n","image":null,"permalink":"/python/container/config/container_config_reader/","subtitle":null,"tags":null,"title":"ContainerConfigReader"},{"content":"Implements: ManagedReferences\nDescription The ContainerReferences class allows you to create container\u0026rsquo;s managed references that can be created from a container configuration.\nConstructors NewContainerReferences Creates a new instance of the references\n NewContainerReferences() *ContainerReferences\n Methods PutFromConfig Puts components into the references from the container\u0026rsquo;s configuration.\nThrows CreateException when one of component cannot be created.\n (c *ContainerReferences) PutFromConfig(config config.ContainerConfig) error\n  config: config.ContainerConfig - container\u0026rsquo;s configuration with information of the components to be added. returns: error - returns error if not put  See also   ManagedReferences   ","description":"Container's managed references that can be created from container configuration.\n","image":null,"permalink":"/golang/container/refer/container_references/","subtitle":null,"tags":null,"title":"ContainerReferences"},{"content":"Inherits: ManagedReferences\nDescription The ContainerReferences class allows you to create container\u0026rsquo;s managed references that can be created from a container configuration.\nInstance methods PutFromConfig Puts components into the references from the container\u0026rsquo;s configuration.\nThrows CreateException when one of component cannot be created.\n public void PutFromConfig(ContainerConfig config)\n  config: ContainerConfig - container\u0026rsquo;s configuration with information of the components to be added.  See also   ManagedReferences   ","description":"Container's managed references that can be created from container configuration.\n","image":null,"permalink":"/net/container/refer/container_references/","subtitle":null,"tags":null,"title":"ContainerReferences"},{"content":"Extends: ManagedReferences\nDescription The ContainerReferences class allows you to create container\u0026rsquo;s managed references that can be created from a container configuration.\nInstance methods putFromConfig Puts components into the references from the container\u0026rsquo;s configuration.\nThrows CreateException when one of component cannot be created.\n public putFromConfig(config: ContainerConfig): void\n  config: ContainerConfig - container\u0026rsquo;s configuration with information of the components to be added.  See also   ManagedReferences   ","description":"Container's managed references that can be created from container configuration.\n","image":null,"permalink":"/node/container/refer/container_references/","subtitle":null,"tags":null,"title":"ContainerReferences"},{"content":"Implements: ManagedReferences\nDescription The ContainerReferences class allows you to create container\u0026rsquo;s managed references that can be created from a container configuration.\nInstance methods put_from_config Puts components into the references from the container\u0026rsquo;s configuration.\nThrows CreateException when one of component cannot be created.\n put_from_config(config: ContainerConfig)\n  config: ContainerConfig - container\u0026rsquo;s configuration with information of the components to be added.  See also   ManagedReferences   ","description":"Container's managed references that can be created from container configuration.\n","image":null,"permalink":"/python/container/refer/container_references/","subtitle":null,"tags":null,"title":"ContainerReferences"},{"content":"Description The ContextInfo class allows you to create context information components that provide detailed information about execution contexts.\nImportant points\n Most often ContextInfo is used by logging and performance counters to identify the source of the collected logs and metrics.  Configuration parameters  name: context\u0026rsquo;s (container or process) name description: human-readable description of the context properties: entire section of additional descriptive properties \u0026hellip;  Constructors NewContextInfo Creates a new instance of this context info.\n NewContextInfo() *ContextInfo\n NewContextInfoFromConfig Creates a new ContextInfo and sets its configuration parameters.\n NewContextInfoFromConfig(cfg *config.ConfigParams) *ContextInfo\n  config: *config.ConfigParams - configuration parameters for the new ContextInfo. returns: *ContextInfo - newly created ContextInfo  Fields ContextId Gets and sets the unique context id. Usually it is the current host name.\n ContextId: string\n Description Gets and sets the human-readable description of the context.\n Description: string\n Name Gets and sets the context\u0026rsquo;s name.\n Name: string\n Properties Gets context\u0026rsquo;s additional parameters.\n Properties: map[string]string\n StartTime Gets the context\u0026rsquo;s start time.\n StartTime: time.Time\n  Methods Configure Configures component by passing configuration parameters.\n (c *ContextInfo) Configure(cfg *config.ConfigParams)\n  cfg: *config.ConfigParams - configuration parameters to be set.  Examples contextInfo := NewContextInfo(); contextInfo.Configure(NewConfigParamsFromTuples( \u0026#34;name\u0026#34;, \u0026#34;MyMicroservice\u0026#34;, \u0026#34;description\u0026#34;, \u0026#34;My first microservice\u0026#34; )); context.Name; // Result: \u0026#34;MyMicroservice\u0026#34; context.ContextId; // Possible result: \u0026#34;mylaptop\u0026#34; context.StartTime; // Possible result: 2018-01-01:22:12:23.45Z ","description":"Context information component that provides detailed information about an execution context.\n","image":null,"permalink":"/golang/components/info/context_info/","subtitle":null,"tags":null,"title":"ContextInfo"},{"content":"Inherits: IReconfigurable\nDescription The ContextInfo class allows you to create context information components that provide detailed information about execution contexts.\nImportant points\n Most often ContextInfo is used by logging and performance counters to identify the source of the collected logs and metrics.  Configuration parameters  name: the context (container or process) name description: human-readable description of the context properties: entire section of additional descriptive properties \u0026hellip;  Constructors Creates a new instance of this context info.\n public ContextInfo(string name = null, string description = null)\n  name: string - (optional) a context name. description: string - (optional) a human-readable description of the context.  Creates a new instance of this context info.\n public ContextInfo()\n Properties Name Gets or sets the context name.\n public string Name { get; set; }\n Description Gets or sets the human-readable description of the context.\n public string Description { get; set; }\n ContextId Gets or sets the unique context id. Usually it is the current host name.\n public string ContextId = null { get; set; }\n Properties Gets or sets context additional parameters.\n public StringValueMap Properties { get; set; }\n StartTime Gets or sets the context start time.\n public DateTime StartTime = Environment.MachineName { get; set; }\n Uptime Calculates the context uptime as from the start time.\n public long Uptime = DateTime.UtcNow { get; }\n Instance methods Configure Configures component by passing configuration parameters.\n public void Configure(ConfigParams config)\n  config: ConfigParams - configuration parameters to be set.  Static methods FromConfig Creates a new ContextInfo and sets its configuration parameters.\n public static ContextInfo FromConfig(ConfigParams config)\n  config: ConfigParams - configuration parameters for the new ContextInfo. returns: ContextInfo - a newly created ContextInfo  Examples var contextInfo = new ContextInfo(); contextInfo.Configure(ConfigParams.FromTuples( \u0026#34;name\u0026#34;, \u0026#34;MyMicroservice\u0026#34;, \u0026#34;description\u0026#34;, \u0026#34;My first microservice\u0026#34; )); context.Name; // Result: \u0026#34;MyMicroservice\u0026#34; context.ContextId; // Possible result: \u0026#34;mylaptop\u0026#34; context.StartTime; // Possible result: 2018-01-01:22:12:23.45Z context.Uptime; // Possible result: 3454345 ","description":"Context information component that provides detailed information about an execution context.\n","image":null,"permalink":"/net/components/info/context_info/","subtitle":null,"tags":null,"title":"ContextInfo"},{"content":"Implements: IReconfigurable\nDescription The ContextInfo class allows you to create context information components that provide detailed information about execution contexts.\nImportant points\n Most often ContextInfo is used by logging and performance counters to identify the source of the collected logs and metrics.  Configuration parameters  name: the context (container or process) name description: human-readable description of the context properties: entire section of additional descriptive properties \u0026hellip;  Constructors Creates a new instance of this context info.\n public constructor(name?: string, description?: string)\n  name: string - (optional) a context name. description: string - (optional) a human-readable description of the context.  Properties contextId Gets the unique context id. Usually it is the current host name.\n public contextId(): string\n  returns: string - the unique context id.  Gets the unique context id. Usually it is the current host name.\n public contextId(context_id: string)\n  contextId: string - the unique context id.  description Gets the human-readable description of the context.\n public description(): string\n  returns: string - the human-readable description of the context.  Sets the human-readable description of the context.\n public description(description: string)\n  description: string - a new human readable description of the context.  name Gets the context name.\n public name(): string\n  returns: string - the context name  Sets the context name.\n public name(name: string)\n  name: string - a new name for the context.  properties Gets context additional parameters.\n public properties(): any\n  returns: any - a JSON object with additional context parameters.  Sets context additional parameters.\n public properties(properties: any)\n  properties: any - a JSON object with context additional parameters  startTime Gets the context start time.\n public startTime(): Date\n  returns: any - a JSON object with additional context parameters.  Sets the context start time.\n public startTime(start_time: Date)\n  start_time: Date - a new context start time.  Instance methods configure Configures component by passing configuration parameters.\n public configure(config: ConfigParams): void\n  config: ConfigParams - configuration parameters to be set.  Static methods fromConfig Creates a new ContextInfo and sets its configuration parameters.\n public static fromConfig(config: ConfigParams): ContextInfo\n  config: ConfigParams - configuration parameters for the new ContextInfo. returns: ContextInfo - a newly created ContextInfo  Examples let contextInfo = new ContextInfo(); contextInfo.configure(ConfigParams.fromTuples( \u0026#34;name\u0026#34;, \u0026#34;MyMicroservice\u0026#34;, \u0026#34;description\u0026#34;, \u0026#34;My first microservice\u0026#34; )); context.name; // Result: \u0026#34;MyMicroservice\u0026#34; context.contextId; // Possible result: \u0026#34;mylaptop\u0026#34; context.startTime; // Possible result: 2018-01-01:22:12:23.45Z context.uptime; // Possible result: 3454345 ","description":"Context information component that provides detailed information about an execution context.\n","image":null,"permalink":"/node/components/info/context_info/","subtitle":null,"tags":null,"title":"ContextInfo"},{"content":"Implements: IReconfigurable\nDescription The ContextInfo class allows you to create context information components that provide detailed information about execution contexts.\nImportant points\n Most often ContextInfo is used by logging and performance counters to identify the source of the collected logs and metrics.  Configuration parameters  name: the context (container or process) name description: human-readable description of the context properties: entire section of additional descriptive properties \u0026hellip;  Constructors Creates a new instance of this context info.\n MemoryDiscovery(name: str = None, description: str = None)\n  name: str - (optional) a context name. description: str - (optional) a human-readable description of the context.  Properties context_id Gets the unique context id. Usually it is the current host name.\n context_id(): str\n  returns: str - the unique context id.  Gets the unique context id. Usually it is the current host name.\n context_id(context_id: str)\n  context_id: str - the unique context id.  description Gets the human-readable description of the context.\n description(): str\n  returns: str - the human-readable description of the context.  Sets the human-readable description of the context.\n description(description: str)\n  description: str - a new human readable description of the context.  name Gets the context name.\n name(): str\n  returns: str - the context name  Sets the context name.\n name(name: str)\n  name: str - a new name for the context.  properties Gets context additional parameters.\n properties(): Any\n  returns: Any - a JSON object with additional context parameters.  Sets context additional parameters.\n properties(properties: Any)\n  properties: Any - a JSON object with context additional parameters  start_time Gets the context start time.\n start_time(): datetime.datetime\n  returns: Any - a JSON object with additional context parameters.  Sets the context start time.\n start_time(start_time: datetime.datetime)\n  start_time: datetime.datetime - a new context start time.  Instance methods configure Configures component by passing configuration parameters.\n configure(config: ConfigParams)\n  config: ConfigParams - configuration parameters to be set.  Static methods from_config Creates a new ContextInfo and sets its configuration parameters.\n static from_config(config: ConfigParams): ContextInfo\n  config: ConfigParams - configuration parameters for the new ContextInfo. returns: ContextInfo - a newly created ContextInfo  Examples contextInfo = ContextInfo() contextInfo.configure(ConfigParams.from_tuples( \u0026#34;name\u0026#34;, \u0026#34;MyMicroservice\u0026#34;, \u0026#34;description\u0026#34;, \u0026#34;My first microservice\u0026#34;)) context.name\t# Result: \u0026#34;MyMicroservice\u0026#34; context.context_id\t# Possible result: \u0026#34;mylaptop\u0026#34; context.start_time\t# Possible result: 2018-01-01:22:12:23.45Z context.uptime\t# Possible result: 3454345 ","description":"Context information component that provides detailed information about an execution context.\n","image":null,"permalink":"/python/components/info/context_info/","subtitle":null,"tags":null,"title":"ContextInfo"},{"content":"Description The Counter class allows you to create data objects used to store the measurements of performance counters.\nImportant points\n This object is used by CachedCounters to store counters.  Constructors NewCounter Creates a instance of the data object.\n NewCounter(name string, typ int) *Counter\n  name: string - counter name. type: int - counter type.  Fields Last Last recorded value\n Last: float32\n Count Total count\n Count: int\n Min Minimum value\n Min: float32\n max Maximum value\n Max: float32\n Average Average value\n Average: float32\n Time Recorded timestamp\n Time: time.Time\n Name Counter\u0026rsquo;s unique name\n Name: string\n Type Counter\u0026rsquo;s type that defines the measurement algorithm\n Type: CounterType\n  ","description":"Data object used to store the measurements of a performance counter.\n","image":null,"permalink":"/golang/components/count/counter/","subtitle":null,"tags":null,"title":"Counter"},{"content":"Description The Counter class allows you to create data objects used to store the measurements of performance counters.\nImportant points\n This object is used by CachedCounters to store counters.  Constructors Creates a instance of the data object.\n public Counter(string name, CounterType type)\n  name: string - a counter name. type: CounterType - a counter type.  Creates a instance of the data object.\n public Counter()\n Properties Name The counter\u0026rsquo;s unique name\n public string Name { get; set; }\n Type The counter type that defines the measurement algorithm\n public CounterType Type { get; set; }\n Last The last recorded value\n public double Last { get; set; }\n Min The minimum value\n public double Min { get; set; }\n Max The maximum value\n public double Max { get; set; }\n Average The average value\n public double Average { get; set; }\n Time The recorded timestamp\n public DateTime Time { get; set; }\n ","description":"Data object used to store the measurements of a performance counter.\n","image":null,"permalink":"/net/components/count/counter/","subtitle":null,"tags":null,"title":"Counter"},{"content":"Description The Counter class allows you to create data objects used to store the measurements of performance counters.\nImportant points\n This object is used by CachedCounters to store counters.  Constructors Creates a instance of the data object.\n public constructor(name: string = null, type: CounterType = null)\n  name: string - a counter name. type: CounterType - a counter type.  Fields last The last recorded value\n public last: number\n count The total count\n public count: number\n min The minimum value\n public min: number\n max The maximum value\n public max: number\n average The average value\n public average: number\n time The recorded timestamp\n public time: Date\n name The counter\u0026rsquo;s unique name\n public name: string\n type The counter type that defines the measurement algorithm\n public type: CounterType\n  ","description":"Data object used to store the measurements of a performance counter.\n","image":null,"permalink":"/node/components/count/counter/","subtitle":null,"tags":null,"title":"Counter"},{"content":"Description The Counter class allows you to create data objects used to store the measurements of performance counters.\nImportant points\n This object is used by CachedCounters to store counters.  Constructors Creates a instance of the data object.\n Counter(name: str = None, tipe: CounterType = None)\n  name: str - a counter name. tipe: CounterType - a counter type.  Fields last The last recorded value\n last: Optional[float]\n count The total count\n count: Optional[int]\n min The minimum value\n min: Optional[float]\n max The maximum value\n max: Optional[float]\n average The average value\n average: Optional[float]\n time The recorded timestamp\n time: Optional[datetime.datetime]\n name The counter\u0026rsquo;s unique name\n name: str\n type The counter type that defines the measurement algorithm\n type: CounterType\n  ","description":"Data object used to store the measurements of a performance counter.\n","image":null,"permalink":"/python/components/count/counter/","subtitle":null,"tags":null,"title":"Counter"},{"content":"Description The CounterTiming class allows you to create callback objects that are returned by ICounters.BeginTiming to end the timing of execution blocks and update the associated counters.\nConstructors NewCounterTiming Creates a new instance of the timing callback object.\n NewCounterTiming(counter string, callback ICounterTimingCallback) *CounterTiming\n  counter: string - associated counter name callback: ICounterTimingCallback - callback that shall be called when end_timing is called.  NewEmptyCounterTiming Creates a new instance of the timing callback object.\n NewEmptyCounterTiming() *CounterTiming\n Methods EndTiming Ends timing of an execution block, calculates elapsed time and updates the associated counter.\n (c *CounterTiming) EndTiming()\n Examples timing := counters.BeginTiming(\u0026#34;mymethod.exec_time\u0026#34;); defer timing.EndTiming(); ","description":"Callback object returned by [ICounters.beginTiming](../icounters/#begintiming) to end the timing of an execution block and update the associated counter.\n","image":null,"permalink":"/golang/components/count/counter_timing/","subtitle":null,"tags":null,"title":"CounterTiming"},{"content":"Description The CounterTiming class allows you to create callback objects that are returned by ICounters.BeginTiming to end the timing of execution blocks and update the associated counters.\nConstructors Creates a new instance of the timing callback object.\n public CounterTiming(string counter, ICounterTimingCallback callback)\n  counter: string - an associated counter name callback: ICounterTimingCallback - a callback that shall be called when end_timing is called.  Creates a new instance of the timing callback object.\n public CounterTiming()\n Instance methods EndTiming Ends timing of an execution block, calculates elapsed time and updates the associated counter.\n public void EndTiming()\n Examples var timing = counters.beginTiming(\u0026#34;mymethod.exec_time\u0026#34;); try { ... } finally { timing.EndTiming(); } ","description":"Callback object returned by [ICounters.beginTiming](../icounters/#begintiming) to end the timing of an execution block and update the associated counter.\n","image":null,"permalink":"/net/components/count/counter_timing/","subtitle":null,"tags":null,"title":"CounterTiming"},{"content":"Description The CounterTiming class allows you to create callback objects that are returned by ICounters.beginTiming to end the timing of execution blocks and update the associated counters.\nConstructors Creates a new instance of the timing callback object.\n public constructo(counter: string = null, callback: ICounterTimingCallback = null)\n  counter: string - an associated counter name callback: ICounterTimingCallback - a callback that shall be called when end_timing is called.  Fields _counters A list containing different counters\n protected _counters: ICounters[] = []\n  Instance methods endTiming Ends timing of an execution block, calculates elapsed time and updates the associated counter.\n public endTiming(): void\n Examples let timing = counters.beginTiming(\u0026#34;mymethod.exec_time\u0026#34;); try { ... } finally { timing.endTiming(); } ","description":"Callback object returned by [ICounters.beginTiming](../icounters/#begintiming) to end the timing of an execution block and update the associated counter.\n","image":null,"permalink":"/node/components/count/counter_timing/","subtitle":null,"tags":null,"title":"CounterTiming"},{"content":"Description The CounterTiming class allows you to create callback objects that are returned by ICounters.begin_timing to end the timing of execution blocks and update the associated counters.\nConstructors Creates a new instance of the timing callback object.\n CounterTiming(counter: str = None, callback: ICounterTimingCallback = None)\n  counter: str - an associated counter name callback: ICounterTimingCallback - a callback that shall be called when end_timing is called.  Fields _counters A list containing different counters\n _counters: List[ICounters] = []\n  Instance methods end_timing Ends timing of an execution block, calculates elapsed time and updates the associated counter.\n end_timing()\n Examples timing = counters.begin_timing(\u0026#34;mymethod.exec_time\u0026#34;) # do something timing.end_timing() ","description":"Callback object returned by [ICounters.begin_timing](../icounters/#begin_timing) to end the timing of an execution block and update the associated counter.\n","image":null,"permalink":"/python/components/count/counter_timing/","subtitle":null,"tags":null,"title":"CounterTiming"},{"content":"Description The CounterType class enumerates the types of counters that measure different types of metrics.\nEnumeration members  Interval = 0 - Counters that measure execution time intervals LastValue = 1 - Counters that keeps the latest measured value Statistics = 2 - Counters that measure min/average/max statistics Timestamp = 3 - Counter that record timestamps Increment = 4 - Counter that increment counters   ","description":"Counter type enumeration containing the types of counters that measure different types of metrics.\n","image":null,"permalink":"/golang/components/count/counter_type/","subtitle":null,"tags":null,"title":"CounterType"},{"content":"Description The CounterType class enumerates the types of counters that measure different types of metrics.\nEnumeration members  Interval = 0 - Counters that measure execution time intervals LastValue = 1 - Counters that keeps the latest measured value Statistics = 2 - Counters that measure min/average/max statistics Timestamp = 3 - Counter that record timestamps Increment = 4 - Counter that increment counters   ","description":"Counter type enumeration containing the types of counters that measure different types of metrics.\n","image":null,"permalink":"/node/components/count/counter_type/","subtitle":null,"tags":null,"title":"CounterType"},{"content":"Description The CounterType class enumerates the types of counters that measure different types of metrics.\nEnumeration members  Interval = 0 - Counters that measure execution time intervals LastValue = 1 - Counters that keeps the latest measured value Statistics = 2 - Counters that measure min/average/max statistics Timestamp = 3 - Counter that record timestamps Increment = 4 - Counter that increment counters   ","description":"Counter type enumeration containing the types of counters that measure different types of metrics.\n","image":null,"permalink":"/python/components/count/counter_type/","subtitle":null,"tags":null,"title":"CounterType"},{"content":"Description The CounterType class enumerates the types of counters that measure different types of metrics.\nEnumeration members  Interval = 0 - Counters that measure execution time intervals LastValue = 1 - Counters that keeps the latest measured value Statistics = 2 - Counters that measure min/average/max statistics Timestamp = 3 - Counter that record timestamps Increment = 4 - Counter that increment counters   ","description":"Counter type enumeration containing the types of counters that measure different types of metrics.\n","image":null,"permalink":"/net/components/count/counter_type/","subtitle":null,"tags":null,"title":"CounterType!"},{"content":"Extends: GenericCommentState\nDescription The CppCommentState class allows you to create a state that will either delegate to a comment-handling state, or return a token with just a slash in it.\nFields STAR Represents a star (*) char\n protected STAR: number = \u0026lsquo;*'.charCodeAt(0)\n SLASH Represents a forward slash (/) char.\n protected SLASH: number = \u0026lsquo;/'.charCodeAt(0)\n  Instance methods getMultiLineComment Ignore everything up to a closing star and slash, and then return the tokenizer\u0026rsquo;s next token.\n protected getMultiLineComment(scanner: IScanner): string\n  scanner: IScanner - scanner returns: string - comment  getSingleLineComment Ignore everything up to an end-of-line and return the tokenizer\u0026rsquo;s next token.\n protected getSingleLineComment(scanner: IScanner): string\n  scanner: IScanner - scanner returns: string - comment  nextToken Either delegate to a comment-handling state, or return a token with just a slash in it.\n public nextToken(scanner: IScanner, tokenizer: ITokenizer): Token\n  scanner: IScanner - A textual string to be tokenized. tokenizer: ITokenizer - A tokenizer class that controls the process. returns: Token - The next token from the top of the stream.  ","description":"This state will either delegate to a comment-handling state, or return a token with just a slash in it.\n","image":null,"permalink":"/node/expressions/tokenizers/generic/cpp_comment_state/","subtitle":null,"tags":null,"title":"CppCommentState"},{"content":"Description The CreateError class allows you to manage the error raised when a factory is not able to create a requested component.\nConstructors NewCreateError Creates an error instance and assigns its values.\n NewCreateError(correlationId string, message string) *errors.ApplicationError\n  correlationId: string - (optional) a unique transaction id used to trace execution through the call chain. message: string - human-readable error of the component that cannot be created.  NewCreateErrorByLocator Creates an error instance and assigns its values.\n NewCreateErrorByLocator(correlationId string, locator interface{}) *errors.ApplicationError\n  correlationId: string - (optional) unique transaction used id to trace execution through the call chain. message: interface{} - human-readable locator of the component that cannot be created.  See also   InternalError   ApplicationError   ","description":"Error raised when factory is not able to create a requested component.\n","image":null,"permalink":"/golang/components/build/create_error/","subtitle":null,"tags":null,"title":"CreateError"},{"content":"Inherits: InternalException\nDescription The CreateException class allows you to manage the error raised when a factory is not able to create a requested component.\nConstructors Creates an error instance and assigns its values.\n public CreateException(string correlationId, string message)\n  correlationId: string - (optional) a unique transaction id to trace execution through a call chain. message: string - human-readable error  Creates an error instance and assigns its values.\n public CreateException(string correlationId, object locator)\n  correlationId: string - (optional) a unique transaction id to trace execution through a call chain. message: object - locator of the component that cannot be created.  Creates an error instance.\n public CreateException()\n See also   InternalException   ApplicationException   ","description":"Error raised when factory is not able to create a requested component.\n","image":null,"permalink":"/net/components/build/create_exception/","subtitle":null,"tags":null,"title":"CreateException"},{"content":"Implements: InternalException\nDescription The CreateException class allows you to manage the error raised when a factory is not able to create a requested component.\nConstructors Creates an error instance and assigns its values.\n public constructor(correlationId: string = null, messageOrLocator: any)\n  correlationId: string - (optional) a unique transaction id to trace execution through a call chain. messageOrLocator: any - human-readable error or locator of the component that cannot be created.  See also   InternalException   ApplicationException   ","description":"Error raised when factory is not able to create a requested component.\n","image":null,"permalink":"/node/components/build/create_exception/","subtitle":null,"tags":null,"title":"CreateException"},{"content":"Implements: InternalException\nDescription The CreateException class allows you to manage the error raised when a factory is not able to create a requested component.\nConstructors Creates an error instance and assigns its values.\n CreateException(correlation_id: Optional[str] = None, message_or_locator: str = None)\n  correlation_id: Optional[str] - (optional) a unique transaction id to trace execution through a call chain. message_or_locator: str - human-readable error or locator of the component that cannot be created.  See also   InternalException   ApplicationException   ","description":"Error raised when factory is not able to create a requested component.\n","image":null,"permalink":"/python/components/build/create_exception/","subtitle":null,"tags":null,"title":"CreateException"},{"content":"Implements: ConfigParams\nDescription The CredentialParams class allows you to create credential parameters that can be used to authenticate against external services.\nImportant points\n Credential parameters are used together with connection parameters, but usually stored in a separate store, protected from unauthorized access.  Configuration parameters  store_key: key to retrieve parameters from a credential store username: user name user: alternative to username password: user password pass: alternative to password access_id: application access id client_id: alternative to access_id access_key: application secret key client_key: alternative to access_key secret_key: alternative to access_key  In addition to standard parameters CredentialParams may contain any number of custom parameters.\nConstructors NewEmptyCredentialParams Creates a new CredentialParams object and fills it with values.\n NewEmptyCredentialParams() *CredentialParams\n NewCredentialParams Creates a new CredentialParams object and fills it with values.\n NewCredentialParams(values map[string]string) *CredentialParams\n  values: map[string]string - (optional) object to be converted into key-value pairs to initialize these credentials.  NewCredentialParamsFromValue Method that creates a ConfigParams object based on the values that are stored in the \u0026lsquo;value\u0026rsquo; object\u0026rsquo;s properties.\n NewCredentialParamsFromValue(value interface{}) *CredentialParams\n  value: interface{} - configuration parameters in the form of an object with properties.  NewManyCredentialParamsFromConfig Retrieves a single CredentialParams from configuration parameters from the \u0026ldquo;credential\u0026rdquo; section. If the \u0026ldquo;credentials\u0026rdquo; section is present instead, then it returns only the first credential element.\n NewManyCredentialParamsFromConfig(config *config.ConfigParams) []*CredentialParams\n  config: *config.ConfigParams - containing a section named \u0026ldquo;credential(s)\u0026rdquo;. returns: []*CredentialParams - generated CredentialParams object.  NewCredentialParamsFromString Creates a new CredentialParams object filled with key-value pairs serialized as a string.\n NewCredentialParamsFromString(line string) *CredentialParams\n  line: string - a string with serialized key-value pairs as \u0026ldquo;key1=value1;key2=value2;\u0026hellip;\u0026quot; Example: \u0026ldquo;Key1=123;Key2=ABC;Key3=2016-09-16T00:00:00.00Z\u0026rdquo; returns: CredentialParams - new CredentialParams object.  NewCredentialParamsFromTuples Creates a new CredentialParams object filled with provided key-value pairs called tuples. Tuples parameters contain a sequence of key1, value1, key2, value2, \u0026hellip; pairs.\n NewCredentialParamsFromTuples(tuples \u0026hellip;interface{}) *CredentialParams\n  tuples: \u0026hellip;interface{} - tuples used to fill a new CredentialParams object. returns: *CredentialParams - a new CredentialParams object.  NewManyCredentialParamsFromConfig Retrieves all CredentialParams from configuration parameters from \u0026ldquo;credentials\u0026rdquo; section. If \u0026ldquo;credential\u0026rdquo; section is present instead, then it returns a list with only one CredentialParams.\n NewManyCredentialParamsFromConfig(config *config.ConfigParams) []*CredentialParams\n  config: *config.ConfigParams - configuration parameters to retrieve credentials returns: []*CredentialParams - list of retrieved CredentialParams  Methods AccessId Gets the application access id. The value can be stored in parameters \u0026ldquo;access_id\u0026rdquo; pr \u0026ldquo;client_id\u0026rdquo;\n (c *CredentialParams) AccessId() string\n  returns: string - application access id.  AccessKey Gets the application secret key. The value can be stored in parameters \u0026ldquo;access_key\u0026rdquo;, \u0026ldquo;client_key\u0026rdquo; or \u0026ldquo;secret_key\u0026rdquo;.\n (c *CredentialParams) AccessKey() string\n  returns: string - application secret key.  Password Gets the user password. The value can be stored in parameters \u0026ldquo;password\u0026rdquo; or \u0026ldquo;pass\u0026rdquo;.\n (c *CredentialParams) Password() string\n  returns: string - user password.  StoreKey Gets the key to retrieve these credentials from ICredentialStore. If this key is nil, then all parameters are already present.\n (c *CredentialParams) StoreKey() string\n  returns: string - store key to retrieve credentials.  Username Gets the user name. The value can be stored in parameters \u0026ldquo;username\u0026rdquo; or \u0026ldquo;user\u0026rdquo;.\n (c *CredentialParams) Username() string\n  returns: string - user name.  SetAccessId Sets the application access id.\n (c *CredentialParams) SetAccessId(value string)\n  value: string - new application access id.  SetAccessKey Sets the application secret key.\n (c *CredentialParams) SetAccessKey(value string)\n  value: string - new application secret key.  SetPassword Sets the user password.\n (c *CredentialParams) SetPassword(value string)\n  password: string - new user password.  SetStoreKey Sets the key to retrieve these parameters from ICredentialStore.\n (c *CredentialParams) SetStoreKey(value string)\n  value: string - new key to retrieve credentials.  SetUsername Sets the user name.\n (c *CredentialParams) SetUsername(value string)\n  value: string - new user name.  UseCredentialStore Checks if these credential parameters shall be retrieved from ICredentialStore. The credential parameters are redirected to ICredentialStore when the store_key parameter is set.\n (c *CredentialParams) UseCredentialStore() bool\n  value: bool - true if credentials shall be retrieved from ICredentialStore  Examples credential := NewCredentialParamsFromTuples( \u0026#34;user\u0026#34;, \u0026#34;jdoe\u0026#34;, \u0026#34;pass\u0026#34;, \u0026#34;pass123\u0026#34;, \u0026#34;pin\u0026#34;, \u0026#34;321\u0026#34; ); username := credential.Username(); // Result: \u0026#34;jdoe\u0026#34; password := credential.Password(); // Result: \u0026#34;pass123\u0026#34; See also   ConfigParams   ConnectionParams   CredentialResolver   ICredentialStore   ","description":"Contains credentials to authenticate against external services.\n","image":null,"permalink":"/golang/components/auth/credential_params/","subtitle":null,"tags":null,"title":"CredentialParams"},{"content":"Implemets: ConfigParams\nDescription The CredentialParams class allows you to create credential parameters that can be used to authenticate against external services.\nImportant points\n Credential parameters are used together with connection parameters, but usually stored in a separate store, protected from unauthorized access.  Configuration parameters  store_key: key to retrieve parameters from credential store username: user name user: alternative to username password: user password pass: alternative to password access_id: application access id client_id: alternative to access_id access_key: application secret key client_key: alternative to access_key secret_key: alternative to access_key  In addition to standard parameters CredentialParams may contain any number of custom parameters.\nConstructors Creates a new credential parameters and fills it with values.\n public CredentialParams(IDictionary\u0026lt;string, string\u0026gt; values)\n  values: IDictionary\u0026lt;string, string\u0026gt; - (optional) an object to be converted into key-value pairs to initialize these credentials.  Creates an empty instance of credential parameters.\n public CredentialParams()\n Properties UseCredentialStore Checks if these credential parameters shall be retrieved from ICredentialStore. The credential parameters are redirected to ICredentialStore when store_key parameter is set.\n public bool UseCredentialStore { get; }\n StoreKey Gets and sets the key to retrieve these credentials from ICredentialStore. If this key is null, then all parameters are already present.\n public string StoreKey { get; set; }\n Username Gets and sets the user name. The value can be stored in parameters \u0026ldquo;username\u0026rdquo; or \u0026ldquo;user\u0026rdquo;.\n public string Username { get; set; }\n Password Gets and sets the user password. The value can be stored in parameters \u0026ldquo;password\u0026rdquo; or \u0026ldquo;pass\u0026rdquo;.\n public string Password { get; set; }\n AccessId Gets and sets the application access id. The value can be stored in parameters \u0026ldquo;access_id\u0026rdquo; pr \u0026ldquo;client_id\u0026rdquo;\n public string AccessId { get; set; }\n AccessKey Gets and sets the application secret key. The value can be stored in parameters \u0026ldquo;access_key\u0026rdquo;, \u0026ldquo;client_key\u0026rdquo; or \u0026ldquo;secret_key\u0026rdquo;.\n public string AccessKey { get; set; }\n Static methods FromConfig Retrieves a single CredentialParams from configuration parameters from \u0026ldquo;credential\u0026rdquo; section. If \u0026ldquo;credentials\u0026rdquo; section is present instead, then it returns only the first credential element.\n public static CredentialParams FromConfig(ConfigParams config)\n  config: ConfigParams - containing a section named \u0026ldquo;credential(s)\u0026rdquo;. returns: CredentialParams - the generated CredentialParams object.  FromString Creates a new CredentialParams object filled with key-value pairs serialized as a string.\n public static CredentialParams FromString(string line)\n  line: string - a string with serialized key-value pairs as \u0026ldquo;key1=value1;key2=value2;\u0026hellip;\u0026quot; Example: \u0026ldquo;Key1=123;Key2=ABC;Key3=2016-09-16T00:00:00.00Z\u0026rdquo; returns: CredentialParams - a new CredentialParams object.  ManyFromConfig Retrieves all CredentialParams from configuration parameters from \u0026ldquo;credentials\u0026rdquo; section. If \u0026ldquo;credential\u0026rdquo; section is present instead, then it returns a list with only one CredentialParams.\n public static List\u0026lt;CredentialParams\u0026gt; ManyFromConfig(ConfigParams config)\n  config: ConfigParams - a configuration parameters to retrieve credentials returns: List\u0026lt;CredentialParams\u0026gt; - a list of retrieved CredentialParams  Examples var credential = CredentialParams.FromTuples( \u0026#34;user\u0026#34;, \u0026#34;jdoe\u0026#34;, \u0026#34;pass\u0026#34;, \u0026#34;pass123\u0026#34;, \u0026#34;pin\u0026#34;, \u0026#34;321\u0026#34; ); var username = credential.GetUsername(); // Result: \u0026#34;jdoe\u0026#34; var password = credential.GetPassword(); // Result: \u0026#34;pass123\u0026#34; var pin = credential.GetAsNullableString(\u0026#34;pin\u0026#34;); // Result: 321 See also   ConfigParams   ConnectionParams   CredentialResolver   ICredentialStore   ","description":"Contains credentials to authenticate against external services.\n","image":null,"permalink":"/net/components/auth/credential_params/","subtitle":null,"tags":null,"title":"CredentialParams"},{"content":"Extends: ConfigParams\nDescription The CredentialParams class allows you to create credential parameters that can be used to authenticate against external services.\nImportant points\n Credential parameters are used together with connection parameters, but usually stored in a separate store, protected from unauthorized access.  Configuration parameters  store_key: key to retrieve parameters from credential store username: user name user: alternative to username password: user password pass: alternative to password access_id: application access id client_id: alternative to access_id access_key: application secret key client_key: alternative to access_key secret_key: alternative to access_key  In addition to standard parameters CredentialParams may contain any number of custom parameters.\nConstructors Creates a new credential parameters and fills it with values.\n public constructor(values: any = null)\n  values: any - (optional) an object to be converted into key-value pairs to initialize these credentials.  Instance methods getAccessId Gets the application access id. The value can be stored in parameters \u0026ldquo;access_id\u0026rdquo; pr \u0026ldquo;client_id\u0026rdquo;\n public getAccessId(): string\n  returns: string - the application access id.  getAccessKey Gets the application secret key. The value can be stored in parameters \u0026ldquo;access_key\u0026rdquo;, \u0026ldquo;client_key\u0026rdquo; or \u0026ldquo;secret_key\u0026rdquo;.\n public getAccessKey(): string\n  returns: string - the application secret key.  getPassword Get the user password. The value can be stored in parameters \u0026ldquo;password\u0026rdquo; or \u0026ldquo;pass\u0026rdquo;.\n public getPassword(): string\n  returns: string - the user password.  getStoreKey Gets the key to retrieve these credentials from ICredentialStore. If this key is null, then all parameters are already present.\n public getStoreKey(): string\n  returns: string - the store key to retrieve credentials.  getUsername Gets the user name. The value can be stored in parameters \u0026ldquo;username\u0026rdquo; or \u0026ldquo;user\u0026rdquo;.\n public getUsername(): string\n  returns: string - the user name.  setAccessId Sets the application access id.\n public setAccessId(value: string): void\n  value: string - a new application access id.  setAccessKey Sets the application secret key.\n public set_access_key(value: string): void\n  value: string - a new application secret key.  setPassword Sets the user password.\n public setPassword(password: string): void\n  password: string - a new user password.  setStoreKey Sets the key to retrieve these parameters from ICredentialStore.\n public setStoreKey(value: string): void\n  value: string - a new key to retrieve credentials.  setUsername Sets the user name.\n public setUsername(value: string): void\n  value: string - a new user name.  useCredentialStore Checks if these credential parameters shall be retrieved from ICredentialStore. The credential parameters are redirected to ICredentialStore when store_key parameter is set.\n public useCredentialStore(): bool\n  value: bool - true if credentials shall be retrieved from ICredentialStore  Static methods fromConfig Retrieves a single CredentialParams from configuration parameters from \u0026ldquo;credential\u0026rdquo; section. If \u0026ldquo;credentials\u0026rdquo; section is present instead, then it returns only the first credential element.\n public static fromConfig(config: ConfigParams): CredentialParams\n  config: ConfigParams - containing a section named \u0026ldquo;credential(s)\u0026rdquo;. returns: CredentialParams - the generated CredentialParams object.  fromString Creates a new CredentialParams object filled with key-value pairs serialized as a string.\n public static fromString(line: string): CredentialParams\n  line: string - a string with serialized key-value pairs as \u0026ldquo;key1=value1;key2=value2;\u0026hellip;\u0026quot; Example: \u0026ldquo;Key1=123;Key2=ABC;Key3=2016-09-16T00:00:00.00Z\u0026rdquo; returns: CredentialParams - a new CredentialParams object.  fromTuples Creates a new CredentialParams object filled with provided key-value pairs called tuples. Tuples parameters contain a sequence of key1, value1, key2, value2, \u0026hellip; pairs.\n public static fromTuples(\u0026hellip;tuples: any): CredentialParams\n  tuples: any - the tuples to fill a new CredentialParams object. returns: CredentialParams - a new CredentialParams object.  manyFromConfig Retrieves all CredentialParams from configuration parameters from \u0026ldquo;credentials\u0026rdquo; section. If \u0026ldquo;credential\u0026rdquo; section is present instead, then it returns a list with only one CredentialParams.\n public static manyFromConfig(config: ConfigParams): CredentialParams[]\n  config: ConfigParams - a configuration parameters to retrieve credentials returns: CredentialParams[] - a list of retrieved CredentialParams  Examples let credential = CredentialParams.fromTuples( \u0026#34;user\u0026#34;, \u0026#34;jdoe\u0026#34;, \u0026#34;pass\u0026#34;, \u0026#34;pass123\u0026#34;, \u0026#34;pin\u0026#34;, \u0026#34;321\u0026#34; ); let username = credential.getUsername(); // Result: \u0026#34;jdoe\u0026#34; let password = credential.getPassword(); // Result: \u0026#34;pass123\u0026#34; let pin = credential.getAsNullableString(\u0026#34;pin\u0026#34;); // Result: 321 See also   ConfigParams   ConnectionParams   CredentialResolver   ICredentialStore   ","description":"Contains credentials to authenticate against external services.\n","image":null,"permalink":"/node/components/auth/credential_params/","subtitle":null,"tags":null,"title":"CredentialParams"},{"content":"Implements: ConfigParams\nDescription The CredentialParams class allows you to create credential parameters that can be used to authenticate against external services.\nImportant points\n Credential parameters are used together with connection parameters, but usually stored in a separate store, protected from unauthorized access.  Configuration parameters  store_key: key to retrieve parameters from credential store username: user name user: alternative to username password: user password pass: alternative to password access_id: application access id client_id: alternative to access_id access_key: application secret key client_key: alternative to access_key secret_key: alternative to access_key  In addition to standard parameters CredentialParams may contain any number of custom parameters.\nConstructors Creates a new credential parameters and fills it with values.\n CredentialParams(values: Any = None)\n  values: Any - (optional) an object to be converted into key-value pairs to initialize these credentials.  Instance methods get_access_id Gets the application access id. The value can be stored in parameters \u0026ldquo;access_id\u0026rdquo; pr \u0026ldquo;client_id\u0026rdquo;\n get_access_id(): str\n  returns: str - the application access id.  get_access_key Gets the application secret key. The value can be stored in parameters \u0026ldquo;access_key\u0026rdquo;, \u0026ldquo;client_key\u0026rdquo; or \u0026ldquo;secret_key\u0026rdquo;.\n get_access_key(): str\n  returns: str - the application secret key.  get_password Get the user password. The value can be stored in parameters \u0026ldquo;password\u0026rdquo; or \u0026ldquo;pass\u0026rdquo;.\n get_password(): str\n  returns: str - the user password.  get_store_key Gets the key to retrieve these credentials from ICredentialStore. If this key is None, then all parameters are already present.\n get_store_key(): str\n  returns: str - the store key to retrieve credentials.  get_username Gets the user name. The value can be stored in parameters \u0026ldquo;username\u0026rdquo; or \u0026ldquo;user\u0026rdquo;.\n get_username(): str\n  returns: str - the user name.  set_access_id Sets the application access id.\n set_access_id(value: str)\n  value: str - a new application access id.  set_access_key Sets the application secret key.\n set_access_key(value: str)\n  value: str - a new application secret key.  set_password Sets the user password.\n set_password(password: str)\n  password: str - a new user password.  set_store_key Sets the key to retrieve these parameters from ICredentialStore.\n set_store_key(value: str)\n  value: str - a new key to retrieve credentials.  set_username Sets the user name.\n set_username(value: str)\n  value: str - a new user name.  use_credential_store Checks if these credential parameters shall be retrieved from ICredentialStore. The credential parameters are redirected to ICredentialStore when store_key parameter is set.\n use_credential_store(): bool\n  value: bool - true if credentials shall be retrieved from ICredentialStore  Static methods from_config Retrieves a single CredentialParams from configuration parameters from \u0026ldquo;credential\u0026rdquo; section. If \u0026ldquo;credentials\u0026rdquo; section is present instead, then it returns only the first credential element.\n static from_config(config: ConfigParams): CredentialParams\n  config: ConfigParams - containing a section named \u0026ldquo;credential(s)\u0026rdquo;. returns: CredentialParams - the generated CredentialParams object.  from_string Creates a new CredentialParams object filled with key-value pairs serialized as a string.\n static from_string(line: str): CredentialParams\n  line: str - a string with serialized key-value pairs as \u0026ldquo;key1=value1;key2=value2;\u0026hellip;\u0026quot; Example: \u0026ldquo;Key1=123;Key2=ABC;Key3=2016-09-16T00:00:00.00Z\u0026rdquo; returns: CredentialParams - a new CredentialParams object.  from_tuples Creates a new CredentialParams object filled with provided key-value pairs called tuples. Tuples parameters contain a sequence of key1, value1, key2, value2, \u0026hellip; pairs.\n static from_tuples(*tuples: Any): CredentialParams\n  tuples: Any - the tuples to fill a new CredentialParams object. returns: CredentialParams - a new CredentialParams object.  many_from_config Retrieves all CredentialParams from configuration parameters from \u0026ldquo;credentials\u0026rdquo; section. If \u0026ldquo;credential\u0026rdquo; section is present instead, then it returns a list with only one CredentialParams.\n static many_from_config(config: ConfigParams): List[CredentialParams]\n  config: ConfigParams - a configuration parameters to retrieve credentials returns: List[CredentialParams] - a list of retrieved CredentialParams  Examples credential = CredentialParams.from_tuples (\u0026#34;user\u0026#34;, \u0026#34;jdoe\u0026#34;, \u0026#34;pass\u0026#34;, \u0026#34;pass123\u0026#34;, \u0026#34;pin\u0026#34;, \u0026#34;321\u0026#34;) username = credential.get_username() # Result: \u0026#34;jdoe\u0026#34; password = credential.get_password() # Result: \u0026#34;pass123\u0026#34; pin = credential.get_as_nullable_string(\u0026#34;pin\u0026#34;) # Result: 321 See also   ConfigParams   ConnectionParams   CredentialResolver   ICredentialStore   ","description":"Contains credentials to authenticate against external services.\n","image":null,"permalink":"/python/components/auth/credential_params/","subtitle":null,"tags":null,"title":"CredentialParams"},{"content":"Description The CredentialResolver class is used to retrieve component credentials.\nImportant points\n If credentials are configured to be retrieved from ICredentialStore, it will automatically locate ICredentialStore in component references and retrieve the credentials from there using the store_key parameter.  Configuration parameters credential:\n store_key: (optional) key to retrieve the credentials from ICredentialStore \u0026hellip;: other credential parameters  credentials: alternative to credential\n [credential params 1]: first credential parameters  \u0026hellip; : credential parameters for key 1   \u0026hellip; [credential params N]: Nth credential parameters  \u0026hellip; : credential parameters for key N    References  *:credential-store:*:*:1.0 - (optional) Credential stores to resolve credentials  Constructors NewCredentialResolver Creates a new instance of credentials resolver.\n NewCredentialResolver(config *config.ConfigParams, references refer.IReferences) *CredentialResolver\n  config: *config.ConfigParams - (optional) component configuration parameters references: refer.IReferences - (optional) component references  NewEmptyCredentialResolver Creates a new instance of credentials resolver.\n NewEmptyCredentialResolver() *CredentialResolver\n Methods Add Adds a new credential to a credential component.\n (c *CredentialResolver) Add(credential *CredentialParams)\n  connection: *CredentialParams - new credential parameters to be added  Configure Configures component by passing configuration parameters.\n (c *CredentialResolver) Configure(config *config.ConfigParams)\n  config: *config.ConfigParams - configuration parameters to be set.  GetAll Gets all credentials configured in component configuration.\nRedirect to CredentialStores is not done at this point. If you need fully fleshed credential use lookup method instead.\n (c *CredentialResolver) GetAll() []*CredentialParams\n  returns: []*CredentialParams - list with credential parameters  Lookup Looks up component\u0026rsquo;s credential parameters. If credentials are configured to be retrieved from a credential store it finds a ICredentialStore` and lookups the credentials there.\n (c *CredentialResolver) Lookup(correlationId string) (*CredentialParams, error)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. returns: (*CredentialParams, error) - resolved credential parameters or nil if nothing was found.  SetReferences Sets references to dependent components.\n (c *CredentialResolver) SetReferences(references refer.IReferences)\n  references: refer.IReferences - references to locate the component dependencies.  Examples config := NewConfigParamsFromTuples( \u0026#34;credential.user\u0026#34;, \u0026#34;jdoe\u0026#34;, \u0026#34;credential.pass\u0026#34;, \u0026#34;pass123\u0026#34; ); credentialResolver := NewCredentialResolver(); credentialResolver.Configure(config); credentialResolver.SetReferences(references); credentialResolver.Lookup(\u0026#34;123\u0026#34;, (err, credential) =\u0026gt; { // Now use credential... }); See also   CredentialParams   ICredentialStore   ","description":"Helper class used to retrieve component credentials.\n","image":null,"permalink":"/golang/components/auth/credential_resolver/","subtitle":null,"tags":null,"title":"CredentialResolver"},{"content":"Inherits: IConfigurable, IReferenceable\nDescription The CredentialResolver class is used to retrieve component credentials.\nImportant points\n If credentials are configured to be retrieved from ICredentialStore, it will automatically locate ICredentialStore in component references and retrieve the credentials from there using the store_key parameter.  Configuration parameters credential:\n store_key: (optional) a key to retrieve the credentials from ICredentialStore \u0026hellip;: other credential parameters  credentials: alternative to credential\n [credential params 1]: first credential parameters  \u0026hellip; : credential parameters for key 1   \u0026hellip; [credential params N]: Nth credential parameters  \u0026hellip; : credential parameters for key N    References  *:credential-store:*:*:1.0 - (optional) Credential stores to resolve credentials  Constructors Creates a new instance of credentials resolver.\n public CredentialResolver(ConfigParams config = null, IReferences references = null)\n  config: ConfigParams - (optional) component configuration parameters references: IReferences - (optional) component references  Instance methods Add Adds a new credential to component credentials\n public void Add(CredentialParams connection)\n  connection: CredentialParams - new credential parameters to be added  Configure Configures component by passing configuration parameters.\n public void Configure(ConfigParams config, bool configAsDefault = true)\n  config: ConfigParams - configuration parameters to be set. configAsDefault: bool - boolean parameter for default configuration. If \u0026ldquo;true\u0026rdquo; the default value will be added to the result.  GetAll Gets all credentials configured in component configuration.\nRedirect to CredentialStores is not done at this point. If you need fully fleshed credential use lookup method instead.\n public List\u0026lt;CredentialParams\u0026gt; GetAll()\n  returns: List\u0026lt;CredentialParams\u0026gt; - a list with credential parameters  LookupAsync Looks up component credential parameters. If credentials are configured to be retrieved from Credential store it finds a ICredentialStore` and lookups credentials there.\n public Task\u0026lt;CredentialParams\u0026gt; LookupAsync(string correlationId)\n  correlationId: string - (optional) transaction id to trace execution through call chain. returns: Task\u0026lt;CredentialParams\u0026gt; - resolved credential parameters or null if nothing was found.  SetReferences Sets references to dependent components.\n public void SetReferences(IReferences references)\n  references: IReferences - references to locate the component dependencies.  Examples var config = ConfigParams.FromTuples( \u0026#34;credential.user\u0026#34;, \u0026#34;jdoe\u0026#34;, \u0026#34;credential.pass\u0026#34;, \u0026#34;pass123\u0026#34; ); var credentialResolver = new CredentialResolver(); credentialResolver.Configure(config); credentialResolver.SetReferences(references); credentialResolver.LookupAsync(\u0026#34;123\u0026#34;); ### See also - #### [CredentialParams](../credential_params) - #### [ICredentialStore](../icredentialStore) ","description":"Helper class used to retrieve component credentials.\n","image":null,"permalink":"/net/components/auth/credential_resolver/","subtitle":null,"tags":null,"title":"CredentialResolver"},{"content":"Implements: IConfigurable, IReferenceable\nDescription The CredentialResolver class is used to retrieve component credentials.\nImportant points\n If credentials are configured to be retrieved from ICredentialStore, it will automatically locate ICredentialStore in component references and retrieve the credentials from there using the store_key parameter.  Configuration parameters credential:\n store_key: (optional) a key to retrieve the credentials from ICredentialStore \u0026hellip;: other credential parameters  credentials: alternative to credential\n [credential params 1]: first credential parameters  \u0026hellip; : credential parameters for key 1   \u0026hellip; [credential params N]: Nth credential parameters  \u0026hellip; : credential parameters for key N    References  *:credential-store:*:*:1.0 - (optional) Credential stores to resolve credentials  Constructors Creates a new instance of credentials resolver.\n public constructor(config: ConfigParams = null, references: IReferences = null)\n  config: ConfigParams - (optional) component configuration parameters references: IReferences - (optional) component references  Instance methods add Adds a new credential to component credentials\n public add(connection: CredentialParams): void\n  connection: CredentialParams - new credential parameters to be added  configure Configures component by passing configuration parameters.\n public configure(config: ConfigParams): void\n  config: ConfigParams - configuration parameters to be set.  getAll Gets all credentials configured in component configuration.\nRedirect to CredentialStores is not done at this point. If you need fully fleshed credential use lookup method instead.\n public getAll(): CredentialParams[]\n  returns: CredentialParams[] - a list with credential parameters  lookup Looks up component credential parameters. If credentials are configured to be retrieved from Credential store it finds a ICredentialStore` and lookups credentials there.\n public lookup(correlationId: string): Promise\u0026lt;CredentialParams\u0026gt;\n  correlationId: string - (optional) transaction id to trace execution through call chain. returns: Promise\u0026lt;CredentialParams\u0026gt; - resolved credential parameters or null if nothing was found.  setReferences Sets references to dependent components.\n public setReferences(references: IReferences): void\n  references: IReferences - references to locate the component dependencies.  Examples let config = ConfigParams.fromTuples( \u0026#34;credential.user\u0026#34;, \u0026#34;jdoe\u0026#34;, \u0026#34;credential.pass\u0026#34;, \u0026#34;pass123\u0026#34; ); let credentialResolver = new CredentialResolver(); credentialResolver.configure(config); credentialResolver.setReferences(references); let credential = credentialResolver.lookup(\u0026#34;123\u0026#34;); // Now use the credential... See also   CredentialParams   ICredentialStore   ","description":"Helper class used to retrieve component credentials.\n","image":null,"permalink":"/node/components/auth/credential_resolver/","subtitle":null,"tags":null,"title":"CredentialResolver"},{"content":"Implements: IConfigurable, IReferenceable\nDescription The CredentialResolver class is used to retrieve component credentials.\nImportant points\n If credentials are configured to be retrieved from ICredentialStore, it will automatically locate ICredentialStore in component references and retrieve the credentials from there using the store_key parameter.  Configuration parameters credential:\n store_key: (optional) a key to retrieve the credentials from ICredentialStore \u0026hellip;: other credential parameters  credentials: alternative to credential\n [credential params 1]: first credential parameters  \u0026hellip; : credential parameters for key 1   \u0026hellip; [credential params N]: Nth credential parameters  \u0026hellip; : credential parameters for key N    References  *:credential-store:*:*:1.0 - (optional) Credential stores to resolve credentials  Constructors Creates a new instance of credentials resolver.\n CredentialResolver(config: ConfigParams = None, references: IReferences = None)\n  config: ConfigParams - (optional) component configuration parameters references: IReferences - (optional) component references  Instance methods add Adds a new credential to component credentials\n add(connection: CredentialParams)\n  connection: CredentialParams - new credential parameters to be added  configure Configures component by passing configuration parameters.\n configure(config: ConfigParams)\n  config: ConfigParams - configuration parameters to be set.  get_all Gets all credentials configured in component configuration.\nRedirect to CredentialStores is not done at this point. If you need fully fleshed credential use lookup method instead.\n get_all(): List[CredentialParams]\n  returns: List[CredentialParams] - a list with credential parameters  lookup Looks up component credential parameters. If credentials are configured to be retrieved from Credential store it finds a ICredentialStore` and lookups credentials there.\n lookup(correlation_id: Optional[str]): Optional[CredentialParams]\n  correlation_id: Optional[str] - (optional) transaction id to trace execution through call chain. returns: Optional[CredentialParams] - resolved credential parameters or None if nothing was found.  set_references Sets references to dependent components.\n set_references(references: IReferences)\n  references: IReferences - references to locate the component dependencies.  Examples config = ConfigParams.from_tuples(\u0026#34;credential.user\u0026#34;, \u0026#34;jdoe\u0026#34;, \u0026#34;credential.pass\u0026#34;, \u0026#34;pass123\u0026#34;) credentialResolver = CredentialResolver() credentialResolver.configure(config) credentialResolver.set_references(references) credentialResolver.lookup(\u0026#34;123\u0026#34;) See also   CredentialParams   ICredentialStore   ","description":"Helper class used to retrieve component credentials.\n","image":null,"permalink":"/python/components/auth/credential_resolver/","subtitle":null,"tags":null,"title":"CredentialResolver"},{"content":"Stores customer credit cards internally or in external PCI-complient service like Paypal\n Server implementations: NodeJS Communication protocols: Direct, Commandable HTTP, Commandable GRPC, GRPC Persistence: Memory, Flat Files, MongoDB, Couchbase Deployment options: Monolith, Process, Docker, AWS Lambda Client implementations: NodeJS  ","description":null,"image":null,"permalink":"/microservices/ecommrce/creditcards/","subtitle":null,"tags":null,"title":"Credit cards Microservice"},{"content":"Description The CsvConstant class defines a set of constants, such as control return, line feed and nil.\nFields CR Control return\n public static CR: number = \u0026lsquo;\\r\u0026rsquo;.charCodeAt(0)\n Nil Nil\n public static Nil: number = 0\n LF Line feed.\n public static LF: number = \u0026lsquo;\\n\u0026rsquo;.charCodeAt(0)\n  ","description":"Defines a set of constants, such as control return, line feed and nil.\n","image":null,"permalink":"/node/expressions/csv/csv_constant/","subtitle":null,"tags":null,"title":"CsvConstant"},{"content":"Implements: IQuoteState\nDescription The CsvQuoteState implements a quote string state object for CSV streams.\nInstance methods decodeString Decodes a string value.\n public decodeString(value: string, quoteSymbol: number): string\n  value: string - string value to be decoded. quoteSymbol: number - string quote character.  encodeString Encodes a string value.\n public encodeString(value: string, quoteSymbol: number): string\n  value: string - string value to be encoded. quoteSymbol: number - string quote character. returns: string - encoded string.  nextToken Gets the next token from the stream started from the character linked to this state.\n public nextToken(scanner: IScanner, tokenizer: ITokenizer): Token\n  scanner: IScanner - textual string to be tokenized. tokenizer: ITokenizer - tokenizer class that controls the process. returns: Token - next token from the top of the stream.  ","description":"Implements a quote string state object for CSV streams.\n","image":null,"permalink":"/node/expressions/csv/csv_quote_state/","subtitle":null,"tags":null,"title":"CsvQuoteState"},{"content":"Extends: GenericSymbolState\nDescription The CsvSymbolState implements a symbol state to tokenize delimiters in CSV streams.\nConstructors Constructs this object with specified parameters.\n public constructor()\n Instance methods nextToken Gets the next token from the stream started from the character linked to this state.\n public nextToken(scanner: IScanner, tokenizer: ITokenizer): Token\n  scanner: IScanner - textual string to be tokenized. tokenizer: ITokenizer - tokenizer class that controls the process. returns: Token - next token from the top of the stream.  ","description":"Implements a symbol state to tokenize delimiters in CSV streams.\n","image":null,"permalink":"/node/expressions/csv/csv_symbol_state/","subtitle":null,"tags":null,"title":"CsvSymbolState"},{"content":"Extends: AbstractTokenizer\nDescription The CsvTokenizer class allows you to implement a tokenizer class for CSV files.\nConstructors Constructs this object with default parameters.\n public constructor()\n Properties endOfLine Separator for rows in CSV stream.\n public endOfLine(): string\n  returns: string - separator for rows.   public endOfLine(value: string)\n  value: string - separator for rows.  fieldSeparators Separator for fields in CSV stream.\n public fieldSeparators(): number[]\n  returns: number[] - separator for fields.   public fieldSeparators(value: number[])\n  value: number[] - separator for fields.  quoteSymbols Character to quote strings.\n public quoteSymbols(): number[]\n  returns: number[] - character to quote strings.   public quoteSymbols(value: number[])\n  value: number[] - character to quote strings.  ","description":"Implements a tokenizer class for CSV files.\n","image":null,"permalink":"/node/expressions/csv/csv_tokenizer/","subtitle":null,"tags":null,"title":"CsvTokenizer"},{"content":"Extends: GenericWordState\nDescription The CsvWordState class implements a word state to tokenize a CSV stream.\nConstructors Constructs this object with specified parameters.\n public constructor(fieldSeparators: number[], quoteSymbols: number[])\n  fieldSeparators: number[] - separators for fields in a CSV stream. quoteSymbols: number[] - delimiter characters used to quote strings.  ","description":"Implements a word state to tokenize a CSV stream.\n","image":null,"permalink":"/node/expressions/csv/csv_word_state/","subtitle":null,"tags":null,"title":"CsvWordState"},{"content":"Provides guidance to application users: introduces about application features, tells about new version and so on. Each dashboard:\n Can be written in multiple languages Can include one or more pages with title, text and a picture Supports editing lifecycle via status tracking  ‍\n Server implementations: NodeJS Communication protocols: Direct, Commandable HTTP, Commandable GRPC, GRPC Persistence: Memory, Flat Files, MongoDB, Couchbase Deployment options: Monolith, Process, Docker, AWS Lambda Client implementations: NodeJS  This microservice has dependencies on the following microservices:\n Blob Attachments - to reference pictures and documents associates with dashboards  ","description":null,"image":null,"permalink":"/microservices/content/dashboards/","subtitle":null,"tags":null,"title":"Dashboards Microservice"},{"content":"Description The DataPage class allows you to create a data transfer object that can be used to pass the results of a paginated query. This object contains items of the retrieved page.\nImportant points\n Most often, this object type is used to send responses to paginated queries. Pagination parameters are defined by a PagingParams object. The skip parameter in the PagingParams indicates how many items to skip. The takes parameter sets number of items to return in the page. An optional total paramter allows you to specify the total number of items returned from a request. However, not all implementations support the total parameter because its generation may lead to severe performance implications.  Constructors NewDataPage Creates a new instance of data page and assigns its values.\n NewDataPage(total *int64, data []interface{}) *DataPage\n  data: *int64 - list of items from the retrieved page. total: []interface{} - total amount of items in a request.  NewEmptyDataPage Creates a new empty instance of data page.\n NewEmptyDataPage() *DataPage\n Fields Data The items of the retrieved page.\n Data: *int64\n Total The total amount of items in a request.\n Total: []interface{}\n  Examples err, page = myDataClient.GetDataByFilter( \u0026#34;123\u0026#34;, FilterParams.NewFilterParamsFromTuples(\u0026#34;completed\u0026#34;: true), NewPagingParams(0, 100, true) }; if err != nil { panic() } for item range page.Data { fmt.Println(item); } ); See also   PagingParams   ","description":"Data transfer object that is used to pass the results of a paginated query. This object contains items of the retrieved page.\n","image":null,"permalink":"/golang/commons/data/data_page/","subtitle":null,"tags":null,"title":"DataPage"},{"content":"Description The DataPage class allows you to create a data transfer object that can be used to pass the results of a paginated query. This object contains items of the retrieved page.\nImportant points\n Most often, this object type is used to send responses to paginated queries. Pagination parameters are defined by a PagingParams object. The skip parameter in the PagingParams indicates how many items to skip. The takes parameter sets the number of items to return in the page. An optional total paramter allows you to specify the total number of items returned from a request. However, not all implementations support the total parameter because its generation may lead to severe performance implications.  Constructors Creates a new instance of data page and assigns its values.\n public DataPage(List\u0026lt;T\u0026gt; data, long? total = null)\n  data: List\u0026lt;T\u0026gt; - list of items from the retrieved page. total: long - total amount of items in a request.  Creates a new instance of data page.\n public DataPage()\n Properties Data Items of the retrieved page.\n public List\u0026lt;T\u0026gt; Data { get; set; }\n Total Total amount of items in a request.\n public long Total { get; set; }\n Examples myDataClient.GetDataByFilter( \u0026#34;123\u0026#34;, FilterParams.FromTuples(\u0026#34;completed\u0026#34;, true), new PagingParams(0, 100, true), async(DataPage\u0026lt;MyData\u0026gt; page) =\u0026gt; { Console.WriteLine(\u0026#34;Items: \u0026#34;); for (MyData item : page.getData()) { Console.WriteLine(item); } Console.WriteLine(\u0026#34;Total items: \u0026#34; + page.getTotal()); }; ); See also   PagingParams   ","description":"Data transfer object that is used to pass the results of a paginated query. This object contains items of the retrieved page.\n","image":null,"permalink":"/net/commons/data/data_page/","subtitle":null,"tags":null,"title":"DataPage"},{"content":"Description The DataPage class allows you to create a data transfer object that can be used to pass the results of a paginated query. This object contains items of the retrieved page.\nImportant points\n Most often, this object type is used to send responses to paginated queries. Pagination parameters are defined by a PagingParams object. The skip parameter in the PagingParams indicates how many items to skip. The takes parameter sets number of items to return in the page. An optional total paramter allows you to specify the total number of items returned from a request. However, not all implementations support the total parameter because its generation may lead to severe performance implications.  Constructors Creates a new instance of DataPage and assigns its values.\n public constructor(data: T[] = null, total: number = null)\n  data: T[] - list of items from the retrieved page. total: number - total amount of items in a request.  Fields data Items of the retrieved page.\n public data: T[]\n total Total amount of items in a request.\n public total: number\n  Examples page := await myDataClient.getDataByFilter( \u0026#34;123\u0026#34;, FilterParams.fromTuples(\u0026#34;completed\u0026#34;: true), new PagingParams(0, 100, true) ); See also   PagingParams   ","description":"Data transfer object that is used to pass the results of a paginated query. This object contains items of the retrieved page.\n","image":null,"permalink":"/node/commons/data/data_page/","subtitle":null,"tags":null,"title":"DataPage"},{"content":"Description The DataPage class allows you to create a data transfer object that can be used to pass the results of a paginated query. This object contains items of the retrieved page.\nImportant points\n Most often, this object type is used to send responses to paginated queries. Pagination parameters are defined by a PagingParams object. The skip parameter in the PagingParams indicates how many items to skip. The takes parameter sets number of items to return in the page. An optional total paramter allows you to specify the total number of items returned from a request. However, not all implementations support the total parameter because its generation may lead to severe performance implications.  Constructors Creates a new instance of data page and assigns its values.\n DataPage(data: Sequence[Any] = None, total: int = None)\n  data: Sequence[Any] - a list of items from the retrieved page. total: int - total amount of items in a request.  Fields data The items of the retrieved page.\n data: Sequence[Any]\n total The total amount of items in a request.\n total: int\n  Examples my_data_client.get_data_by_filter(\u0026#34;123\u0026#34;, FilterParams.from_tuples(\u0026#34;completed\u0026#34;, true), PagingParams(0, 100, true), page ) for item in page.get_data(): print (item) See also   PagingParams   ","description":"Data transfer object that is used to pass the results of a paginated query. This object contains items of the retrieved page.\n","image":null,"permalink":"/python/commons/data/data_page/","subtitle":null,"tags":null,"title":"DataPage"},{"content":"Description The DateTimeConverter class allows you to convert arbitrary values into Date values using following extended conversion rules:\n Strings: converted using ISO time format Numbers: converted using milliseconds since unix epoch  Methods ToDateTime Converts value into Date or returns current date when conversion is not possible.\nSee ToDateTimeWithDefault\n ToDateTime(value interface{}) time.Time\n  value: interface{} - value to convert. returns: time.Time - Date value or current date when conversion is not supported.  ToDateTimeWithDefault Converts value into Date or returns default when conversion is not possible.\n ToDateTimeWithDefault(value interface{}, defaultValue time.Time) time.Time\n  value: interface{} - value to convert. defaultValue: time.Time - default value. returns: time.Time - Date value or default when conversion is not supported.  ToNullableDateTime Converts value into Date or returns nil when conversion is not possible.\n ToNullableDateTime(value interface{}) *time.Time\n  value: interface{} - the value to convert. returns: *time.Time - Date value or nil when conversion is not supported.  Examples value1 := convert.DateTimeConverter.ToNullableDateTime(\u0026#34;ABC\u0026#34;) value2 := convert.DateTimeConverter.ToNullableDateTime(\u0026#34;2019-01-01T11:30:00.0Z\u0026#34;) value3 := convert.DateTimeConverter.ToNullableDateTime(123) fmt.Println(value1) // \u0026lt;nil\u0026gt; fmt.Println(value2) // 2019-01-01 11:30:00 +0000 UTC fmt.Println(value3) // 1970-01-01 02:02:03 +0200 EET  ","description":"The DateTimeConverter class allows you to convert arbitrary values into Date values using extended conversion rules.\n","image":null,"permalink":"/golang/commons/convert/date_time_converter/","subtitle":null,"tags":null,"title":"DateTimeConverter"},{"content":"Description The DateTimeConverter class allows you to convert arbitrary values into Date values using following extended conversion rules:\n Strings: converted using the ISO time format Numbers: converted using milliseconds since unix epoch  Static methods ToDateTime Converts value into Date or returns current date when conversion is not possible.\nSee ToDateTimeWithDefault\n public static DateTime ToDateTime(object value)\n  value: object - value to convert. returns: DateTime - Date value or current date when conversion is not supported.  ToDateTimeWithDefault Converts value into Date or returns default when conversion is not possible.\n public static DateTime toDateTimeWithDefault(object value, DateTime? defaultValue)\n  value: object - value to convert. defaultValue: DateTime - default value. returns: DateTime - Date value or default when conversion is not supported.  ToNullableDateTime Converts value into Date or returns null when conversion is not possible.\n public static DateTime ToNullableDateTime(object value)\n  value: object - value to convert. returns: DateTime - Date value or null when conversion is not supported.  Examples DateTime value1 = DateTimeConverter.ToNullableDateTime(\u0026#34;ABC\u0026#34;); // Result: null DateTime value2 = DateTimeConverter.ToNullableDateTime(\u0026#34;2018-01-01T11:30:00.0\u0026#34;); // Result: ZonedDateTime(2018,0,1,11,30) DateTime value3 = DateTimeConverter.ToNullableDateTime(123); // Result: ZonedDateTime(123)  ","description":"The DateTimeConverter class allows you to convert arbitrary values into Date values using extended conversion rules.\n","image":null,"permalink":"/net/commons/convert/date_time_converter/","subtitle":null,"tags":null,"title":"DateTimeConverter"},{"content":"Description The DateTimeConverter class allows you to convert arbitrary values into Date values using the following extended conversion rules:\n Strings: converted using ISO time format. Numbers: converted using milliseconds since unix epoch.  Static methods toDateTime Converts a value into Date or returns the current date when the conversion is not possible.\nSee toDateTimeWithDefault\n public static toDateTime(value: any): Date\n  value: any - value to convert. returns: Date - Date value or current date when the conversion is not supported.  toDateTimeWithDefault Converts a value into Date or returns a given default when the conversion is not possible.\n public static toDateTimeWithDefault(value: any, defaultValue: Date = null): Date\n  value: any - value to convert. defaultValue: Date - default value. returns: Date - Date value or given default when the conversion is not supported.  toNullableDateTime Converts a value into Date or returns null when the conversion is not possible.\n public static toNullableDateTime(value: any): Date\n  value: any - value to convert. returns: Date - Date value or null when the conversion is not supported.  Examples let value1 = DateTimeConverter.toNullableDateTime(\u0026#34;ABC\u0026#34;); // Result: null let value2 = DateTimeConverter.toNullableDateTime(\u0026#34;2018-01-01T11:30:00.0\u0026#34;); // Result: Date(2018,0,1,11,30) let value3 = DateTimeConverter.toNullableDateTime(123); // Result: Date(123)  ","description":"The DateTimeConverter class allows you to convert arbitrary values into Date values using extended conversion rules.\n","image":null,"permalink":"/node/commons/convert/date_time_converter/","subtitle":null,"tags":null,"title":"DateTimeConverter"},{"content":"Description The DateTimeConverter class allows you to convert arbitrary values into Date values using following extended conversion rules:\n Strings: converted using ISO time format Numbers: converted using milliseconds since unix epoch  Static methods to_date_time Converts value into Date or returns current date when conversion is not possible.\nSee to_date_time_with_default\n static to_date_time(value: Any): datetime\n  value: Any - the value to convert. returns: datetime - Date value or current date when conversion is not supported.  to_date_time_with_default Converts value into Date or returns default when conversion is not possible.\n static to_date_time_with_default(value: Any, default_value: datetime = None): datetime\n  value: Any - the value to convert. defaultValue: datetime - the default value. returns: datetime - Date value or default when conversion is not supported.  to_nullable_date_time Converts value into Date or returns None when conversion is not possible.\n static to_nullable_date_time(value: Any): Optional[datetime]\n  value: Any - the value to convert. returns: datetime - Date value or None when conversion is not supported.  Examples value1 = DateTimeConverter.to_nullable_datetime(\u0026#34;ABC\u0026#34;) # Returns None ","description":"The DateTimeConverter class allows you to convert arbitrary values into Date values using extended conversion rules.\n","image":null,"permalink":"/python/commons/convert/date_time_converter/","subtitle":null,"tags":null,"title":"DateTimeConverter"},{"content":"Description The DecimalConverter class can be used to convert objects to decimals according to the following rules:\n  Strings are converted to double values\n  DateTime: total number of milliseconds since unix epoсh\n  Boolean: 1 for true and 0 for false\n  Static methods ToDecimal Converts an object to a decimal value\n public static decimal ToDecimal (object value)\n  value: object - object to be converted returns: decimal - returned decimal value  ToDecimalWithDefault Converts an object to decimal. If the conversion is not possible, it returns the given default.\n public static decimal ToDecimalWithDefault (object value, decimal defaultValue)\n  value: object - object to convert defaultValue: decimal - default value returns: decimal - returned decimal value  ToNullableDecimal Converts value into doubles or returns null when conversion is not possible.\n public static decimal ToNullableDecimal(object value)\n  value: object - object to be converted returns: decimal - returned decimal value  ","description":"Converts objects to decimals.\n","image":null,"permalink":"/net/commons/convert/decimal_converter/","subtitle":null,"tags":null,"title":"DecimalConverter"},{"content":"Extends: Factory\nDescription The DefaultAwsFactory class allows you to create AWS components by their descriptors.\nConstructors Creates a new instance of the factory.\n public constructor()\n See also   CloudWatchLogger   CloudWatchCounters   ","description":"Creates AWS components by their descriptors.\n","image":null,"permalink":"/node/aws/build/default_aws_factory/","subtitle":null,"tags":null,"title":"DefaultAwsFactory"},{"content":"Constructors NewDefaultCacheFactory Create a new instance of the factory.\n NewDefaultCacheFactory() *build.Factory\n Fields NullCacheDescriptor A description for a null cache (dummy cache).\n NullCacheDescriptor: Descriptor\n Descriptor A descriptor for a factory cache.\n Descriptor: Descriptor\n  See also   Factory   ICache   MemoryCache   NullCache   ","description":"Creates [ICache](../icache) components by their descriptors.\n","image":null,"permalink":"/golang/components/cache/default_cache_factory/","subtitle":null,"tags":null,"title":"DefaultCacheFactory"},{"content":"Inherits: Factory\nConstructors Create a new instance of the factory.\n public DefaultCacheFactory()\n Fields NullCacheDescriptor A description for a null cache (dummy cache).\n public static NullCacheDescriptor: Descriptor\n MemoryCacheDescriptor A descriptor for a memory cache.\n public static MemoryCacheDescriptor: Descriptor\n Descriptor A descriptor for a factory cache.\n public static Descriptor: Descriptor\n  See also   Factory   ICache   MemoryCache   NullCache   ","description":"Creates [ICache](../icache) components by their descriptors.\n","image":null,"permalink":"/net/components/cache/default_cache_factory/","subtitle":null,"tags":null,"title":"DefaultCacheFactory"},{"content":"Extends: Factory\nConstructors Create a new instance of the factory.\n public constructor()\n Fields NullCacheDescriptor A description for a null cache (dummy cache).\n public static NullCacheDescriptor: Descriptor\n MemoryCacheDescriptor A descriptor for a memory cache.\n public static MemoryCacheDescriptor: Descriptor\n Descriptor A descriptor for a factory cache.\n public static Descriptor: Descriptor\n  See also   Factory   ICache   MemoryCache   NullCache   ","description":"Creates [ICache](../icache) components by their descriptors.\n","image":null,"permalink":"/node/components/cache/default_cache_factory/","subtitle":null,"tags":null,"title":"DefaultCacheFactory"},{"content":"Implements: Factory\nConstructors Create a new instance of the factory.\n DefaultCacheFactory()\n Fields NullCacheDescriptor A description for a null cache (dummy cache).\n NullCacheDescriptor: Descriptor\n MemoryCacheDescriptor A descriptor for a memory cache.\n MemoryCacheDescriptor: Descriptor\n Descriptor A descriptor for a factory cache.\n descriptor: Descriptor\n  See also   Factory   ICache   MemoryCache   NullCache   ","description":"Creates [ICache](../icache) components by their descriptors.\n","image":null,"permalink":"/python/components/cache/default_cache_factory/","subtitle":null,"tags":null,"title":"DefaultCacheFactory"},{"content":"Description The DefaultConfigReaderFactory class allows you to create IConfigReader components based on their descriptors.\nConstructors Creates a new instance of the factory.\n NewDefaultConfigReaderFactory() *build.Factory\n See also   Factory   MemoryConfigReader   JsonConfigReader   YamlConfigReader   ","description":"Creates [IConfigReader](../iconfig_reader) components based on their descriptors.\n","image":null,"permalink":"/golang/components/config/default_config_reader_factory/","subtitle":null,"tags":null,"title":"DefaultConfigReaderFactory"},{"content":"Inherits: Factory\nDescription The DefaultConfigReaderFactory class allows you to create IConfigReader components based on their descriptors.\nConstructors Creates a new instance of the factory.\n public DefaultConfigReaderFactory()\n See also   Factory   MemoryConfigReader   JsonConfigReader   YamlConfigReader   ","description":"Creates [IConfigReader](../iconfig_reader) components based on their descriptors.\n","image":null,"permalink":"/net/components/config/default_config_reader_factory/","subtitle":null,"tags":null,"title":"DefaultConfigReaderFactory"},{"content":"Extends: Factory\nDescription The DefaultConfigReaderFactory class allows you to create IConfigReader components based on their descriptors.\nConstructors Creates a new instance of the factory.\n public constructor()\n See also   Factory   MemoryConfigReader   JsonConfigReader   YamlConfigReader   ","description":"Creates [IConfigReader](../iconfig_reader) components based on their descriptors.\n","image":null,"permalink":"/node/components/config/default_config_reader_factory/","subtitle":null,"tags":null,"title":"DefaultConfigReaderFactory"},{"content":"Implements: Factory\nDescription The DefaultConfigReaderFactory class allows you to create IConfigReader components based on their descriptors.\nConstructors Creates a new instance of the factory.\n DefaultConfigReaderFactory()\n See also   Factory   MemoryConfigReader   JsonConfigReader   YamlConfigReader   ","description":"Creates [IConfigReader](../iconfig_reader) components based on their descriptors.\n","image":null,"permalink":"/python/components/config/default_config_reader_factory/","subtitle":null,"tags":null,"title":"DefaultConfigReaderFactory"},{"content":"Implements: CompositeFactory\nDescription The DefaultContainerFactory class allows you to create factories used to create default container components by their descriptors. The factories included are:\n DefaultInfoFactory DefaultLoggerFactory DefaultCountersFactory DefaultConfigReaderFactory DefaultCacheFactory DefaultCredentialStoreFactory DefaultDiscoveryFactory DefaultTestFactory DefaultTracerFactory  Constructors NewDefaultContainerFactoryFromFactories Creates a new instance of the factory and sets nested factories.\n NewDefaultContainerFactoryFromFactories(factories \u0026hellip;IFactory) *CompositeFactory\n  factories: \u0026hellip;IFactory - list of nested factories  NewDefaultContainerFactory Create a new instance of the factory and sets nested factories.\n NewDefaultContainerFactory() *CompositeFactory\n See also   Factory   ","description":"Creates default container components (loggers, counters, caches, locks, etc.) by their descriptors.\n","image":null,"permalink":"/golang/container/build/default_container_factory/","subtitle":null,"tags":null,"title":"DefaultContainerFactory"},{"content":"Inherits: CompositeFactory\nDescription The DefaultContainerFactory class allows you to create factories used to create default container components by their descriptors. The factories included are:\n DefaultInfoFactory DefaultLoggerFactory DefaultCountersFactory DefaultConfigReaderFactory DefaultCacheFactory DefaultCredentialStoreFactory DefaultDiscoveryFactory DefaultTestFactory DefaultTracerFactory  Constructors Creates a new instance of the factory and sets nested factories.\n public DefaultContainerFactory(params IFactory[] factories)\n  factories: IFactory[] - list of nested factories  See also   Factory   ","description":"Creates default container components (loggers, counters, caches, locks, etc.) by their descriptors.\n","image":null,"permalink":"/net/container/build/default_container_factory/","subtitle":null,"tags":null,"title":"DefaultContainerFactory"},{"content":"Implements: CompositeFactory\nDescription The DefaultContainerFactory class allows you to create factories used to create default container components by their descriptors. The factories included are:\n DefaultInfoFactory DefaultLoggerFactory DefaultCountersFactory DefaultConfigReaderFactory DefaultCacheFactory DefaultCredentialStoreFactory DefaultDiscoveryFactory DefaultTestFactory DefaultTracerFactory  Constructors Creates a new instance of the factory and sets nested factories.\n public constructor(\u0026hellip;factories: IFactory[])\n  factories: IFactory[] - list of nested factories  See also   Factory   ","description":"Creates default container components (loggers, counters, caches, locks, etc.) by their descriptors.\n","image":null,"permalink":"/node/container/build/default_container_factory/","subtitle":null,"tags":null,"title":"DefaultContainerFactory"},{"content":"Implements: CompositeFactory\nDescription The DefaultContainerFactory class allows you to create factories used to create default container components by their descriptors. The factories included are:\n DefaultInfoFactory DefaultLoggerFactory DefaultCountersFactory DefaultConfigReaderFactory DefaultCacheFactory DefaultCredentialStoreFactory DefaultDiscoveryFactory DefaultTestFactory DefaultTracerFactory  Constructors Creates a new instance of the factory and sets nested factories.\n DefaultContainerFactory(*factories: IFactory)\n  factories: IFactory - list of nested factories  See also   Factory   ","description":"Creates default container components (loggers, counters, caches, locks, etc.) by their descriptors.\n","image":null,"permalink":"/python/container/build/default_container_factory/","subtitle":null,"tags":null,"title":"DefaultContainerFactory"},{"content":"Description The DefaultCountersFactory class allows you to create a factory that builds ICounters components based on their descriptors.\nConstructors NewDefaultCountersFactory Creates a new instance of the factory.\n NewDefaultCountersFactory() *build.Factory\n See also   Factory   NullCounters   LogCounters   CompositeCounters   ","description":"Creates a factory that builds [ICounters](../icounters) components based on their descriptors.\n","image":null,"permalink":"/golang/components/count/default_counters_factory/","subtitle":null,"tags":null,"title":"DefaultCountersFactory"},{"content":"Inherits: Factory\nDescription The DefaultCountersFactory class allows you to create a factory that builds ICounters components based on their descriptors.\nConstructors Create a new instance of the factory.\n public DefaultCountersFactory()\n See also   Factory   NullCounters   LogCounters   CompositeCounters   ","description":"Creates a factory that builds [ICounters](../icounters) components based on their descriptors.\n","image":null,"permalink":"/net/components/count/default_counters_factory/","subtitle":null,"tags":null,"title":"DefaultCountersFactory"},{"content":"Extends: Factory\nDescription The DefaultCountersFactory class allows you to create a factory that builds ICounters components based on their descriptors.\nConstructors Create a new instance of the factory.\n public constructor()\n See also   Factory   NullCounters   LogCounters   CompositeCounters   ","description":"Creates a factory that builds [ICounters](../icounters) components based on their descriptors.\n","image":null,"permalink":"/node/components/count/default_counters_factory/","subtitle":null,"tags":null,"title":"DefaultCountersFactory"},{"content":"Implements: Factory\nDescription The DefaultCountersFactory class allows you to create a factory that builds ICounters components based on their descriptors.\nConstructors Create a new instance of the factory.\n DefaultCountersFactory()\n See also   Factory   NullCounters   LogCounters   CompositeCounters   ","description":"Creates a factory that builds [ICounters](../icounters) components based on their descriptors.\n","image":null,"permalink":"/python/components/count/default_counters_factory/","subtitle":null,"tags":null,"title":"DefaultCountersFactory"},{"content":"Description The DefaultCredentialStoreFactory class is used to create ICredentialStore components based on their descriptors.\nConstructors NewDefaultCredentialStoreFactory Creates a new instance of the factory.\n NewDefaultCredentialStoreFactory() *build.Factory\n See also   IFactory   ICredentialStore   MemoryCredentialStore   ","description":"Creates [ICredentialStore](../icredentialStore) components based on their descriptors.\n","image":null,"permalink":"/golang/components/auth/default_credential_store_factory/","subtitle":null,"tags":null,"title":"DefaultCredentialStoreFactory"},{"content":"Inherits: Factory\nDescription The DefaultCredentialStoreFactory class is used to create ICredentialStore components based on their descriptors.\nConstructors Create a new instance of the factory.\n public DefaultCredentialStoreFactory()\n See also   IFactory   ICredentialStore   MemoryCredentialStore   ","description":"Creates [ICredentialStore](../icredentialStore) components based on their descriptors.\n","image":null,"permalink":"/net/components/auth/default_credential_store_factory/","subtitle":null,"tags":null,"title":"DefaultCredentialStoreFactory"},{"content":"Extends: Factory\nDescription The DefaultCredentialStoreFactory class is used to create ICredentialStore components based on their descriptors.\nConstructors Create a new instance of the factory.\n public constructor()\n See also   IFactory   ICredentialStore   MemoryCredentialStore   ","description":"Creates [ICredentialStore](../icredentialStore) components based on their descriptors.\n","image":null,"permalink":"/node/components/auth/default_credential_store_factory/","subtitle":null,"tags":null,"title":"DefaultCredentialStoreFactory"},{"content":"Implements: Factory\nDescription The DefaultCredentialStoreFactory class is used to create ICredentialStore components based on their descriptors.\nConstructors Create a new instance of the factory.\n DefaultCredentialStoreFactory()\n See also   IFactory   ICredentialStore   MemoryCredentialStore   ","description":"Creates [ICredentialStore](../icredentialStore) components based on their descriptors.\n","image":null,"permalink":"/python/components/auth/default_credential_store_factory/","subtitle":null,"tags":null,"title":"DefaultCredentialStoreFactory"},{"content":"Description The DefaultDiscoveryFactory class allows you to create an instance of Factory to create IDiscovery components based on their descriptors.\nConstructors NewDefaultDiscoveryFactory Create a new instance of Factory.\n NewDefaultDiscoveryFactory() *build.Factory\n See also   Factory   IDiscovery   MemoryDiscovery   ","description":"Creates an instance of [Factory](../../build/factory).\n","image":null,"permalink":"/golang/components/connect/default_discovery_factory/","subtitle":null,"tags":null,"title":"DefaultDiscoveryFactory"},{"content":"Inherits: Factory\nDescription The DefaultDiscoveryFactory class allows you to create an instance of Factory to create IDiscovery components based on their descriptors.\nConstructors Create a new instance of factory.\n public DefaultDiscoveryFactory()\n See also   Factory   IDiscovery   MemoryDiscovery   ","description":"Creates an instance of [Factory](../../build/factory).\n","image":null,"permalink":"/net/components/connect/default_discovery_factory/","subtitle":null,"tags":null,"title":"DefaultDiscoveryFactory"},{"content":"Extends: Factory\nDescription The DefaultDiscoveryFactory class allows you to create an instance of Factory to create IDiscovery components based on their descriptors.\nConstructors Create a new instance of factory.\n public constructor()\n See also   Factory   IDiscovery   MemoryDiscovery   ","description":"Creates an instance of [Factory](../../build/factory).\n","image":null,"permalink":"/node/components/connect/default_discovery_factory/","subtitle":null,"tags":null,"title":"DefaultDiscoveryFactory"},{"content":"Implements: Factory\nDescription The DefaultDiscoveryFactory class allows you to create an instance of Factory to create IDiscovery components based on their descriptors.\nConstructors Create a new instance of factory.\n DefaultDiscoveryFactory()\n See also   Factory   IDiscovery   MemoryDiscovery   ","description":"Creates an instance of [Factory](../../build/factory).\n","image":null,"permalink":"/python/components/connect/default_discovery_factory/","subtitle":null,"tags":null,"title":"DefaultDiscoveryFactory"},{"content":"Implementss: Factory\nDescription The DefaultElasticSearchFactory class allows you to create a factory used to create Elasticsearch components based on their descriptors.\nConstructors NewDefaultElasticSearchFactory Creates a new instance of the factory.\n NewDefaultElasticSearchFactory() *DefaultElasticSearchFactory\n See also   ElasticSearchLogger   ","description":"Creates Elasticsearch components based on their descriptors.\n","image":null,"permalink":"/golang/elasticsearch/build/default_elasticsearch_factory/","subtitle":null,"tags":null,"title":"DefaultElasticSearchFactory"},{"content":"Inherits: Factory\nDescription The DefaultElasticSearchFactory class allows you to create a factory used to create Elasticsearch components based on their descriptors.\nConstructors Creates a new instance of the factory.\n public DefaultElasticSearchFactory()\n See also   ElasticSearchLogger   ","description":"Creates Elasticsearch components based on their descriptors.\n","image":null,"permalink":"/net/elasticsearch/build/default_elasticsearch_factory/","subtitle":null,"tags":null,"title":"DefaultElasticSearchFactory"},{"content":"Extends: Factory\nDescription The DefaultElasticSearchFactory class allows you to create a factory used to create Elasticsearch components based on their descriptors.\nConstructors Creates a new instance of the factory.\n public constructor()\n See also   ElasticSearchLogger   ","description":"Creates Elasticsearch components based on their descriptors.\n","image":null,"permalink":"/node/elasticsearch/build/default_elasticsearch_factory/","subtitle":null,"tags":null,"title":"DefaultElasticSearchFactory"},{"content":"Implements: Factory\nDescription The DefaultElasticSearchFactory class allows you to create a factory used to create Elasticsearch components based on their descriptors.\nConstructors Creates a new instance of the factory.\n DefaultElasticSearchFactory()\n See also   ElasticSearchLogger   ","description":"Creates Elasticsearch components based on their descriptors.\n","image":null,"permalink":"/python/elasticsearch/build/default_elasticsearch_factory/","subtitle":null,"tags":null,"title":"DefaultElasticSearchFactory"},{"content":"Extends: FunctionCollection\nDescription The DefaultFunctionCollection class allows you to implement a list filled with standard functions.\nConstructors Constructs this list and fills it with the standard functions.\n public constructor()\n Instance methods checkParamCount Checks if params contains the correct number of function parameters (must be stored on the top of the params).\n protected checkParamCount(params: Variant[], expectedParamCount: number): void\n  params: Variant[] - list of function parameters. expectedParamCount: number - expected number of function parameters.  getParameter Gets a function\u0026rsquo;s parameter by it\u0026rsquo;s index.\n protected getParameter(params: Variant[], paramIndex: number): Variant\n  params: Variant[] - list of function parameters. paramIndex: number - index for the function parameter (0 for the first parameter). returns: Variant - function\u0026rsquo;s parameter value.  ","description":"Implements a list filled with standard functions.\n","image":null,"permalink":"/node/expressions/calculator/functions/default_function_collection/","subtitle":null,"tags":null,"title":"DefaultFunctionCollection"},{"content":"Implements: Factory\nDescription The DefaultGrpcFactory class allows you to create a factory used to create GRPC components based on their descriptors.\nConstructors NewDefaultGrpcFactory Creates a new instance of the factory.\n NewDefaultGrpcFactory() *DefaultGrpcFactory\n See also   Factory   GrpcEndpoint   ","description":"Creates GRPC components based on their descriptors.\n","image":null,"permalink":"/golang/grpc/build/default_grpc_factory/","subtitle":null,"tags":null,"title":"DefaultGrpcFactory"},{"content":"Inherits: Factory\nDescription The DefaultGrpcFactory class allows you to create a factory used to create GRPC components based on their descriptors.\nConstructors Creates a new instance of the factory.\n public DefaultGrpcFactory()\n See also   Factory   GrpcEndpoint   ","description":"Creates GRPC components based on their descriptors.\n","image":null,"permalink":"/net/grpc/build/default_grpc_factory/","subtitle":null,"tags":null,"title":"DefaultGrpcFactory"},{"content":"Extends: Factory\nDescription The DefaultGrpcFactory class allows you to create a factory used to create GRPC components based on their descriptors.\nConstructors Creates a new instance of the factory.\n public constructor()\n See also   Factory   GrpcEndpoint   ","description":"Creates GRPC components based on their descriptors.\n","image":null,"permalink":"/node/grpc/build/default_grpc_factory/","subtitle":null,"tags":null,"title":"DefaultGrpcFactory"},{"content":"Implements: Factory\nSee also Factory GrpcEndpoint\nDescription The DefaultGrpcFactory class allows you to create a factory used to create GRPC components based on their descriptors.\nConstructors Creates a new instance of the factory.\n DefaultGrpcFactory()\n See also   Factory   GrpcEndpoint   ","description":"Creates GRPC components based on their descriptors.\n","image":null,"permalink":"/python/grpc/build/default_grpc_factory/","subtitle":null,"tags":null,"title":"DefaultGrpcFactory"},{"content":"Description The DefaultInfoFactory class allows you to create a factory used to create information components based on their descriptors.\nConstructors NewDefaultInfoFactory Creates a new instance of the factory.\n NewDefaultInfoFactory() *build.Factory\n See also  IFactory ContextInfo  ","description":"Creates a factory used to create information components based on their descriptors.\n","image":null,"permalink":"/golang/components/info/default_info_factory/","subtitle":null,"tags":null,"title":"DefaultInfoFactory"},{"content":"Inherits: Factory\nDescription The DefaultInfoFactory class allows you to create a factory used to create information components based on their descriptors.\nConstructors Creates a new instance of the factory.\n public DefaultInfoFactory()\n See also  IFactory ContextInfo  ","description":"Creates a factory used to create information components based on their descriptors.\n","image":null,"permalink":"/net/components/info/default_info_factory/","subtitle":null,"tags":null,"title":"DefaultInfoFactory"},{"content":"Extends: Factory\nDescription The DefaultInfoFactory class allows you to create a factory used to create information components based on their descriptors.\nConstructors Creates a new instance of the factory.\n public constructor()\n See also  IFactory ContextInfo  ","description":"Creates a factory used to create information components based on their descriptors.\n","image":null,"permalink":"/node/components/info/default_info_factory/","subtitle":null,"tags":null,"title":"DefaultInfoFactory"},{"content":"Implements: Factory\nDescription The DefaultInfoFactory class allows you to create a factory used to create information components based on their descriptors.\nConstructors Creates a new instance of the factory.\n DefaultInfoFactory()\n See also  IFactory ContextInfo  ","description":"Creates a factory used to create information components based on their descriptors.\n","image":null,"permalink":"/python/components/info/default_info_factory/","subtitle":null,"tags":null,"title":"DefaultInfoFactory"},{"content":"Description The DefaultLockFactory class allows you to create a factory used to create ILock components based on their descriptors.\nConstructors Creates a new instance of the factory.\n NewDefaultLockFactory() *build.Factory\n See also   IFactory   Factory   MemoryLock   NullLock   ","description":"Creates a factory used to create [ILock](../ilock) components based on their descriptors.\n","image":null,"permalink":"/golang/components/lock/default_lock_factory/","subtitle":null,"tags":null,"title":"DefaultLockFactory"},{"content":"Inherits: Factory\nDescription The DefaultLockFactory class allows you to create a factory used to create ILock components based on their descriptors.\nConstructors Create a new instance of the factory.\n public DefaultLockFactory()\n See also   IFactory   Factory   MemoryLock   NullLock   ","description":"Creates a factory used to create [ILock](../ilock) components based on their descriptors.\n","image":null,"permalink":"/net/components/lock/default_lock_factory/","subtitle":null,"tags":null,"title":"DefaultLockFactory"},{"content":"Extends: Factory\nDescription The DefaultLockFactory class allows you to create a factory used to create ILock components based on their descriptors.\nConstructors Create a new instance of the factory.\n public constructor()\n See also   IFactory   Factory   MemoryLock   NullLock   ","description":"Creates a factory used to create [ILock](../ilock) components based on their descriptors.\n","image":null,"permalink":"/node/components/lock/default_lock_factory/","subtitle":null,"tags":null,"title":"DefaultLockFactory"},{"content":"Implements: Factory\nDescription The DefaultLockFactory class allows you to create a factory used to create ILock components based on their descriptors.\nConstructors Create a new instance of the factory.\n DefaultLockFactory()\n See also   IFactory   Factory   MemoryLock   NullLock   ","description":"Creates a factory used to create [ILock](../ilock) components based on their descriptors.\n","image":null,"permalink":"/python/components/lock/default_lock_factory/","subtitle":null,"tags":null,"title":"DefaultLockFactory"},{"content":"Implements: Factory\nDescription The DefaultLoggerFactory class provides a factory used to create ILogger components based on their descriptors.\nConstructors Create a new instance of the factory.\n NewDefaultLoggerFactory() *build.Factory\n See also   Factory   NullLogger   ConsoleLogger,   CompositeLogger   ","description":"Creates [ILogger](../ilogger) components based on their descriptors.\n","image":null,"permalink":"/golang/components/log/default_logger_factory/","subtitle":null,"tags":null,"title":"DefaultLoggerFactory"},{"content":"Inherits: Factory\nDescription The DefaultLoggerFactory class provides a factory used to create ILogger components based on their descriptors.\nConstructors Create a new instance of the factory.\n public DefaultLoggerFactory()\n See also   Factory   NullLogger   ConsoleLogger,   CompositeLogger   ","description":"Creates [ILogger](../ilogger) components based on their descriptors.\n","image":null,"permalink":"/net/components/log/default_logger_factory/","subtitle":null,"tags":null,"title":"DefaultLoggerFactory"},{"content":"Extends: Factory\nDescription The DefaultLoggerFactory class provides a factory used to create ILogger components based on their descriptors.\nConstructors Create a new instance of the factory.\n public constructor()\n See also   Factory   NullLogger   ConsoleLogger,   CompositeLogger   ","description":"Creates [ILogger](../ilogger) components based on their descriptors.\n","image":null,"permalink":"/node/components/log/default_logger_factory/","subtitle":null,"tags":null,"title":"DefaultLoggerFactory"},{"content":"Implements: Factory\nDescription The DefaultLoggerFactory class provides a factory used to create ILogger components based on their descriptors.\nConstructors Create a new instance of the factory.\n DefaultLoggerFactory()\n See also   Factory   NullLogger   ConsoleLogger,   CompositeLogger   ","description":"Creates [ILogger](../ilogger) components based on their descriptors.\n","image":null,"permalink":"/python/components/log/default_logger_factory/","subtitle":null,"tags":null,"title":"DefaultLoggerFactory"},{"content":"Implements: Factory\nDescription The DefaultMessagingFactory class allows you to create MemoryMessageQueue components based on their descriptors.\nImportant points\n The name of created message queue is taken from its descriptor.  Constructors NewDefaultMessagingFactory Creates a new instance of the factory.\n NewDefaultMessagingFactory() *DefaultMessagingFactory\n See also   Factory   MemoryMessageQueue   ","description":"Creates [MemoryMessageQueue](../../queues/memory_message_queue)  components based on their descriptors.\n","image":null,"permalink":"/golang/messaging/build/default_messaging_factory/","subtitle":null,"tags":null,"title":"DefaultMessagingFactory"},{"content":"Inherits: Factory\nDescription The DefaultMessagingFactory class allows you to create MemoryMessageQueue components based on their descriptors.\nImportant points\n The name of created message queue is taken from its descriptor.  Constructors Creates a new instance of the factory.\n public DefaultMessagingFactory()\n See also   Factory   MemoryMessageQueue   ","description":"Creates [MemoryMessageQueue](../../queues/memory_message_queue)  components based on their descriptors.\n","image":null,"permalink":"/net/messaging/build/default_messaging_factory/","subtitle":null,"tags":null,"title":"DefaultMessagingFactory"},{"content":"Extends: Factory\nDescription The DefaultMessagingFactory class allows you to create MemoryMessageQueue components based on their descriptors.\nImportant points\n The name of created message queue is taken from its descriptor.  Constructors Creates a new instance of the factory.\n public constructor()\n See also   Factory   MemoryMessageQueue   ","description":"Creates [MemoryMessageQueue](../../queues/memory_message_queue)  components based on their descriptors.\n","image":null,"permalink":"/node/messaging/build/default_messaging_factory/","subtitle":null,"tags":null,"title":"DefaultMessagingFactory"},{"content":"Implements: Factory\nDescription The DefaultMessagingFactory class allows you to create MemoryMessageQueue components based on their descriptors.\nImportant points\n The name of created message queue is taken from its descriptor.  Constructors Creates a new instance of the factory.\n DefaultMessagingFactory()\n See also   Factory   MemoryMessageQueue   ","description":"Creates [MemoryMessageQueue](../../queues/memory_message_queue)  components based on their descriptors.\n","image":null,"permalink":"/python/messaging/build/default_messaging_factory/","subtitle":null,"tags":null,"title":"DefaultMessagingFactory"},{"content":"Implements: Factory\nDescription The DefaultMongoDbFactory class provides a factory used to create MongoDb components based on their descriptors.\nConstructors NewDefaultMongoDbFactory Creates a new instance of the factory.\n NewDefaultMongoDbFactory() *DefaultMongoDbFactory\n See also   Factory   MongoDbConnection   ","description":"Creates MongoDb components by their descriptors.\n","image":null,"permalink":"/golang/mongodb/build/default_mongodb_factory/","subtitle":null,"tags":null,"title":"DefaultMongoDbFactory"},{"content":"Inherits: Factory\nDescription The DefaultMongoDbFactory class provides a factory used to create MongoDb components based on their descriptors.\nConstructors Creates a new instance of the factory.\n public DefaultMongoDbFactory()\n See also   Factory   MongoDbConnection   ","description":"Creates MongoDb components by their descriptors.\n","image":null,"permalink":"/net/mongodb/build/default_mongodb_factory/","subtitle":null,"tags":null,"title":"DefaultMongoDbFactory"},{"content":"Extends: Factory\nDescription The DefaultMongoDbFactory class provides a factory used to create MongoDb components based on their descriptors.\nConstructors Creates a new instance of the factory.\n public constructor()\n See also   Factory   MongoDbConnection   ","description":"Creates MongoDb components by their descriptors.\n","image":null,"permalink":"/node/mongodb/build/default_mongodb_factory/","subtitle":null,"tags":null,"title":"DefaultMongoDbFactory"},{"content":"Implements: Factory\nDescription The DefaultMongoDbFactory class provides a factory used to create MongoDb components based on their descriptors.\nConstructors Creates a new instance of the factory.\n DefaultMongoDbFactory()\n See also   Factory   MemoryMessageQueue   ","description":"Creates MongoDb components by their descriptors.\n","image":null,"permalink":"/python/mongodb/build/default_mongodb_factory/","subtitle":null,"tags":null,"title":"DefaultMongoDbFactory"},{"content":"Inherits: Factory\nDescription The DefaultMySqlFactory class allows you to create a factory used to create MySql components based on their descriptors.\nConstructors Create a new instance of the factory.\n public DefaultMySqlFactory()\n See also   Factory   MySqlConnection   ","description":"Creates MySql components based on their descriptors.\n","image":null,"permalink":"/net/mysql/build/default_mysql_factory/","subtitle":null,"tags":null,"title":"DefaultMySqlFactory"},{"content":"Extends: Factory\nDescription The DefaultMySqlFactory class allows you to create a factory used to create MySql components based on their descriptors.\nConstructors Create a new instance of the factory.\n public constructor()\n See also   Factory   MySqlConnection   ","description":"Creates MySql components based on their descriptors.\n","image":null,"permalink":"/node/mysql/build/default_mysql_factory/","subtitle":null,"tags":null,"title":"DefaultMySqlFactory"},{"content":"Implements: Factory\nDescription The DefaultMySqlFactory class allows you to create a factory used to create MySql components based on their descriptors.\nConstructors Create a new instance of the factory.\n DefaultMySqlFactory()\n See also   Factory   MySqlConnection   ","description":"Creates MySql components based on their descriptors.\n","image":null,"permalink":"/python/mysql/build/default_mysql_factory/","subtitle":null,"tags":null,"title":"DefaultMySqlFactory"},{"content":"Implements: Factory\nDescription The DefaultPostgresFactory class allows you to create a factory used to create Postgres components based on their descriptors.\nConstructors NewDefaultPostgresFactory Creates a new instance of the factory.\n NewDefaultPostgresFactory() *DefaultPostgresFactory\n See also   Factory   PostgresConnection   ","description":"Creates Postgres components based on their descriptors.\n","image":null,"permalink":"/golang/postgres/build/default_postgres_factory/","subtitle":null,"tags":null,"title":"DefaultPostgresFactory"},{"content":"Inherits: Factory\nDescription The DefaultPostgresFactory class allows you to create a factory used to create Postgres components based on their descriptors.\nConstructors Creates a new instance of the factory.\n public DefaultPostgresFactory()\n See also   Factory   PostgresConnection   ","description":"Creates Postgres components based on their descriptors.\n","image":null,"permalink":"/net/postgres/build/default_postgres_factory/","subtitle":null,"tags":null,"title":"DefaultPostgresFactory"},{"content":"Extends: Factory\nDescription The DefaultPostgresFactory class allows you to create a factory used to create Postgres components based on their descriptors.\nConstructors Creates a new instance of the factory.\n public constructor()\n See also   Factory   PostgresConnection   ","description":"Creates Postgres components based on their descriptors.\n","image":null,"permalink":"/node/postgres/build/default_postgres_factory/","subtitle":null,"tags":null,"title":"DefaultPostgresFactory"},{"content":"Implements: Factory\nDescription The DefaultPostgresFactory class allows you to create a factory used to create Postgres components based on their descriptors.\nConstructors Creates a new instance of the factory.\n DefaultPostgresFactory()\n See also   Factory   PostgresConnection   ","description":"Creates Postgres components based on their descriptors.\n","image":null,"permalink":"/python/postgres/build/default_postgres_factory/","subtitle":null,"tags":null,"title":"DefaultPostgresFactory"},{"content":"Implements: Factory\nDescription The DefaultPrometheusFactory class allows you to create a factory used to create Prometheus components based on their descriptors.\nConstructors NewDefaultPrometheusFactory Create a new instance of the factory.\n NewDefaultPrometheusFactory() *DefaultPrometheusFactory\n See also   Factory   PrometheusCounters   PrometheusMetricsService   ","description":"Creates Prometheus components based on their descriptors.\n","image":null,"permalink":"/golang/prometheus/build/default_prometheus_factory/","subtitle":null,"tags":null,"title":"DefaultPrometheusFactory"},{"content":"Inherits: Factory\nDescription The DefaultPrometheusFactory class allows you to create a factory used to create Prometheus components based on their descriptors.\nConstructors Create a new instance of the factory.\n public DefaultPrometheusFactory()\n See also   Factory   PrometheusCounters   PrometheusMetricsService   ","description":"Creates Prometheus components based on their descriptors.\n","image":null,"permalink":"/net/prometheus/build/default_prometheus_factory/","subtitle":null,"tags":null,"title":"DefaultPrometheusFactory"},{"content":"Extends: Factory\nDescription The DefaultPrometheusFactory class allows you to create a factory used to create Prometheus components based on their descriptors.\nConstructors Create a new instance of the factory.\n public constructor()\n See also   Factory   PrometheusCounters   PrometheusMetricsService   ","description":"Creates Prometheus components based on their descriptors.\n","image":null,"permalink":"/node/prometheus/build/default_prometheus_factory/","subtitle":null,"tags":null,"title":"DefaultPrometheusFactory"},{"content":"Implements: Factory\nDescription The DefaultPrometheusFactory class allows you to create a factory used to create Prometheus components based on their descriptors.\nConstructors Create a new instance of the factory.\n DefaultPrometheusFactory()\n See also   Factory   PrometheusCounters   PrometheusMetricsService   ","description":"Creates Prometheus components based on their descriptors.\n","image":null,"permalink":"/python/prometheus/build/default_prometheus_factory/","subtitle":null,"tags":null,"title":"DefaultPrometheusFactory"},{"content":"Extends: Factory\nDescription TODO: add description\nConstructors Create a new instance of the factory.\n public constructor()\n See also   RedisCache   RedisLock   ","description":"Creates Redis components by their descriptors.\n","image":null,"permalink":"/node/redis/build/default_redis_factory/","subtitle":null,"tags":null,"title":"DefaultRedisFactory"},{"content":"Implements: Factory\nDescription The DefaultRpcFactory class allows you to create a factory used to create RPC components based on their descriptors.\nConstructors NewDefaultRpcFactory Creates a new instance of the factory.\n NewDefaultRpcFactory() *DefaultRpcFactory\n See also   Factory   HttpEndpoint   HeartbeatRestService   StatusRestService   ","description":"Creates RPC components based on their descriptors.\n","image":null,"permalink":"/golang/rpc/build/default_rpc_factory/","subtitle":null,"tags":null,"title":"DefaultRpcFactory"},{"content":"Inherits: Factory\nDescription The DefaultRpcFactory class allows you to create a factory used to create RPC components based on their descriptors.\nConstructors Creates a new instance of the factory.\n public DefaultRpcFactory()\n See also   Factory   HttpEndpoint   HeartbeatRestService   StatusRestService   ","description":"Creates RPC components based on their descriptors.\n","image":null,"permalink":"/net/rpc/build/default_rpc_factory/","subtitle":null,"tags":null,"title":"DefaultRpcFactory"},{"content":"Extends: Factory\nDescription The DefaultRpcFactory class allows you to create a factory used to create RPC components based on their descriptors.\nConstructors Creates a new instance of the factory.\n public constructor()\n See also   Factory   HttpEndpoint   HeartbeatRestService   StatusRestService   ","description":"Creates RPC components based on their descriptors.\n","image":null,"permalink":"/node/rpc/build/default_rpc_factory/","subtitle":null,"tags":null,"title":"DefaultRpcFactory"},{"content":"Implements: Factory\nDescription The DefaultRpcFactory class allows you to create a factory used to create RPC components based on their descriptors.\nConstructors Creates a new instance of the factory.\n DefaultRpcFactory()\n See also   Factory   HttpEndpoint   HeartbeatRestService   StatusRestService   ","description":"Creates RPC components based on their descriptors.\n","image":null,"permalink":"/python/rpc/build/default_rpc_factory/","subtitle":null,"tags":null,"title":"DefaultRpcFactory"},{"content":"Inherits: Factory\nDescription The DefaultSqlServerFactory class allows you to create a factory used to create SQLServer components based on their descriptors.\nConstructors Creates a new instance of the factory.\n public DefaultSqlServerFactory()\n See also   Factory   SqlServerConnection   ","description":"Creates SQLServer components based on their descriptors.\n","image":null,"permalink":"/net/sqlserver/build/default_sqlserver_factory/","subtitle":null,"tags":null,"title":"DefaultSqlServerFactory"},{"content":"Extends: Factory\nDescription The DefaultSqlServerFactory class allows you to create a factory used to create SQLServer components based on their descriptors.\nConstructors Creates a new instance of the factory.\n public constructor()\n See also   Factory   SqlServerConnection   ","description":"Creates SQLServer components based on their descriptors.\n","image":null,"permalink":"/node/sqlserver/build/default_sqlserver_factory/","subtitle":null,"tags":null,"title":"DefaultSqlServerFactory"},{"content":"Implements: Factory\nDescription The DefaultSqlServerFactory class allows you to create a factory used to create SQLServer components based on their descriptors.\nConstructors Creates a new instance of the factory.\n DefaultPostgresFactory()\n See also   Factory   SqlServerConnection   ","description":"Creates SQLServer components based on their descriptors.\n","image":null,"permalink":"/python/sqlserver/build/default_sqlserver_factory/","subtitle":null,"tags":null,"title":"DefaultSqlServerFactory"},{"content":"Implements: Factory\nDescription The DefaultSwaggerFactory allows you to create a factory used to create Swagger components by their descriptors.\nConstructors NewDefaultSwaggerFactory Creates a new instance of the factory.\n NewDefaultSwaggerFactory() *DefaultSwaggerFactory\n See also   Factory   HttpEndpoint   HeartbeatRestService   StatusRestService   ","description":"Creates Swagger components by their descriptors.\n","image":null,"permalink":"/golang/swagger/build/default_swagger_factory/","subtitle":null,"tags":null,"title":"DefaultSwaggerFactory"},{"content":"Inherits: Factory\nDescription The DefaultSwaggerFactory allows you to create a factory used to create Swagger components by their descriptors.\nConstructors Creates a new instance of the factory.\n public DefaultSwaggerFactory()\n See also   Factory   HttpEndpoint   HeartbeatRestService   StatusRestService   ","description":"Creates Swagger components by their descriptors.\n","image":null,"permalink":"/net/swagger/build/default_swagger_factory/","subtitle":null,"tags":null,"title":"DefaultSwaggerFactory"},{"content":"Extends: Factory\nDescription The DefaultSwaggerFactory allows you to create a factory used to create Swagger components by their descriptors.\nConstructors Creates a new instance of the factory.\n public constructor()\n See also   Factory   HttpEndpoint   HeartbeatRestService   StatusRestService   ","description":"Creates Swagger components by their descriptors.\n","image":null,"permalink":"/node/swagger/build/default_swagger_factory/","subtitle":null,"tags":null,"title":"DefaultSwaggerFactory"},{"content":"Implements: Factory\nDescription The DefaultSwaggerFactory allows you to create a factory used to create Swagger components by their descriptors.\nConstructors Creates a new instance of the factory.\n DefaultSwaggerFactory()\n See also   Factory   HttpEndpoint   HeartbeatRestService   StatusRestService   ","description":"Creates Swagger components by their descriptors.\n","image":null,"permalink":"/python/swagger/build/default_swagger_factory/","subtitle":null,"tags":null,"title":"DefaultSwaggerFactory"},{"content":"Implements: Factory\nDescription The DefaultLoggerFactory class provides a factory for shutdowns.\nConstructors NewDefaultTestFactory Creates a new instance of the factory.\n NewDefaultTestFactory() *build.Factory\n See also   Factory   Shutdown   ","description":"A factory for shutdowns.\n","image":null,"permalink":"/golang/components/test/default_test_factory/","subtitle":null,"tags":null,"title":"DefaultTestFactory"},{"content":"Inherits: Factory\nDescription The DefaultLoggerFactory class provides a factory for shutdowns.\nConstructors Create a new instance of the factory.\n public DefaultTestFactory()\n See also   Factory   Shutdown   ","description":"A factory for shutdowns.\n","image":null,"permalink":"/net/components/test/default_test_factory/","subtitle":null,"tags":null,"title":"DefaultTestFactory"},{"content":"Extends: Factory\nDescription The DefaultLoggerFactory class provides a factory for shutdowns.\nConstructors Create a new instance of the factory.\n public constructor()\n See also   Factory   Shutdown   ","description":"A factory for shutdowns.\n","image":null,"permalink":"/node/components/test/default_test_factory/","subtitle":null,"tags":null,"title":"DefaultTestFactory"},{"content":"Implements: Factory\nDescription The DefaultLoggerFactory class provides a factory for shutdowns.\nConstructors Create a new instance of the factory.\n DefaultLoggerFactory()\n See also   Factory   Shutdown   ","description":"A factory for shutdowns.\n","image":null,"permalink":"/python/components/test/default_test_factory/","subtitle":null,"tags":null,"title":"DefaultTestFactory"},{"content":"Implements: Factory\nDescription The DefaultTracerFactory class allows you to create a factory used to create ITracer components based on their descriptors.\nConstructors NewDefaultTracerFactory Creates a new instance of the factory.\n NewDefaultTracerFactory() *DefaultTracerFactory\n See also   Factory   NullTracer   ConsoleTracer   CompositeTracer   ","description":"Creates [ITracer](../itracer) components based on their descriptors.\n","image":null,"permalink":"/golang/components/trace/default_tracer_factory/","subtitle":null,"tags":null,"title":"DefaultTracerFactory"},{"content":"Inherits: Factory\nDescription The DefaultTracerFactory class allows you to create a factory used to create ITracer components based on their descriptors.\nConstructors Creates a new instance of the factory.\n public DefaultTracerFactory()\n See also   Factory   NullTracer   ConsoleTracer   CompositeTracer   ","description":"Creates [ITracer](../itracer) components based on their descriptors.\n","image":null,"permalink":"/net/components/trace/default_tracer_factory/","subtitle":null,"tags":null,"title":"DefaultTracerFactory"},{"content":"Extends: Factory\nDescription The DefaultTracerFactory class allows you to create a factory used to create ITracer components based on their descriptors.\nConstructors Creates a new instance of the factory.\n public constructor()\n See also   Factory   NullTracer   ConsoleTracer   CompositeTracer   ","description":"Creates [ITracer](../itracer) components based on their descriptors.\n","image":null,"permalink":"/node/components/trace/default_tracer_factory/","subtitle":null,"tags":null,"title":"DefaultTracerFactory"},{"content":"Implements: Factory\nDescription The DefaultTracerFactory class allows you to create a factory used to create ITracer components based on their descriptors.\nConstructors Creates a new instance of the factory.\n DefaultLoggerFactory()\n See also   Factory   NullTracer   ConsoleTracer   CompositeTracer   ","description":"Creates [ITracer](../itracer) components based on their descriptors.\n","image":null,"permalink":"/python/components/trace/default_tracer_factory/","subtitle":null,"tags":null,"title":"DefaultTracerFactory"},{"content":"Implements: IFunction\nDescription The DelegatedFunction class allows you to define a delegate to implement a function.\nConstructors Constructs this function class with the specified parameters.\n public constructor(name: string, calculator: (params: Variant[], variantOperations: IVariantOperations) =\u0026gt; Promise\u0026lt;Variant\u0026gt;, context?: any)\n  params: Variant[] - name of this function. variantOperations: IVariantOperations) =\u0026gt; Promise\u0026lt;Variant\u0026gt; - function calculator delegate. context: any - context  Properties name Function\u0026rsquo;s name.\n public name(): string\n  retuns: string - function\u0026rsquo;s name.  Instance methods calculate Function\u0026rsquo;s calculation method.\n public calculate(params: Variant[], variantOperations: IVariantOperations): Promise\u0026lt;Variant\u0026gt;\n  params: Variant[] - an array with function parameters. variantOperations: IVariantOperations - variants operations manager. returns: Promise\u0026lt;Variant\u0026gt; - returned function\u0026rsquo;s result.  ","description":"Defines a delegate to implement a function.\n","image":null,"permalink":"/node/expressions/calculator/functions/delegated_function/","subtitle":null,"tags":null,"title":"DelegatedFunction"},{"content":"Implements: IReferences\nDescription The DependencyResolver is a helper class that allows you to resolve component dependencies. It is configured to resolve named dependencies by a specific locator.\nImportant points:\n During deployment the dependency locator can be changed. This mechanism can be used to clarify a specific dependency among several alternatives. Typically components are configured to retrieve the first dependency that matches a logical group, type and version. However, if the container contains more than one instance and the resolution has to be specific about those instances; they can be given a unique name, and the dependency resolvers can be reconfigured to retrieve dependencies according to their name.  Configuration parameters  dependencies:  [dependency name 1]: Dependency 1 locator (descriptor) \u0026hellip; [dependency name N]: Dependency N locator (descriptor)    References References must match configured dependencies.\nConstructors NewDependencyResolverWithParams Creates a new instance of the dependency resolver.\nSee ConfigParams, IReferences\n NewDependencyResolverWithParams(config *conf.ConfigParams, references IReferences) *DependencyResolver\n  config: *conf.ConfigParams - (optional) default configuration where key is dependency name and value is locator (descriptor) references: IReferences - (optional) default component references  NewDependencyResolverFromTuples Creates a new DependencyResolver from a list of key-value pairs called tuples where key is dependency name and value the depedency locator (descriptor).\n NewDependencyResolverFromTuples(tuples \u0026hellip;interface{}) *DependencyResolver\n  tuples: \u0026hellip;interface{} - list of values where odd elements are dependency name and the following even elements are dependency locator (descriptor)  NewDependencyResolver Creates a new instance of the dependency resolver.\n NewDependencyResolver() *DependencyResolver\n Methods Configure Configures the component with specified parameters.\n (c *DependencyResolver) Configure(config *conf.ConfigParams)\n  config: *conf.ConfigParams - configuration parameters to set.  Find Finds all matching dependencies by their name.\n (c *DependencyResolver) Find(name string, required bool) ([]interface{}, error)\n  name: string - dependency name to locate. required: bool - true to raise an exception when no dependencies are found. returns: ([]interface{}, error) - list of found dependencies  GetOneOptional Gets one optional dependency by its name.\n (c *DependencyResolver) GetOneOptional(name string) interface{}\n  name: string - dependency name to locate. returns: interface{} - dependency reference or nil of the dependency was not found  GetOneRequired Gets one required dependency by its name. At least one dependency must present. If the dependency was found it throws a ReferenceError\n (c *DependencyResolver) GetOneRequired(name string) (interface{}, error)\n  name: string - dependency name to locate. returns: (interface{}, error) - dependency reference  GetOptional Gets all optional dependencies by their name.\n (c *DependencyResolver) GetOptional(name string) []interface{}\n  name: string - dependency name to locate. returns: []interface{} - list with found dependencies or empty list of no dependencies was found.  GetRequired Gets all required dependencies by their name. At least one dependency must be present. If no dependencies were found it throws a ReferenceError\n (c *DependencyResolver) GetRequired(name string) ([]interface{}, error)\n  name: string - dependency name to locate. returns: ([]interface{}, error) - list with found dependencies.  Put Adds a new dependency into this resolver.\n (c *DependencyResolver) Put(name string, locator interface{})\n  name: string - dependency\u0026rsquo;s name. locator: interface{} - locator to find the dependency by.  SetReferences Sets the component references. References must match configured dependencies.\n (c *DependencyResolver) SetReferences(references IReferences)\n  references: IReferences - references to set.  Examples TODO: add example See also   IReferences   ","description":"Helper class for resolving component dependencies.  \n","image":null,"permalink":"/golang/commons/refer/dependency_resolver/","subtitle":null,"tags":null,"title":"DependencyResolver"},{"content":"Inherits: IReferenceable, IReconfigurable\nDescription The DependencyResolver is a helper class that allows you to resolve component dependencies. It is configured to resolve named dependencies by a specific locator.\nImportant points:\n During deployment the dependency locator can be changed. This mechanism can be used to clarify a specific dependency among several alternatives. Typically components are configured to retrieve the first dependency that matches a logical group, type and version. However, if the container contains more than one instance and the resolution has to be specific about those instances; they can be given a unique name, and the dependency resolvers can be reconfigured to retrieve dependencies according to their name.  Configuration parameters  dependencies:  [dependency name 1]: Dependency 1 locator (descriptor) \u0026hellip; [dependency name N]: Dependency N locator (descriptor)    References References must match configured dependencies.\nConstructors Creates a new instance of the dependency resolver.\nSee ConfigParams, IReferences\n public DependencyResolver(ConfigParams config)\n  config: ConfigParams - (optional) default configuration where key is a dependency name and value is its locator (descriptor)  Creates a new instance of the dependency resolver.\n public DependencyResolver()\n Instance methods configure Configures the component with specified parameters.\n public void Configure(config: ConfigParams)\n  config: ConfigParams - configuration parameters to set.  Find Finds all matching dependencies by their name.\n public List\u0026lt;object\u0026gt; Find(string name, bool required)\n  name: string - dependency name to locate. required: bool - true to raise an exception when no dependencies are found. returns: List\u0026lt;object\u0026gt; - list of found dependencies  Find Finds all matching dependencies by their name and matching to the specified type. T - class type\n public List\u0026lt;T\u0026gt; find\u0026lt;T\u0026gt;(string name, bool required)\n  name: string - dependency name to locate. required: bool - true to raise an exception when no dependencies are found. returns: List\u0026lt;T\u0026gt; - list of found dependencies  GetOneOptional Gets one optional dependency by its name.\n public object GetOneOptional(name: string)\n  name: string - dependency name to locate. returns: object - dependency reference or null if the dependency was not found  GetOneOptional Gets one optional dependency by its name and matching to the specified type. T - class type\n public T GetOneOptional\u0026lt;T\u0026gt;(string name)\n  name: string - dependency name to locate. returns: T - dependency reference or null if the dependency was not found  GetOneRequired Gets one required dependency by its name. At least one dependency must present. If the dependency was found, it throws a ReferenceException\n public object GetOneRequired\u0026lt;T\u0026gt;(string name)\n  name: string - dependency name to locate. returns: object - dependency reference  GetOneRequired Gets one required dependency by its name and matching to the specified type. At least one dependency must present. If the dependency was found, it throws a ReferenceException T - the class type.\n public T GetOneRequired\u0026lt;T\u0026gt;(string name)\n  name: string - the dependency name to locate. returns: T - dependency reference  GetOptional Gets all optional dependencies by their name.\n public List\u0026lt;T\u0026gt; GetOptional(string name)\n  name: string - dependency name to locate. returns: List\u0026lt;T\u0026gt; - list with found dependencies or empty list of no dependency was found.  GetOptional Gets all optional dependencies by their name. T - the class type.\n public List\u0026lt;T\u0026gt; GetOptional\u0026lt;T\u0026gt;(string name)\n  name: string - the dependency name to locate. returns: List\u0026lt;T\u0026gt; - list with found dependencies or empty list of no dependency was found.  GetRequired Gets all required dependencies by their name. At least one dependency must present. If no dependency was found, it throws aReferenceException.\n public List\u0026lt;object\u0026gt; GetRequired(string name)\n  name: string - dependency name to locate. returns: List\u0026lt;T\u0026gt; - list with found dependencies.  GetRequired Gets all required dependencies by their name. At least one dependency must be present. If no dependency was found it throws a ReferenceException. T - class type\n public List\u0026lt;T\u0026gt; GetRequired\u0026lt;T\u0026gt;(string name)\n  name: string - dependency name to locate. returns: List\u0026lt;T\u0026gt; - list with found dependencies.  Put Adds a new dependency into this resolver.\n public void Put(string name, object locator)\n  name: string - dependency\u0026rsquo;s name. locator: object - locator used to find the dependency.  SetReferences Sets the component references. References must match configured dependencies.\n public void SetReferences(IReferences references)\n  references: IReferences - references to set.  Static methods FromTuples Creates a new DependencyResolver from a list of key-value pairs called tuples, where key is dependency name and value the depedency locator (descriptor).\n public static DependencyResolver FromTuples(params object[] tuples)\n  tuples: object[] - list of values where odd elements are dependency names and the following even elements are dependency locators (descriptor) returns: DependencyResolver - newly created DependencyResolver.  Examples class MyComponent: IConfigurable, IReferenceable { private DependencyResolver _dependencyResolver = new DependencyResolver(); private IMyPersistence _persistence; ... public MyComponent() { this._dependencyResolver.Put(\u0026#34;persistence\u0026#34;, new Descriptor(\u0026#34;mygroup\u0026#34;, \u0026#34;persistence\u0026#34;, \u0026#34;*\u0026#34;, \u0026#34;*\u0026#34;, \u0026#34;1.0\u0026#34;)); } public void Configure(ConfigParams config) { this._dependencyResolver.Configure(config); } public void SetReferences(IReferences references) { this._dependencyResolver.SetReferences(references); this._persistence = this._dependencyResolver.GetOneRequired\u0026lt;IMyPersistence\u0026gt;(\u0026#34;persistence\u0026#34;); } } /// // Create mycomponent and set specific dependency out of many var component = new MyComponent(); component.Configure(ConfigParams.FromTuples( \u0026#34;dependencies.persistence\u0026#34;, \u0026#34;mygroup:persistence:*:persistence2:1.0\u0026#34; // Override default persistence dependency )); component.SetReferences(References.fromTuples( new Descriptor(\u0026#34;mygroup\u0026#34;,\u0026#34;persistence\u0026#34;,\u0026#34;*\u0026#34;,\u0026#34;persistence1\u0026#34;,\u0026#34;1.0\u0026#34;), new MyPersistence(), new Descriptor(\u0026#34;mygroup\u0026#34;,\u0026#34;persistence\u0026#34;,\u0026#34;*\u0026#34;,\u0026#34;persistence2\u0026#34;,\u0026#34;1.0\u0026#34;), new MyPersistence() // This dependency shall be set )); See also   IReferences   ","description":"Helper class for resolving component dependencies.  \n","image":null,"permalink":"/net/commons/refer/dependency_resolver/","subtitle":null,"tags":null,"title":"DependencyResolver"},{"content":"Implements: IReferenceable, IReconfigurable\nDescription The DependencyResolver is a helper class that allows you to resolve component dependencies. It is configured to resolve named dependencies by a specific locator.\nImportant points:\n During deployment the dependency locator can be changed. This mechanism can be used to clarify a specific dependency among several alternatives. Typically components are configured to retrieve the first dependency that matches a logical group, type and version. However, if the container contains more than one instance and the resolution has to be specific about those instances, they can be given a unique name and the dependency resolvers can be reconfigured to retrieve dependencies according to their name.  Configuration parameters  dependencies:  [dependency name 1]: Dependency 1 locator (descriptor) \u0026hellip; [dependency name N]: Dependency N locator (descriptor)    References References must match configured dependencies.\nConstructors Creates a new instance of the dependency resolver.\nSee ConfigParams, IReferences\n public constructor(config?: ConfigParams, references?: IReferences)\n  config: ConfigParams - (optional) default configuration where key the is dependency name and value is the locator (descriptor) references: IReferences - (optional) default component references  Instance methods configure Configures the component with specified parameters.\n public configure(config: ConfigParams): void\n  config: ConfigParams - configuration parameters to set.  find Finds all matching dependencies by their name.\n public find\u0026lt;T\u0026gt;(name: string, required: boolean): T[]\n  name: string - dependency name to locate. required: boolean - true to raise an exception when no dependencies are found. returns: T[] - list of found dependencies  getOneOptional Gets one optional dependency by its name.\n public getOneOptional\u0026lt;T\u0026gt;(name: string): T\n  name: string - dependency name to locate. returns: T - dependency reference or null if the dependency was not found.  getOneRequired Gets one required dependency by its name. At least one dependency must present. If the dependency was found it throws a ReferenceException.\n public getOneRequired\u0026lt;T\u0026gt;(name: string): T\n  name: string - dependency name to locate. returns: T - dependency reference  getOptional Gets all optional dependencies by their name.\n public getOptional\u0026lt;T\u0026gt;(name: string): T[]\n  name: string - dependency name to locate. returns: T[] - list with found dependencies or empty list of no dependencies was found.  getRequired Gets all required dependencies by their name. At least one dependency must be present. If no dependency was found, it throws a ReferenceException\n public getRequired\u0026lt;T\u0026gt;(name: string): T[]\n  name: string - dependency name to locate. returns: T[] - list with found dependencies.  put Adds a new dependency into this resolver.\n public put(name: string, locator: any): void\n  name: string - dependency\u0026rsquo;s name. locator: any - locator to find the dependency by.  setReferences Sets the component references. References must match configured dependencies.\n public setReferences(references: IReferences): void\n  references: IReferences - references to set.  Static methods fromTuples Creates a new DependencyResolver from a list of key-value pairs called tuples where key is a dependency name and value the depedency locator (descriptor).\n public static fromTuples(\u0026hellip;tuples: any[]): DependencyResolver\n  tuples: any[] - list of values where odd elements are dependency names and the following even elements are dependency locators (descriptor). returns: DependencyResolver - newly created DependencyResolver.  Examples class MyComponent: IConfigurable, IReferenceable { private _dependencyResolver: DependencyResolver = new DependencyResolver(); private _persistence: IMyPersistence; ... public constructor() { this._dependencyResolver.put(\u0026#34;persistence\u0026#34;, new Descriptor(\u0026#34;mygroup\u0026#34;, \u0026#34;persistence\u0026#34;, \u0026#34;*\u0026#34;, \u0026#34;*\u0026#34;, \u0026#34;1.0\u0026#34;)); } public configure(config: ConfigParams): void { this._dependencyResolver.configure(config); } public setReferences(references: IReferences): void { this._dependencyResolver.setReferences(references); this._persistence = this._dependencyResolver.getOneRequired\u0026lt;IMyPersistence\u0026gt;(\u0026#34;persistence\u0026#34;); } } // Create mycomponent and set specific dependency out of many let component = new MyComponent(); component.configure(ConfigParams.fromTuples( \u0026#34;dependencies.persistence\u0026#34;, \u0026#34;mygroup:persistence:*:persistence2:1.0\u0026#34; // Override default persistence dependency )); component.setReferences(References.fromTuples( new Descriptor(\u0026#34;mygroup\u0026#34;,\u0026#34;persistence\u0026#34;,\u0026#34;*\u0026#34;,\u0026#34;persistence1\u0026#34;,\u0026#34;1.0\u0026#34;), new MyPersistence(), new Descriptor(\u0026#34;mygroup\u0026#34;,\u0026#34;persistence\u0026#34;,\u0026#34;*\u0026#34;,\u0026#34;persistence2\u0026#34;,\u0026#34;1.0\u0026#34;), new MyPersistence() // This dependency shall be set )); See also   IReferences   ","description":"Helper class for resolving component dependencies.  \n","image":null,"permalink":"/node/commons/refer/dependency_resolver/","subtitle":null,"tags":null,"title":"DependencyResolver"},{"content":"Implements: IReferenceable, IReconfigurable\nDescription The DependencyResolver is a helper class that allows you to resolve component dependencies. It is configured to resolve named dependencies by a specific locator.\nImportant points:\n During deployment the dependency locator can be changed. This mechanism can be used to clarify a specific dependency among several alternatives. Typically components are configured to retrieve the first dependency that matches a logical group, type and version. However, if the container contains more than one instance and the resolution has to be specific about those instances; they can be given a unique name, and the dependency resolvers can be reconfigured to retrieve dependencies according to their name.  Configuration parameters  dependencies:  [dependency name 1]: Dependency 1 locator (descriptor) \u0026hellip; [dependency name N]: Dependency N locator (descriptor)    References References must match configured dependencies.\nConstructors Creates a new instance of the dependency resolver.\nSee ConfigParams, IReferences\n DependencyResolver(config: ConfigParams = None, references: IReferences = None)\n  config: ConfigParams - (optional) default configuration where key is dependency name and value is locator (descriptor) references: IReferences - (optional) default component references  Instance methods configure Configures the component with specified parameters.\n configure(config: ConfigParams)\n  config: ConfigParams - configuration parameters to set.  find Finds all matching dependencies by their name.\n find(name: str, required: bool): List[Any]\n  name: str - the dependency name to locate. required: bool - true to raise an exception when no dependencies are found. returns: List[Any] - a list of found dependencies  get_one_optional Gets one optional dependency by its name.\n get_one_optional(name: str): Any\n  name: str - the dependency name to locate. returns: Any - a dependency reference or None of the dependency was not found  get_one_required Gets one required dependency by its name. At least one dependency must present. If the dependency was found it throws a ReferenceException\n get_one_required(name: str): Any\n  name: str - the dependency name to locate. returns: Any - a dependency reference  get_optional Gets all optional dependencies by their name.\n get_optional(name: str): List[Any]\n  name: str - the dependency name to locate. returns: List[Any] - a list with found dependencies or empty list of no dependencies were found.  get_required Gets all required dependencies by their name. At least one dependency must be present. If no dependencies were found it throws a ReferenceException\n get_required(name: str): List[Any]\n  name: str - the dependency name to locate. returns: List[Any] - a list with found dependencies.  put Adds a new dependency into this resolver.\n put(name: str, locator: Any)\n  name: str - the dependency\u0026rsquo;s name. locator: Any - the locator to find the dependency by.  set_references Sets the component references. References must match configured dependencies.\n set_references(references: IReferences)\n  references: IReferences - references to set.  Static methods from_tuples Creates a new DependencyResolver from a list of key-value pairs called tuples where key is the dependency name and value the depedency locator (descriptor).\n static from_tuples(*tuples: Any): DependencyResolver\n  tuples: Any - a list of values where odd elements are dependency name and the following even elements are dependency locator (descriptor) returns: DependencyResolver - a newly created DependencyResolver.  Examples class MyComponent(IConfigurable, IReferenceable): _dependencyResolver = None _persistence = None def __init__(self): self._dependencyResolver.put(\u0026#34;persistence\u0026#34;, new Descriptor(\u0026#34;mygroup\u0026#34;, \u0026#34;persistence\u0026#34;, \u0026#34;*\u0026#34;, \u0026#34;*\u0026#34;, \u0026#34;1.0\u0026#34;)) def configure(self, config): self._dependencyResolver.configure(config) def set_references(self, references): self._dependencyResolver.setReferences(references) self._persistence = self._dependencyResolver.get_one_required(\u0026#34;persistence\u0026#34;) component = MyComponent() component.configure(ConfigParams.from_tuples( \u0026#34;dependencies.persistence\u0026#34;, \u0026#34;mygroup:persistence:*:persistence2:1.0\u0026#34;)) component.set_references(References.from_tuples(Descriptor(\u0026#34;mygroup\u0026#34;,\u0026#34;persistence\u0026#34;,\u0026#34;*\u0026#34;,\u0026#34;persistence1\u0026#34;,\u0026#34;1.0\u0026#34;), MyPersistence(), Descriptor(\u0026#34;mygroup\u0026#34;,\u0026#34;persistence\u0026#34;,\u0026#34;*\u0026#34;,\u0026#34;persistence2\u0026#34;,\u0026#34;1.0\u0026#34;), MyPersistence() # This dependency shall be set )) See also   IReferences   ","description":"Helper class for resolving component dependencies.  \n","image":null,"permalink":"/python/commons/refer/dependency_resolver/","subtitle":null,"tags":null,"title":"DependencyResolver"},{"content":"Description The Descriptor class provides you with a component locator. This locator is often used in the PipServices toolkit. It locates components using the following fields:\n Group: a package or just named group of components, like \u0026ldquo;pip-services\u0026rdquo;. Type: logical component type that defines it\u0026rsquo;s contract, like \u0026ldquo;persistence\u0026rdquo; . Kind: physical implementation type, like \u0026ldquo;mongodb\u0026rdquo;. Name: unique component name, like \u0026ldquo;default\u0026rdquo;. Version: version of the component contract, like \u0026ldquo;1.0\u0026rdquo;.  Important points\n The locator matching can be done by all or only few selected fields. The fields that shall be excluded from the matching must be set to \u0026quot;\u0026quot;* or *nil*. This approach allows to implement many interesting scenarios. For instance:  Locate all loggers (match by type and version) Locate persistence components for a microservice (match by group and type) Locate specific component by its name (match by name)    Constructors NewDescriptor Creates a new instance of the descriptor.\n NewDescriptor(group string, typ string, kind string, name string, version string) *Descriptor\n  group: string - logical component group typ: string - logical component type or contract kind: string - component implementation type name: string - unique component name version: string - component implementation version  Methods Equals Compares this descriptor to a value. If value is a Descriptor it tries to match them, otherwise the method returns false.\n (c *Descriptor) Equals(value interface{}) bool\n  value: interface{} - value to match against this descriptor. returns: bool - true if the value is matching descriptor and false otherwise.  ExactMatch Matches this descriptor to another descriptor by all fields. No exceptions are made.\n (c *Descriptor) ExactMatch(descriptor *Descriptor) bool\n  descriptor: *Descriptor - descriptor to match this one against. returns: bool - true if descriptors match and false otherwise.  Group Gets the component\u0026rsquo;s logical group.\n (c *Descriptor) Group() string\n  returns: string - component\u0026rsquo;s logical group  Kind Gets the component\u0026rsquo;s implementation type.\n (c *Descriptor) Kind() string\n  returns: string - component\u0026rsquo;s implementation type.  Name Gets the unique component\u0026rsquo;s name.\n (c *Descriptor) Name() string\n  returns: string - unique component\u0026rsquo;s name.  Version Gets the component\u0026rsquo;s implementation version.\n (c *Descriptor) Version() string\n  returns: string - component\u0026rsquo;s implementation version.  IsComplete Checks whether all descriptor fields are set. If descriptor has at least one \u0026ldquo;*\u0026rdquo; or nil field it is considered \u0026ldquo;incomplete\u0026rdquo;,\n (c *Descriptor) IsComplete() bool\n  returns: bool - true if all descriptor fields are defined and false otherwise.  Match Partially matches this descriptor to another descriptor. Fields that contain \u0026ldquo;*\u0026rdquo; or nil are excluded from the match.\n (c *Descriptor) Match(descriptor *Descriptor) bool\n  descriptor: *Descriptor descriptor to match this one against. returns: bool - true if descriptors match and false otherwise  ParseDescriptorFromString Parses colon-separated list of descriptor fields and returns them as a Descriptor.\nThrows a ConfigError if the descriptor string is of a wrong format.\n ParseDescriptorFromString(value string) (*Descriptor, error)\n  value: string - colon-separated descriptor fields to initialize Descriptor. returns: *Descriptor - newly created Descriptor.  String Gets a string representation of the object. The result is a colon-separated list of descriptor fields as \u0026ldquo;mygroup:connector:aws:default:1.0\u0026rdquo;\n (c *Descriptor) String() string\n  returns: string - string representation of the object.  Examples locator1 := NewDescriptor(\u0026#34;mygroup\u0026#34;, \u0026#34;connector\u0026#34;, \u0026#34;aws\u0026#34;, \u0026#34;default\u0026#34;, \u0026#34;1.0\u0026#34;); locator2 := NewDescriptorFromString(\u0026#34;mygroup:connector:*:*:1.0\u0026#34;); locator1.Match(locator2); // Result: true locator1.Equal(locator2); // Result: true locator1.ExactMatch(locator2); // Result: false  ","description":"Component locator based on group, type, kind, name and version of the component.\n","image":null,"permalink":"/golang/commons/refer/descriptor/","subtitle":null,"tags":null,"title":"Descriptor"},{"content":"Description The Descriptor class provides you with a component locator. This locator is often used in the PipServices toolkit. It locates components using the following fields:\n Group: package or just named group of components, like \u0026ldquo;pip-services\u0026rdquo;. Type: logical component type that defines it\u0026rsquo;s contract, like \u0026ldquo;persistence\u0026rdquo; . Kind: physical implementation type, like \u0026ldquo;mongodb\u0026rdquo;. Name: unique component name, like \u0026ldquo;default\u0026rdquo;. Version: version of the component contract, like \u0026ldquo;1.0\u0026rdquo;.  Important points\n The locator matching can be done by all or only a few selected fields. The fields that shall be excluded from the matching must be set to \u0026quot;\u0026quot;* or *null*. This approach allows to implement many interesting scenarios. For instance:  Locate all loggers (match by type and version) Locate persistence components for a microservice (match by group and type) Locate specific component by its name (match by name)    Constructors Creates a new instance of the descriptor.\n public Descriptor(string group, string type, string kind, string name, string version)\n  group: string - logical component group type: string - logical component type or contract kind: string - component implementation type name: string - unique component name version: string - component implementation version  Properties Group Gets the component\u0026rsquo;s logical group.\n public string Group [ get, private set ]\n Type  public string Type [ get, private set ]\n Kind Gets the component\u0026rsquo;s implementation type.\n public string Kind [ get, private set ]\n Name Gets the unique component\u0026rsquo;s name.\n public string Name [ get, private set ]\n Version Gets the component\u0026rsquo;s implementation version.\n public string Version [ get, private set ]\n Instance methods Equals Compares this descriptor to a value. If value is a Descriptor, it tries to match them; otherwise, the method returns false.\n public override bool Equals(object obj)\n  obj: object - value to match against this descriptor. returns: bool - true if the value is matching descriptor and false otherwise.  ExactMatch Matches this descriptor to another descriptor by all fields. No exceptions are made.\n public bool ExactMatch(Descriptor descriptor)\n  descriptor: Descriptor - descriptor to match this one against. returns: bool - true if the descriptors match and false otherwise.  GetHashCode Gets a Hash code\n public override int GetHashCode()\n  returns: int - Hash code  IsComplete Checks whether all descriptor fields are set. If descriptor has at least one \u0026ldquo;*\u0026rdquo; or null field, it is considered \u0026ldquo;incomplete\u0026rdquo;,\n public bool IsComplete()\n  returns: bool - true if all descriptor fields are defined and false otherwise.  Match Partially matches this descriptor to another descriptor. Fields that contain \u0026ldquo;*\u0026rdquo; or null are excluded from the match.\n public bool Match(Descriptor descriptor)\n  descriptor: Descriptor descriptor to match this one against. returns: bool - true if the descriptors match and false otherwise  ToString Gets a string representation of the object. The result is a colon-separated list of the descriptor\u0026rsquo;s fields as \u0026ldquo;mygroup:connector:aws:default:1.0\u0026rdquo;\n public override string ToString()\n  returns: string - string representation of the object.  Static methods FromString Parses a colon-separated list of descriptor fields and returns them as a Descriptor.\nThrows a ConfigException if the descriptor string is of a wrong format.\n public static Descriptor FromString(string value)\n  value: string - colon-separated descriptor fields used to initialize Descriptor. returns: Descriptor - newly created Descriptor.  Examples var locator1 = new Descriptor(\u0026#34;mygroup\u0026#34;, \u0026#34;connector\u0026#34;, \u0026#34;aws\u0026#34;, \u0026#34;default\u0026#34;, \u0026#34;1.0\u0026#34;); var locator2 = Descriptor.fromString(\u0026#34;mygroup:connector:*:*:1.0\u0026#34;); locator1.match(locator2); // Result: true locator1.equal(locator2); // Result: true locator1.exactMatch(locator2); // Result: false  ","description":"Component locator based on group, type, kind, name and version of the component.\n","image":null,"permalink":"/net/commons/refer/descriptor/","subtitle":null,"tags":null,"title":"Descriptor"},{"content":"Description The Descriptor class provides you with a component locator. This locator is often used in the PipServices toolkit. It locates components using the following fields:\n Group: package or named group of components, like \u0026ldquo;pip-services\u0026rdquo;. Type: logical component type that defines it\u0026rsquo;s contract, like \u0026ldquo;persistence\u0026rdquo; . Kind: physical implementation type, like \u0026ldquo;mongodb\u0026rdquo;. Name: unique component name, like \u0026ldquo;default\u0026rdquo;. Version: version of the component contract, like \u0026ldquo;1.0\u0026rdquo;.  Important points\n The locator matching can be done by all or only few selected fields. The fields that shall be excluded from the matching must be set to \u0026quot;\u0026quot;* or *null*. This approach allows to implement many interesting scenarios. For instance:  Locate all loggers (match by type and version) Locate persistence components for a microservice (match by group and type) Locate specific component by its name (match by name)    Constructors Creates a new instance of the descriptor.\n public constructor(group: string, type: string, kind: string, name: string, version: string)\n  group: string - logical component group type: string - logical component type or contract kind: string - component implementation type name: string - unique component name version: string - component implementation version  Instance methods equals Compares this descriptor to a value. If value is a Descriptor it tries to match them, otherwise the method returns false.\n public equals(value: any): boolean\n  value: any - value to match against this descriptor. returns: boolean - true if the value is matching descriptor and false otherwise.  exactMatch Matches this descriptor to another descriptor by all fields. No exceptions are made.\n public exactMatch(descriptor: Descriptor): boolean\n  descriptor: Descriptor - descriptor to match this one against. returns: boolean - true if descriptors match and false otherwise.  getGroup Gets the component\u0026rsquo;s logical group.\n public getGroup(): string\n  returns: string - component\u0026rsquo;s logical group  getKind Gets the component\u0026rsquo;s implementation type.\n public getKind(): string\n  returns: string - component\u0026rsquo;s implementation type.  getName Gets the unique component\u0026rsquo;s name.\n public getName(): string\n  returns: string - unique component\u0026rsquo;s name.  getVersion Gets the component\u0026rsquo;s implementation version.\n public getVersion(): string\n  returns: string - component\u0026rsquo;s implementation version.  isComplete Checks whether all descriptor fields are set. If descriptor has at least one \u0026ldquo;*\u0026rdquo; or null field it is considered \u0026ldquo;incomplete\u0026rdquo;,\n public isComplete(): boolean\n  returns: boolean - true if all descriptor fields are defined and false otherwise.  match Partially matches this descriptor to another descriptor. Fields that contain \u0026ldquo;*\u0026rdquo; or null are excluded from the match.\n public match(descriptor: Descriptor): boolean\n  descriptor: Descriptor descriptor to match this one against. returns: boolean - true if descriptors match and false otherwise  toString Gets a string representation of the object. The result is a colon-separated list of descriptor fields as \u0026ldquo;mygroup:connector:aws:default:1.0\u0026rdquo;\n public toString(): string\n  returns: string - string representation of the object.  Static methods fromString Parses colon-separated list of descriptor fields and returns them as a Descriptor.\nThrows a ConfigException if the descriptor string is of a wrong format.\n public static fromString(value: string): Descriptor\n  value: string - colon-separated descriptor fields to initialize Descriptor. returns: Descriptor - newly created Descriptor.  Examples let locator1 = new Descriptor(\u0026#34;mygroup\u0026#34;, \u0026#34;connector\u0026#34;, \u0026#34;aws\u0026#34;, \u0026#34;default\u0026#34;, \u0026#34;1.0\u0026#34;); let locator2 = Descriptor.fromString(\u0026#34;mygroup:connector:*:*:1.0\u0026#34;); locator1.match(locator2);\t// Result: true locator1.equal(locator2);\t// Result: true locator1.exactMatch(locator2);\t// Result: false  ","description":"Component locator based on group, type, kind, name and version of the component.\n","image":null,"permalink":"/node/commons/refer/descriptor/","subtitle":null,"tags":null,"title":"Descriptor"},{"content":"Description The Descriptor class provides you with a component locator. This locator is often used in the PipServices toolkit. It locates components using the following fields:\n Group: a package or just named group of components, like \u0026ldquo;pip-services\u0026rdquo;. Type: logical component type that defines it\u0026rsquo;s contract, like \u0026ldquo;persistence\u0026rdquo; . Kind: physical implementation type, like \u0026ldquo;mongodb\u0026rdquo;. Name: unique component name, like \u0026ldquo;default\u0026rdquo;. Version: version of the component contract, like \u0026ldquo;1.0\u0026rdquo;.  Important points\n The locator matching can be done by all or only few selected fields. The fields that shall be excluded from the matching must be set to \u0026quot;\u0026quot;* or *None*. This approach allows to implement many interesting scenarios. For instance:  Locate all loggers (match by type and version) Locate persistence components for a microservice (match by group and type) Locate specific component by its name (match by name)    Constructors Creates a new instance of the descriptor.\n Descriptor(group: Optional[str], type: Optional[str], kind: Optional[str], name: Optional[str], version: Optional[str])\n  group: Optional[str] - a logical component group type: Optional[str] - a logical component type or contract kind: Optional[str] - a component implementation type name: Optional[str] - a unique component name version: Optional[str] - a component implementation version  Instance methods equals Compares this descriptor to a value. If value is a Descriptor it tries to match them, otherwise the method returns false.\n equals(value: Any): bool\n  value: Any - the value to match against this descriptor. returns: bool - true if the value is matching descriptor and false otherwise.  exact_match Matches this descriptor to another descriptor by all fields. No exceptions are made.\n exact_match(descriptor: Descriptor): bool\n  descriptor: Descriptor - the descriptor to match this one against. returns: bool - true if descriptors match and false otherwise.  get_group Gets the component\u0026rsquo;s logical group.\n get_group(): str\n  returns: str - the component\u0026rsquo;s logical group  get_kind Gets the component\u0026rsquo;s implementation type.\n get_kind(): str\n  returns: str - the component\u0026rsquo;s implementation type.  get_name Gets the unique component\u0026rsquo;s name.\n get_name(): str\n  returns: str - the unique component\u0026rsquo;s name.  get_version Gets the component\u0026rsquo;s implementation version.\n get_version(): str\n  returns: str - the component\u0026rsquo;s implementation version.  is_complete Checks whether all descriptor fields are set. If descriptor has at least one \u0026ldquo;*\u0026rdquo; or None field it is considered \u0026ldquo;incomplete\u0026rdquo;,\n is_complete(): bool\n  returns: bool - true if all descriptor fields are defined and false otherwise.  match Partially matches this descriptor to another descriptor. Fields that contain \u0026ldquo;*\u0026rdquo; or None are excluded from the match.\n match(descriptor: Descriptor): bool\n  descriptor: Descriptor the descriptor to match this one against. returns: bool - true if descriptors match and false otherwise  to_string Gets a string representation of the object. The result is a colon-separated list of descriptor fields as \u0026ldquo;mygroup:connector:aws:default:1.0\u0026rdquo;\n to_string(): str\n  returns: str - a string representation of the object.  Static methods from_string Parses colon-separated list of descriptor fields and returns them as a Descriptor.\nThrows a ConfigException if the descriptor string has a wrong format.\n static from_string(value: str): Descriptor\n  value: str - colon-separated descriptor fields to initialize Descriptor. returns: Descriptor - a newly created Descriptor.  Examples locator1 = Descriptor(\u0026#34;mygroup\u0026#34;, \u0026#34;connector\u0026#34;, \u0026#34;aws\u0026#34;, \u0026#34;default\u0026#34;, \u0026#34;1.0\u0026#34;) locator2 = Descriptor.from_string(\u0026#34;mygroup:connector:*:*:1.0\u0026#34;) locator1.match(locator2) # Returns True locator1.exact_match(locator2) # Returns False ","description":"Component locator based on group, type, kind, name and version of the component.\n","image":null,"permalink":"/python/commons/refer/descriptor/","subtitle":null,"tags":null,"title":"Descriptor"},{"content":"Inherits: Logger\nDescription TODO: add description\nInstance methods Write Writes a log message to the logger destination(s).\n public override void Write(LogLevel level, string correlation_id, Exception error, string message)\n  level: LogLevel - a log level. correlation_id: string - (optional) transaction id to trace execution through call chain. error: Exception - an error object associated with this message. message: string - a human-readable message to log.  Examples var logger = new ConsoleLogger(); logger.SetLevel(LogLevel.debug); logger.Error(\u0026#34;123\u0026#34;, ex, \u0026#34;Error occured: %s\u0026#34;, ex.message); logger.Debug(\u0026#34;123\u0026#34;, \u0026#34;Everything is OK.\u0026#34;); See also   Logger   ","description":"Diagnostic logger.\n","image":null,"permalink":"/net/components/log/diagnostics_logger/","subtitle":null,"tags":null,"title":"DiagnosticsLogger "},{"content":"Description The DirectClientclass allows you to create clients that call a controller directly in the same memory space.\nImportant points\n It is used when multiple microservices are deployed in a single container (monolyth) and communication between them can be done by direct calls rather than through the network.  Configuration parameters  dependencies:  controller: override controller descriptor    References  *:logger:*:*:1.0 - (optional) ILogger components to pass log messages *:counters:*:*:1.0 - (optional) ICounters components to pass collected measurements *:traces:*:*:1.0 - (optional) ITracer components to record traces *:discovery:*:*:1.0 - (optional) IDiscovery services to resolve a connection  Constructors NewDirectClient NewDirectClient is creates a new instance of the client.\n NewDirectClient() *DirectClient\n Fields Controller The controller reference.\n Controller: interface{}\n Opened The open flag.\n Opened: bool = True\n Logger The logger.\n Logger: CompositeLogger\n Counters The performance counters\n Counters: CompositeCounters\n DependencyResolver The dependency resolver used to get the controller\u0026rsquo;s reference.\n DependencyResolver: DependencyResolver\n Tracer The tracer.\n Tracer *ctrace.CompositeTracer \n Methods Close Closes a component and frees used resources.\n (c *DirectClient) Close(correlationId string) error\n  correlationId: string - (optional) transaction id used to trace execution through a call chain. returns: error - returns error if not closed  Configure Configures component by passing configuration parameters.\n (c *DirectClient) Configure(config *cconf.ConfigParams)\n  config: *cconf.ConfigParams - configuration parameters to be set.  Instrument Adds instrumentation to log calls and measures call time. It returns a Timing object that is used to end the time measurement.\n (c *DirectClient) Instrument(correlationId string, name string) *service.InstrumentTiming\n  correlationId: string - (optional) transaction id used to trace execution through a call chain. name: string - method name. returns: *service.InstrumentTiming - InstrumentTiming object used to end the time measurement.  IsOpen Checks if the component is open.\n (c *DirectClient) IsOpen() bool\n  returns: bool - True if the component has been opened and False otherwise.  Open Opens the component.\n (c *DirectClient) Open(correlationId string) error\n  correlationId: string - (optional) transaction id used to trace execution through a call chain.  SetReferences Sets references to dependent components.\n (c *DirectClient) SetReferences(references crefer.IReferences)\n  references: crefer.IReferences - references to locate the component dependencies.  Examples type MyDirectClient struct { *DirectClient } func MyDirectClient()* MyDirectClient { c:= MyDirectClient{} c.DirectClient = NewDirectClient() c.DependencyResolver.Put(\u0026#34;controller\u0026#34;, cref.NewDescriptor( \u0026#34;mygroup\u0026#34;, \u0026#34;controller\u0026#34;, \u0026#34;*\u0026#34;, \u0026#34;*\u0026#34;, \u0026#34;*\u0026#34;)); } func (c *MyDirectClient) SetReferences(references cref.IReferences) { c.DirectClient.SetReferences(references) specificController, ok := c.Controller.(tdata.IMyDataController) if !ok { panic(\u0026#34;MyDirectClient: Cant\u0026#39;t resolv dependency \u0026#39;controller\u0026#39; to IMyDataController\u0026#34;) } c.specificController = specificController } ... func (c * MyDirectClient) GetData(correlationId string, id string)(result MyData, err error) { timing := c.Instrument(correlationId, \u0026#34;myclient.get_data\u0026#34;) cmRes, cmdErr := c.specificController.GetData(correlationId, id) timing.EndTiming(); return c.InstrumentError(correlationId, \u0026#34;myclient.get_data\u0026#34;, cmdRes, cmdErr) } ... client = NewMyDirectClient(); client.SetReferences(cref.NewReferencesFromTuples( cref.NewDescriptor(\u0026#34;mygroup\u0026#34;,\u0026#34;controller\u0026#34;,\u0026#34;default\u0026#34;,\u0026#34;default\u0026#34;,\u0026#34;1.0\u0026#34;), controller, )); res, err := client.GetData(\u0026#34;123\u0026#34;, \u0026#34;1\u0026#34;) ","description":"Abstract client that calls a controller directly in the same memory space.\n","image":null,"permalink":"/golang/rpc/clients/direct_client/","subtitle":null,"tags":null,"title":"DirectClient"},{"content":"Inherits: IConfigurable, IReferenceable, IOpenable\nDescription The DirectClientclass allows you to create clients that call a controller directly in the same memory space.\nImportant points\n It is used when multiple microservices are deployed in a single container (monolyth) and communication between them can be done by direct calls rather than through the network.  Configuration parameters  dependencies:  controller: override controller descriptor    References  *:logger:*:*:1.0 - (optional) ILogger components to pass log messages *:counters:*:*:1.0 - (optional) ICounters components to pass collected measurements *:traces:*:*:1.0 - (optional) ITracer components to record traces *:discovery:*:*:1.0 - (optional) IDiscovery services to resolve a connection  Fields _controller The controller reference.\n protected _controller: T\n _opened The open flag.\n protected _opened: boolean = True\n _logger The logger.\n protected _logger: CompositeLogger = CompositeLogger()\n _counters The performance counters\n protected _counters: CompositeCounters = CompositeCounters()\n _dependencyResolver The dependency resolver used to get the controller\u0026rsquo;s reference.\n protected _dependencyResolver: DependencyResolver = DependencyResolver()\n  Instance methods CloseAsync Closes a component and frees used resources.\n public virtual Task CloseAsync(string correlationId)\n  correlationId: string - (optional) transaction id used to trace execution through a call chain.  Configure Configures component by passing configuration parameters.\n public virtual void Configure(ConfigParams config)\n  config: ConfigParams - configuration parameters to be set.  Instrument Adds instrumentation to log calls and measures call time. It returns a Timing object that is used to end the time measurement.\n protected CounterTiming Instrument(string correlationId, [CallerMemberName]string methodName = null)\n  correlationId: string - (optional) transaction id used to trace execution through a call chain. methodName: [CallerMemberName]string - method name. returns: CounterTiming - CounterTiming object used to end the time measurement.  InstrumentError Adds instrumentation to error handling.\n protected void InstrumentError(string correlationId, [CallerMemberName]string methodName = null, Exception ex = null, bool rethrow = false)\n  correlationId: string - (optional) transaction id used to trace execution through a call chain. methodName: [CallerMemberName]string - method name. ex: Exception - Error that occured during the method call. rethrow: bool - True to throw the exception.  IsOpen Checks if the component is open.\n public virtual bool IsOpen()\n  returns: bool - True if the component has been opened and False otherwise.  OpenAsync Opens the component.\n public virtual Task OpenAsync(string correlationId)\n  correlationId: string - (optional) transaction id used to trace execution through a call chain.  SetReferences Sets references to dependent components.\n public virtual void SetReferences(IReferences references)\n  references: IReferences - references to locate the component dependencies.  Examples class MyDirectClient: DirectClient\u0026lt;IMyController\u0026gt;, IMyClient { public MyDirectClient() { base(); this._dependencyResolver.put(\u0026#39;controller\u0026#39;, new Descriptor(\u0026#34;mygroup\u0026#34;, \u0026#34;controller\u0026#34;, \u0026#34;*\u0026#34;, \u0026#34;*\u0026#34;, \u0026#34;*\u0026#34;)); } ... public MyData GetData(string correlationId, string id) { var timing = this.Instrument(correlationId, \u0026#39;myclient.get_data\u0026#39;); var result = this._controller.GetData(correlationId, id); timing.EndTiming(); return result; } ... } var client = new MyDirectClient(); client.SetReferences(References.FromTuples( new Descriptor(\u0026#34;mygroup\u0026#34;,\u0026#34;controller\u0026#34;,\u0026#34;default\u0026#34;,\u0026#34;default\u0026#34;,\u0026#34;1.0\u0026#34;), controller) ); var data = client.GetData(\u0026#34;123\u0026#34;, \u0026#34;1\u0026#34;); ... ","description":"Abstract client that calls a controller directly in the same memory space.\n","image":null,"permalink":"/net/rpc/clients/direct_client/","subtitle":null,"tags":null,"title":"DirectClient\u003cT\u003e"},{"content":"Implements: IConfigurable, IReferenceable, IOpenable\nDescription The DirectClientclass allows you to create clients that call a controller directly in the same memory space.\nImportant points\n It is used when multiple microservices are deployed in a single container (monolyth) and communication between them can be done by direct calls rather than through the network.  Configuration parameters  dependencies:  controller: override controller descriptor    References  *:logger:*:*:1.0 - (optional) ILogger components to pass log messages *:counters:*:*:1.0 - (optional) ICounters components to pass collected measurements *:traces:*:*:1.0 - (optional) ITracer components to record traces *:discovery:*:*:1.0 - (optional) IDiscovery services to resolve a connection  Fields _controller The controller reference.\n protected _controller: T\n _opened The open flag.\n protected _opened: boolean = True\n _logger The logger.\n protected _logger: CompositeLogger = CompositeLogger()\n _counters The performance counters\n protected _counters: CompositeCounters = CompositeCounters()\n _dependencyResolver The dependency resolver used to get the controller\u0026rsquo;s reference.\n protected _dependencyResolver: DependencyResolver = DependencyResolver()\n  Instance methods close Closes a component and frees used resources.\n public close(correlationId: string): Promise\u0026lt;void\u0026gt;\n  correlationId: string - (optional) transaction id used to trace execution through a call chain.  configure Configures component by passing configuration parameters.\n public configure(config: ConfigParams): void\n  config: ConfigParams - configuration parameters to be set.  instrument Adds instrumentation to log calls and measures call time. It returns a Timing object that is used to end the time measurement.\n protected instrument(correlationId: string, name: string): InstrumentTiming\n  correlationId: string - (optional) transaction id used to trace execution through a call chain. name: string - method name. returns: InstrumentTiming - InstrumentTiming object used to end the time measurement.  isOpen Checks if the component is open.\n public isOpen(): boolean\n  returns: boolean - True if the component has been opened and False otherwise.  open Opens the component.\n public open(correlationId: string): Promise\u0026lt;void\u0026gt;\n  correlationId: string - (optional) transaction id used to trace execution through a call chain.  setReferences Sets references to dependent components.\n public setReferences(references: IReferences): void\n  references: IReferences - references to locate the component dependencies.  Examples class MyDirectClient extends DirectClient\u0026lt;IMyController\u0026gt; implements IMyClient { public constructor() { super(); this._dependencyResolver.put(\u0026#39;controller\u0026#39;, new Descriptor( \u0026#34;mygroup\u0026#34;, \u0026#34;controller\u0026#34;, \u0026#34;*\u0026#34;, \u0026#34;*\u0026#34;, \u0026#34;*\u0026#34;)); } ... public async getData(correlationId: string, id: string): Promise\u0026lt;MyData\u0026gt; { let timing = this.instrument(correlationId, \u0026#39;myclient.get_data\u0026#39;); try { return await this._controller.getData(correlationId, id); } catch (ex) { timing.endFailure(ex); } finally { timing.endTiming(); } } ... } let client = new MyDirectClient(); client.setReferences(References.fromTuples( new Descriptor(\u0026#34;mygroup\u0026#34;,\u0026#34;controller\u0026#34;,\u0026#34;default\u0026#34;,\u0026#34;default\u0026#34;,\u0026#34;1.0\u0026#34;), controller )); let result = await client.getData(\u0026#34;123\u0026#34;, \u0026#34;1\u0026#34;); ","description":"Abstract client that calls a controller directly in the same memory space.\n","image":null,"permalink":"/node/rpc/clients/direct_client/","subtitle":null,"tags":null,"title":"DirectClient\u003cT\u003e"},{"content":"Implements: IConfigurable, IReferenceable, IOpenable\nDescription The DirectClientclass allows you to create clients that call a controller directly in the same memory space.\nImportant points\n It is used when multiple microservices are deployed in a single container (monolyth) and communication between them can be done by direct calls rather than through the network.  Configuration parameters  dependencies:  controller: override controller descriptor    References  *:logger:*:*:1.0 - (optional) ILogger components to pass log messages *:counters:*:*:1.0 - (optional) ICounters components to pass collected measurements *:traces:*:*:1.0 - (optional) ITracer components to record traces *:discovery:*:*:1.0 - (optional) IDiscovery services to resolve a connection  Fields _controller The controller reference.\n _controller: Any\n _opened The open flag.\n _opened: bool = True\n _logger The logger.\n _logger: CompositeLogger = CompositeLogger()\n _counters The performance counters\n _counters: CompositeCounters = CompositeCounters()\n _dependency_resolver The dependency resolver used to get the controller\u0026rsquo;s reference.\n _dependency_resolver: DependencyResolver = DependencyResolver()\n  Instance methods close Closes a component and frees used resources.\n close(correlation_id: Optional[str])\n  correlation_id: Optional[str] - (optional) transaction id used to trace execution through a call chain.  configure Configures component by passing configuration parameters.\n configure(config: ConfigParams)\n  config: ConfigParams - configuration parameters to be set.  _instrument Adds instrumentation to log calls and measures call time. It returns a Timing object that is used to end the time measurement.\n _instrument(correlation_id: Optional[str], name: str): InstrumentTiming\n  correlation_id: Optional[str] - (optional) transaction id used to trace execution through a call chain. name: str - method name. returns: InstrumentTiming - InstrumentTiming object used to end the time measurement.  is_open Checks if the component is open.\n is_open(): bool\n  returns: bool - True if the component has been opened and False otherwise.  open Opens the component.\n open(correlation_id: Optional[str])\n  correlation_id: Optional[str] - (optional) transaction id used to trace execution through a call chain.  set_references Sets references to dependent components.\n set_references(references: IReferences)\n  references: IReferences - references to locate the component dependencies.  Examples class MyDirectClient(DirectClient, IMyClient): def __init__(self): super(MyDirectClient, self).__init__() self._dependencyResolver.put(\u0026#39;controller\u0026#39;, Descriptor(\u0026#34;mygroup\u0026#34;, \u0026#34;controller\u0026#34;, \u0026#34;*\u0026#34;, \u0026#34;*\u0026#34;, \u0026#34;*\u0026#34;)) # ... def get_data(self, correlation_id, id): timing = self.instrument(correlationId, \u0026#39;myclient.get_data\u0026#39;) result = self._controller.get_data(correlationId, id) timing.end_timing() return result client = MyDirectClient() client.set_references(References.from_tuples(Descriptor(\u0026#34;mygroup\u0026#34;,\u0026#34;controller\u0026#34;,\u0026#34;default\u0026#34;,\u0026#34;default\u0026#34;,\u0026#34;1.0\u0026#34;), controller)) data = client.get_data(\u0026#34;123\u0026#34;, \u0026#34;1\u0026#34;) # ... ","description":"Abstract client that calls a controller directly in the same memory space.\n","image":null,"permalink":"/python/rpc/clients/direct_client/","subtitle":null,"tags":null,"title":"DirectClient"},{"content":"Description The DoubleConverter class allows you to convert arbitrary values into double using the following extended conversion rules:\n  Strings are converted to double values\n  DateTime: total number of milliseconds since unix epoсh\n  Boolean: 1 for true and 0 for false\n  Methods toDouble Converts value into doubles or returns 0 when conversion is not possible.\nSee ToDoubleWithDefault\n ToDouble(value interface{}) float64\n  value: interface{} - value to convert. returns: float64 - double value or 0 when conversion is not supported.  ToDoubleWithDefault Converts value into integer or returns default value when conversion is not possible.\n ToDoubleWithDefault(value interface{}, defaultValue float64) float64\n  value: interface{} - value to convert. defaultValue: float64 - default value. returns: float64 - double value or default when conversion is not supported.  ToNullableDouble Converts value into doubles or returns nil when conversion is not possible.\n ToNullableDouble(value interface{}) *float64\n  value: interface{} - value to convert. returns: *float64 - double value or nil when conversion is not supported.  Examples value1 := convert.DoubleConverter.ToNullableDouble(\u0026#34;ABC\u0026#34;) value2 := convert.DoubleConverter.ToNullableDouble(\u0026#34;123.456\u0026#34;) value3 := convert.DoubleConverter.ToNullableDouble(true) value4 := convert.DoubleConverter.ToNullableDouble(time.Now()) fmt.Println(value1) // \u0026lt;nil\u0026gt; fmt.Println(*value2) // 123.456 fmt.Println(*value3) // 1 fmt.Println(*value4) // current milliseconds (e.g. 1.566333114e+09)  ","description":"The DoubleConverter class allows you to convert arbitrary values into double using extended conversion rules.\n","image":null,"permalink":"/golang/commons/convert/double_converter/","subtitle":null,"tags":null,"title":"DoubleConverter"},{"content":"Description The DoubleConverter class allows you to convert arbitrary values into double using the following extended conversion rules:\n  Strings are converted to double values\n  DateTime: total number of milliseconds since unix epoсh\n  Boolean: 1 for true and 0 for false\n  Static methods ToDouble Converts value into doubles or returns 0 when conversion is not possible.\nSee toDoubleWithDefault\n public static double ToDouble(object value)\n  value: object - value to convert. returns: double - double value or 0 when conversion is not supported.  ToDoubleWithDefault Converts value into integer or returns default value when conversion is not possible.\n public static double ToDoubleWithDefault(object value, double defaultValue)\n  value: object - value to convert. defaultValue: double - default value. returns: double - double value or default when conversion is not supported.  ToNullableDouble Converts value into doubles or returns null when conversion is not possible.\n public static double ToNullableDouble(object value)\n  value: object - value to convert. returns: double - double value or null when conversion is not supported.  Examples var value1 = DoubleConverter.ToNullableDouble(\u0026#34;ABC\u0026#34;); // Result: null var value2 = DoubleConverter.ToNullableDouble(\u0026#34;123.456\u0026#34;); // Result: 123.456 var value3 = DoubleConverter.ToNullableDouble(true); // Result: 1 var value4 = DoubleConverter.ToNullableDouble(new Date()); // Result: current milliseconds  ","description":"The DoubleConverter class allows you to convert arbitrary values into double using extended conversion rules.\n","image":null,"permalink":"/net/commons/convert/double_converter/","subtitle":null,"tags":null,"title":"DoubleConverter"},{"content":"Description The DoubleConverter class allows you to convert arbitrary values into doubles using the following extended conversion rules:\n  Strings are converted to double values\n  DateTime: total number of milliseconds since unix epoсh\n  Boolean: 1 for true and 0 for false\n  Static methods toDouble Converts a value into a double or returns 0 when the conversion is not possible.\nSee toDoubleWithDefault\n public static toDouble(value: any): number\n  value: any - value to convert. returns: number - double value or 0 when the conversion is not supported.  toDoubleWithDefault Converts value into integer or returns default value when the conversion is not possible.\n public static toDoubleWithDefault(value: any, defaultValue: number = 0): number\n  value: any - value to convert. defaultValue: number - default value. returns: number - double value or default when the conversion is not supported.  toNullableDouble Converts a value into a double or returns null when the conversion is not possible.\n public static toNullableDouble(value: any): number\n  value: any - value to convert. returns: number - double value or null when the conversion is not supported.  Examples let value1 = DoubleConverter.toNullableDouble(\u0026#34;ABC\u0026#34;) // Returns null let value2 = DoubleConverter.toNullableDouble(\u0026#34;123.456\u0026#34;) // Returns 123.456 let value3 = DoubleConverter.toNullableDouble(True) // Returns 1 let value4 = DoubleConverter.toNullableDouble(new Date()) // Returns current milliseconds (E.g. 1619812281454)  ","description":"The DoubleConverter class allows you to convert arbitrary values into doubles using extended conversion rules.\n","image":null,"permalink":"/node/commons/convert/double_converter/","subtitle":null,"tags":null,"title":"DoubleConverter"},{"content":"Description The DoubleConverter class allows you to convert arbitrary values into double using the following extended conversion rules:\n  Strings are converted to double values\n  DateTime: total number of milliseconds since unix epoсh\n  Boolean: 1 for true and 0 for false\n  Static methods to_double Converts value into doubles or returns 0 when conversion is not possible.\nSee to_double_with_default\n static to_double(value: Any): float\n  value: Any - the value to convert. returns: float - double value or 0 when conversion is not supported.  to_double_with_default Converts value into integer or returns default value when conversion is not possible.\n static to_double_with_default(value: Any, default_value: float = 0): float\n  value: Any - the value to convert. default_value: float = None - the default value. returns: float - double value or default when conversion is not supported.  to_nullable_double Converts value into doubles or returns None when conversion is not possible.\n static to_nullable_double(value: Any): Optional[float]\n  value: Any - the value to convert. returns: Optional[float] - double value or None when conversion is not supported.  Examples value1 = DoubleConverter.to_nullable_double(\u0026#34;ABC\u0026#34;) # Returns None value2 = DoubleConverter.to_nullable_double(\u0026#34;123.456\u0026#34;) # Returns 123.456 value3 = DoubleConverter.to_nullable_double(True) # Returns 1 value4 = DoubleConverter.to_nullable_double(datetime.datetime.now()) # Returns current milliseconds (E.g. 1619812281454) ","description":"The DoubleConverter class allows you to convert arbitrary values into double using extended conversion rules.\n","image":null,"permalink":"/python/commons/convert/double_converter/","subtitle":null,"tags":null,"title":"DoubleConverter"},{"content":"Description The DurationConverter class allows you to convert arbitrary values into time.Duration values.\nMethods ToDuration Converts value into time.Duration or returns current when conversion is not possible.\n ToDuration(value interface{}) time.Duration\n  value: interface{} - value to convert. returns: time.Duration - value or current when conversion is not supported.  ToDurationWithDefault Converts value into time.Duration or returns default when conversion is not possible.\n ToDurationWithDefault(value interface{}, defaultValue time.Duration) time.Duration\n  value: interface{} - value to convert. defaultValue: time.Duration - default value. returns: time.Duration - value or default when conversion is not supported.  ToNullableDuration Converts value into time.Duration or returns nil when conversion is not possible.\n ToNullableDuration(value interface{}) *time.Duration\n  value: interface{} - value to convert. returns: *time.Duration - value or nil when conversion is not supported.  Examples value1 := convert.DurationConverter.ToNullableDuration(\u0026#34;123\u0026#34;) value2 := convert.DurationConverter.ToNullableDuration(123) value3 := convert.DurationConverter.ToNullableDuration(123 * time.Second) fmt.Println(value1) // 123ms fmt.Println(value2) // 123ms fmt.Println(value3) // 2m3s  ","description":"Converts arbitrary values into time.Duration values.\n","image":null,"permalink":"/golang/commons/convert/duration_converter-copy/","subtitle":null,"tags":null,"title":"DurationConverter"},{"content":"Implements: CachedLogger\nDescription The ElasticSearchLogger class allows you to create loggers that dump execution logs to an ElasticSearch service.\nImportant points\n Elasticsearch is a popular search index. It is often used to store and index execution logs by itself or as a part of ELK (ElasticSearch - Logstash - Kibana) stack. Authentication is not supported in this version.  Configuration parameters  level: maximum log level to capture source: source (context) name  connection(s):\n discovery_key: (optional) a key to retrieve the connection from IDiscovery protocol: connection protocol: http or https host: host name or IP address port: port number uri: resource URI or connection string with all parameters in it  options:\n interval: interval in milliseconds to save log messages (default: 10 seconds) max_cache_size: maximum number of messages stored in this cache (default: 100) index: ElasticSearch index name (default: \u0026ldquo;log\u0026rdquo;) date_format: date format used to create the index name. Eg. log-YYYYMMDD (default: \u0026ldquo;YYYYMMDD\u0026rdquo;). daily: True to create a new index every day by adding a date suffix to the index name (default: False) reconnect: reconnect timeout in milliseconds (default: 60 sec) timeout: invocation timeout in milliseconds (default: 30 sec) max_retries: maximum number of retries (default: 3) index_message: True to enable indexing for message object (default: False) include_type_name: will create using a \u0026ldquo;typed\u0026rdquo; index compatible with ElasticSearch 6.x (default: false)  References  *:discovery:*:*:1.0 - (optional) IDiscovery services *:context-info:*:*:1.0 - (optional) ContextInfo to detect the context id and specify the counter\u0026rsquo;s source.  Constructors NewElasticSearchLogger Creates a new instance of the logger.\n NewElasticSearchLogger() *ElasticSearchLogger\n Methods Close Closes the component and frees used resources.\n (c *ElasticSearchLogger) Close(correlationId string) (err error)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. returns: error - returns error if not closed  Configure Closes the component and frees used resources.\n (c *ElasticSearchLogger) Configure(config *cconf.ConfigParams)\n  config: *cconf.ConfigParams - configuration parameters to be set.  IsOpen Checks if the component is open.\n (c *ElasticSearchLogger) IsOpen() bool\n  returns: bool - True if the component is open and False otherwise.  Open Opens the component.\n (c *ElasticSearchLogger) Open(correlationId string) (err error)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. returns: error - returns error if not opened  Save Saves log messages from the cache.\n (c *ElasticSearchLogger) Save(messages []*clog.LogMessage) (err error)\n  messages: []*clog.LogMessage - list with log messages returns: error - returns error if not saved  SetReferences Sets references to dependent components.\n (c *ElasticSearchLogger) SetReferences(references cref.IReferences)\n  messages: cref.IReferences - references to locate the component dependencies.  Examples logger := NewElasticSearchLogger(); logger.Configure(cconf.NewConfigParamsFromTuples( \u0026#34;connection.protocol\u0026#34;, \u0026#34;http\u0026#34;, \u0026#34;connection.host\u0026#34;, \u0026#34;localhost\u0026#34;, \u0026#34;connection.port\u0026#34;, \u0026#34;9200\u0026#34; )); logger.Open(\u0026#34;123\u0026#34;) logger.Error(\u0026#34;123\u0026#34;, ex, \u0026#34;Error occured: %s\u0026#34;, ex.message); logger.Debug(\u0026#34;123\u0026#34;, \u0026#34;Everything is OK.\u0026#34;); ","description":"Logger that dumps execution logs to ElasticSearch service.\n","image":null,"permalink":"/golang/elasticsearch/log/elasticsearch_logger/","subtitle":null,"tags":null,"title":"ElasticSearchLogger"},{"content":"Inherits: CachedLogger, IReferenceable, IOpenable\nDescription The ElasticSearchLogger class allows you to create loggers that dump execution logs to an ElasticSearch service.\nImportant points\n Elasticsearch is a popular search index. It is often used to store and index execution logs by itself or as a part of ELK (ElasticSearch - Logstash - Kibana) stack. Authentication is not supported in this version.  Configuration parameters  level: maximum log level to capture source: source (context) name  connection(s):\n discovery_key: (optional) a key to retrieve the connection from IDiscovery protocol: connection protocol: http or https host: host name or IP address port: port number uri: resource URI or connection string with all parameters in it  options:\n interval: interval in milliseconds to save log messages (default: 10 seconds) max_cache_size: maximum number of messages stored in this cache (default: 100) index: ElasticSearch index name (default: \u0026ldquo;log\u0026rdquo;) date_format: date format used to create the index name. Eg. log-YYYYMMDD (default: \u0026ldquo;YYYYMMDD\u0026rdquo;). daily: True to create a new index every day by adding a date suffix to the index name (default: False) reconnect: reconnect timeout in milliseconds (default: 60 sec) timeout: invocation timeout in milliseconds (default: 30 sec) max_retries: maximum number of retries (default: 3) index_message: True to enable indexing for message object (default: False) include_type_name: will create using a \u0026ldquo;typed\u0026rdquo; index compatible with ElasticSearch 6.x (default: false)  References  *:discovery:*:*:1.0 - (optional) IDiscovery services *:context-info:*:*:1.0 - (optional) ContextInfo to detect the context id and specify the counter\u0026rsquo;s source.  Constructors Creates a new instance of the logger.\n public ElasticSearchLogger()\n Instance methods Close Closes the component and frees used resources.\n public Task CloseAsync(string correlationId)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain.  Configure Closes the component and frees used resources.\n public override void Configure(ConfigParams config)\n  config: ConfigParams - configuration parameters to be set.  IsOpen Checks if the component is open.\n public bool IsOpen()\n  returns: bool - True if the component is open and False otherwise.  Open Opens the component.\n public Task OpenAsync(string correlationId)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain.  Save Saves log messages from the cache.\n protected override void Save(List\u0026lt;LogMessage\u0026gt; messages)\n  messages: List\u0026lt;LogMessage\u0026gt; - list with log messages  SetReferences Sets references to dependent components.\n public override void SetReferences(IReferences references)\n  messages: IReferences - references to locate the component dependencies.  Write Writes a log message to the logger destination.\n protected override void Write(LogLevel level, string correlationId, Exception error, string message)\n  level: [LogLevel](../../../components/log/log_level - a log level. correlationId: string - (optional) transaction id to trace execution through call chain. error: Exception - an error object associated with this message. message: string - a human-readable message to log.  Examples var logger = new ElasticSearchLogger(); logger.Configure(ConfigParams.FromTuples( \u0026#34;connection.protocol\u0026#34;, \u0026#34;http\u0026#34;, \u0026#34;connection.host\u0026#34;, \u0026#34;localhost\u0026#34;, \u0026#34;connection.port\u0026#34;, 9200 )); logger.Open(\u0026#34;123\u0026#34;); logger.Error(\u0026#34;123\u0026#34;, ex, \u0026#34;Error occured: %s\u0026#34;, ex.message); logger.Debug(\u0026#34;123\u0026#34;, \u0026#34;Everything is OK.\u0026#34;); ","description":"Logger that dumps execution logs to ElasticSearch service.\n","image":null,"permalink":"/net/elasticsearch/log/elasticsearch_logger/","subtitle":null,"tags":null,"title":"ElasticSearchLogger"},{"content":"Implements: CachedLogger, IReferenceable, IOpenable\nDescription The ElasticSearchLogger class allows you to create loggers that dump execution logs to an ElasticSearch service.\nImportant points\n Elasticsearch is a popular search index. It is often used to store and index execution logs by itself or as a part of ELK (ElasticSearch - Logstash - Kibana) stack. Authentication is not supported in this version.  Configuration parameters  level: maximum log level to capture source: source (context) name  connection(s):\n discovery_key: (optional) a key to retrieve the connection from IDiscovery protocol: connection protocol: http or https host: host name or IP address port: port number uri: resource URI or connection string with all parameters in it  options:\n interval: interval in milliseconds to save log messages (default: 10 seconds) max_cache_size: maximum number of messages stored in this cache (default: 100) index: ElasticSearch index name (default: \u0026ldquo;log\u0026rdquo;) date_format: date format used to create the index name. Eg. log-YYYYMMDD (default: \u0026ldquo;YYYYMMDD\u0026rdquo;). daily: True to create a new index every day by adding a date suffix to the index name (default: False) reconnect: reconnect timeout in milliseconds (default: 60 sec) timeout: invocation timeout in milliseconds (default: 30 sec) max_retries: maximum number of retries (default: 3) index_message: True to enable indexing for message object (default: False) include_type_name: will create using a \u0026ldquo;typed\u0026rdquo; index compatible with ElasticSearch 6.x (default: false)  References  *:discovery:*:*:1.0 - (optional) IDiscovery services *:context-info:*:*:1.0 - (optional) ContextInfo to detect the context id and specify the counter\u0026rsquo;s source.  Constructors Creates a new instance of the logger.\n public constructor()\n Instance methods close Closes the component and frees used resources.\n public close(correlationId: string): Promise\u0026lt;void\u0026gt;\n  correlationId: string - (optional) transaction id used to trace execution through the call chain.  configure Closes the component and frees used resources.\n public configure(config: ConfigParams): void\n  config: ConfigParams - configuration parameters to be set.  isOpen Checks if the component is open.\n public isOpen(): boolean\n  returns: boolean - True if the component is open and False otherwise.  open Opens the component.\n public open(correlationId: string): Promise\u0026lt;void\u0026gt;\n  correlationId: string - (optional) transaction id used to trace execution through the call chain.  _save Saves log messages from the cache.\n protected save(messages: LogMessage[]): Promise\u0026lt;void\u0026gt;\n  messages: LogMessage[] - list with log messages  setReferences Sets references to dependent components.\n setReferences(references: IReferences): void\n  messages: IReferences - references to locate the component dependencies.  Examples let logger = new ElasticSearchLogger(); logger.configure(ConfigParams.fromTuples( \u0026#34;connection.protocol\u0026#34;, \u0026#34;http\u0026#34;, \u0026#34;connection.host\u0026#34;, \u0026#34;localhost\u0026#34;, \u0026#34;connection.port\u0026#34;, 9200 )); await logger.open(\u0026#34;123\u0026#34;); logger.error(\u0026#34;123\u0026#34;, ex, \u0026#34;Error occured: %s\u0026#34;, ex.message); logger.debug(\u0026#34;123\u0026#34;, \u0026#34;Everything is OK.\u0026#34;); ","description":"Logger that dumps execution logs to ElasticSearch service.\n","image":null,"permalink":"/node/elasticsearch/log/elasticsearch_logger/","subtitle":null,"tags":null,"title":"ElasticSearchLogger"},{"content":"Implements: CachedLogger, IReferenceable, IOpenable\nDescription The ElasticSearchLogger class allows you to create loggers that dump execution logs to an ElasticSearch service.\nImportant points\n Elasticsearch is a popular search index. It is often used to store and index execution logs by itself or as a part of ELK (ElasticSearch - Logstash - Kibana) stack. Authentication is not supported in this version.  Configuration parameters  level: maximum log level to capture source: source (context) name  connection(s):\n discovery_key: (optional) a key to retrieve the connection from IDiscovery protocol: connection protocol: http or https host: host name or IP address port: port number uri: resource URI or connection string with all parameters in it  options:\n interval: interval in milliseconds to save log messages (default: 10 seconds) max_cache_size: maximum number of messages stored in this cache (default: 100) index: ElasticSearch index name (default: \u0026ldquo;log\u0026rdquo;) date_format: date format used to create the index name. Eg. log-YYYYMMDD (default: \u0026ldquo;YYYYMMDD\u0026rdquo;). daily: True to create a new index every day by adding a date suffix to the index name (default: False) reconnect: reconnect timeout in milliseconds (default: 60 sec) timeout: invocation timeout in milliseconds (default: 30 sec) max_retries: maximum number of retries (default: 3) index_message: True to enable indexing for message object (default: False) include_type_name: will create using a \u0026ldquo;typed\u0026rdquo; index compatible with ElasticSearch 6.x (default: false)  References  *:discovery:*:*:1.0 - (optional) IDiscovery services *:context-info:*:*:1.0 - (optional) ContextInfo to detect the context id and specify the counter\u0026rsquo;s source.  Constructors Creates a new instance of the logger.\n ElasticSearchLogger()\n Instance methods close Closes the component and frees used resources.\n close(correlation_id: Optional[str])\n  correlation_id: Optional[str] - (optional) transaction id used to trace execution through the call chain.  configure Closes the component and frees used resources.\n configure(config: ConfigParams)\n  config: ConfigParams - configuration parameters to be set.  is_open Checks if the component is open.\n is_open(): bool\n  returns: bool - True if the component is open and False otherwise.  open Opens the component.\n open(correlation_id: Optional[str])\n  correlation_id: Optional[str] - (optional) transaction id used to trace execution through the call chain.  _save Saves log messages from the cache.\n _save(messages: List[LogMessage])\n  messages: List[LogMessage] - list with log messages  set_references Sets references to dependent components.\n set_references(references: IReferences)\n  messages: List[LogMessage] - references to locate the component\u0026rsquo;s dependencies.  Examples logger = new ElasticSearchLogger() logger.configure(ConfigParams.from_tuples( \u0026#34;connection.protocol\u0026#34;, \u0026#34;http\u0026#34;, \u0026#34;connection.host\u0026#34;, \u0026#34;localhost\u0026#34;, \u0026#34;connection.port\u0026#34;, 9200 )) try: logger.open(\u0026#34;123\u0026#34;) except Exception as err: logger.error(\u0026#34;123\u0026#34;, err, \u0026#34;Error occured: {}\u0026#34;, err.message) # do something logger.debug(\u0026#34;123\u0026#34;, \u0026#34;Everything is OK.\u0026#34;); ","description":"Logger that dumps execution logs to ElasticSearch service.\n","image":null,"permalink":"/python/elasticsearch/log/elasticsearch_logger/","subtitle":null,"tags":null,"title":"ElasticSearchLogger"},{"content":"Email delivery microservice, it sends emails to specified recipients.\n Server implementations: NodeJS, Dart Communication protocols: Direct, Commandable HTTP, Commandable GRPC, GRPC Persistence: Memory, Flat Files, MongoDB, Couchbase Deployment options: Monolith, Process, Docker, AWS Lambda Client implementations: NodeJS, .NET, Golang, Dart  ","description":null,"image":null,"permalink":"/microservices/infrastructure/email_delivery/","subtitle":null,"tags":null,"title":"Email Delivery Microservice"},{"content":"Keeps settings of email recipients.\n Server implementations: NodeJS, Dart Communication protocols: Direct, Commandable HTTP, Commandable GRPC, GRPC Persistence: Memory, Flat Files, MongoDB, Couchbase Deployment options: Monolith, Process, Docker, AWS Lambda Client implementations: NodeJS, Golang, Dart  This microservice has optional dependencies on the following microservices:\n Party activities - to log user activities Message Templates - to get message templates Email Delivery - to send email messages  ","description":null,"image":null,"permalink":"/microservices/users/email_settings/","subtitle":null,"tags":null,"title":"Email Settings Microservice"},{"content":"Description Tje EnumConverter allows you to convert objects to Enums\nStatic methods ToEnum Converts an object to an Enum.\n public static T ToEnum\u0026lt;T\u0026gt;(object value)\n  value: object - object to be converted returns: T - returned Enum  ToEnumWithDefault Converts an object to an Enum or returns a given default value when the conversion is not possible. .\n public static T ToEnumWithDefault\u0026lt;T\u0026gt;(object value, T defaultValue)\n  value: object - object to be converted defaultValue: T - default value returns: T - returned Enum or given default whe the conversion is not possible.  ToNullableEnum Converts an object to an Enum or returns null when the conversion is not possible..\n public static T ToNullableEnum\u0026lt;T\u0026gt;(object value)\n  value: object - value to be converted returns: T - returned Enum or null when the conversion is not possible  ","description":"Converts objects to Enums.\n","image":null,"permalink":"/net/commons/convert/enum_converter/","subtitle":null,"tags":null,"title":"EnumConverter"},{"content":"Description The ErrorCategory defines the 12 standard error categories supported by the PipServices toolkit.\nConstants Unknown Unknown or unexpected errors.\n Unknown: string = \u0026ldquo;Unknown\u0026rdquo;\n Internal Internal errors caused by programming mistakes.\n Internal: string = \u0026ldquo;Internal\u0026rdquo;\n Misconfiguration Errors related to mistakes in user-defined configurations.\n Misconfiguration: string = \u0026ldquo;Misconfiguration\u0026rdquo;\n InvalidState Errors caused by an incorrect object state.. For example: business calls when the component is not ready.\n InvalidState: string = \u0026ldquo;InvalidState\u0026rdquo;\n NoResponse Errors caused by remote calls timed out and not returning results. It allows to clearly separate communication related problems from other application errors.\n NoResponse: string = \u0026ldquo;NoResponse\u0026rdquo;\n FailedInvocation Errors caused by remote calls failed due to unidenfied reasons.\n FailedInvocation: string = \u0026ldquo;FailedInvocation\u0026rdquo;\n FileError Errors in read/write local disk operations.\n FileError: string = \u0026ldquo;FileError\u0026rdquo;\n BadRequest Errors due to incorrectly specified invocation parameters. For example: missing or incorrect parameters.\n BadRequest: string = \u0026ldquo;BadRequest\u0026rdquo;\n Unauthorized Access errors caused by missing user identity (authentication error) or incorrect security permissions (authorization error).\n Unauthorized: string = \u0026ldquo;Unauthorized\u0026rdquo;\n NotFound Errors caused by attempts to access missing objects.\n NotFound: string = \u0026ldquo;NotFound\u0026rdquo;\n Conflict Errors raised by conflicts between object versions that were posted by the user and those that are stored on the server.\n Conflict: string = \u0026ldquo;Conflict\u0026rdquo;\n Unsupported Errors caused by calls to unsupported or not yet implemented functionality.\n Unsupported: string = \u0026ldquo;Unsupported\u0026rdquo;\n  ","description":"Defines the 12 standard error categories supported by the PipServices toolkit.\n","image":null,"permalink":"/golang/commons/errors/error_category/","subtitle":null,"tags":null,"title":"ErrorCategory"},{"content":"Description The ErrorCategory class defines the 12 standard error categories supported by the PipServices toolkit.\nFields Unknown Unknown or unexpected errors.\n public const Unknown: string = \u0026ldquo;Unknown\u0026rdquo;\n Internal Internal errors caused by programming mistakes.\n public const Internal: string = \u0026ldquo;Internal\u0026rdquo;\n Misconfiguration Errors related to mistakes in user-defined configurations.\n public const Misconfiguration: string = \u0026ldquo;Misconfiguration\u0026rdquo;\n InvalidState Errors caused by an incorrect object state. For example: business calls when the component is not ready.\n public const InvalidState: string = \u0026ldquo;InvalidState\u0026rdquo;\n NoResponse Errors caused by remote calls timeouted and not returning results. It allows to clearly separate communication related problems from other application errors.\n public const NoResponse: string = \u0026ldquo;NoResponse\u0026rdquo;\n FailedInvocation Errors caused by remote calls that failed due to unidenfied reasons.\n public const FailedInvocation: string = \u0026ldquo;FailedInvocation\u0026rdquo;\n FileError Errors in read/write local disk operations.\n public const NoFileAccess: string = \u0026ldquo;NoFileAccess\u0026rdquo;\n BadRequest Errors due to incorrectly specified invocation parameters. For example: missing or incorrect parameters.\n public const BadRequest: string = \u0026ldquo;BadRequest\u0026rdquo;\n Unauthorized Access errors caused by missing user identity (authentication error) or incorrect security permissions (authorization error).\n public const Unauthorized: string = \u0026ldquo;Unauthorized\u0026rdquo;\n NotFound Errors caused by attempts to access missing objects.\n public const NotFound: string = \u0026ldquo;NotFound\u0026rdquo;\n Conflict Errors raised by conflicts between object versions that were posted by the user and those that are stored on the server.\n public const Conflict: string = \u0026ldquo;Conflict\u0026rdquo;\n Unsupported Errors caused by calls to unsupported or not yet implemented functionality.\n public const Unsupported = \u0026ldquo;Unsupported\u0026rdquo;\n  ","description":"Defines the 12 standard error categories supported by the PipServices toolkit.\n","image":null,"permalink":"/net/commons/errors/error_category/","subtitle":null,"tags":null,"title":"ErrorCategory"},{"content":"Description The ErrorCategory class defines the 12 standard error categories supported by the PipServices toolkit.\nFields Unknown Unknown or unexpected errors.\n public static Unknown: string = \u0026ldquo;Unknown\u0026rdquo;\n Internal Internal errors caused by programming mistakes.\n public static Internal: string = \u0026ldquo;Internal\u0026rdquo;\n Misconfiguration Errors related to mistakes in user-defined configurations.\n public static Misconfiguration: string = \u0026ldquo;Misconfiguration\u0026rdquo;\n InvalidState Errors caused by incorrect object state.. For example: business calls when the component is not ready.\n public static InvalidState: string = \u0026ldquo;InvalidState\u0026rdquo;\n NoResponse Errors caused by remote calls timeouted and not returning results. It allows to clearly separate communication related problems from other application errors.\n public static NoResponse: string = \u0026ldquo;NoResponse\u0026rdquo;\n FailedInvocation Errors caused by remote calls failed due to unidenfied reasons.\n public static FailedInvocation: string = \u0026ldquo;FailedInvocation\u0026rdquo;\n FileError Errors in read/write local disk operations.\n public static FileError: string = \u0026ldquo;FileError\u0026rdquo;\n BadRequest Errors due to incorrectly specified invocation parameters. For example: missing or incorrect parameters.\n public static BadRequest: string = \u0026ldquo;BadRequest\u0026rdquo;\n Unauthorized Access errors caused by missing user identity (authentication error) or incorrect security permissions (authorization error).\n public static Unauthorized: string = \u0026ldquo;Unauthorized\u0026rdquo;\n NotFound Errors caused by attempts to access missing objects.\n public static NotFound: string = \u0026ldquo;NotFound\u0026rdquo;\n Conflict Errors raised by conflicts between object versions that were posted by the user and those that are stored on the server.\n public static Conflict: string = \u0026ldquo;Conflict\u0026rdquo;\n Unsupported Errors caused by calls to unsupported or not yet implemented functionality.\n public static Unsupported: string = \u0026ldquo;Unsupported\u0026rdquo;\n  ","description":"Defines the 12 standard error categories supported by the PipServices toolkit.\n","image":null,"permalink":"/node/commons/errors/error_category/","subtitle":null,"tags":null,"title":"ErrorCategory"},{"content":"Description The ErrorCategory class defines the 12 standard error categories supported by the PipServices toolkit.\nFields Unknown Unknown or unexpected errors.\n static Unknown: str = \u0026ldquo;Unknown\u0026rdquo;\n Internal Internal errors caused by programming mistakes.\n static Internal: str = \u0026ldquo;Internal\u0026rdquo;\n Misconfiguration Errors related to mistakes in user-defined configurations.\n static Misconfiguration: str = \u0026ldquo;Misconfiguration\u0026rdquo;\n InvalidState Errors caused by incorrect object state. For example: business calls when the component is not ready.\n static InvalidState: str = \u0026ldquo;InvalidState\u0026rdquo;\n NoResponse Errors caused by remote calls timeouted and not returning results. It allows to clearly separate communication related problems from other application errors.\n static NoResponse: str = \u0026ldquo;NoResponse\u0026rdquo;\n FailedInvocation Errors caused by remote calls failed due to unidenfied reasons.\n static FailedInvocation: str = \u0026ldquo;FailedInvocation\u0026rdquo;\n FileError Errors in read/write local disk operations.\n static FileError: str = \u0026ldquo;FileError\u0026rdquo;\n BadRequest Errors due to incorrectly specified invocation parameters. For example: missing or incorrect parameters.\n static BadRequest: str = \u0026ldquo;BadRequest\u0026rdquo;\n Unauthorized Access errors caused by missing user identity (authentication error) or incorrect security permissions (authorization error).\n static Unauthorized: str = \u0026ldquo;Unauthorized\u0026rdquo;\n NotFound Errors caused by attempts to access missing objects.\n static NotFound: str = \u0026ldquo;NotFound\u0026rdquo;\n Conflict Errors raised by conflicts between object versions that were posted by the user and those that are stored on the server.\n static Conflict: str = \u0026ldquo;Conflict\u0026rdquo;\n Unsupported Errors caused by calls to unsupported or not yet implemented functionality.\n static Unsupported: str = \u0026ldquo;Unsupported\u0026rdquo;\n  ","description":"Defines the 12 standard error categories supported by the PipServices toolkit.\n","image":null,"permalink":"/python/commons/errors/error_category/","subtitle":null,"tags":null,"title":"ErrorCategory"},{"content":"Description The ErrorDescription class is used to pass information about errors between microservices implemented in different languages. On the receiving side ErrorDescription is used to recreate the exception object close to its original type without missing additional details. This class is serializeable.\nFields Type Data type of the original error\n Type: string\n Category Standard error category\n Category: string\n Status HTTP status code associated with this error type\n Status: int\n Code A unique error code\n Code: string\n Message A human-readable error description (usually written in English)\n Message: string\n Details Map with additional details that can be used to restore error description in other languages\n Details: map[string]interface{}\n CorrelationId Unique transaction id used to trace execution through the call chain\n CorrelationId: string\n Cause Original error wrapped by this exception\n Cause: string\n StackTrace Stack trace of the exception\n StackTrace: string\n  See also   ApplicationException   ApplicationExceptionFactory   ","description":"Class used to pass information about errors between microservices implemented in different languages. On the receiving side [ErrorDescription]() is used to recreate the exception object close to its original type without missing additional details.\n","image":null,"permalink":"/golang/commons/errors/error_description/","subtitle":null,"tags":null,"title":"ErrorDescription"},{"content":"Description The ErrorDescription class is used to pass information about errors between microservices implemented in different languages. On the receiving side ErrorDescription is used to recreate the exception object close to its original type without missing additional details. This class is serializeable.\nProperties Type Data type of the original error.\n public string Type { get; set; }\n Category Standard error category.\n public string Category { get; set; }\n Status HTTP status code associated with this error type.\n public int Status { get; set; }\n Code A unique error code.\n public string Code { get; set; }\n Message A human-readable error description (usually written in English).\n public string Message { get; set; }\n Details Map with additional details that can be used to restore an error description in other languages.\n public StringValueMap Details { get; set; }\n CorrelationId A unique transaction id to trace execution throug call chain.\n public string CorrelationId { get; set; }\n Cause Original error wrapped by this exception.\n public string Cause { get; set; }\n StackTrace Stack trace of the exception.\n public string StackTrace { get; set; }\n See also   ApplicationException   ApplicationExceptionFactory   ","description":"Class used to pass information about errors between microservices implemented in different languages. On the receiving side [ErrorDescription]() is used to recreate the exception object close to its original type without missing additional details.\n","image":null,"permalink":"/net/commons/errors/error_description/","subtitle":null,"tags":null,"title":"ErrorDescription"},{"content":"Description The ErrorDescription class is used to pass information about errors between microservices implemented in different languages. On the receiving side ErrorDescription is used to recreate the exception object close to its original type without missing additional details. This class is serializeable.\nFields type Data type of the original error.\n public type: string\n category Standard error category.\n public category: string\n status HTTP status code associated with this error type.\n public status: number\n code Unique error code.\n public code: string\n message A human-readable error description (usually written in English).\n public message: string\n details A map with additional details that can be used to restore error description in other languages.\n public details: any\n correlation_id Unique transaction id used to trace execution through a call chain\n public correlation_id: string\n cause Original error wrapped by this exception.\n public cause: string\n stack_trace Stack trace of the exception.\n public stack_trace: string\n  See also   ApplicationException   ApplicationExceptionFactory   ","description":"Class used to pass information about errors between microservices implemented in different languages. On the receiving side [ErrorDescription]() is used to recreate the exception object close to its original type without missing additional details.\n","image":null,"permalink":"/node/commons/errors/error_description/","subtitle":null,"tags":null,"title":"ErrorDescription"},{"content":"Description The ErrorDescription class is used to pass information about errors between microservices implemented in different languages. On the receiving side ErrorDescription is used to recreate the exception object close to its original type without missing additional details. This class is serializeable.\nFields type Data type of the original error\n type: str\n category Standard error category\n category: str\n status HTTP status code associated with this error type\n status: number\n code A unique error code\n code: str\n message A human-readable error description (usually written in English)\n message: str\n details A map with additional details that can be used to restore error description in other languages\n details: Any\n correlation_id A unique transaction id to trace execution throug call chain\n correlation_id: Optional[str]\n cause Original error wrapped by this exception\n cause: str\n stack_trace Stack trace of the exception\n stack_trace: str\n  See also   ApplicationException   ApplicationExceptionFactory   ","description":"Class used to pass information about errors between microservices implemented in different languages. On the receiving side [ErrorDescription]() is used to recreate the exception object close to its original type without missing additional details.\n","image":null,"permalink":"/python/commons/errors/error_description/","subtitle":null,"tags":null,"title":"ErrorDescription"},{"content":"Description The ErrorDescriptionFactory class provides a factory to create a serializeable ErrorDescription from ApplicationError or from arbitrary errors.\nImportant points\n Error descriptions are used to pass errors through the wire between microservices implemented in different languages. They allow to restore exceptions on the receiving side close to the original type and preserve additional information.  Methods Create Creates a serializable ErrorDescription from error object.\n (c *TErrorDescriptionFactory) Create(err interface{}) *ErrorDescription\n  error: interface{} - error object returns: *ErrorDescription - serializeable ErrorDescription object that describes the error.  See also   ApplicationError   ErrorDescription   ","description":"Factory used to create a serializeable [ErrorDescription](../error_description) from [ApplicationError](../application_error) or from arbitrary errors.  \n","image":null,"permalink":"/golang/commons/errors/error_description_factory/","subtitle":null,"tags":null,"title":"ErrorDescriptionFactory"},{"content":"Description The ErrorDescriptionFactory class provides a factory to create a serializeable ErrorDescription from ApplicationException or from arbitrary errors.\nImportant points\n Error descriptions are used to pass errors through the wire between microservices implemented in different languages. They allow to restore exceptions on the receiving side close to the original type and preserve additional information.  Static methods Create Creates a serializable ErrorDescription from an error object.\n public static ErrorDescription Create(ApplicationException error)\n  error: ApplicationException - error object returns: ErrorDescription - serializeable ErrorDescription object that describes the error.  Create Creates a serializable ErrorDescription from a throwable object with an unknown error category.\n public static ErrorDescription Create(Exception ex, string correlationId = null)\n  ex: Exception - error object correlationId: string - (optional) unique transaction id used to trace execution through the call chain. returns: ErrorDescription - serializeable ErrorDescription object that describes the error.  See also   ApplicationException   ErrorDescription   ","description":"Factory used to create a serializeable [ErrorDescription](../error_description) from [ApplicationException](../application_exception) or from arbitrary errors.  \n","image":null,"permalink":"/net/commons/errors/error_description_factory/","subtitle":null,"tags":null,"title":"ErrorDescriptionFactory"},{"content":"Description The ErrorDescriptionFactory class provides a factory to create a serializeable ErrorDescription from ApplicationException or from arbitrary errors.\nImportant points\n Error descriptions are used to pass errors through the wire between microservices implemented in different languages. They allow to restore exceptions on the receiving side close to the original type and preserve additional information.  Static methods create Creates a serializable ErrorDescription from n error object.\n public static create(error: any): ErrorDescription\n  error: any - error object returns: ErrorDescription - serializeable ErrorDescription object that describes the error.  See also   ApplicationException   ErrorDescription   ","description":"Factory used to create a serializeable [ErrorDescription](../error_description) from [ApplicationException](../application_exception) or from arbitrary errors.  \n","image":null,"permalink":"/node/commons/errors/error_description_factory/","subtitle":null,"tags":null,"title":"ErrorDescriptionFactory"},{"content":"Description The ErrorDescriptionFactory class provides a factory to create a serializeable ErrorDescription from ApplicationException or from arbitrary errors.\nImportant points\n Error descriptions are used to pass errors through the wire between microservices implemented in different languages. They allow to restore exceptions on the receiving side close to the original type and preserve additional information.  Static methods create Creates a serializable ErrorDescription from error object.\n static create(error: Any): ErrorDescription\n  error: Any - an error object returns: ErrorDescription - a serializeable ErrorDescription object that describes the error.  See also   ApplicationException   ErrorDescription   ","description":"Factory used to create a serializeable [ErrorDescription](../error_description) from [ApplicationException](../application_exception) or from arbitrary errors.  \n","image":null,"permalink":"/python/commons/errors/error_description_factory/","subtitle":null,"tags":null,"title":"ErrorDescriptionFactory"},{"content":"Description The Event class allows you to create events.\nImportant points\n It allows you to send asynchronous notifications to multiple subscribed listeners.  Constructors NewEvent Creates a new event and assigns its name.\nThrows an Error if the name is nil.\n NewEvent(name string) *Event\n  name: string - name of the event that is to be created.  Methods AddListener Adds a listener to receive notifications when this event is fired.\n (c *Event) AddListener(listener IEventListener)\n  listener: IEventListener - listener\u0026rsquo;s reference to add.  Listeners Gets all listeners registred in this event.\n (c *Event) Listeners() []IEventListener\n  returns: []IEventListener - list of listeners.  Name Gets the name of the event.\n (c *Event) Name() string\n  returns: string - name of the event.  Notify Fires this event and notifies all registred listeners.\nThrows an InvocationException if the event fails to be raised.\n (c *Event) Notify(correlationId string, args *run.Parameters)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. args: *run.Parameters - parameters to raise this event with.  RemoveListener Removes a listener, so that it no longer receives notifications for this event.\n (c *Event) RemoveListener(listener IEventListener)\n  listener: IEventListener - listener reference to remove.  Example:\nevent: = NewEvent(\u0026#34;my_event\u0026#34;); event.AddListener(myListener); event.Notify(\u0026#34;123\u0026#34;, Parameters.fromTuples( \u0026#34;param1\u0026#34;, \u0026#34;ABC\u0026#34;, \u0026#34;param2\u0026#34;, 123 )); See also   IEvent   IEventListener   ","description":"Concrete implementation of the [IEvent](../ievent) interface.\n","image":null,"permalink":"/golang/commons/commands/event/","subtitle":null,"tags":null,"title":"Event"},{"content":"Inherits: IEvent\nDescription The Event class allows you to create events.\nImportant points\n It allows you to send asynchronous notifications to multiple subscribed listeners.  Constructors Creates a new event and assigns its name.\nThrows an Error if the name is null.\n public Event(string name)\n  name: string - the name of the event that is to be created.  Properties Name Gets the name of the event.\n public string Name { get; }\n Listeners Gets all listeners registered in this event.\n public List\u0026lt;IEventListener\u0026gt; Listeners { get; }\n Instance methods AddListener Adds a listener to receive notifications when this event is fired.\n public void AddListener(IEventListener listener)\n  listener: IEventListener - listener\u0026rsquo;s reference to add.  NotifyAsync Fires this event and notifies all registred listeners.\nThrows an InvocationException if the event fails to be raised.\n public void NotifyAsync(string correlationId, Parameters args)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. args: Parameters - parameters to raise this event with.  RemoveListener Removes a listener, so that it no longer receives notifications for this event.\n public void RemoveListener(IEventListener listener)\n  listener: IEventListener - listener\u0026rsquo;s reference to remove.  Example:\nvar event = new Event(\u0026#34;my_event\u0026#34;); event.addListener(myListener); event.notify(\u0026#34;123\u0026#34;, Parameters.FromTuples( \u0026#34;param1\u0026#34;, \u0026#34;ABC\u0026#34;, \u0026lt;br\u0026gt;\u0026#34;param2\u0026#34;, 123 )); See also   IEvent   IEventListener   ","description":"Concrete implementation of the [IEvent](../ievent) interface.\n","image":null,"permalink":"/net/commons/commands/event/","subtitle":null,"tags":null,"title":"Event"},{"content":"Implements: IEvent\nDescription The Event class allows you to create events.\nImportant points\n It allows you to send asynchronous notifications to multiple subscribed listeners.  Constructors Creates a new event and assigns its name.\nThrows an Error if the name is null.\n public constructor(name: string)\n  name: string - name of the event that is to be created.  Instance methods addListener Adds a listener to receive notifications when this event is fired.\n public addListener(listener: IEventListener): void\n  listener: IEventListener - listener reference to add.  getListeners Gets all listeners registred in this event.\n public getListeners(): IEventListener[]\n  returns: IEventListener[] - list of listeners.  getName Gets the name of the event.\n public getName(): string\n  returns: string - name of this event.  notify Fires this event and notifies all registred listeners.\nThrows an InvocationException if the event fails to be raised.\n publicnotify(correlationId: string, args: Parameters): void\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. args: Parameters - parameters to raise this event with.  removeListener Removes a listener, so that it no longer receives notifications for this event.\n public removeListener(listener: IEventListener): void\n  listener: IEventListener - listener reference to remove.  Example:\nlet event = new Event(\u0026#34;my_event\u0026#34;); event.addListener(myListener); * event.notify(\u0026#34;123\u0026#34;, Parameters.fromTuples( \u0026#34;param1\u0026#34;, \u0026#34;ABC\u0026#34;, \u0026#34;param2\u0026#34;, 123 )); See also   IEvent   IEventListener   ","description":"Concrete implementation of the [IEvent](../ievent) interface.\n","image":null,"permalink":"/node/commons/commands/event/","subtitle":null,"tags":null,"title":"Event"},{"content":"Implements: IEvent\nDescription The Event class allows you to create events.\nImportant points\n It allows you to send asynchronous notifications to multiple subscribed listeners.  Constructors Creates a new event and assigns its name.\nThrows an Error if the name is None.\n Event(name: str)\n  name: str - the name of the event that is to be created.  Instance methods add_listener Adds a listener to receive notifications when this event is fired.\n add_listener(listener: IEventListener)\n  listener: IEventListener - the listener reference to add.  get_listeners Gets all listeners registred in this event.\n getListeners(): List[IEventListener]\n  returns: List[IEventListener] - a list of listeners.  get_name Gets the name of the event.\n get_name(): str\n  returns: str - the name of this event.  notify Fires this event and notifies all registred listeners.\nThrows an InvocationException if the event fails to be raised.\n notify(correlation_id: Optional[str], args: Parameters)\n  correlation_id: Optional[str] - (optional) transaction id to trace execution through call chain. args: Parameters - the parameters to raise this event with.  remove_listener Removes a listener, so that it no longer receives notifications for this event.\n removeListener(listener: IEventListener)\n  listener: IEventListener - the listener reference to remove.  Example:\nevent_name = Event(\u0026#34;my_event\u0026#34;) event_name.add_listener(myListener) event_name.notify(\u0026#34;123\u0026#34;, Parameters.from_tuples(\u0026#34;param1\u0026#34;, \u0026#34;ABC\u0026#34;, \u0026#34;param2\u0026#34;, 123) See also   IEvent   IEventListener   ","description":"Concrete implementation of the [IEvent](../ievent) interface.\n","image":null,"permalink":"/python/commons/commands/event/","subtitle":null,"tags":null,"title":"Event"},{"content":"Processes and generates events for tracking objects based on their state\n Server implementations: NodeJS Communication protocols: Direct, Commandable HTTP, Commandable GRPC, GRPC Persistence: Memory, Flat Files, MongoDB, Couchbase Deployment options: Monolith, Process, Docker, AWS Lambda Client implementations: NodeJS  ","description":null,"image":null,"permalink":"/microservices/iot/event_generation/","subtitle":null,"tags":null,"title":"Event generation Microservice"},{"content":"Logs important system events like starts and stops of servers, upgrades to a new version, fatal system errors or key business transactions.\n Server implementations: NodeJS, Dart Communication protocols: Direct, Commandable HTTP, Commandable GRPC, GRPC Persistence: Memory, Flat Files, MongoDB, Couchbase Deployment options: Monolith, Process, Docker, AWS Lambda Client implementations: NodeJS, .NET, Dart  ","description":null,"image":null,"permalink":"/microservices/infrastructure/eventlog/","subtitle":null,"tags":null,"title":"EventLog Microservice"},{"content":"Inherits: Logger\nDescription TODO: add description\nInstance methods Write Writes a log message to the logger destination(s).\n public override void Write(LogLevel level, string correlation_id, Exception error, string message)\n  level: LogLevel - a log level. correlation_id: string - (optional) transaction id to trace execution through call chain. error: Exception - an error object associated with this message. message: string - a human-readable message to log.  Examples var logger = new ConsoleLogger(); logger.SetLevel(LogLevel.debug); logger.Error(\u0026#34;123\u0026#34;, ex, \u0026#34;Error occured: %s\u0026#34;, ex.message); logger.Debug(\u0026#34;123\u0026#34;, \u0026#34;Everything is OK.\u0026#34;); See also   Logger   ","description":"TODO: add description\n","image":null,"permalink":"/net/components/log/event_logger/","subtitle":null,"tags":null,"title":"EventLogger "},{"content":"Description The ExcludedRule allows you to verify that none of the values specified in the rule is present in a list of constants.\nConstructors NewExcludedRule Creates a new validation rule and sets its values\n NewExcludedRule(values \u0026hellip;interface{}) *ExcludedRule\n  values: \u0026hellip;interface{} - list of values that must be excluded from a list of constants  Methods Validate Validates the given value. None of the values set in this ExcludedRule object must exist in the value that is given for validation to pass.\n (c *ExcludedRule) Validate(path string, schema ISchema, value interface{}) []*ValidationResult\n  path: string - dot notation path to the value that is to be validated. schema: ISchema - (not used in this implementation). value: interface{} - value that is to be validated. results: []*ValidationResult - results of the validation.  Examples schema := NewSchema() .WithRule(NewExcludedRule(1, 2, 3)); schema.Validate(2); // Result: 2 must not be one of 1, 2, 3 schema.Validate(10); // Result: no errors  See also   IValidationRule   ","description":"Validation rule to check that one or more values are excluded from the list of constants.\n","image":null,"permalink":"/golang/commons/validate/excluded_rule/","subtitle":null,"tags":null,"title":"ExcludedRule"},{"content":"Inherits: IValidationRule\nDescription The ExcludedRule allows you to verify that none of the values specified in the rule is present in a list of constants.\nConstructors Creates a new validation rule and sets its values\n public ExcludedRule(params object[] values)\n  values: object[] - list of constants that value must be excluded from  Instance methods Validate Validates the given value. None of the values set in this ExcludedRule object must exist in the value that is given for validation to pass.\n public void Validate(string path, Schema schema, object value, List\u0026lt;ValidationResult\u0026gt; results)\n  path: string - dot notation path to the value that is to be validated. schema: Schema - (not used in this implementation). value: object - value that is to be validated. results: List\u0026lt;ValidationResult\u0026gt; - results of the validation.  Examples var schema = new Schema().WithRule(new ExcludedRule(1, 2, 3)); schema.Validate(2); // Result: 2 must not be one of 1, 2, 3 schema.Validate(10); // Result: no errors  See also   IValidationRule   ","description":"Validation rule used to check that one or more values are excluded from the list of constants.\n","image":null,"permalink":"/net/commons/validate/excluded_rule/","subtitle":null,"tags":null,"title":"ExcludedRule"},{"content":"Implements: IValidationRule\nDescription The ExcludedRule allows you to verify that none of the values specified in the rule is present in a list of constants.\nConstructors Creates a new validation rule and sets its values\n public constructor(\u0026hellip;values: any[])\n  values: any[] - list of constants that value must be excluded from  Instance methods validate Validates the given value. none of the values set in this ExcludedRule object must exist in the value that is given for validation to pass.\n public validate(path: string, schema: Schema, value: any, results: ValidationResult[]): void\n  path: string - dot notation path to the value that is to be validated. schema: Schema - (not used in this implementation). value: any - value that is to be validated. results: ValidationResult[] - results of the validation.  Examples let schema = new Schema() .withRule(new ExcludedRule(1, 2, 3)); schema.validate(2); // Result: 2 must not be one of 1, 2, 3 schema.validate(10); // Result: no errors  See also   IValidationRule   ","description":"Validation rule used to check that one or more values are excluded from the list of constants.\n","image":null,"permalink":"/node/commons/validate/excluded_rule/","subtitle":null,"tags":null,"title":"ExcludedRule"},{"content":"Implements: IValidationRule\nDescription The ExcludedRule allows you to verify that none of the values specified in the rule is present in a list of constants.\nConstructors Creates a new validation rule and sets its values\n ExcludedRule(*values: Any)\n  values: Any - a list of constants that value must be excluded from  Instance methods validate Validates the given value. None of the values set in this ExcludedRule object must exist in the value that is given for validation to pass.\n validate(path: str, schema: Schema, value: Any, results: List[ValidationResult])\n  path: str - the dot notation path to the value that is to be validated. schema: Schema - (not used in this implementation). value: Any - the value that is to be validated. results: List[ValidationResult] - the results of the validation.  Examples schema = Schema().with_rule(ExcludedRule(1, 2, 3)) schema.validate(2) # Result: 2 must not be one of 1, 2, 3 schema.validate(10) # Result: no errors See also   IValidationRule   ","description":"Validation rule to check that one or more values are excluded from the list of constants.\n","image":null,"permalink":"/python/commons/validate/excluded_rule/","subtitle":null,"tags":null,"title":"ExcludedRule"},{"content":"Delegate: Task\u0026lt;object\u0026gt;\nDescription TODO add description\nConstructors  ExecutableDelegate(string correlationId, Parameters args)\n  correlationId: string - TODO add description args: Parameters - TODO add description  ","description":"TODO add description\n","image":null,"permalink":"/net/commons/commands/executable_delegate/","subtitle":null,"tags":null,"title":"ExecutableDelegate"},{"content":"Description The Executor class allows you to execute one or more components.\nMethods Execute Executes multiple components.\nTo be executed components must implement the IExecutable interface. If they don\u0026rsquo;t, the call to this method has no effect.\nSee IExecutable, Parameters\n (c *TExecutor) Execute(correlationId string, components []interface{}, args *Parameters) ([]interface{}, error)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. components: []interface{} - list of components that are to be executed. args: *Parameters - execution arguments. returns: ([]interface{}, error) - execution result  ExecuteOne Executes a specific component.\nTo be executed a component must implement the IExecutable interface. If they don\u0026rsquo;t, the call to this method has no effect.\n (c *TExecutor) ExecuteOne(correlationId string, component interface{}, args *Parameters) (interface{}, error)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. component: interface{} - component that is to be executed. args: *Parameters - execution arguments. returns: (interface{}, error) - execution result.  See also   IExecutable   ","description":"Helper class that allows you to execute one or more components.\n","image":null,"permalink":"/golang/commons/run/executor/","subtitle":null,"tags":null,"title":"Executor"},{"content":"Description The Executor class allows you to execute one or more components.\nStatic methods ExecuteAsync Executes multiple components.\nTo be executed, components must implement the IExecutable interface. If they don\u0026rsquo;t, the call to this method has no effect.\nSee IExecutable, Parameters\n public static Task\u0026lt;List\u0026lt;object\u0026gt;\u0026gt; ExecuteAsync(string correlationId, IEnumerable components, Parameters args)\n  correlationId: string - (optional) transaction id the to trace execution through the call chain. components: IEnumerable - list of components that are to be executed. args: Parameters - execution arguments. returns: Task\u0026lt;List\u0026lt;object\u0026gt;\u0026gt; - execution result  ExecuteOneAsync Executes specific component.\nTo be executed, components must implement the IExecutable interface. If they don\u0026rsquo;t, the call to this method has no effect.\n public static Task\u0026lt;object\u0026gt; ExecuteOneAsync(string correlationId, object component, Parameters args)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. component: object - component that is to be executed. args: Parameters - execution arguments. returns: Task\u0026lt;object\u0026gt; - execution result.  See also   IExecutable   ","description":"Helper class that allows you to execute one or more components.\n","image":null,"permalink":"/net/commons/run/executor/","subtitle":null,"tags":null,"title":"Executor"},{"content":"Description The Executor class allows you to execute one or more components.\nStatic methods execute Executes multiple components.\nTo be executed, components must implement the IExecutable interface. If they don\u0026rsquo;t, the call to this method has no effect.\nSee IExecutable, Parameters.\n public static execute(correlationId: string, components: any[], args: Parameters): Promise\u0026lt;any[]\u0026gt;\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. components: any[] - list of components that are to be executed. args: Parameters - execution arguments. returns: Promise\u0026lt;any[]\u0026gt; - execution result  executeOne Executes a specific component.\nTo be executed, components must implement the IExecutable interface. If they don\u0026rsquo;t, the call to this method has no effect.\n public static executeOne(correlationId: string, component: any, args: Parameters): Promise\u0026lt;any\u0026gt;\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. component: any - component that is to be executed. args: Parameters - execution arguments. returns: Promise\u0026lt;any\u0026gt; - execution result.  See also   IExecutable   ","description":"Helper class that allows you to execute one or more components.\n","image":null,"permalink":"/node/commons/run/executor/","subtitle":null,"tags":null,"title":"Executor"},{"content":"Description The Executor class allows you to execute one or more components.\nStatic methods execute Executes multiple components.\nTo be executed components must implement IExecutable interface. If they don\u0026rsquo;t, the call to this method has no effect.\nSee IExecutable, Parameters\n static execute(correlation_id: Optional[str], components: List[Any], args: Parameters)\n  correlation_id: Optional[str] - (optional) transaction id to trace execution through call chain. components: List[Any] - a list of components that are to be executed. args: Parameters - execution arguments.  execute_one Executes specific component.\nTo be executed components must implement IExecutable interface. If they don\u0026rsquo;t, the call to this method has no effect.\n static execute_one(correlation_id: Optional[str], component: Any, args: Parameters)\n  correlation_id: Optional[str] - (optional) transaction id to trace execution through call chain. component: Any - the component that is to be executed. args: Parameters - execution arguments.  See also   IExecutable   ","description":"Helper class that allows you to execute one or more components.\n","image":null,"permalink":"/python/commons/run/executor/","subtitle":null,"tags":null,"title":"Executor"},{"content":"Description The ExpressionCalculator class allows you to create an expression calculator.\nConstructors Constructs this class and assigns expression string.\n public constructor(expression?: string)\n  expression: string - expression string.  Properties autoVariables Gets the flag to turn on auto-creation of variables for a specified expression.\n public autoVariables(): boolean\n  returns: boolean - returns the flag to turn on auto-creation.  Sets the flag to turn on auto-creation of variables for specified expression.\n public autoVariables(value: boolean)\n  value: boolean - flag to turn on auto-creation.  defaultFunctions List with default functions.\n public defaultFunctions(): IFunctionCollection\n  returns: IFunctionCollection - list with default functions.  defaultVariables List with default variables.\n public defaultVariables(): IVariableCollection\n  returns: IVariableCollection - list with default variables.  expression Expression string.\n public expression(): string\n  returns: string - expression string.   public expression(value: string)\n  value: string - expression string.  initialTokens List of original expression tokens.\n public initialTokens(): ExpressionToken[]\n  returns: ExpressionToken[] - list of original expression tokens.  originalTokens List of expression tokens.\n public originalTokens(): Token[]\n  returns: Token[] - list of expression tokens.   public originalTokens(value: Token[])\n  value: Token[] - list of expression tokens.  resultTokens List of processed expression tokens.\n public resultTokens(): ExpressionToken[]\n  returns: ExpressionToken[] - list of processed expression tokens.  variantOperations Gets the manager for operations on variant values.\n public variantOperations(): IVariantOperations\n  returns: IVariantOperations - manager for operations.  Sets the manager for operations on variant values.\n public variantOperations(value: IVariantOperations)\n  value: IVariantOperations - manager for operations.  Instance methods clear Cleans up this calculator from all data.\n public clear(): void\n createVariables Cleans up this calculator from all data.\n public createVariables(variables: IVariantOperations): void\n  variables: IVariantOperations - list of variables to be populated.  evaluate Evaluates this expression using default variables and functions.\n public evaluate(): Promise\u0026lt;Variant\u0026gt;\n  returns: Promise\u0026lt;Variant\u0026gt; - evaluation result.  evaluateWithVariables Evaluates this expression using specified variables.\n public evaluateWithVariables(variables: IVariantOperations): Promise\u0026lt;Variant\u0026gt;\n  variables: IVariantOperations - list of variables. returns: Promise\u0026lt;Variant\u0026gt; - evaluation result.  evaluateWithVariablesAndFunctions Evaluates this expression using specified variables and functions.\n public evaluateWithVariablesAndFunctions(variables: IVariantOperations, functions: IFunctionCollection): Promise\u0026lt;Variant\u0026gt;\n  variables: IVariantOperations - list of variables. functions: IFunctionCollection - list of functions returns: Promise\u0026lt;Variant\u0026gt; - evaluation result.  ","description":"Implements an expression calculator.\n","image":null,"permalink":"/node/expressions/calculator/expression_calculator/","subtitle":null,"tags":null,"title":"ExpressionCalculator"},{"content":"Extends: BadRequestException\nDescription TODO: add description\nConstructors TODO: add description\n public constructor(correlationId: string, code: string, message: string, line: number = 0, column: number = 0)\n  correlationId: string - TODO: add description code: string - TODO: add description message: string - TODO: add description line: number - TODO: add description column: number - TODO: add description  ","description":"Exception that can be thrown by Expression Calculator.\n","image":null,"permalink":"/node/expressions/calculator/expression_exception/","subtitle":null,"tags":null,"title":"ExpressionException"},{"content":"Extends: GenericNumberState\nDescription The ExpressionNumberState implements an expression-specific number state object.\nFields PLUS Represents a \u0026lsquo;+\u0026rsquo; symbol.\n protected PLUS: number = \u0026lsquo;+'.charCodeAt(0)\n EXP1 Represents an \u0026lsquo;e\u0026rsquo; symbol.\n protected EXP1: number = \u0026lsquo;e\u0026rsquo;.charCodeAt(0)\n EXP2 Represents an \u0026lsquo;E\u0026rsquo; symbol.\n protected EXP2: number = \u0026lsquo;E\u0026rsquo;.charCodeAt(0)\n  Instance methods nextToken Gets the next token from the stream started from the character linked to this state.\n public nextToken(scanner: IScanner, tokenizer: ITokenizer): Token\n  scanner: IScanner - textual string to be tokenized. tokenizer: ITokenizer - tokenizer class that controls the process. returns: Token - next token from the top of the stream.  ","description":"Implements an Expression-specific number state object.\n","image":null,"permalink":"/node/expressions/calculator/tokenizers/expression_number_state/","subtitle":null,"tags":null,"title":"ExpressionNumberState"},{"content":"Description The ExpressionParser class allows you to implement an expression parser.\nProperties expression Expression string.\n public expression(): string\n  public expression(value: string)\n  value: string - expression string.  expression Expression string.\n public expression(): string\n  returns: string - expression string.   public expression(value: string)\n  value: string - expression string.  initialTokens List of original expression tokens.\n public initialTokens(): ExpressionToken[]\n  returns: ExpressionToken[] - list of expression tokens.  resultTokens List of parsed expression tokens.\n public resultTokens(): ExpressionToken[]\n  returns: ExpressionToken[] - list of expression tokens.  variableNames List of found variable names.\n public variableNames(): string[]\n  returns: string[] - list of found variable names.  Instance methods clear Clears parsing results.\n public clear(): void\n parseString Sets a new expression string and parses it into internal byte code.\n public parseString(expression: string): void\n  expression: string - new expression string.  parseTokens Parses a given token.\n public parseTokens(tokens: Token[]): void\n  tokens: Token[] - token to be parsed.  ","description":"Implements an expression parser class.\n","image":null,"permalink":"/node/expressions/calculator/parser/expression_parser/","subtitle":null,"tags":null,"title":"ExpressionParser"},{"content":"Implements: IQuoteState\nDescription The ExpressionQuoteState class implements an Expression-specific quote string state object.\nFields QUOTE Represents a \u0026quot; symbol.\n protected QUOTE: number = \u0026lsquo;\u0026quot;'.charCodeAt(0);\n  Instance methods nextToken Gets the next token from the stream started from the character linked to this state.\n public nextToken(scanner: IScanner, tokenizer: ITokenizer): Token\n  scanner: IScanner - textual string to be tokenized. tokenizer: ITokenizer - tokenizer class that controls the process. returns: Token - next token from the top of the stream.  ","description":"Implements an Expression-specific quote string state object.\n","image":null,"permalink":"/node/expressions/calculator/tokenizers/expression_quote_state/","subtitle":null,"tags":null,"title":"ExpressionQuoteState"},{"content":"Extends: GenericSymbolState\nDescription The ExpressionSymbolState allows you to implement a symbol state object.\nConstructors Constructs an instance of this class.\n public constructor()\n ","description":"Implements a symbol state object.\n","image":null,"permalink":"/node/expressions/calculator/tokenizers/expression_symbol_state/","subtitle":null,"tags":null,"title":"ExpressionSymbolState"},{"content":"Description The ExpressionToken class defines an expression token holder.\nConstructors Creates an instance of this token and initializes it with specified values.\n public constructor(type: ExpressionTokenType, value: Variant, line: number, column: number)\n  type: ExpressionTokenType - type of the token. value: Variant - value of the token. line: number - line number where the token is. column: number - column number where the token is.  Properties column The column number where the token is.\n public column(): number\n  returns: number - column number.  line The line number where the token is.\n public line(): number\n  returns: number - column number.  type Type of the token.\n public type(): ExpressionTokenType\n  returns: ExpressionTokenType - type of the token.  value Value of the token.\n public value(): Variant\n  returns: Variant - value of the token.  ","description":"Defines an expression token holder.\n","image":null,"permalink":"/node/expressions/calculator/parser/expression_token/","subtitle":null,"tags":null,"title":"ExpressionToken"},{"content":"Extends: AbstractTokenizer\nDescription The ExpressionTokenizer allows you to implement a tokenizer to perform lexical analysis for expression.\nConstructors Constructs an instance of this class.\n public constructor()\n ","description":"Implement tokenizer to perform lexical analysis for expressions.\n","image":null,"permalink":"/node/expressions/calculator/tokenizers/expression_tokenizer/","subtitle":null,"tags":null,"title":"ExpressionTokenizer"},{"content":"Description The ExpressionTokenType class defines types of expression tokens.\nEnumeration members The codes are as follows:\n Unknown = 0 LeftBrace = 1 RightBrace = 2 LeftSquareBrace = 3 RightSquareBrace = 4 Plus = 5 Minus = 6 Star = 7 Slash = 8 Procent = 9 Power = 10 Equal = 11 NotEqual = 12 More = 13 Less = 14 EqualMore = 15 EqualLess = 16 ShiftLeft = 17 ShiftRight = 18 And = 19 Or = 20 Xor = 21 Is = 22 In = 23 NotIn = 24 Element = 25 Null = 26 Not = 27 Like = 28 NotLike = 29 IsNull = 30 IsNotNull = 31 Comma = 32 Unary = 33 Function = 34 Variable = 35 Constant = 36  ","description":"Define types of expression tokens.\n","image":null,"permalink":"/node/expressions/calculator/parser/expression_token_type/","subtitle":null,"tags":null,"title":"ExpressionTokenType"},{"content":"Extends: GenericWordState\nDescription The ExpressionTokenizer class allows you to implement a word state object.\nConstructors Constructs an instance of this class.\n public constructor()\n ","description":"Implements a word state object.\n","image":null,"permalink":"/node/expressions/calculator/tokenizers/expression_word_state/","subtitle":null,"tags":null,"title":"ExpressionWordState"},{"content":"Allows to search \u0026ldquo;facets\u0026rdquo; recorded by other microservices. For instance, statistics microservice can record groups and later use them in counters search.\n Server implementations: NodeJS Communication protocols: Direct, Commandable HTTP, Commandable GRPC, GRPC Persistence: Memory, Flat Files, MongoDB, Couchbase Deployment options: Monolith, Process, Docker, AWS Lambda Client implementations: NodeJS, .NET  ","description":null,"image":null,"permalink":"/microservices/infrastructure/faceted_search/","subtitle":null,"tags":null,"title":"Faceted Search Microservice"},{"content":"Description The Factory class allows you to create components using registered types and factory functions.\nConstructors NewFactory Creates new factory.\n NewFactory() *Factory\n Methods CanCreate Checks if this factory is able to create component by a given locator.\nThis method searches for all registered components and returns a locator for the component it is able to create that matches the given locator. If the factory is not able to create the requested component it returns nil.\n (c *Factory) CanCreate(locator interface{}) interface{}\n  locator: interface{} - locator used to identify the component to be created. returns: interface{} - locator for a component that the factory is able to create.  Create Creates a component identified by given a locator.\n (c *Factory) Create(locator interface{}) (interface{}, error)\n  locator: interface{} - locator used to identify the component to be created. returns: (interface{}, error) - created component.  Register Registers a component using a factory method.\n (c *Factory) Register(locator interface{}, factory func() interface{})\n  locator: interface{} - locator used to identify the component to be created. factory: func() interface{} - factory function that receives a locator and returns the created component.  RegisterType Registers a component using its type (a constructor function).\n (c *Factory) RegisterType(locator interface{}, factory interface{})\n  locator: interface{} - locator used to identify a component to be created. factory: interface{} - component type.  Examples factory := NewFactory(); factory.RegisterType( NewDescriptor(\u0026#34;mygroup\u0026#34;, \u0026#34;mycomponent1\u0026#34;, \u0026#34;default\u0026#34;, \u0026#34;*\u0026#34;, \u0026#34;1.0\u0026#34;), MyComponent1 ); factory.Register( NewDescriptor(\u0026#34;mygroup\u0026#34;, \u0026#34;mycomponent2\u0026#34;, \u0026#34;default\u0026#34;, \u0026#34;*\u0026#34;, \u0026#34;1.0\u0026#34;), (locator){ return NewMyComponent2(); } ); factory.Create(NewDescriptor(\u0026#34;mygroup\u0026#34;, \u0026#34;mycomponent1\u0026#34;, \u0026#34;default\u0026#34;, \u0026#34;name1\u0026#34;, \u0026#34;1.0\u0026#34;)) factory.Create(NewDescriptor(\u0026#34;mygroup\u0026#34;, \u0026#34;mycomponent2\u0026#34;, \u0026#34;default\u0026#34;, \u0026#34;name2\u0026#34;, \u0026#34;1.0\u0026#34;)) See also   Descriptor   IFactory   ","description":"Basic component factory that creates components using registered types and factory functions.\n","image":null,"permalink":"/golang/components/build/factory/","subtitle":null,"tags":null,"title":"Factory"},{"content":"Inherits: IFactory\nDescription The Factory class allows you to create components using registered types and factory functions.\nInstance methods CanCreate Checks if this factory is able to create component by a given locator.\nThis method searches for all registered components and returns a locator for the component it is able to create that matches the given locator. If the factory is not able to create the requested component is returns null.\n public object CanCreate(object locator)\n  locator: object - a locator to identify component to be created. returns: object - a locator for a component that the factory is able to create.  Create Creates a component identified by given a locator.\n public object Create(object locator)\n  locator: object - a locator to identify component to be created. returns: object - the created component.  Register Registers a component using a factory method.\n public void Register(object locator, Func\u0026lt;object, object\u0026gt; factory)\n  locator: object - a locator to identify component to be created. factory: Func\u0026lt;object, object\u0026gt; - a factory function that receives a locator and returns a created component.  RegisterAsType Registers a component using its type (a constructor function).\n public void RegisterAsType(object locator, Type type)\n  locator: object - a locator to identify component to be created. type: Type - a component type.  Examples Factory factory = new Factory(); factory.RegisterAsType( new Descriptor(\u0026#34;mygroup\u0026#34;, \u0026#34;mycomponent1\u0026#34;, \u0026#34;default\u0026#34;, \u0026#34;*\u0026#34;, \u0026#34;1.0\u0026#34;), MyComponent1 ); factory.Register( new Descriptor(\u0026#34;mygroup\u0026#34;, \u0026#34;mycomponent2\u0026#34;, \u0026#34;default\u0026#34;, \u0026#34;*\u0026#34;, \u0026#34;1.0\u0026#34;), (locator) =\u0026gt; {return new MyComponent2(); }); factory.Create(new Descriptor(\u0026#34;mygroup\u0026#34;, \u0026#34;mycomponent1\u0026#34;, \u0026#34;default\u0026#34;, \u0026#34;name1\u0026#34;, \u0026#34;1.0\u0026#34;)) factory.Create(new Descriptor(\u0026#34;mygroup\u0026#34;, \u0026#34;mycomponent2\u0026#34;, \u0026#34;default\u0026#34;, \u0026#34;name2\u0026#34;, \u0026#34;1.0\u0026#34;)) See also   Descriptor   IFactory   ","description":"Basic component factory that creates components using registered types and factory functions.\n","image":null,"permalink":"/net/components/build/factory/","subtitle":null,"tags":null,"title":"Factory"},{"content":"Implements: IFactory\nDescription The Factory class allows you to create components using registered types and factory functions.\nInstance methods canCreate Checks if this factory is able to create component by a given locator.\nThis method searches for all registered components and returns a locator for the component it is able to create that matches the given locator. If the factory is not able to create the requested component is returns null.\n public canCreate(locator: any): any\n  locator: any - a locator to identify component to be created. returns: any - a locator for a component that the factory is able to create.  create Creates a component identified by given a locator.\n public create(locator: any): any\n  locator: any - a locator to identify component to be created. returns: any - the created component.  register Registers a component using a factory method.\n public register(locator: any, factory: any)\n  locator: any - a locator to identify component to be created. factory: any - a factory function that receives a locator and returns a created component.  registerAsType Registers a component using its type (a constructor function).\n public registerAsType(locator: any, type: any)\n  locator: any - a locator to identify component to be created. type: any - a component type.  Examples let factory = new Factory(); factory.registerAsType( new Descriptor(\u0026#34;mygroup\u0026#34;, \u0026#34;mycomponent1\u0026#34;, \u0026#34;default\u0026#34;, \u0026#34;*\u0026#34;, \u0026#34;1.0\u0026#34;), MyComponent1 ); factory.register( new Descriptor(\u0026#34;mygroup\u0026#34;, \u0026#34;mycomponent2\u0026#34;, \u0026#34;default\u0026#34;, \u0026#34;*\u0026#34;, \u0026#34;1.0\u0026#34;), (locator) =\u0026gt; { return new MyComponent2(); } ); factory.create(new Descriptor(\u0026#34;mygroup\u0026#34;, \u0026#34;mycomponent1\u0026#34;, \u0026#34;default\u0026#34;, \u0026#34;name1\u0026#34;, \u0026#34;1.0\u0026#34;)) factory.create(new Descriptor(\u0026#34;mygroup\u0026#34;, \u0026#34;mycomponent2\u0026#34;, \u0026#34;default\u0026#34;, \u0026#34;name2\u0026#34;, \u0026#34;1.0\u0026#34;)) See also   Descriptor   IFactory   ","description":"Basic component factory that creates components using registered types and factory functions.\n","image":null,"permalink":"/node/components/build/factory/","subtitle":null,"tags":null,"title":"Factory"},{"content":"Implements: IFactory\nDescription The Factory class allows you to create components using registered types and factory functions.\nInstance methods can_create Checks if this factory is able to create component by a given locator.\nThis method searches for all registered components and returns a locator for the component it is able to create that matches the given locator. If the factory is not able to create the requested component is returns None.\n can_create(locator: Any): Any\n  locator: Any - a locator to identify component to be created. returns: Any - a locator for a component that the factory is able to create.  create Creates a component identified by given a locator.\n create(locator: Any): Any\n  locator: Any - a locator to identify component to be created. returns: Any - the created component.  register Registers a component using a factory method.\n register(locator: Any, factory: Any)\n  locator: Any - a locator to identify component to be created. factory: Any - a factory function that receives a locator and returns a created component.  register_as_type Registers a component using its type (a constructor function).\n register_as_type(locator: Any, object_factory: Any)\n  locator: Any - a locator to identify component to be created. object_factory: Any - a component type.  Examples factory = Factory() factory.register_as_type(Descriptor(\u0026#34;mygroup\u0026#34;, \u0026#34;mycomponent1\u0026#34;, \u0026#34;default\u0026#34;, \u0026#34;*\u0026#34;, \u0026#34;1.0\u0026#34;), MyComponent1) factory.create(Descriptor(\u0026#34;mygroup\u0026#34;, \u0026#34;mycomponent1\u0026#34;, \u0026#34;default\u0026#34;, \u0026#34;name1\u0026#34;, \u0026#34;1.0\u0026#34;)) See also   Descriptor   IFactory   ","description":"Basic component factory that creates components using registered types and factory functions.\n","image":null,"permalink":"/python/components/build/factory/","subtitle":null,"tags":null,"title":"Factory"},{"content":"Allows users to communicate to application support, request help, share ideas or raise copyright issues. When feedbacks are processed by support personnel, user receives a feedback via provided email.\n Server implementations: NodeJS Communication protocols: Direct, Commandable HTTP, Commandable GRPC, GRPC Persistence: Memory, Flat Files, MongoDB, Couchbase Deployment options: Monolith, Process, Docker, AWS Lambda Client implementations: NodeJS  This microservice has dependencies on the following microservices:\n Blobs Attachments - to reference pictures and documents associates with feedbacks  ","description":null,"image":null,"permalink":"/microservices/support/feedbacks/","subtitle":null,"tags":null,"title":"Feedbacks Microservice"},{"content":"Implements: ConfigReader\nDescription The FileConfigReader class allows you to create a config reader that reads a configuration from a file.\nConfiguration parameters  path: path to configuration file parameters: this entire section is used as template parameters \u0026hellip;  Constructors NewFileConfigReader Creates a new instance of the config reader.\n NewFileConfigReader(path string) *FileConfigReader\n  path: string - (optional) path to a configuration file.  NewEmptyFileConfigReader Creates a new instance of the config reader.\n NewEmptyFileConfigReader() *FileConfigReader\n Methods Configure Configures a component by passing its configuration parameters.\n (c *FileConfigReader) Configure(config *cconfig.ConfigParams)\n  cconfig: *cconfig.ConfigParams - configuration parameters to be set.  Path Gets the path to a configuration file.\n (c *FileConfigReader) Path() string\n  returns: string - path to a configuration file.  SetPath Sets the path to a configuration file.\n (c *FileConfigReader) SetPath(path string)\n  path: string - new path to a configuration file.  See also   IConfigReader   ConfigReader   ","description":"Config reader that reads a configuration from a file.\n","image":null,"permalink":"/golang/components/config/file_config_reader/","subtitle":null,"tags":null,"title":"FileConfigReader"},{"content":"Inherits: ConfigReader\nDescription The FileConfigReader class allows you to create a config reader that reads a configuration from a file.\nConfiguration parameters  path: path to configuration file parameters: this entire section is used as template parameters \u0026hellip;  Constructors Creates a new instance of the config reader.\n public FileConfigReader(string path = null)\n  path: string - (optional) a path to configuration file.  Properties Path Gets and sets the path to configuration file.\n public string Path { get; set; }\n Instance methods Configure Configures component by passing configuration parameters.\n public override void Configure(ConfigParams config)\n  config: ConfigParams - configuration parameters to be set.  See also   IConfigReader   ConfigReader   ","description":"Config reader that reads a configuration from a file.\n","image":null,"permalink":"/net/components/config/file_config_reader/","subtitle":null,"tags":null,"title":"FileConfigReader"},{"content":"Extends: ConfigReader\nDescription The FileConfigReader class allows you to create a config reader that reads a configuration from a file.\nConfiguration parameters  path: path to configuration file parameters: this entire section is used as template parameters \u0026hellip;  Constructors Creates a new instance of the config reader.\n public constructor(path: string = null)\n  path: string - (optional) a path to configuration file.  Instance methods configure Configures component by passing configuration parameters.\n public configure(config: ConfigParams): void\n  config: ConfigParams - configuration parameters to be set.  getPath Gets the path to configuration file.\n getPath(): string\n  returns: string - path to configuration file.  setPath Sets the path to configuration file.\n setPath(path: string): void\n  path: string - new path to configuration file.  See also   IConfigReader   ConfigReader   ","description":"Config reader that reads a configuration from a file.\n","image":null,"permalink":"/node/components/config/file_config_reader/","subtitle":null,"tags":null,"title":"FileConfigReader"},{"content":"Implements: ConfigReader\nDescription The FileConfigReader class allows you to create a config reader that reads a configuration from a file.\nConfiguration parameters  path: path to configuration file parameters: this entire section is used as template parameters \u0026hellip;  Constructors Creates a new instance of the config reader.\n FileConfigReader(path: str = None)\n  path: str - (optional) a path to configuration file.  Instance methods configure Configures component by passing configuration parameters.\n configure(config: ConfigParams)\n  config: ConfigParams - configuration parameters to be set.  get_path Gets the path to configuration file.\n get_path(): str\n  returns: str - path to configuration file.  set_path Sets the path to configuration file.\n set_path(path: str)\n  path: str - new path to configuration file.  See also   IConfigReader   ConfigReader   ","description":"Config reader that reads a configuration from a file.\n","image":null,"permalink":"/python/components/config/file_config_reader/","subtitle":null,"tags":null,"title":"FileConfigReader"},{"content":"The FileError class is used to manage errors in read/write local disk operations.\nConstructors NewFileError Creates an error instance and assigns its values.\n NewFileError(correlationId, code, message string) *ApplicationError\n  correlationId: string - (optional) unique transaction id used to trace execution through the call chain. code: string - (optional) unique error code. Default: \u0026ldquo;UNKNOWN\u0026rdquo; message: string - (optional) a human-readable description of the error.  ","description":"Errors in read/write local disk operations.\n","image":null,"permalink":"/golang/commons/errors/file_error/","subtitle":null,"tags":null,"title":"FileError"},{"content":"Inherits: ApplicationException\nThe FileException class is used to manage errors in read/write local disk operations.\nConstructors Creates an error instance and assigns its values.\n public FileException(string correlationId = null, string code = null, string message = null)\n  correlationId: string - (optional) unique transaction id used to trace execution through the call chain. code: string - (optional) unique error code. Default: \u0026ldquo;UNKNOWN\u0026rdquo; message: string - (optional) human-readable description of the error.  Creates an error instance with error message\n public FileException(string message)\n  message: string - human-readable description of the error.  Creates an error instance and assigns its values.\n public FileException(Exception innerException)\n  innerException: Exception - error object  Creates an error instance by processing native C# Exceptions.\n protected FileException(SerializationInfo info, StreamingContext context)\n  info: SerializationInfo - serialized information containing the serialized object data about the exception being thrown. context: StreamingContext - streaming context containing contextual information about the source or destination.  ","description":"Errors in read/write local disk operations.\n","image":null,"permalink":"/net/commons/errors/file_exception/","subtitle":null,"tags":null,"title":"FileException"},{"content":"Extends: ApplicationException\nThe FileException class is used to manage errors in read/write local disk operations.\nConstructors Creates an error instance and assigns its values.\n public constructor(correlation_id: string = null, code: string = null, message: string = null)\n  correlation_id: string - (optional) unique transaction id used to trace execution through a call chain. code: string - (optional) unique error code. Default: \u0026ldquo;UNKNOWN\u0026rdquo; message: string - (optional) human-readable description of the error.  ","description":"Errors in read/write local disk operations.\n","image":null,"permalink":"/node/commons/errors/file_exception/","subtitle":null,"tags":null,"title":"FileException"},{"content":"Implements: ApplicationException\nThe FileException class is used to manage errors in read/write local disk operations.\nConstructors Creates an error instance and assigns its values.\n FileException(correlation_id: Optional[str] = None, code: str = None, message: str = None)\n  correlation_id: Optional[str] - (optional) a unique transaction id to trace execution through call chain. code: str - (optional) a unique error code. Default: \u0026ldquo;UNKNOWN\u0026rdquo; message: str - (optional) a human-readable description of the error.  ","description":"Errors in read/write local disk operations.\n","image":null,"permalink":"/python/commons/errors/file_exception/","subtitle":null,"tags":null,"title":"FileException"},{"content":"Implements: MemoryPersistence\nDescription The FilePersistence class allows you to create persistence components that store data in flat files and chache them in memory.\nImportant points\n This is the most basic persistence component that is only able to store data items of any type. Specific CRUD operations over the data items must be implemented in child classes by accessing the self._items property and calling the save method.  Configuration parameters  path: path to the file where data is stored  References  *:logger:*:*:1.0 - (optional) ILogger components to pass log messages  Constructors NewFilePersistence Creates a new instance of the file persistence component.\n NewFilePersistence(prototype reflect.Type, persister *JsonFilePersister) *FilePersistence\n  prototype: reflect.Type - (optional) a persister component that loads and saves data from/to flat file. persister: *JsonFilePersister - (optional) persister component that loads and saves data from/to a flat file.  Fields Persister JSON file persister.\n Persister: *JsonFilePersister\n  Methods Configure Configures the component by passing its configuration parameters.\n (c *FilePersistence) Configure(conf *config.ConfigParams)\n  config: *config.ConfigParams - configuration parameters to be set.  Examples type MyJsonFilePersistence struct { FilePersistence } func NewMyJsonFilePersistence(path string) *NewMyJsonFilePersistence { prototype := reflcet.TypeOf(MyData{}) return \u0026amp;NewFilePersistence(prototype, NewJsonPersister(prototype, path)) } func (c * FilePersistence) GetByName(correlationId string, name string) (item MyData, err error){ for _,v := range c._items { if v.Name == name { item = v.(MyData) break } } return item, nil } func (c *FilePersistence) Set(correlatonId string, item MyData) error { for i,v := range c._items { if v.name == item.name { c._items = append(c._items[:i], c._items[i+1:]) } } c._items = append(c._items, item) retrun c.save(correlationId) } See also   MemoryPersistence   JsonFilePersister   ","description":"Abstract persistence component that stores data in flat files and caches them in memory.\n","image":null,"permalink":"/golang/data/persistence/file_persistence/","subtitle":null,"tags":null,"title":"FilePersistence"},{"content":"Inherits: MemoryPersistence\nDescription The FilePersistence class allows you to create persistence components that store data in flat files and chache them in memory.\nImportant points\n This is the most basic persistence component that is only able to store data items of any type. Specific CRUD operations over the data items must be implemented in child classes by accessing the self._items property and calling the save method.  Configuration parameters  path: path to the file where data is stored  References  *:logger:*:*:1.0 - (optional) ILogger components to pass log messages  Constructors Creates a new instance of the file persistence component.\n public FilePersistence(JsonFilePersister persister)\n  persister: JsonFilePersister - (optional) persister component that loads and saves data from/to a flat file.  Creates a new instance of the persistence.\n public FilePersistence()\n Fields _persister JSON file persister.\n protected _persister: JsonFilePersister\n  Instance methods Configure Configures the component by passing its configuration parameters.\n public virtual void Configure(ConfigParams config)\n  config: ConfigParams - configuration parameters to be set.  Examples class MyJsonFilePersistence: FilePersistence\u0026lt;MyData\u0026gt; { public MyJsonFilePersistence(string path) { super(MyData.class, new JsonFilePersister(path)); } public MyData GetByName(String correlationId, String name) { MyData item = _items.Find((mydata) =\u0026gt; { return mydata.Name == name; }); ... return item; } public MyData Set(String correlatonId, MyData item) { this._items = _items.Filter((mydata) =\u0026gt; { return mydata.Name != name; }); ... this._items.add(item); this.save(correlationId); } } See also   MemoryPersistence   JsonFilePersister   ","description":"Abstract persistence component that stores data in flat files and caches them in memory.\n","image":null,"permalink":"/net/data/persistence/file_persistence/","subtitle":null,"tags":null,"title":"FilePersistence\u003cT\u003e"},{"content":"Extends: MemoryPersistence\nimplements: IConfigurable\nDescription The FilePersistence class allows you to create persistence components that store data in flat files and chache them in memory.\nImportant points\n This is the most basic persistence component that is only able to store data items of any type. Specific CRUD operations over the data items must be implemented in child classes by accessing the self._items property and calling the save method.  Configuration parameters  path: path to the file where data is stored  References  *:logger:*:*:1.0 - (optional) ILogger components to pass log messages  Constructors Creates a new instance of the file persistence component.\n public constructor(persister?: JsonFilePersister)\n  persister: JsonFilePersister - (optional) persister component that loads and saves data from/to a flat file.  Fields _persister JSON file persister.\n protected _persister: JsonFilePersister\n  Instance methods configure Configures the component by passing its configuration parameters.\n public configure(config: ConfigParams): void\n  config: ConfigParams - configuration parameters to be set.  Examples class MyJsonFilePersistence extends FilePersistence\u0026lt;MyData\u0026gt; { public constructor(path?: string) { super(new JsonPersister(path)); } public async getByName(correlationId: string, name: string): Promise\u0026lt;MyData\u0026gt; { let item = this._items.find((d) =\u0026gt; d.name == name); retur item; }); public async set(correlatonId: string, item: MyData): Promise\u0026lt;MyData\u0026gt; { this._items = this._items.filter((d) =\u0026gt; d.name != name); this._items.push(item); await this.save(correlationId); return item; } } See also   MemoryPersistence   JsonFilePersister   ","description":"Abstract persistence component that stores data in flat files and caches them in memory.\n","image":null,"permalink":"/node/data/persistence/file_persistence/","subtitle":null,"tags":null,"title":"FilePersistence\u003cT\u003e"},{"content":"Implements: MemoryPersistence, IConfigurable\nDescription The FilePersistence class allows you to create persistence components that store data in flat files and chache them in memory.\nImportant points\n This is the most basic persistence component that is only able to store data items of any type. Specific CRUD operations over the data items must be implemented in child classes by accessing the self._items property and calling the save method.  Configuration parameters  path: path to the file where data is stored  References  *:logger:*:*:1.0 - (optional) ILogger components to pass log messages  Constructors Creates a new instance of the file persistence component.\n FilePersistence(persister: Optional[JsonFilePersister] = None)\n  persister: JsonFilePersister - (optional) persister component that loads and saves data from/to a flat file.  Fields _persister JSON file persister.\n _persister: JsonFilePersister\n  Instance methods configure Configures the component by passing its configuration parameters.\n configure(config: ConfigParams)\n  config: ConfigParams - configuration parameters to be set.  Examples class MyJsonFilePersistence(FilePersistence): def __init__(self, path): super(MyJsonFilePersistence, self).__init__(JsonPersister(path)) def get_by_name(self, correlation_id, name): item = self.find(name) ... return item See also   MemoryPersistence   JsonFilePersister   ","description":"Abstract persistence component that stores data in flat files and caches them in memory.\n","image":null,"permalink":"/python/data/persistence/file_persistence/","subtitle":null,"tags":null,"title":"FilePersistence"},{"content":"Keeps lists of files that can be stored in blob storage or linked to external source using uri.\n Server implementations: NodeJS Communication protocols: Direct, Commandable HTTP, Commandable GRPC, GRPC Persistence: Memory, Flat Files, MongoDB, Couchbase, AWS S3 Deployment options: Monolith, Process, Docker, AWS Lambda Client implementations: NodeJS  ","description":null,"image":null,"permalink":"/microservices/content/files/","subtitle":null,"tags":null,"title":"Files Microservice"},{"content":"Implements: StringValueMap\nDescription The FilterParams class allows you to create a data transfer object that can be used to pass filter parameters as key-value pairs.\nConstructors NewFilterParams Creates a new instance and initalizes it with elements from the specified map.\n NewFilterParams(values map[string]string) *FilterParams\n  map: map[string]string - a map to initialize this instance.  NewFilterParams Converts a specified value into FilterParams.\n NewFilterParamsFromValue(value interface{}) *FilterParams\n  value: interface{} - value to be converted returns: *FilterParams - newly created FilterParams.  NewFilterParamsFromString Parses semicolon-separated key-value pairs and returns them as a FilterParams.\nSee StringValueMap.NewStringValueMapFromString\n NewFilterParamsFromString(line string) *FilterParams\n  line: string - semicolon-separated key-value list to initialize FilterParams. returns: *FilterParams - newly created FilterParams.  NewFilterParamsFromTuples Creates a new FilterParams from a list of key-value pairs called tuples.\n NewFilterParamsFromTuples(tuples \u0026hellip;interface{}) *FilterParams\n  tuples: \u0026hellip;interface{} - list of values where odd elements are keys and the following even elements are values returns: *FilterParams - newly created FilterParams.  Examples filter := NewFilterParamsFromTuples( \u0026#34;type\u0026#34;, \u0026#34;Type1\u0026#34;, \u0026#34;from_create_time\u0026#34;, new Date(2000, 0, 1), \u0026#34;to_create_time\u0026#34;, new Date(), \u0026#34;completed\u0026#34;, true ); paging = NewPagingParams(0, 100); err, page = myDataClient.GetDataByFilter(filter, paging); See also   StringValueMap   ","description":"Data transfer object used to pass filter parameters as key-value pairs.\n","image":null,"permalink":"/golang/commons/data/filter_params/","subtitle":null,"tags":null,"title":"FilterParams"},{"content":"Inherits: StringValueMap\nDescription The FilterParams class allows you to create a data transfer object that can be used to pass filter parameters as key-value pairs.\nConstructors Creates a new instance and initalizes it with elements from the specified map.\n public FilterParams(IDictionary\u0026lt;string, string\u0026gt; map)\n  map: IDictionary\u0026lt;string, string\u0026gt; - map to initialize this instance.  Creates a new instance and initalizes it with elements from the specified map.\n public FilterParams(AnyValueMap map)\n  map: AnyValueMap - map to initialize this instance.  Creates a new instance and initalizes it with elements from the specified map.\n public FilterParams()\n Static methods FromString Parses semicolon-separated key-value pairs and returns them as a FilterParams.\nSee StringValueMap.FromString\n public static FilterParams FromString(string line)\n  line: string - semicolon-separated key-value list to initialize FilterParams. returns: FilterParams - newly created FilterParams.  FromTuples Creates a new FilterParams from a list of key-value pairs called tuples.\n public static FilterParams FromTuples(params object[] tuples)\n  tuples: object[] - list of values where odd elements are keys and the following even elements are values returns: FilterParams - newly created FilterParams.  FromValue Converts a specified value to FilterParams.\n public static FilterParams FromValue(object value)\n  value: object - value to be converted returns: FilterParams - newly created FilterParams.  Examples var filter = FilterParams.FromTuples( \u0026#34;type\u0026#34;, \u0026#34;Type1\u0026#34;, \u0026#34;from_create_time\u0026#34;, new Date(2000, 0, 1), \u0026#34;to_create_time\u0026#34;, new Date(), \u0026#34;completed\u0026#34;, true ); var paging = new PagingParams(0, 100); myDataClient.GetDataByFilter(filter, paging); See also   StringValueMap   ","description":"Data transfer object used to pass filter parameters as key-value pairs.\n","image":null,"permalink":"/net/commons/data/filter_params/","subtitle":null,"tags":null,"title":"FilterParams"},{"content":"Extends: StringValueMap\nDescription The FilterParams class allows you to create a data transfer object that can be used to pass filter parameters as key-value pairs.\nConstructors Creates a new instance and initalizes it with elements from the specified map.\n public constructor(map: any = null)\n  map: any - map to initialize this instance.  Static methods fromString Parses semicolon-separated key-value pairs and returns them as a FilterParams.\nSee StringValueMap.fromString\n public static fromString(line: string): FilterParams\n  line: string - semicolon-separated key-value list to initialize FilterParams. returns: FilterParams - newly created FilterParams.  fromTuples Creates a new FilterParams from a list of key-value pairs called tuples.\n public static fromTuples(\u0026hellip;tuples: any[]): FilterParams\n  tuples: any[] - list of values where odd elements are keys and the following even elements are values. returns: FilterParams - newly created FilterParams.  fromValue Converts a specified value into a FilterParams object.\n public static fromValue(value: any): FilterParams\n  value: any - value to be converted. returns: FilterParams - newly created FilterParams object.  Examples let filter = FilterParams.fromTuples( \u0026#34;type\u0026#34;, \u0026#34;Type1\u0026#34;, \u0026#34;from_create_time\u0026#34;, new Date(2000, 0, 1), \u0026#34;to_create_time\u0026#34;, new Date(), \u0026#34;completed\u0026#34;, true ); let paging = new PagingParams(0, 100); myDataClient.getDataByFilter(filter, paging, (err, page) =\u0026gt; {...}); See also   StringValueMap   ","description":"Data transfer object used to pass filter parameters as key-value pairs.\n","image":null,"permalink":"/node/commons/data/filter_params/","subtitle":null,"tags":null,"title":"FilterParams"},{"content":"Implements: StringValueMap\nDescription The FilterParams class allows you to create a data transfer object that can be used to pass filter parameters as key-value pairs.\nConstructors Creates a new instance and initalizes it with elements from the specified map.\n FilterParams(map: Any = None)\n  map: Any - a map to initialize this instance.  Static methods from_string Parses semicolon-separated key-value pairs and returns them as a FilterParams.\nSee StringValueMap.from_string\n static from_string(line: str): FilterParams\n  line: str - semicolon-separated key-value list to initialize FilterParams. returns: FilterParams - a newly created FilterParams.  from_tuples Creates a new FilterParams from a list of key-value pairs called tuples.\n static from_tuples(*tuples: Any): FilterParams\n  tuples: Any - a list of values where odd elements are keys and the following even elements are values. returns: FilterParams - a newly created FilterParams.  from_value Converts specified value into FilterParams.\n static from_value(value: Any): FilterParams\n  value: Any - value to be converted. returns: FilterParams - a newly created FilterParams.  Examples filter = FilterParams.from_tuples(\u0026#34;type\u0026#34;, \u0026#34;Type1\u0026#34;, \u0026#34;from_create_time\u0026#34;, datetime.datetime(2000, 0, 1), \u0026#34;to_create_time\u0026#34;, datetime.datetime.now(), \u0026#34;completed\u0026#34;, True ) paging = PagingParams(0, 100) myDataClient.get_data_by_filter(filter, paging) See also   StringValueMap   ","description":"Data transfer object used to pass filter parameters as key-value pairs.\n","image":null,"permalink":"/python/commons/data/filter_params/","subtitle":null,"tags":null,"title":"FilterParams"},{"content":"Description The FilterParamsSchema class allows you to create a schema to validate FilterParams.\nConstructors NewFilterParamsSchema Creates a new instance of a validation schema.\n NewFilterParamsSchema() *MapSchema\n See also   FilterParams   ","description":"Schema to validate [FilterParams](../../data/filter_params).\n","image":null,"permalink":"/golang/commons/validate/filter_params_schema/","subtitle":null,"tags":null,"title":"FilterParamsSchema"},{"content":"Inherits: MapSchema\nDescription The FilterParamsSchema class allows you to create a schema to validate FilterParams.\nConstructors Creates a new instance of a validation schema.\n public FilterParamsSchema()\n See also   FilterParams   ","description":"Schema to validate [FilterParams](../../data/filter_params).\n","image":null,"permalink":"/net/commons/validate/filter_params_schema/","subtitle":null,"tags":null,"title":"FilterParamsSchema"},{"content":"Extends: MapSchema\nDescription The FilterParamsSchema class allows you to create a schema to validate FilterParams.\nConstructors Creates a new instance of FilterParamsSchema.\n public constructor()\n See also   FilterParams   ","description":"Schema to validate [FilterParams](../../data/filter_params).\n","image":null,"permalink":"/node/commons/validate/filter_params_schema/","subtitle":null,"tags":null,"title":"FilterParamsSchema"},{"content":"Implements: MapSchema\nDescription The FilterParamsSchema class allows you to create a schema to validate FilterParams.\nConstructors Creates a new instance of validation schema.\n FilterParamsSchema()\n See also   FilterParams   ","description":"Schema to validate [FilterParams](../../data/filter_params).\n","image":null,"permalink":"/python/commons/validate/filter_params_schema/","subtitle":null,"tags":null,"title":"FilterParamsSchema"},{"content":"Description The FixerRateTimer class represents a timer that is triggered in equal time intervals.\nImportant points\n It has a symmetric cross-language implementation and is often used by the Pip.Services toolkit to perform periodic processing and cleanup in microservices.  Constructors NewFixedRateTimerFromCallback Creates new instance of the timer and sets its values.\n NewFixedRateTimerFromCallback(callback func(), interval int, delay int) *FixedRateTimer\n  callback: func() - (optional) Notifiable object or callback function to call when timer is triggered. interval: int - (optional) interval to trigger the timer in milliseconds. delay: int - (optional) delay before the first triggering in milliseconds.  NewFixedRateTimerFromTask Creates new instance of the timer and sets its values.\n NewFixedRateTimerFromTask(task INotifiable, interval int, delay int) *FixedRateTimer\n  task: INotifiable - Notifiable object used to call when the timer is triggered. interval: int - (optional) interval used to trigger the timer in milliseconds. delay: int - (optional) delay before the first triggering in milliseconds.  NewFixedRateTimer Creates new instance of the timer and sets its values.\n NewFixedRateTimer() *FixedRateTimer\n Methods Close Closes the timer.\nThis is required by ICloseable interface, but besides that, it is identical to Stop().\n (c *FixedRateTimer) Close(correlationId string) error\n  correlationId: string - (optional) transaction id used to trace execution through the call chain.  Callback Gets the callback function that is called when this timer is triggered.\n (c *FixedRateTimer) Callback() func()\n  returns: func() - callback function or nil if it is not set.  Delay Gets the initial delay before the timer is triggered for the first time.\n (c *FixedRateTimer) Delay() int\n  returns: int - delay in milliseconds.  Interval Gets the periodic timer\u0026rsquo;s triggering interval.\n (c *FixedRateTimer) Interval() int\n  returns: int - interval in milliseconds  Task Gets the INotifiable object that receives notifications from this timer.\n (c *FixedRateTimer) Task() INotifiable\n  returns: INotifiable - INotifiable object or nil if it is not set.  SetTask Sets a new INotifiable object to receive notifications from this timer.\n (c *FixedRateTimer) SetTask(value INotifiable)\n  value: INotifiable - INotifiable object to be triggered.  IsStarted Checks if the timer is started.\n (c *FixedRateTimer) IsStarted() bool\n  returns: bool - true if the timer is started and false if it is stopped.  SetCallback Sets the callback function that is called when this timer is triggered.\n (c *FixedRateTimer) SetCallback(value func())\n  value: func() - callback function to be called.  SetDelay Sets initial delay before the timer is triggered for the first time.\n (c *FixedRateTimer) SetDelay(value int)\n  value: int - delay in milliseconds.  SetInterval Sets periodic timer triggering interval.\n (c *FixedRateTimer) SetInterval(value int)\n  value: int - interval in milliseconds.  Start Starts the timer.\nInitially the timer is triggered after a delay. After that, it is triggered after the interval until it is stopped.\n (c *FixedRateTimer) Start()\n Stop Stops the timer.\n (c *FixedRateTimer) Stop()\n Examples type MyComponent { timer FixedRateTimer } ... func (mc* MyComponent) open(correlationId string) { ... mc.timer = NewFixedRateTimerFromCallback(() =\u0026gt; { this.cleanup }, 60000, 0); mc.timer.start(); ... } func (mc* MyComponent) open(correlationId: string){ ... mc.timer.stop(); ... } See also   INotifiable   ","description":"Timer that is triggered in equal time intervals.\n","image":null,"permalink":"/golang/commons/run/fixed_rate_timer/","subtitle":null,"tags":null,"title":"FixedRateTimer"},{"content":"Inherits: IClosable\nDescription The FixerRateTimer class represents a timer that is triggered in equal time intervals.\nImportant points\n It has symmetric cross-language implementation and is often used by the Pip.Services toolkit to perform periodic processing and cleanup in microservices.  Constructors Creates new instance of the timer and sets its values.\n public FixedRateTimer(Action task, int interval, int delay)\n  taskOrCallback: Action - (optional) Notifiable object or callback function to call when timer is triggered. interval: int - (optional) interval to trigger timer (in milliseconds). delay: int - (optional) delay before the first triggering (in milliseconds).  Creates new instance of the timer with default parameters.\n public FixedRateTimer()\n Properties Task Gets the INotifiable object that receives notifications from this timer.\n public Action Task { get; set; }\n Delay Gets the initial delay before the timer is triggered for the first time.\n public int Delay { get; set; }\n Interval Gets the periodic timer triggering interval.\n public int Interval { get; set; }\n IsStarted Checks if the timer has started. True if the timer has started and false if it has stopped.\n public bool IsStarted [ get, private set ]\n Instance methods Restart Restarts the timer.\n void Restart()\n Start Starts the timer.\nInitially the timer is triggered after delay. After that, it is triggered after interval until it is stopped.\n public void Start()\n Stop Stops the timer.\n public void Stop()\n Example class MyComponent { var timer = new FixedRateTimer(() =\u0026gt; { this.cleanup }, 60000, 0); ... public void )pen(string correlationId) { ... timer.Start(); ... } public void Open(string correlationId) { ... timer.Stop(); ... } private void Cleanup() { ... } ... } See also   INotifiable   ","description":"Timer that is triggered in equal time intervals.\n","image":null,"permalink":"/net/commons/run/fixed_rate_timer/","subtitle":null,"tags":null,"title":"FixedRateTimer"},{"content":"Implements: IClosable\nDescription The FixerRateTimer class represents a timer that is triggered in equal time intervals.\nImportant points\n It has symmetric cross-language implementation and is often used by the Pip.Services toolkit to perform periodic processing and cleanup in microservices.  Constructors Creates new instance of the timer and sets its values.\n public constructor(taskOrCallback: any = null, interval: number = null, delay: number = null)\n  taskOrCallback: any - (optional) Notifiable object or callback function to call when timer is triggered. interval: number - (optional) interval to trigger timer in milliseconds. delay: number - (optional) delay before the first triggering in milliseconds.  Instance methods close Closes the timer.\nThis is required by the ICloseable interface, but besides that it is identical to stop().\n public close(correlationId: string): Promise\u0026lt;void\u0026gt;\n  correlationId: string - (optional) transaction id used to trace execution through the call chain.  getCallback Gets the callback function that is called when this timer is triggered.\n public getCallback(): () =\u0026gt; void\n  returns: function - callback function or null if it is not set.  getDelay Gets an initial delay before the timer is triggered for the first time.\n public getDelay(): number\n  returns: number - delay in milliseconds.  getInterval Gets a periodic timer triggering interval.\n public getInterval(): number\n  returns: number - interval in milliseconds  getTask Gets the INotifiable object that receives notifications from this timer.\n public getTask(): INotifiable\n  returns: INotifiable - INotifiable object or null if it is not set.  setTask Sets a new INotifiable object to receive notifications from this timer.\n public setTask(value: INotifiable): void\n  value: INotifiable - INotifiable object to be triggered.  isStarted Checks if the timer is started.\n public isStarted(): boolean\n  returns: boolean - true if the timer is started and false if it is stopped.  setCallback Sets the callback function that is called when this timer is triggered.\n public setCallback(value: () =\u0026gt; void)\n  value: function - callback function to be called.  setDelay Sets an initial delay before the timer is triggered for the first time.\n public setDelay(value: number): void\n  value: number - delay in milliseconds.  setInterval Sets a periodic timer triggering interval.\n public setInterval(value: number): void\n  value: number - interval in milliseconds.  start Starts the timer.\nInitially. the timer is triggered after delay. After that, it is triggered after interval until it is stopped.\n public start(): void\n stop Stops the timer.\n public stop(): void\n Examples class MyComponent { private timer: FixedRateTimer = new FixedRateTimer(() =\u0026gt; { this.cleanup }, 60000); ... public async open(correlationId: string): Promise\\\u0026lt;void\\\u0026gt; { ... timer.start(); ... } public async close(correlationId: string): Promise\\\u0026lt;void\\\u0026gt; { ... timer.stop(); ... } private cleanup(): void { ... } ... } See also   INotifiable   ","description":"Timer that is triggered in equal time intervals.\n","image":null,"permalink":"/node/commons/run/fixed_rate_timer/","subtitle":null,"tags":null,"title":"FixedRateTimer"},{"content":"Implements: IClosable\nDescription The FixerRateTimer class represents a timer that is triggered in equal time intervals.\nImportant points\n It has symmetric cross-language implementation and is often used by the Pip.Services toolkit to perform periodic processing and cleanup in microservices.  Constructors Creates new instance of the timer and sets its values.\n FixedRateTimer(task_or_object: Any = None, interval: int = None, delay: int = None)\n  task_or_object: Any - (optional) a Notifiable object or callback function to call when timer is triggered. interval: int - (optional) an interval to trigger timer in milliseconds. delay: int - (optional) a delay before the first triggering in milliseconds.  Instance methods close Closes the timer.\nThis is required by ICloseable interface, but besides that it is identical to stop().\n close(correlation_id: Optional[str])\n  correlation_id: Optional[str] - (optional) transaction id to trace execution through call chain.  get_callback Gets the callback function that is called when this timer is triggered.\n get_callback(): Callable\n  returns: Callable - the callback function or None if it is not set.  get_delay Gets initial delay before the timer is triggered for the first time.\n getDelay(): int\n  returns: int - the delay in milliseconds.  get_interval Gets periodic timer triggering interval.\n get_interval(): int\n  returns: int - the interval in milliseconds  get_task Gets the INotifiable object that receives notifications from this timer.\n get_task(): INotifiable\n  returns: INotifiable - the INotifiable object or None if it is not set.  set_task Sets a new INotifiable object to receive notifications from this timer.\n set_task(value: INotifiable)\n  value: INotifiable - a INotifiable object to be triggered.  is_started Checks if the timer is started.\n is_started(): bool\n  returns: bool - true if the timer is started and false if it is stopped.  set_callback Sets the callback function that is called when this timer is triggered.\n set_callback(value: Callable)\n  value: Callable - the callback function to be called.  set_delay Sets initial delay before the timer is triggered for the first time.\n set_delay(value: int)\n  value: int - a delay in milliseconds.  set_interval Sets periodic timer triggering interval.\n set_interval(value: int)\n  value: int - an interval in milliseconds.  start Starts the timer.\nInitially the timer is triggered after delay. After that it, is triggered after interval until it is stopped.\n start()\n stop Stops the timer.\n stop()\n Examples class MyComponent: timer: FixedRateTimer = FixedRateTimer(self.__cleanup, 60000) ... def open(correlation_id: str): ... timer.start() ... def close(correlationId: str): ... timer.stop() ... def __cleanup(): ... ... See also   INotifiable   ","description":"Timer that is triggered in equal time intervals.\n","image":null,"permalink":"/python/commons/run/fixed_rate_timer/","subtitle":null,"tags":null,"title":"FixedRateTimer"},{"content":"Description The FloatConverter class allows you to convert arbitrary values into float using the following extended conversion rules:\n Strings are converted to float values DateTime: total number of milliseconds since unix epoсh Boolean: 1 for true and 0 for false  Methods ToFloat Converts value into float or returns 0 when conversion is not possible.\n ToFloat(value interface{}) float32\n  value: interface{} - value to convert. returns: float32 - float value or 0 when conversion is not supported.  ToFloatWithDefault Converts value into float or returns default when conversion is not possible.\nSee DoubleConverter.ToDoubleWithDefault,\nDoubleConverter.ToNullableDouble\n ToFloatWithDefault(value interface{}, defaultValue float32) float32\n  value: interface{} - value to convert. defaultValue: float32 - default value. returns: float32 - float value or default value when conversion is not supported.  ToNullableFloat Converts value into float or returns nil when conversion is not possible.\nSee DoubleConverter.ToNullableDouble\n ToNullableFloat(value interface{}) *float32\n  value: interface{} - value to convert. returns: *float32 - float value or nil when conversion is not supported.  Examples value1 := convert.FloatConverter.ToNullableFloat(\u0026#34;ABC\u0026#34;) value2 := convert.FloatConverter.ToNullableFloat(\u0026#34;123.456\u0026#34;) value3 := convert.FloatConverter.ToNullableFloat(true) value4 := convert.FloatConverter.ToNullableFloat(time.Now()) fmt.Println(value1) // \u0026lt;nil\u0026gt; fmt.Println(*value2) // 123.456 fmt.Println(*value3) // 1 fmt.Println(*value4) // current milliseconds (e.g. 1.566333114e+09)  ","description":"The FloatConverter class allows you to convert arbitrary values into float using extended conversion rules.\n","image":null,"permalink":"/golang/commons/convert/float_converter/","subtitle":null,"tags":null,"title":"FloatConverter"},{"content":"Description The FloatConverter class allows you to convert arbitrary values into a float using the following extended conversion rules:\n Strings are converted to float values DateTime: total number of milliseconds since unix epoсh Boolean: 1 for true and 0 for false  Static methods ToFloat Converts value into float or returns 0 when the conversion is not possible.\nSee DoubleConverter.toDouble\n public static float ToFloat(object value)\n  value: object - value to convert. returns: float - float value or 0 when conversion is not supported.  ToFloatWithDefault Converts value into float or returns a given default value when the conversion is not possible.\nSee DoubleConverter.ToDoubleWithDefault,\nDoubleConverter.ToNullableDouble\n public static float ToFloatWithDefault(object value, float defaultValue)\n  value: object - value to convert. defaultValue: float - default value. returns: float - float value or default value when conversion is not supported.  ToNullableFloat Converts value into float or returns null when the conversion is not possible.\nSee DoubleConverter.ToNullableDouble\n public static float toNullableFloat(object value)\n  value: object - the value to convert. returns: float - float value or null when conversion is not supported.  Examples var value1 = FloatConverter.ToNullableFloat(\u0026#34;ABC\u0026#34;); // Result: null var value2 = FloatConverter.ToNullableFloat(\u0026#34;123.456\u0026#34;); // Result: 123.456 var value3 = FloatConverter.ToNullableFloat(true); // Result: 1 var value4 = FloatConverter.ToNullableFloat(new Date()); // Result: current milliseconds  ","description":"The FloatConverter class allows you to convert arbitrary values into a float using extended conversion rules.\n","image":null,"permalink":"/net/commons/convert/float_converter/","subtitle":null,"tags":null,"title":"FloatConverter"},{"content":"Description The FloatConverter class allows you to convert arbitrary values into float using the following extended conversion rules:\n Strings are converted to float values DateTime: total number of milliseconds since unix epoсh Boolean: 1 for true and 0 for false  Static methods toFloat Converts a value into a float or returns 0 when the conversion is not possible.\nSee DoubleConverter.toDouble\n public static toFloat(value: any): number\n  value: any - value to convert. returns: number - float value or 0 when the conversion is not supported.  toFloatWithDefault Converts a value into a float or returns a given default when the conversion is not possible.\nSee DoubleConverter.toDoubleWithDefault,\nDoubleConverter.toNullableDouble\n public static toFloatWithDefault(value: any, defaultValue: number): number\n  value: any - value to convert. defaultValue: number - default value. returns: number - float value or default value when the conversion is not supported.  toNullableFloat Converts a value into a float or returns null when the conversion is not possible.\nSee DoubleConverter.toNullableDouble\n public static toNullableFloat(value: any): number\n  value: any - value to convert. returns: number - float value or null when the conversion is not supported.  Examples let value1 = FloatConverter.toNullableFloat(\u0026#34;ABC\u0026#34;); // Result: null let value2 = FloatConverter.toNullableFloat(\u0026#34;123.456\u0026#34;); // Result: 123.456 let value3 = FloatConverter.toNullableFloat(true); // Result: 1 let value4 = FloatConverter.toNullableFloat(new Date()); // Result: current milliseconds (E.g. 1619869474907)  ","description":"The FloatConverter class allows you to convert arbitrary values into float using extended conversion rules.\n","image":null,"permalink":"/node/commons/convert/float_converter/","subtitle":null,"tags":null,"title":"FloatConverter"},{"content":"Description The FloatConverter class allows you to convert arbitrary values into float using the following extended conversion rules:\n Strings are converted to float values DateTime: total number of milliseconds since unix epoсh Boolean: 1 for true and 0 for false  Static methods to_float Converts value into float or returns 0 when conversion is not possible.\nSee DoubleConverter.toDouble\n static to_float(value: Any): float\n  value: Any - the value to convert. returns: float - float value or 0 when conversion is not supported.  to_float_with_default Converts value into float or returns default when conversion is not possible.\nSee DoubleConverter.to_double_with_default,\nDoubleConverter.to_nullable_double\n static to_float_with_default(value: Any, default_value: float): float\n  value: Any - the value to convert. default_value: float - the default value. returns: float - float value or default value when conversion is not supported.  to_nullable_float Converts value into float or returns None when conversion is not possible.\nSee DoubleConverter.to_nullable_double\n static to_nullable_float(value: Any): Optional[float]\n  value: Any - the value to convert. returns: Optional[float] - float value or None when conversion is not supported.  Examples value1 = FloatConverter.to_nullable_float(\u0026#34;ABC\u0026#34;) # Returns None value2 = FloatConverter.to_nullable_float(\u0026#34;123.456\u0026#34;) # Returns 123.456 value3 = FloatConverter.to_nullable_float(True) # Returns 1 value4 = FloatConverter.to_nullable_float(datetime.datetime.now()) # Returns current milliseconds (E.g. 1619866773703) ","description":"The FloatConverter class allows you to convert arbitrary values into float using extended conversion rules.\n","image":null,"permalink":"/python/commons/convert/float_converter/","subtitle":null,"tags":null,"title":"FloatConverter"},{"content":"Implements: IFunctionCollection\nDescription The FunctionCollection class allows you to implement a list of functions\nProperties length Gets a number of functions stored in the collection.\n public length(): number\n  retuns: number - number of stored functions.  Instance methods add Adds a new function to the collection.\n public add(func: IFunction): void\n  func: IFunction - array with function parameters.  clear Clears the collection.\n public clear(): void\n findByName Finds a function in the list by it\u0026rsquo;s name.\n public findByName(name: string): IFunction\n  name: string - function name to be found. returns: IFunction - function or null if function was not found.  findIndexByName Finds a function\u0026rsquo;s index in the list by it\u0026rsquo;s name.\n public findIndexByName(name: string): number\n  name: string - function name to be found. returns: number - function\u0026rsquo;s index in the list or -1 if function was not found.  get Gets a function by its index.\n public get(index: number): IFunction\n  index: number - function\u0026rsquo;s index. returns: IFunction - retrieved function.  getAll Gets all functions stored in the collection.\n public getAll(): IFunction[]\n  returns: IFunction[] - list with functions.  remove Removes a function by its index.\n public remove(index: number): void\n  index: number - index of the function to be removed.  removeByName Removes a function by its name.\n public removeByName(name: string): void\n  name: string - name of the function to be removed.  ","description":"Implements a list of functions.\n","image":null,"permalink":"/node/expressions/calculator/functions/function_collection/","subtitle":null,"tags":null,"title":"FunctionCollection"},{"content":"Implements: ICommentState\nDescription The GenericCommentState class allows you to create a CommentState object that returns a comment from a scanner.\nFields CR Carrige return or \\n character\n protected CR: number = \u0026lsquo;\\n\u0026rsquo;.charCodeAt(0)\n LF Line feed or \\r character\n protected LF: number = \u0026lsquo;\\r\u0026rsquo;.charCodeAt(0)\n  Instance methods nextToken Either delegates to a comment-handling state, or returns a token with just a slash in it.\n public nextToken(scanner: IScanner, tokenizer: ITokenizer): Token\n  scanner: IScanner - textual string to be tokenized. tokenizer: ITokenizer - tokenizer class that controls the process. returns: Token - next token from the top of the stream.  ","description":"A CommentState object returns a comment from a scanner.\n","image":null,"permalink":"/node/expressions/tokenizers/generic/generic_comment_state/","subtitle":null,"tags":null,"title":"GenericCommentState"},{"content":"Implements: ICommentState\nDescription The GenericNumberState class allows you to create a NumberState object returns a number from a scanner.\nImportant points\n This state\u0026rsquo;s idea of a number allows an optional, initial minus sign, followed by one or more digits. A decimal point and another string of digits may follow these digits.  Fields DOT Represents a dot (.) character.\n protected DOT: number = \u0026lsquo;.'.charCodeAt(0);\n MINUS Represents a minus (-) character.\n protected MINUS: number = \u0026lsquo;-'.charCodeAt(0);\n  Instance methods nextToken Gets the next token from the stream started from the character linked to this state.\n public nextToken(scanner: IScanner, tokenizer: ITokenizer): Token\n  scanner: IScanner - textual string to be tokenized. tokenizer: ITokenizer - tokenizer class that controls the process. returns: Token - next token from the top of the stream.  ","description":"A NumberState object returns a number from a scanner. \n","image":null,"permalink":"/node/expressions/tokenizers/generic/generic_number_state/","subtitle":null,"tags":null,"title":"GenericNumberState"},{"content":"Implements: IQuoteState\nDescription The GenericQuoteState allows you to create a quoteState that returns a quoted string token from a scanner.\nImportant points\n This state will collect characters until it sees a match to the character that the tokenizer used to switch to this state. For example, if a tokenizer uses a double-quote character to enter this state, then nextToken() will search for another double-quote until it finds one or finds the end of the scanner.  Fields DOT Represents a dot (.) character.\n protected DOT: number = \u0026lsquo;.'.charCodeAt(0);\n MINUS Represents a minus (-) character.\n protected MINUS: number = \u0026lsquo;-'.charCodeAt(0);\n  Instance methods decodeString Decodes a string value.\n public decodeString(value: string, quoteSymbol: number): string\n  value: string - string value to be decoded. quoteSymbol: number - string quote character. returns: string - decoded string.  encodeString Encodes a string value.\n public encodeString(value: string, quoteSymbol: number): string\n  value: string - string value to be encoded. quoteSymbol: number - string quote character. returns: string - encoded string.  nextToken Returns a quoted string token from a scanner. This method will collect characters until it sees a match to the character that the tokenizer used to switch to this state.\n public nextToken(scanner: IScanner, tokenizer: ITokenizer): Token\n  scanner: IScanner - textual string to be tokenized. tokenizer: ITokenizer - tokenizer class that controls the process. returns: Token - next token from the top of the stream.  ","description":"A quoteState returns a quoted string token from a scanner. \n","image":null,"permalink":"/node/expressions/tokenizers/generic/generic_quote_state/","subtitle":null,"tags":null,"title":"GenericQuoteState"},{"content":"Implements: ISymbolState\nDescription The GenericSymbolState class allows you to add multi-character symbols and obtain a symbol token from a scanner.\nImportant points\n The idea of a symbol is a character that stands on its own, such as an ampersand or a parenthesis. For example, when tokenizing the expression (isReady)\u0026amp; (isWilling), a typical tokenizer would return 7 tokens, including one for each parenthesis and one for the ampersand. Thus a series of symbols such as )\u0026amp;( becomes three tokens, while a series of letters such as isReady becomes a single word token. Multi-character symbols are an exception to the rule that a symbol is a standalone character. For example, a tokenizer may want less-than-or-equals to tokenize as a single token. This class provides a method for establishing which multi-character symbols an object of this class should treat as single symbols. This allows, for example, \u0026ldquo;cat \u0026lt;= dog\u0026rdquo; to tokenize as three tokens, rather than splitting the less-than and equals symbols into separate tokens. By default, this state recognizes the following multi-character symbols: !=, :-, \u0026lt;=, \u0026gt;=  Instance methods add Adds a multi-character symbol.\n public add(value: string, tokenType: TokenType): void\n  value: string - symbol to add, such as \u0026quot;=:=\u0026quot; tokenType: TokenType - type of token  nextToken Returns a symbol token from a scanner.\n public nextToken(scanner: IScanner, tokenizer: ITokenizer): Token\n  scanner: IScanner - textual string to be tokenized. tokenizer: ITokenizer - tokenizer class that controls the process. returns: Token - next token from the top of the stream.  ","description":"The GenericSymbolState class allows you to add multi-character symbols and obtain a symbol token from a scanner.\n","image":null,"permalink":"/node/expressions/tokenizers/generic/generic_symbol_state/","subtitle":null,"tags":null,"title":"GenericSymbolState"},{"content":"Extends: AbstractTokenizer\nDescription The GenericTokenizer allows you to implement a default tokenizer class.\nConstructors Creates an instance of GenericTokenizer\n public constructor()\n ","description":"Implements a default tokenizer class.\n","image":null,"permalink":"/node/expressions/tokenizers/generic/generic_tokenizer/","subtitle":null,"tags":null,"title":"GenericTokenizer"},{"content":"Implements: IWhitespaceState\nDescription The GenericWhitespaceState allows you to create a whitespace state.\nImportant points\n A whitespace state ignores whitespace (such as blanks and tabs), and returns the tokenizer\u0026rsquo;s next token. By default, all characters from 0 to 32 are whitespace.  Constructors Constructs a whitespace state with a default idea of what characters are, in fact, whitespace.\n public constructor()\n Instance methods clearWhitespaceChars Clears definitions of whitespace characters.\n public clearWhitespaceChars(): void\n nextToken Ignores whitespace (such as blanks and tabs), and returns the tokenizer\u0026rsquo;s next token.\n public nextToken(scanner: IScanner, tokenizer: ITokenizer): Token\n  scanner: IScanner - textual string to be tokenized. tokenizer: ITokenizer - tokenizer class that controls the process. returns: Token - next token from the top of the stream.  setWhitespaceChars Establishes the given characters as whitespace to ignore.\n public setWhitespaceChars(fromSymbol: number, toSymbol: number, enable: boolean): void\n  fromSymbol: number - first character index of the interval. toSymbol: number - last character index of the interval. enable: boolean - true if this state should ignore characters in the given range.  ","description":"Creates a whitespace state.\n","image":null,"permalink":"/node/expressions/tokenizers/generic/generic_whitespace_state/","subtitle":null,"tags":null,"title":"GenericWhitespaceState"},{"content":"Implements: IWordState\nDescription The GenericWordState class allows you to create a WordState that returns a word from a scanner.\nImportant points\n Like other states, a tokenizer transfers the job of reading to this state, depending on an initial character. This state determines which characters may appear as a second or later character in a word. These are typically different sets of characters; in particular, it is typical for digits to appear as parts of a word, but not as the initial character of a word. By default, the following characters may appear in a word (The method setWordChars() allows customizing this):   From To 'a', 'z' 'A', 'Z' '0', '9' *  As well as: minus sign, underscore, and apostrophe.\nConstructors Constructs a word state with a default idea of what characters are admissible inside a word (as described in the class comment).\n public constructor()\n Instance methods clearWordChars Clears definitions of word chars.\n public clearWordChars(): void\n nextToken Ignores a word (such as blanks and tabs), and returns the tokenizer\u0026rsquo;s next token.\n public nextToken(scanner: IScanner, tokenizer: ITokenizer): Token\n  scanner: IScanner - textual string to be tokenized. tokenizer: ITokenizer - tokenizer class that controls the process. returns: Token - next token from the top of the stream.  setWhitespaceChars Establishes characters in the given range as valid characters for part of a word after the first character. Note that the tokenizer must determine which characters are valid as the beginning character of a word.\n public setWordChars(fromSymbol: number, toSymbol: number, enable: boolean): void\n  fromSymbol: number - first character index of the interval. toSymbol: number - last character index of the interval. enable: boolean - true if this state should ignore characters in the given range.  ","description":"A WordState returns a word from a scanner. \n","image":null,"permalink":"/node/expressions/tokenizers/generic/generic_word_state/","subtitle":null,"tags":null,"title":"GenericWordState"},{"content":"Implements: IOpenable, IReferenceable, IConfigurable\nDescription The GrpcClient class allows you to create clients that call remote endpoints using the GRPC protocol.\nConfiguration parameters  connection(s):  discovery_key: (optional) key to retrieve the connection from IDiscovery protocol: connection protocol: http or https host: host name or IP address port: port number uri: resource URI or connection string with all parameters in it   options:  retries: number of retries (default: 3) connect_timeout: connection timeout in milliseconds (default: 10 sec) timeout: invocation timeout in milliseconds (default: 10 sec)    Constructors Creates a new instance of the grpc client.\n NewGrpcClient(name string) *GrpcClient\n  name: string - service name.  Fields Client The GRPC client.\n Client: grpcproto.CommandableClient\n Connection The GRPC connection\n Connection *grpc.ClientConn\n ConnectionResolver The connection resolver.\n _connectionResolver: *HttpConnectionResolver\n Logger The logger.\n Logger: *CompositeLogger()\n Counters The performance counters.\n Counters: *CompositeCounters()\n Options The configuration options.\n Options: *ConfigParams()\n ConnectTimeout The connection timeout in milliseconds.\n ConnectTimeout: time.Duration\n Timeout The invocation timeout in milliseconds.\n Timeout: time.Duration\n Uri The remote service uri which is calculated on openning.\n Uri: string\n interceptors interceptors\n interceptors []grpc.DialOption\n  Instance methods AddInterceptors AddInterceptors method are registers a middleware for methods in gRPC client.\nSee See interceptor\n (c *GrpcClient) AddInterceptors(interceptors \u0026hellip;grpc.DialOption)\n  interceptors: \u0026hellip;grpc.DialOption - interceptor functions (Stream or Unary use grpc.WithUnaryInterceptor() or grpc.WithStreamInterceptor() for inflate in grpc.ServerOption)  AddFilterParams AddFilterParams method are adds filter parameters (with the same name as they defined)\n (c *GrpcClient) AddFilterParams(params *cdata.StringValueMap, filter *cdata.FilterParams) *cdata.StringValueMap\n  params: *cdata.StringValueMap - invocation parameters. filter: *cdata.FilterParams - (optional) filter parameters. returns: *cdata.StringValueMap - invocation parameters with added filter parameters.  AddFilterParams AddFilterParams method are adds filter parameters (with the same name as they defined)\n (c *GrpcClient) AddPagingParams(params *cdata.StringValueMap, paging *cdata.PagingParams) *cdata.StringValueMap\n  params: *cdata.StringValueMap - invocation parameters. filter: *cdata.PagingParams - (optional) filter parameters. returns: *cdata.StringValueMap - invocation parameters with added filter parameters.  Call Calls a remote method via GRPC protocol.\n (c *GrpcClient) Call(method string, correlationId string, request interface{}, response interface{}) error\n  method: string - name of the calling method client: interface{} - current client request: interface{} - (optional) request object. returns: error - error or nil no errors occured.  CallWithContext CallWithContext method are calls a remote method via gRPC protocol.\n (c *GrpcClient) CallWithContext(ctx context.Context, correlationId string, method string, request interface{}, response interface{}) error\n  ctx: context.Context - context correlationId: string - transaction id to trace execution through call chain. method: string - gRPC method name request: interface{} - request query parameters. response: interface{} - response body object. returns: error - error or nil no errors occured.  Close Closes the component and frees used resources.\n (c *GrpcClient) Close(correlationId string) error\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. returns: error - error or nil no errors occured.  Configure Configures the component by passing its configuration parameters.\n (c *GrpcClient) Configure(config *cconf.ConfigParams)\n  config: *cconf.ConfigParams - configuration parameters to be set.  Instrument Adds instrumentation to log calls and measures call time. It returns a CounterTiming object that is used to end the time measurement.\n (c *GrpcClient) Instrument(correlationId string, name string) *ccount.CounterTiming\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. name: string - method name. returns: *ccount.CounterTiming - CounterTiming object used to end the time measurement.  InstrumentError Adds instrumentation to error handling.\n (c *GrpcClient) InstrumentError(correlationId string, name string, inErr error, inRes interface{}) (result interface{}, err error)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. name: string - method name. inErr: error - occured error inRes: interface{} - (optional) an execution result returns: (result interface{}, err error) - input result and error.  IsOpen Checks if the component is open.\n (c *GrpcClient) IsOpen() bool\n  returns: bool - Returns True if the component is open and False otherwise.  open Opens the component.\n (c *GrpcClient) Open(correlationId string) error\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. returns: error - error or nil no errors occured.  SetReferences Sets references to dependent components.\n (c *GrpcClient) SetReferences(references cref.IReferences)\n  references: cref.IReferences - references to locate the component dependencies.  Examples type MyCommandableHttpClient struct{ *CommandableHttpClient } func (c *MyCommandableHttpClient) GetData(correlationId string, id string) (res interface{}, err error) { req := \u0026amp;testproto.MyDataIdRequest{ CorrelationId: correlationId, mydataId: id, } reply := new(testproto.MyData) err = c.Call(\u0026#34;get_mydata_by_id\u0026#34;, correlationId, req, reply) c.Instrument(correlationId, \u0026#34;mydata.get_one_by_id\u0026#34;) if err != nil { return nil, err } result = toMyData(reply) if result != nil \u0026amp;\u0026amp; result.Id == \u0026#34;\u0026#34; \u0026amp;\u0026amp; result.Key == \u0026#34;\u0026#34; { result = nil } return result, nil } var client = NewMyCommandableHttpClient(); client.Configure(NewConfigParamsFromTuples( \u0026#34;connection.protocol\u0026#34;, \u0026#34;http\u0026#34;, \u0026#34;connection.host\u0026#34;, \u0026#34;localhost\u0026#34;, \u0026#34;connection.port\u0026#34;, 8080, )); result, err := client.GetData(\u0026#34;123\u0026#34;, \u0026#34;1\u0026#34;) ... ","description":"Abstract client that calls remote endpoints using the GRPC protocol.\n","image":null,"permalink":"/golang/grpc/clients/grpc_client/","subtitle":null,"tags":null,"title":"GrpcClient"},{"content":"Inherits: IOpenable, IReferenceable, IConfigurable\nDescription The GrpcClient class allows you to create clients that call remote endpoints using the GRPC protocol.\nConfiguration parameters  connection(s):  discovery_key: (optional) key to retrieve the connection from IDiscovery protocol: connection protocol: http or https host: host name or IP address port: port number uri: resource URI or connection string with all parameters in it   options:  retries: number of retries (default: 3) connect_timeout: connection timeout in milliseconds (default: 10 sec) timeout: invocation timeout in milliseconds (default: 10 sec)    Constructors Creates a new instance of the grpc client.\n public GrpcClient(string name = null)\n  name: string - client\u0026rsquo;s name.  Fields _connectionResolver The connection resolver.\n protected _connectionResolver: HttpConnectionResolver\n _logger The logger.\n protected _logger: CompositeLogger()\n _counters The performance counters.\n protected _counters: CompositeCounters()\n _options The configuration options.\n protected _options: ConfigParams()\n _connectTimeout The connection timeout in milliseconds.\n protected _connectTimeout: int = 100000\n _serviceName TODO: add description\n protected _serviceName: string\n  Instance methods CallAsync Calls a remote method via GRPC protocol.\n protected Task\u0026lt;TResponse\u0026gt; CallAsync\u0026lt;TRequest, TResponse\u0026gt;(string name, TRequest request)\n  name: string - name of the calling method request: TRequest - request object. returns: Task\u0026lt;TResponse\u0026gt; - feature that receives the result object .  CloseAsync Closes the component and frees used resources.\n public virtual Task CloseAsync(string correlationId)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain.  Configure Configures the component by passing its configuration parameters.\n public virtual void Configure(ConfigParams config)\n  config: ConfigParams - configuration parameters to be set.  Instrument Adds instrumentation to log calls and measures call time. It returns a CounterTiming object that is used to end the time measurement.\n protected CounterTiming Instrument(string correlationId, [CallerMemberName] string methodName = null)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. methodName: string - method name. returns: CounterTiming - CounterTiming object used to end the time measurement.  InstrumentError Adds instrumentation to error handling.\n protected void InstrumentError(string correlationId, [CallerMemberName] string methodName = null, Exception ex = null, bool rethrow = false)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. methodName: string - method name. ex: Exception - occured error rethrow: bool - if True - throw error  IsOpen Checks if the component is open.\n public virtual bool IsOpen()\n  returns: bool - Returns True if the component is open and False otherwise.  Open Opens the component.\n public virtual Task OpenAsync(string correlationId)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain.  GetOrCreateMethod Creates a method definition to be called using GRPC.\n where TRequest : class, IMessage\u0026lt;TRequest\u0026gt;, new() where TResponse : class, IMessage\u0026lt;TResponse\u0026gt;, new()   protected Method\u0026lt;TRequest, TResponse\u0026gt; GetOrCreateMethod\u0026lt;TRequest, TResponse\u0026gt;(string name)\n  name: string - name of gRPC method returns: Method\u0026lt;TRequest, TResponse\u0026gt; - TRequest - type of request message, TResponse - type of response message.  SetReferences Sets references to dependent components.\n public virtual void SetReferences(IReferences references)\n  references: IReferences - references to locate the component dependencies.  Examples class MyCommandableHttpClient: GrpcClient, IMyClient { ... public MyData GetData(string correlationId, string id) { var timing = this.Instrument(correlationId, \u0026#39;myclient.get_data\u0026#39;); var request = new MyDataObjectRequest { CorrelationId = correlationId, MyDataId = ConvertFromPublic(id) }; var item = await this.CallAsync\u0026lt;MyDataObjectRequest, ProtoMyData\u0026gt;(\u0026#34;get_data\u0026#34;, correlationId, request); timing.EndTiming(); return ConvertToPublic(item); } ... } var client = new MyGrpcClient(); client.Configure(ConfigParams.FromTuples( \u0026#34;connection.protocol\u0026#34;, \u0026#34;http\u0026#34;, \u0026#34;connection.host\u0026#34;, \u0026#34;localhost\u0026#34;, \u0026#34;connection.port\u0026#34;, 8080 )); client.GetData(\u0026#34;123\u0026#34;, \u0026#34;1\u0026#34;); ","description":"Abstract client that calls remote endpoints using the GRPC protocol.\n","image":null,"permalink":"/net/grpc/clients/grpc_client/","subtitle":null,"tags":null,"title":"GrpcClient"},{"content":"Implements: IOpenable, IReferenceable, IConfigurable\nDescription The GrpcClient class allows you to create clients that call remote endpoints using the GRPC protocol.\nConfiguration parameters  connection(s):  discovery_key: (optional) key to retrieve the connection from IDiscovery protocol: connection protocol: http or https host: host name or IP address port: port number uri: resource URI or connection string with all parameters in it   options:  retries: number of retries (default: 3) connect_timeout: connection timeout in milliseconds (default: 10 sec) timeout: invocation timeout in milliseconds (default: 10 sec)    Constructors Creates a new instance of the grpc client.\n public constructor(clientTypeOrPath: any, clientName?: string, packageOptions?: any)\n  clientTypeOrPath: any - TODO: add description clientName: string - client\u0026rsquo;s name. packageOptions: any - TODO: add description  Fields _client The GRPC client.\n protected _client: any\n _connectionResolver The connection resolver.\n protected _connectionResolver: HttpConnectionResolver\n _logger The logger.\n protected _logger: CompositeLogger()\n _counters The performance counters.\n protected _counters: CompositeCounters()\n _options The configuration options.\n protected _options: ConfigParams()\n _connectTimeout The connection timeout in milliseconds.\n protected _connectTimeout: number = 100000\n _timeout The invocation timeout in milliseconds.\n protected _timeout: number = 100000\n _uri The remote service uri which is calculated on openning.\n protected _uri: string\n  Instance methods call Calls a remote method via GRPC protocol.\n protected call(method: string, correlationId?: string, request: any = {}): Promise\u0026lt;any\u0026gt;\n  method: string - name of the calling method client: any - current client request: any - (optional) request object. returns: Promise\u0026lt;any\u0026gt; - (optional) feature that receives the result object or error.  close Closes the component and frees used resources.\n public close(correlationId: string): Promise\u0026lt;void\u0026gt;\n  correlationId: string - (optional) transaction id used to trace execution through the call chain.  configure Configures the component by passing its configuration parameters.\n public configure(config: ConfigParams): void\n  config: ConfigParams - configuration parameters to be set.  instrument Adds instrumentation to log calls and measures call time. It returns a CounterTiming object that is used to end the time measurement.\n protected instrument(correlationId: string, name: string): CounterTiming\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. name: string - method name. returns: CounterTiming - CounterTiming object used to end the time measurement.  instrumentError Adds instrumentation to error handling.\n protected instrumentError(correlationId: string, name: string, err: any, result: any = null, callback: (err: any, result: any) =\u0026gt; void = null): void\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. name: string - method name. err: Exception - occured error result: any - (optional) an execution result callback: (err: any, result: any) =\u0026gt; void - (optional) an execution callback  isOpen Checks if the component is open.\n public isOpen(): boolean\n  returns: boolean - Returns True if the component is open and False otherwise.  open Opens the component.\n public open(correlationId: string): Promise\u0026lt;void\u0026gt;\n  correlationId: string - (optional) transaction id used to trace execution through the call chain.  setReferences Sets references to dependent components.\n public setReferences(references: IReferences): void\n  references: IReferences - references to locate the component dependencies.  Examples class MyGrpcClient extends GrpcClient implements IMyClient { ... public getData(correlationId: string, id: string, callback: (err: any, result: MyData) =\u0026gt; void): void { let timing = this.instrument(correlationId, \u0026#39;myclient.get_data\u0026#39;); this.call(\u0026#34;get_data\u0026#34;, correlationId, { id: id }, (err, result) =\u0026gt; { timing.endTiming(); callback(err, result); }); } ... } let client = new MyGrpcClient(); client.configure(ConfigParams.fromTuples( \u0026#34;connection.protocol\u0026#34;, \u0026#34;http\u0026#34;, \u0026#34;connection.host\u0026#34;, \u0026#34;localhost\u0026#34;, \u0026#34;connection.port\u0026#34;, 8080 )); client.getData(\u0026#34;123\u0026#34;, \u0026#34;1\u0026#34;, (err, result) =\u0026gt; { ... }); ","description":"Abstract client that calls remote endpoints using the GRPC protocol.\n","image":null,"permalink":"/node/grpc/clients/grpc_client/","subtitle":null,"tags":null,"title":"GrpcClient"},{"content":"Implements: IOpenable, IReferenceable, IConfigurable\nDescription The GrpcClient class allows you to create clients that call remote endpoints using the GRPC protocol.\nConfiguration parameters  connection(s):  discovery_key: (optional) key to retrieve the connection from IDiscovery protocol: connection protocol: http or https host: host name or IP address port: port number uri: resource URI or connection string with all parameters in it   options:  retries: number of retries (default: 3) connect_timeout: connection timeout in milliseconds (default: 10 sec) timeout: invocation timeout in milliseconds (default: 10 sec)    Constructors Creates a new instance of the grpc client.\n GrpcClient(client_name: str)\n  client_name: str - client\u0026rsquo;s name.  Fields _channel The GRPC client channel\n _channel: grpc.Channel\n _connection_resolver The connection resolver.\n _connection_resolver: HttpConnectionResolver\n _logger The logger.\n _logger: CompositeLogger\n _counters The performance counters.\n _counters: CompositeCounters\n _options The configuration options.\n _options: ConfigParams\n _connection_timeout The connection timeout in milliseconds.\n _connection_timeout = 100000\n _timeout The invocation timeout in milliseconds.\n _timeout = 100000\n _uri The remote service uri which is calculated on openning.\n _uri: string\n  Instance methods _add_filter_params AddFilterParams method adds filter parameters (with the same name as they defined) to the invocation parameter map.\n _add_filter_params(params: Any, filter: Any): Any\n  params: Any - invocation parameters. filter: Any - (optional) filter parameters returns: Any - invocation parameters with added filter parameters.  _add_paging_params AddPagingParams method adds paging parameters (skip, take, total) to the invocation parameter map.\n _add_filter_params(params: Any, paging: Any): Any\n  params: Any - invocation parameters. paging: Any - (optional) paging parameters returns: Any - invocation parameters with added paging parameters.  call Calls a remote method via GRPC protocol.\n call(method: str, client: Any, request: Any): Any\n  method: str - name of the calling method client: Any - current client request: Any - (optional) request object. returns: Any - (optional) feature that receives the result object or error.  close Closes the component and frees used resources.\n close(correlation_id: Optional[str])\n  correlation_id: Optional[str] - (optional) transaction id used to trace execution through the call chain.  configure Configures the component by passing its configuration parameters.\n configure(config: ConfigParams)\n  config: ConfigParams - configuration parameters to be set.  _instrument Adds instrumentation to log calls and measures call time. It returns a CounterTiming object that is used to end the time measurement.\n _instrument(correlation_id: Optional[str], name: str): CounterTiming\n  correlation_id: Optional[str] - (optional) transaction id used to trace execution through the call chain. name: str - method name. returns: CounterTiming - CounterTiming object used to end the time measurement.  _instrument_error Adds instrumentation to error handling.\n _instrument_error(correlation_id: Optional[str], name: str, err: Exception, reerror=False)\n  correlation_id: Optional[str] - (optional) transaction id used to trace execution through the call chain. name: str - method name. err: Exception - occured error reerror: bool - if True - throw error  is_open Checks if the component is open.\n is_open(): bool\n  returns: bool - Returns True if the component is open and False otherwise.  open Opens the component.\n open(correlation_id: Optional[str])\n  correlation_id: Optional[str] - (optional) transaction id used to trace execution through the call chain.  set_references Sets references to dependent components.\n set_references(references: IReferences)\n  references: IReferences - references to locate the component dependencies.  Examples class MyGrpcClient(GrpcClient, IMyClient): ... def get_data(self, correlation_id, id ): timing = self.instrument(correlation_id, \u0026#39;myclient.get_data\u0026#39;) result = self.call(\u0026#34;get_data\u0026#34;, correlation_id, { id: id }) timing.end_timing() return result ... client = MyGrpcClient() client.configure(ConfigParams.from_tuples( \u0026#34;connection.protocol\u0026#34;, \u0026#34;http\u0026#34;, \u0026#34;connection.host\u0026#34;, \u0026#34;localhost\u0026#34;, \u0026#34;connection.port\u0026#34;, 8080 )) result = client.get_data(\u0026#34;123\u0026#34;, \u0026#34;1\u0026#34;) ","description":"Abstract client that calls remote endpoints using the GRPC protocol.\n","image":null,"permalink":"/python/grpc/clients/grpc_client/","subtitle":null,"tags":null,"title":"GrpcClient"},{"content":"Description The GrpcEndpoint class allows you to create GRPC endpoints. An endpoint is a URL, at which a given service can be accessed by a client.\nConfiguration parameters Parameters to pass to the :func:configure method for component configuration:\nconnection(s): the connection resolver\u0026rsquo;s connections:\n \u0026ldquo;connection.discovery_key\u0026rdquo;: key used for connection resolving in a discovery service; \u0026ldquo;connection.protocol\u0026rdquo;: connection\u0026rsquo;s protocol; \u0026ldquo;connection.host\u0026rdquo;: target host; \u0026ldquo;connection.port\u0026rdquo;: target port; \u0026ldquo;connection.uri\u0026rdquo;: target URI. credential: HTTPS credentials: \u0026ldquo;credential.ssl_key_file\u0026rdquo;: SSL private key in PEM \u0026ldquo;credential.ssl_crt_file\u0026rdquo;: SSL certificate in PEM \u0026ldquo;credential.ssl_ca_file\u0026rdquo;: certificate authorities (root cerfiticates) in PEM  References A logger, counters, and a connection resolver can be referenced by passing the following references to the object\u0026rsquo;s set_references\n *:discovery:*:*:1.0 - (optional) IDiscovery services *:logger:*:*:1.0 - (optional) ILogger components to pass log messages *:counters:*:*:1.0 - (optional) ICounters components to pass collected measurementsand as specified by the counter\u0026rsquo;s source.  Constructors NewGrpcEndpoint NewGrpcEndpoint method are creates new instance of GrpcEndpoint\n NewGrpcEndpoint() *GrpcEndpoint\n Instance methods AddInterceptors AddInterceptors method are registers a middleware for methods in GRPC endpoint.\nSee interceptor\n (c *GrpcEndpoint) AddInterceptors(interceptors \u0026hellip;grpc.ServerOption)\n  interceptors: \u0026hellip;grpc.ServerOption - interceptor functions (Stream or Unary use grpc.UnaryInterceptor() or grpc.StreamInterceptor() for inflate in grpc.ServerOption)  Close Closes this endpoint and the GRPC server (service) that was opened earlier.\n (c *GrpcEndpoint) Close(correlationId string) (err error)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. returns: (err error) - error or nil no errors occured.  Configure Configures this HttpEndpoint using the given configuration parameters.\n (c *GrpcEndpoint) Configure(config *cconf.ConfigParams)\n  config: *cconf.ConfigParams - configuration parameters, containing a \u0026ldquo;connection(s)\u0026rdquo; section.  IsOpen Checks if the component is open.\n (c *GrpcEndpoint) IsOpen() bool\n  returns: bool - whether or not this endpoint is open with an actively listening GRPC server.  Open Opens a connection using the parameters resolved by the referenced connection resolver and creates a GRPC server (service) using the set options and parameters.\n (c *GrpcEndpoint) Open(correlationId string) (err error)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. returns: (err error) - error or nil no errors occured.  Register Registers a registerable object for dynamic endpoint discovery.\n (c *GrpcEndpoint) Register(registration IRegisterable)\n  registration: IRegisterable - registration to be added.  RegisterCommandableMethod Registers a commandable method in the object\u0026rsquo;s GRPC server (service) by the given name.\n (c *GrpcEndpoint) RegisterCommandableMethod(method string, schema *cvalid.Schema, action func(correlationId string, args *crun.Parameters) (result interface{}, err error))\n  method: string - GRPC method name. schema: *cvalid.Schema - schema to use for parameter validation. action: func(correlationId string, args *crun.Parameters) (result interface{}, err error) - action to perform at the given route.  RegisterService Registers a service with related implementation\n (c *GrpcEndpoint) RegisterService(sd *grpc.ServiceDesc, implementation interface{})\n  sd: *grpc.ServiceDesc - a GRPC service object. implementation: interface{} - the service implementation methods.  SetReferences Sets references to this endpoint\u0026rsquo;s logger, counters, and connection resolver.\n (c *GrpcEndpoint) SetReferences(references cref.IReferences)\n  references: cref.IReferences - an IReferences object, containing references to a logger, counters, and a connection resolver.  Unregister Unregisters a registerable object, so that it is no longer used in dynamic\n (c *GrpcEndpoint) Unregister(registration IRegisterable)\n  registration: IRegisterable - the registration to remove.  Examples func (c* Endpoint) MyMethod(config ConfigParams, references IReferences) { endpoint := NewGrpcEndpoint(); if c.config != nil { endpoint.Configure(c._config); } if c.references != nil { endpoint.SetReferences(c.references); } ... err := c.endpoint.Open(correlationId) if err != nil { // error ocured  return err } c.Opened = true return nil ... } ","description":"Used for creating GRPC endpoints. \n","image":null,"permalink":"/golang/grpc/services/grpc_endpoint/","subtitle":null,"tags":null,"title":"GrpcEndpoint"},{"content":"Inherits: IOpenable, IConfigurable, IReferenceable\nDescription The GrpcEndpoint class allows you to create GRPC endpoints. An endpoint is a URL, at which a given service can be accessed by a client.\nConfiguration parameters Parameters to pass to the :func:configure method for component configuration:\nconnection(s): the connection resolver\u0026rsquo;s connections:\n \u0026ldquo;connection.discovery_key\u0026rdquo;: key used for connection resolving in a discovery service; \u0026ldquo;connection.protocol\u0026rdquo;: connection\u0026rsquo;s protocol; \u0026ldquo;connection.host\u0026rdquo;: target host; \u0026ldquo;connection.port\u0026rdquo;: target port; \u0026ldquo;connection.uri\u0026rdquo;: target URI. credential: HTTPS credentials: \u0026ldquo;credential.ssl_key_file\u0026rdquo;: SSL private key in PEM \u0026ldquo;credential.ssl_crt_file\u0026rdquo;: SSL certificate in PEM \u0026ldquo;credential.ssl_ca_file\u0026rdquo;: certificate authorities (root cerfiticates) in PEM  References A logger, counters, and a connection resolver can be referenced by passing the following references to the object\u0026rsquo;s set_references\n *:discovery:*:*:1.0 - (optional) IDiscovery services *:logger:*:*:1.0 - (optional) ILogger components to pass log messages *:counters:*:*:1.0 - (optional) ICounters components to pass collected measurementsand as specified by the counter\u0026rsquo;s source.  Instance methods Close Closes this endpoint and the GRPC server (service) that was opened earlier.\n public virtual Task CloseAsync(string correlationId)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain.  Configure Configures this HttpEndpoint using the given configuration parameters.\n public virtual void Configure(ConfigParams config)\n  config: ConfigParams - configuration parameters, containing a \u0026ldquo;connection(s)\u0026rdquo; section.  Instrument Adds instrumentation to log calls and measure call time. It returns a CounterTiming object that is used to end the time measurement.\n protected CounterTiming Instrument(string correlationId, string name)\n  correlationId: string - (optional) transaction id to trace execution through call chain. name: string - a method name. returns: CounterTiming - CounterTiming object to end the time measurement.  IsOpen Checks if the component is open.\n public virtual bool IsOpen()\n  returns: bool - whether or not this endpoint is open with an actively listening GRPC server.  Open Opens a connection using the parameters resolved by the referenced connection resolver and creates a GRPC server (service) using the set options and parameters.\n public virtual Task OpenAsync(string correlationId)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain.  Register Registers a registerable object for dynamic endpoint discovery.\n public void Register(IRegisterable registration)\n  registration: IRegisterable - registration to be added.  RegisterService Registers a service with related implementation\n public void RegisterService(ServerServiceDefinition serverServiceDefinition)\n  serverServiceDefinition: ServerServiceDefinition - a GRPC service object.  SetReferences Sets references to this endpoint\u0026rsquo;s logger, counters, and connection resolver.\n public virtual void SetReferences(IReferences references)\n  references: IReferences - an IReferences object, containing references to a logger, counters, and a connection resolver.  Unregister Unregisters a registerable object, so that it is no longer used in dynamic\n public void Unregister(IRegisterable registration)\n  registration: IRegisterable - the registration to remove.  Examples public MyMethod(string correlationId, ConfigParams _config, IReferences _references) { var endpoint = new HttpEndpoint(); if (this._config) endpoint.Configure(this._config); if (this._references) endpoint.SetReferences(this._references); ... this._endpoint.Open(correlationId); ... } ","description":"Used for creating GRPC endpoints. \n","image":null,"permalink":"/net/grpc/services/grpc_endpoint/","subtitle":null,"tags":null,"title":"GrpcEndpoint"},{"content":"Implements: IOpenable, IConfigurable, IReferenceable\nDescription The GrpcEndpoint class allows you to create GRPC endpoints. An endpoint is a URL, at which a given service can be accessed by a client.\nConfiguration parameters Parameters to pass to the :func:configure method for component configuration:\nconnection(s): the connection resolver\u0026rsquo;s connections:\n \u0026ldquo;connection.discovery_key\u0026rdquo;: key used for connection resolving in a discovery service; \u0026ldquo;connection.protocol\u0026rdquo;: connection\u0026rsquo;s protocol; \u0026ldquo;connection.host\u0026rdquo;: target host; \u0026ldquo;connection.port\u0026rdquo;: target port; \u0026ldquo;connection.uri\u0026rdquo;: target URI. credential: HTTPS credentials: \u0026ldquo;credential.ssl_key_file\u0026rdquo;: SSL private key in PEM \u0026ldquo;credential.ssl_crt_file\u0026rdquo;: SSL certificate in PEM \u0026ldquo;credential.ssl_ca_file\u0026rdquo;: certificate authorities (root cerfiticates) in PEM  References A logger, counters, and a connection resolver can be referenced by passing the following references to the object\u0026rsquo;s set_references\n *:discovery:*:*:1.0 - (optional) IDiscovery services *:logger:*:*:1.0 - (optional) ILogger components to pass log messages *:counters:*:*:1.0 - (optional) ICounters components to pass collected measurementsand as specified by the counter\u0026rsquo;s source.  Instance methods close Closes this endpoint and the GRPC server (service) that was opened earlier.\n public close(correlationId: string): Promise\u0026lt;void\u0026gt;\n  correlationId: string - (optional) transaction id used to trace execution through the call chain.  configure Configures this HttpEndpoint using the given configuration parameters.\n public configure(config: ConfigParams): void\n  config: ConfigParams - configuration parameters, containing a \u0026ldquo;connection(s)\u0026rdquo; section.  isOpen Checks if the component is open.\n public isOpen(): boolean\n  returns: boolean - whether or not this endpoint is open with an actively listening GRPC server.  open Opens a connection using the parameters resolved by the referenced connection resolver and creates a GRPC server (service) using the set options and parameters.\n public open(correlationId: string): Promise\u0026lt;void\u0026gt;\n  correlationId: string - (optional) transaction id used to trace execution through the call chain.  register Registers a registerable object for dynamic endpoint discovery.\n public register(registration: IRegisterable): void\n  registration: IRegisterable - registration to be added.  registerCommandableMethod Registers a commandable method in the object\u0026rsquo;s GRPC server (service) by the given name.\n public registerCommandableMethod(method: string, schema: Schema, action: (call: any) =\u0026gt; Promise\u0026lt;any\u0026gt;): void\n  method: string - GRPC method name. schema: Schema - schema to use for parameter validation. action: (call: any) =\u0026gt; Promise\u0026lt;any\u0026gt; - action to perform at the given route.  registerService Registers a service with related implementation\n public registerService(service: any, implementation: any): void\n  service: any - a GRPC service object. implementation: any - the service implementation methods.  setReferences Sets references to this endpoint\u0026rsquo;s logger, counters, and connection resolver.\n public setReferences(references: IReferences): void\n  references: IReferences - an IReferences object, containing references to a logger, counters, and a connection resolver.  unregister Unregisters a registerable object, so that it is no longer used in dynamic\n public unregister(registration: IRegisterable): void\n  registration: IRegisterable - the registration to remove.  Examples public MyMethod(_config: ConfigParams, _references: IReferences) { let endpoint = new HttpEndpoint(); if (this._config) endpoint.configure(this._config); if (this._references) endpoint.setReferences(this._references); ... await this._endpoint.open(correlationId); } ","description":"Used for creating GRPC endpoints. \n","image":null,"permalink":"/node/grpc/services/grpc_endpoint/","subtitle":null,"tags":null,"title":"GrpcEndpoint"},{"content":"Implements: IOpenable, IConfigurable, IReferenceable\nDescription The GrpcEndpoint class allows you to create GRPC endpoints. An endpoint is a URL, at which a given service can be accessed by a client.\nConfiguration parameters Parameters to pass to the :func:configure method for component configuration:\nconnection(s): the connection resolver\u0026rsquo;s connections:\n \u0026ldquo;connection.discovery_key\u0026rdquo;: key used for connection resolving in a discovery service; \u0026ldquo;connection.protocol\u0026rdquo;: connection\u0026rsquo;s protocol; \u0026ldquo;connection.host\u0026rdquo;: target host; \u0026ldquo;connection.port\u0026rdquo;: target port; \u0026ldquo;connection.uri\u0026rdquo;: target URI. credential: HTTPS credentials: \u0026ldquo;credential.ssl_key_file\u0026rdquo;: SSL private key in PEM \u0026ldquo;credential.ssl_crt_file\u0026rdquo;: SSL certificate in PEM \u0026ldquo;credential.ssl_ca_file\u0026rdquo;: certificate authorities (root cerfiticates) in PEM  References A logger, counters, and a connection resolver can be referenced by passing the following references to the object\u0026rsquo;s set_references\n *:discovery:*:*:1.0 - (optional) IDiscovery services *:logger:*:*:1.0 - (optional) ILogger components to pass log messages *:counters:*:*:1.0 - (optional) ICounters components to pass collected measurementsand as specified by the counter\u0026rsquo;s source.  Instance methods close Closes this endpoint and the GRPC server (service) that was opened earlier.\n close(correlation_id: Optional[str])\n  correlation_id: Optional[str] - (optional) transaction id used to trace execution through the call chain.  configure Configures this HttpEndpoint using the given configuration parameters.\n configure(config: ConfigParams)\n  config: ConfigParams - configuration parameters, containing a \u0026ldquo;connection(s)\u0026rdquo; section.  is_open Checks if the component is open.\n is_open(): bool\n  returns: bool - whether or not this endpoint is open with an actively listening GRPC server.  open Opens a connection using the parameters resolved by the referenced connection resolver and creates a GRPC server (service) using the set options and parameters.\n open(correlation_id: Optional[str])\n  correlation_id: Optional[str] - (optional) transaction id used to trace execution through the call chain.  register Registers a registerable object for dynamic endpoint discovery.\n register(registration: IRegisterable)\n  registration: IRegisterable - registration to be added.  _register_commandable_method Registers a commandable method in the object\u0026rsquo;s GRPC server (service) by the given name.\n _register_commandable_method(method: str, schema: Schema, action: Callable[[Optional[str], Optional[str], Parameters], None])\n  method: str - GRPC method name. schema: Schema - schema to use for parameter validation. action: Callable[[Optional[str], Optional[str], Parameters], None] - action to perform at the given route.  _register_interceptor Registers a middleware for methods in GRPC endpoint.\n _register_interceptor(interceptor: Callable)\n  interceptor: Callable - the middleware action to perform at the given route.  _register_method! TODO: this method is not implemented for Python\nRegisters a middleware for methods in GRPC endpoint.\n _register_method(name: str, schema: Schema, action: action: Callable[[Optional[str], Optional[str], Parameters], None])\n  name: str - a method name schema: Schema - a validation schema to validate received parameters. action: Callable[[Optional[str], Optional[str], Parameters], None] - an action function that is called when operation is invoked.  Examples def my_method(self, _config, _references): endpoint = GrpcEndpoint() if self._config: endpoint.configure(self._config) if self._references: endpoint.set_references(self._references) ... self._endpoint.open(correlation_id) ... ","description":"Used for creating GRPC endpoints. \n","image":null,"permalink":"/python/grpc/services/grpc_endpoint/","subtitle":null,"tags":null,"title":"GrpcEndpoint"},{"content":"Description The GrpcService class allows you to create services that receive remote calls via the GRPC protocol.\nConfiguration parameters  dependencies:  endpoint: override for GRPC Endpoint dependency controller: override for Controller dependency   connection(s):  discovery_key: (optional) key to retrieve the connection from IDiscovery protocol: connection protocol: http or https host: host name or IP address port: port number uri: resource URI or connection string with all parameters in it   credentials:  ssl_key_file: SSL private key in PEM ssl_crt_file: SSL certificate in PEM ssl_ca_file: certificate authorities (root cerfiticates) in PEM    References  *:discovery:*:*:1.0 - (optional) IDiscovery services *:logger:*:*:1.0 - (optional) ILogger components to pass log messages *:counters:*:*:1.0 - (optional) ICounters components to pass collected measurementsand as specified by the counter\u0026rsquo;s source.  Constructors InheritGrpcService methods are creates new instance NewGrpcService\n InheritGrpcService(overrides IGrpcServiceOverrides, serviceName string) *GrpcService\n  overrides: IGrpcServiceOverrides - a reference to child class that overrides virtual methods serviceName: string - service name from XYZ.pb.go, set \u0026quot;\u0026quot; for use default gRPC commandable protobuf  Fields Endpoint The GRPC endpoint that exposes this service.\n Endpoint: *GrpcEndpoint\n DependencyResolver The dependency resolver.\n DependencyResolver: *DependencyResolver\n Logger The logger.\n Logger: *CompositeLogger\n Counters The Counters counters.\n Counters: *CompositeCounters\n Tracer The tracer.\n Tracer: *CompositeTracer\n  Instance methods Close Closes the component and frees used resources.\n (c *GrpcService) Close(correlationId string) (err error)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. returns: (err error) - error or nil no errors occured.  Configure Configures component by passing configuration parameters.\n (c *GrpcService) Configure(config *cconf.ConfigParams)\n  config: *cconf.ConfigParams - configuration parameters to be set.  IsOpen Checks if the component is open.\n (c *GrpcService) IsOpen() bool\n  returns: bool -True if the endpoint is open with an actively listening GRPC server.  Instrument Adds instrumentation to log calls and measures call time. It returns a CounterTiming object that is used to end the time measurement.\n (c *GrpcService) Instrument(correlationId string, name string) *rpcserv.InstrumentTiming\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. name: string - method name. returns: *rpcserv.InstrumentTiming -Timing object to end the time measurement.  Open Opens the component.\n (c *GrpcService) Open(correlationId string) (err error)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. returns: (err error) - error or nil no errors occured.  Register Register method are registers all service routes in HTTP endpoint.\n (c *GrpcService) Register()\n RegisterUnaryInterceptor Registers a middleware for methods in GRPC endpoint.\n (c *GrpcService) RegisterUnaryInterceptor(action func(ctx context.Context, req interface{}, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler) (interface{}, error) )\n  action: func(ctx context.Context, req interface{}, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler) (interface{}, error) - an action function that is called when middleware is invoked.  RegisterCommandableMethod RegisterCommandableMethod method are registers a commandable method in c objects GRPC server (service) by the given name.\n (c *GrpcService) RegisterCommandableMethod(method string, schema *cvalid.Schema, action func(correlationId string, data *crun.Parameters) (result interface{}, err error))\n  method: string - the GRPC method name. schema: *cvalid.Schema - validation schema to validate received parameters. action: func(correlationId string, data *crun.Parameters) (result interface{}, err error) - action function that is called when operation is invoked.  SetReferences Sets references to dependent components.\n (c *GrpcService) SetReferences(references cref.IReferences)\n  references: cref.IReferences - references to locate the component dependencies.  UnsetReferences Unsets (clears) previously set references to dependent components.\n (c *GrpcService) UnsetReferences()\n Examples type MyGrpcService struct{ *GrpcService controller IMyController; } ... func NewMyGrpcService() *MyGrpcService { c := NewMyGrpcService{} c.GrpcService = grpcservices.NewGrpcService(\u0026#34;Mydata.Mydatas\u0026#34;) c.GrpcService.IRegisterable = \u0026amp;c c.numberOfCalls = 0 c.DependencyResolver.Put(\u0026#34;controller\u0026#34;, cref.NewDescriptor(\u0026#34;mygroup\u0026#34;, \u0026#34;controller\u0026#34;, \u0026#34;*\u0026#34;, \u0026#34;*\u0026#34;, \u0026#34;*\u0026#34;)) return \u0026amp;c } func (c*MyGrpcService) SetReferences(references: IReferences) { c.GrpcService.SetReferences(references); resolv, err := c.DependencyResolver.GetOneRequired(\u0026#34;controller\u0026#34;) if err == nil \u0026amp;\u0026amp; resolv != nil { c.controller = resolv.(grpctest.IMyController) return } panic(\u0026#34;Can\u0026#39;t resolve \u0026#39;controller\u0026#39; reference\u0026#34;) } func (c*MyGrpcService) Register() { protos.RegisterMyDataServer(c.Endpoint.GetServer(), c) ... } service := NewMyGrpcService(); service.Configure(cconf.NewConfigParamsFromTuples( \u0026#34;connection.protocol\u0026#34;, \u0026#34;http\u0026#34;, \u0026#34;connection.host\u0026#34;, \u0026#34;localhost\u0026#34;, \u0026#34;connection.port\u0026#34;, 8080, )); service.SetReferences(cref.NewReferencesFromTuples( cref.NewDescriptor(\u0026#34;mygroup\u0026#34;,\u0026#34;controller\u0026#34;,\u0026#34;default\u0026#34;,\u0026#34;default\u0026#34;,\u0026#34;1.0\u0026#34;), controller )); err := service.Open(\u0026#34;123\u0026#34;) if err == nil { fmt.Println(\u0026#34;The GRPC service is running on port 8080\u0026#34;); } ","description":"Abstract service that receives remote calls via the GRPC protocol.\n","image":null,"permalink":"/golang/grpc/services/grpc_service/","subtitle":null,"tags":null,"title":"GrpcService"},{"content":"Inherits: IOpenable, IConfigurable, IRegisterable, IUnreferenceable\nDescription The GrpcService class allows you to create services that receive remote calls via the GRPC protocol.\nConfiguration parameters  dependencies:  endpoint: override for GRPC Endpoint dependency controller: override for Controller dependency   connection(s):  discovery_key: (optional) key to retrieve the connection from IDiscovery protocol: connection protocol: http or https host: host name or IP address port: port number uri: resource URI or connection string with all parameters in it   credentials:  ssl_key_file: SSL private key in PEM ssl_crt_file: SSL certificate in PEM ssl_ca_file: certificate authorities (root cerfiticates) in PEM    References  *:discovery:*:*:1.0 - (optional) IDiscovery services *:logger:*:*:1.0 - (optional) ILogger components to pass log messages *:counters:*:*:1.0 - (optional) ICounters components to pass collected measurementsand as specified by the counter\u0026rsquo;s source.  Constructors Creates a new instance of the service.\n public GrpcService(string serviceName)\n  serviceName: string - service name.  Fields _endpoint The GRPC endpoint that exposes this service.\n protected _endpoint: GrpcEndpoint\n _dependencyResolver The dependency resolver.\n protected _dependencyResolver: DependencyResolver\n _logger The logger.\n protected _logger: CompositeLogger\n _counters The performance counters.\n protected _counters: CompositeCounters\n _serviceName Service name.\n protected _serviceName: CompositeTracer\n  Instance methods CloseAsync Closes the component and frees used resources.\n public virtual Task CloseAsync(string correlationId)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain.  Configure Configures component by passing configuration parameters.\n public virtual void Configure(ConfigParams config)\n  config: ConfigParams - configuration parameters to be set.  IsOpen Checks if the component is open.\n public bool IsOpen()\n  returns: bool -True if the endpoint is open with an actively listening GRPC server.  Instrument Adds instrumentation to log calls and measures call time. It returns a CounterTiming object that is used to end the time measurement.\n protected CounterTiming Instrument(string correlationId, string methodName)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. methodName: string - method name. returns: CounterTiming - Timing object to end the time measurement.  InstrumentError Adds instrumentation to error handling.\n protected void InstrumentError(string correlationId, string methodName, Exception ex, bool rethrow = false)\n  correlationId: string - (optional) transaction id to trace execution through call chain. methodName: string - a method name. ex: Exception - Error that occured during the method call rethrow: bool - True to throw the exception  OnRegister Registers all service routes in gRPC endpoint.\nThis method is called by the service and must be overriden in child classes.\n protected virtual void OnRegister()\n OpenAsync Opens the component.\n public virtual Task OpenAsync(string correlationId)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain.  Register Registers all service routes in the HTTP endpoint.\n public void Register()\n RegisterMethod Registers a method in GRPC service.\n where TRequest : class, IMessage\u0026lt;TRequest\u0026gt;, new() where TResponse : class, IMessage\u0026lt;TResponse\u0026gt;, new()   protected void RegisterMethod\u0026lt;TRequest, TResponse\u0026gt;(string name, UnaryServerMethod\u0026lt;TRequest, TResponse\u0026gt; handler)\n  name: string - method name handler: UnaryServerMethod\u0026lt;TRequest, TResponse\u0026gt; - TODO add description  SetReferences Sets references to dependent components.\n public virtual void SetReferences(IReferences references)\n  references: IReferences - references to locate the component dependencies.  UnsetReferences Unsets (clears) previously set references to dependent components.\n public virtual void UnsetReferences()\n Examples class MyRestService: RestService { private IMyController _controller; ... public MyRestService() { base(); this._dependencyResolver.put( \u0026#34;controller\u0026#34;, new Descriptor(\u0026#34;mygroup\u0026#34;, \u0026#34;controller\u0026#34;, \u0026#34;*\u0026#34;, \u0026#34;*\u0026#34;, \u0026#34;1.0\u0026#34;)); } public void SetReferences(IReferences references) { base.SetReferences(references); this._controller = this._dependencyResolver.getRequired\u0026lt;IMyController\u0026gt;(\u0026#34;controller\u0026#34;); } public void register() { ... } } var service = new MyRestService(); service.Configure(ConfigParams.FromTuples( \u0026#34;connection.protocol\u0026#34;, \u0026#34;http\u0026#34;, \u0026#34;connection.host\u0026#34;, \u0026#34;localhost\u0026#34;, \u0026#34;connection.port\u0026#34;, 8080 )); service.SetReferences(References.FromTuples( new Descriptor(\u0026#34;mygroup\u0026#34;,\u0026#34;controller\u0026#34;,\u0026#34;default\u0026#34;,\u0026#34;default\u0026#34;,\u0026#34;1.0\u0026#34;), controller )); service.Open(\u0026#34;123\u0026#34;); Console.Out.WriteLine(\u0026#34;The REST service is running on port 8080\u0026#34;); ","description":"Abstract service that receives remote calls via the GRPC protocol.\n","image":null,"permalink":"/net/grpc/services/grpc_service/","subtitle":null,"tags":null,"title":"GrpcService"},{"content":"Implements: IOpenable, IConfigurable, IRegisterable, IUnreferenceable\nDescription The GrpcService class allows you to create services that receive remote calls via the GRPC protocol.\nConfiguration parameters  dependencies:  endpoint: override for GRPC Endpoint dependency controller: override for Controller dependency   connection(s):  discovery_key: (optional) key to retrieve the connection from IDiscovery protocol: connection protocol: http or https host: host name or IP address port: port number uri: resource URI or connection string with all parameters in it   credentials:  ssl_key_file: SSL private key in PEM ssl_crt_file: SSL certificate in PEM ssl_ca_file: certificate authorities (root cerfiticates) in PEM    References  *:discovery:*:*:1.0 - (optional) IDiscovery services *:logger:*:*:1.0 - (optional) ILogger components to pass log messages *:counters:*:*:1.0 - (optional) ICounters components to pass collected measurementsand as specified by the counter\u0026rsquo;s source.  Constructors Creates a new instance of the service.\n public constructor(serviceOrPath: any, serviceName?: string, packageOptions?: any)\n  serviceOrPath: any - TODO: add description serviceName: string - service name. packageOptions: any - TODO: add description  Fields _endpoint The GRPC endpoint that exposes this service.\n protected _endpoint: GrpcEndpoint\n _dependencyResolver The dependency resolver.\n protected _dependencyResolver: DependencyResolver\n _logger The logger.\n protected _logger: CompositeLogger\n _counters The performance counters.\n protected _counters: CompositeCounters\n _tracer The tracer.\n protected _tracer: CompositeTracer\n  Abstract methods register Registers all service routes in the HTTP endpoint.\nThis method is called by the service and must be overriden in child classes.\n public abstract register()\n Instance methods applyValidation TODO: add description\n protected applyValidation(schema: Schema, action: (call: any) =\u0026gt; Promise\u0026lt;any\u0026gt;): (call: any) =\u0026gt; Promise\u0026lt;any\u0026gt;\n  schema: Schema - TODO: add description action: (call: any) =\u0026gt; Promise\u0026lt;any\u0026gt; - TODO: add description returns: (call: any) =\u0026gt; Promise\u0026lt;any\u0026gt; - TODO: add description  applyInterceptors TODO: add description\n protected applyInterceptors(action: (call: any) =\u0026gt; Promise\u0026lt;any\u0026gt;): (call: any) =\u0026gt; Promise\u0026lt;any\u0026gt;\n  action: (call: any) =\u0026gt; Promise\u0026lt;any\u0026gt;) - TODO: add description returns: (call: any) =\u0026gt; Promise\u0026lt;any\u0026gt; - TODO: add description  close Closes the component and frees used resources.\n public close(correlationId: string): Promise\u0026lt;void\u0026gt;\n  correlationId: string - (optional) transaction id used to trace execution through the call chain.  configure Configures component by passing configuration parameters.\n public configure(config: ConfigParams): void\n  config: ConfigParams - configuration parameters to be set.  isOpen Checks if the component is open.\n public isOpen(): boolean\n  returns: boolean -True if the endpoint is open with an actively listening GRPC server.  instrument Adds instrumentation to log calls and measures call time. It returns a CounterTiming object that is used to end the time measurement.\n protected instrument(correlationId: string, name: string): InstrumentTiming\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. name: string - method name. returns: InstrumentTiming -Timing object to end the time measurement.  open Opens the component.\n public open(correlationId: string): Promise\u0026lt;void\u0026gt;\n  correlationId: string - (optional) transaction id used to trace execution through the call chain.  registerInterceptor Registers a middleware for methods in GRPC endpoint.\n protected registerInterceptor(action: (call: any, next: (call: any) =\u0026gt; Promise\u0026lt;any\u0026gt;) =\u0026gt; Promise\u0026lt;any\u0026gt;): void\n  action: (call: any, next: (call: any) =\u0026gt; Promise\u0026lt;any\u0026gt;) =\u0026gt; Promise\u0026lt;any\u0026gt; - an action function that is called when middleware is invoked.  registerMethod Registers a middleware for methods in GRPC endpoint.\n protected registerMethod(name: string, schema: Schema, action: (call: any) =\u0026gt; Promise\u0026lt;any\u0026gt;): void\n  name: string - method name schema: Schema - validation schema to validate received parameters. action: (call: any) =\u0026gt; Promise\u0026lt;any\u0026gt; - action function that is called when operation is invoked.  registerMethodWithAuth  protected registerMethodWithAuth(name: string, schema: Schema, authorize: (call: any, next: (call: any) =\u0026gt; Promise\u0026lt;any\u0026gt;) =\u0026gt; Promise\u0026lt;any\u0026gt;, action: (call: any) =\u0026gt; Promise\u0026lt;any\u0026gt;): void\n  name: string - a method name schema: Schema - a validation schema to validate received parameters. authorize: (call: any, next: (call: any) =\u0026gt; Promise\u0026lt;any\u0026gt;) =\u0026gt; Promise\u0026lt;any\u0026gt; - an authorization interceptor action: (call: any) =\u0026gt; Promise\u0026lt;any\u0026gt; - an action function that is called when operation is invoked.  setReferences Sets references to dependent components.\n public setReferences(references: IReferences): void\n  references: IReferences - references to locate the component dependencies.  unsetReferences Unsets (clears) previously set references to dependent components.\n public unsetReferences(): void\n Examples class MyGrpcService extends GrpcService { private _controller: IMyController; ... public constructor() { base(\u0026#39;... path to proto ...\u0026#39;, \u0026#39;.. service name ...\u0026#39;); this._dependencyResolver.put( \u0026#34;controller\u0026#34;, new Descriptor(\u0026#34;mygroup\u0026#34;,\u0026#34;controller\u0026#34;,\u0026#34;*\u0026#34;,\u0026#34;*\u0026#34;,\u0026#34;1.0\u0026#34;) ); } public setReferences(references: IReferences): void { base.setReferences(references); this._controller = this._dependencyResolver.getRequired\u0026lt;IMyController\u0026gt;(\u0026#34;controller\u0026#34;); } public register(): void { registerMethod(\u0026#34;get_mydata\u0026#34;, null, async (call) =\u0026gt; { let correlationId = call.request.correlationId; let id = call.request.id; return await this._controller.getMyData(correlationId, id); }); ... } } let service = new MyGrpcService(); service.configure(ConfigParams.fromTuples( \u0026#34;connection.protocol\u0026#34;, \u0026#34;http\u0026#34;, \u0026#34;connection.host\u0026#34;, \u0026#34;localhost\u0026#34;, \u0026#34;connection.port\u0026#34;, 8080 )); service.setReferences(References.fromTuples( new Descriptor(\u0026#34;mygroup\u0026#34;,\u0026#34;controller\u0026#34;,\u0026#34;default\u0026#34;,\u0026#34;default\u0026#34;,\u0026#34;1.0\u0026#34;), controller )); service.open(\u0026#34;123\u0026#34;); console.log(\u0026#34;The GRPC service is running on port 8080\u0026#34;); ","description":"Abstract service that receives remote calls via the GRPC protocol.\n","image":null,"permalink":"/node/grpc/services/grpc_service/","subtitle":null,"tags":null,"title":"GrpcService"},{"content":"Implements: IOpenable, IConfigurable, IRegisterable, IUnreferenceable\nDescription The GrpcService class allows you to create services that receive remote calls via the GRPC protocol.\nConfiguration parameters  dependencies:  endpoint: override for GRPC Endpoint dependency controller: override for Controller dependency   connection(s):  discovery_key: (optional) key to retrieve the connection from IDiscovery protocol: connection protocol: http or https host: host name or IP address port: port number uri: resource URI or connection string with all parameters in it   credentials:  ssl_key_file: SSL private key in PEM ssl_crt_file: SSL certificate in PEM ssl_ca_file: certificate authorities (root cerfiticates) in PEM    References  *:discovery:*:*:1.0 - (optional) IDiscovery services *:logger:*:*:1.0 - (optional) ILogger components to pass log messages *:counters:*:*:1.0 - (optional) ICounters components to pass collected measurementsand as specified by the counter\u0026rsquo;s source.  Constructors Creates a new instance of the service.\n GrpcService(service_name: str)\n  service_name: str - service name.  Fields _endpoint The GRPC endpoint that exposes this service.\n _endpoint: GrpcEndpoint\n _dependency_resolver The dependency resolver.\n _dependency_resolver: DependencyResolver\n _logger The logger.\n _logger: CompositeLogger\n _counters The performance counters.\n _counters: CompositeCounters\n  Abstract methods register Registers all service routes in the HTTP endpoint.\nThis method is called by the service and must be overriden in child classes.\n abstractmethod register()\n Instance methods close Closes the component and frees used resources.\n close(correlation_id: Optional[str])\n  correlation_id: Optional[str] - (optional) transaction id used to trace execution through the call chain.  configure Configures component by passing configuration parameters.\n configure(config: ConfigParams)\n  config: ConfigParams - configuration parameters to be set.  is_open Checks if the component is open.\n is_open(): bool\n  returns: bool -True if the endpoint is open with an actively listening GRPC server.  _instrument Adds instrumentation to log calls and measures call time. It returns a CounterTiming object that is used to end the time measurement.\n _instrument(correlation_id: Optional[str], name: str): CounterTiming\n  correlation_id: Optional[str] - (optional) transaction id used to trace execution through the call chain. name: str - method name. returns: CounterTiming - CounterTiming object used to end the time measurement.  _instrument_error Adds instrumentation to error handling.\n _instrument_error(correlation_id: Optional[str], name: str, err: Exception, reerror=False)\n  correlation_id: Optional[str] - (optional) transaction id used to trace execution through the call chain. name: str - method name. err: Exception - occured error reerror: bool - if True - throw error  open Opens the component.\n open(correlation_id: Optional[str])\n  correlation_id: Optional[str] - (optional) transaction id used to trace execution through the call chain.  _register_commandable_method Registers a commandable method in the object\u0026rsquo;s GRPC server (service) by the given name.\n _register_commandable_method(method: str, schema: Schema, action: Callable[[Optional[str], Optional[str], Parameters], None])\n  method: str - GRPC method name. schema: Schema - schema used for parameter validation. action: Callable[[Optional[str], Optional[str], Parameters], None] - action to perform at the given route.  _register_interceptor Registers a middleware for methods in GRPC endpoint.\n _register_interceptor(interceptor: Callable)\n  interceptor: Callable - middleware action to perform at the given route.  _register_method! TODO: this method is not implemented for Python\nRegisters a middleware for methods in GRPC endpoint.\n _register_method(name: str, schema: Schema, action: action: Callable[[Optional[str], Optional[str], Parameters], None])\n  name: str - method name schema: Schema - validation schema to validate received parameters. action: Callable[[Optional[str], Optional[str], Parameters], None] - action function that is called when operation is invoked.  set_references Sets references to dependent components.\n set_references(references: IReferences)\n  references: IReferences - references to locate the component dependencies.  unset_references Unsets (clears) previously set references to dependent components.\n unset_references()\n Examples class MyGrpcService(GrpcService): __controller: IMyController ... def __init__(self): suoer().__init__(\u0026#39;... path to proto ...\u0026#39;, \u0026#39;.. service name ...\u0026#39;) self._dependency_resolver.put( \u0026#34;controller\u0026#34;, Descriptor(\u0026#34;mygroup\u0026#34;,\u0026#34;controller\u0026#34;,\u0026#34;*\u0026#34;,\u0026#34;*\u0026#34;,\u0026#34;1.0\u0026#34;) ) def set_references(self, references): super().set_references(references) self._controller = this._dependency_resolver.get_required(\u0026#34;controller\u0026#34;) def register(self): def method(correlation_id, args, getted_method): correlationId = call.request.correlationId; id = call.request.id; self._controller.getMyData(correlationId, id, callback); self.register_commadable_method(\u0026#34;get_mydata\u0026#34;, None, method) ... service = MyGrpcService() service.configure(ConfigParams.from_tuples( \u0026#34;connection.protocol\u0026#34;, \u0026#34;http\u0026#34;, \u0026#34;connection.host\u0026#34;, \u0026#34;localhost\u0026#34;, \u0026#34;connection.port\u0026#34;, 8080 )) service.set_references(References.from_tuples( Descriptor(\u0026#34;mygroup\u0026#34;,\u0026#34;controller\u0026#34;,\u0026#34;default\u0026#34;,\u0026#34;default\u0026#34;,\u0026#34;1.0\u0026#34;), controller )) service.open(\u0026#34;123\u0026#34;) ","description":"Abstract service that receives remote calls via the GRPC protocol.\n","image":null,"permalink":"/python/grpc/services/grpc_service/","subtitle":null,"tags":null,"title":"GrpcService"},{"content":"Provides guidance to application users: introduces about application features, tells about new version and so on. Each guide:\n  Can be written in multiple languages\n  Can include one or more pages with title, text and a picture\n  Supports editing lifecycle via status tracking\n  Server implementations: NodeJS, Dart\n  Communication protocols: Direct, Commandable HTTP, Commandable GRPC, GRPC\n  Persistence: Memory, Flat Files, MongoDB, Couchbase\n  Deployment options: Monolith, Process, Docker, AWS Lambda\n  Client implementations: NodeJS, Dart\n  This microservice has dependencies on the following microservices:\n Blob Attachments - to reference pictures and documents associates with guides  ","description":null,"image":null,"permalink":"/microservices/content/guides/","subtitle":null,"tags":null,"title":"Guides Microservice"},{"content":"Implements: RestOperations\nDescription The HeartBeatOperations class is used to handle the operations of a heartbeat service.\nConstructors NewHeartbeatOperations NewHeartbeatOperations creates new instance HeartbeatOperations\n NewHeartbeatOperations() *HeartbeatOperations\n Methods Heartbeat Creates a heartbeat. Send request with the current time in UTC.\n (c *HeartbeatOperations) Heartbeat(res http.ResponseWriter, req *http.Request)\n  res: http.ResponseWriter - an HTTP request res: req *http.Request - an HTTP response  GetHeartbeatOperation Gets the heartbeat operation\n (c *HeartbeatOperations) GetHeartbeatOperation() func(res http.ResponseWriter, req *http.Request)\n  returns: func(res http.ResponseWriter, req *http.Request) - heartbeat operation  ","description":"Handles the operations of a heartbeat service.\n","image":null,"permalink":"/golang/rpc/services/heartbeat_operations/","subtitle":null,"tags":null,"title":"HeartBeatOperations"},{"content":"Inherits: RestOperations\nDescription The HeartBeatOperations class is used to handle the operations of a heartbeat service.\nInstance methods heartbeat Creates a heartbeat. Send request with the current time in UTC.\n private Task HeartbeatAsync(HttpRequest httpRequest, HttpResponse response, ClaimsPrincipal user)\n  request: HttpRequest - an HTTP request. response: HttpResponse - an HTTP response. user: ClaimsPrincipal - to identify current user.  GetHeartbeatOperation Gets the heartbeat operation\n public Func\u0026lt;HttpRequest, HttpResponse, ClaimsPrincipal, Task\u0026gt; GetHeartbeatOperation()\n  returns: Func\u0026lt;HttpRequest, HttpResponse, ClaimsPrincipal, Task\u0026gt; - heartbeat operation  ","description":"Handles the operations of a heartbeat service.\n","image":null,"permalink":"/net/rpc/services/heartbeat_operations/","subtitle":null,"tags":null,"title":"HeartBeatOperations"},{"content":"Extends: RestOperations\nDescription The HeartBeatOperations class is used to handle the operations of a heartbeat service.\nInstance methods heartbeat Creates a heartbeat. Send request with the current time in UTC.\n public heartbeat(req, res): void\n  req: any - an HTTP request res: any - an HTTP response  getHeartbeatOperation Gets the heartbeat operation\n public getHeartbeatOperation(): function\n  returns: function - heartbeat operation  ","description":"Handles the operations of a heartbeat service.\n","image":null,"permalink":"/node/rpc/services/heartbeat_operations/","subtitle":null,"tags":null,"title":"HeartBeatOperations"},{"content":"Implements: RestOperations\nDescription The HeartBeatOperations class is used to handle the operations of a heartbeat service.\nInstance methods heartbeat Creates a heartbeat.\n heartbeat(): str\n  returns: str - string with the current time in UTC.  get_heart_beat_operation Gets the heartbeat operation\n get_heart_beat_operation(): Callable\n  returns: Callable - heartbeat operation  ","description":"Handles the operations of a heartbeat service.\n","image":null,"permalink":"/python/rpc/services/heartbeat_operations/","subtitle":null,"tags":null,"title":"HeartBeatOperations"},{"content":"Implements: RestService\nDescription The HeartbeatRestService class allows you to create services that return heartbeat via HTTP/REST protocol.\nImportant points\n The service responds on /heartbeat route (can be changed) with a string with the current time in UTC. This service route can be used to perform health checks by loadbalancers and container orchestrators.  Configuration parameters  base_route: base route for remote URI (default: \u0026ldquo;\u0026quot;) route: route to heartbeat operation (default: \u0026ldquo;heartbeat\u0026rdquo;) dependencies:  endpoint: override for HTTP Endpoint dependency   connection(s):  discovery_key: (optional) key to retrieve the connection from IDiscovery protocol: connection protocol: http or https host: host name or IP address port: port number uri: resource URI or connection string with all parameters in it    References  *:logger:*:*:1.0 - (optional) ILogger components to pass log messages *:counters:*:*:1.0 - (optional) ICounters components to pass collected measurements *:traces:*:*:1.0 - (optional) ITracer components to record traces *:discovery:*:*:1.0 - (optional) IDiscovery services to resolve connection  Constructors NewHeartbeatRestService Creates a new instance of c service.\n NewHeartbeatRestService() *HeartbeatRestService\n Methods Configure Configures component by passing configuration parameters.\n (c *HeartbeatRestService) Configure(config *cconf.ConfigParams)\n  config: ConfigParams - configuration parameters to be set.  Register Registers all service routes in HTTP endpoint.\n (c *HeartbeatRestService) Register()\n heartbeat Handles heartbeat requests\n (c *HeartbeatRestService) heartbeat(req *http.Request, res http.ResponseWriter)\n  req: *http.Request - an HTTP request res: http.ResponseWriter - an HTTP response  Examples service := NewHeartbeatService(); service.Configure(cconf.NewConfigParamsFromTuples( \u0026#34;route\u0026#34;, \u0026#34;ping\u0026#34;, \u0026#34;connection.protocol\u0026#34;, \u0026#34;http\u0026#34;, \u0026#34;connection.host\u0026#34;, \u0026#34;localhost\u0026#34;, \u0026#34;connection.port\u0026#34;, 8080, )); opnErr := service.Open(\u0026#34;123\u0026#34;) if opnErr == nil { fmt.Println(\u0026#34;The Heartbeat service is accessible at http://+:8080/ping\u0026#34;); } See also   RestService   RestClient   ","description":"Service returns heartbeat via HTTP/REST protocol.\n","image":null,"permalink":"/golang/rpc/services/heartbeat_rest_service/","subtitle":null,"tags":null,"title":"HeartbeatRestService"},{"content":"Inherits: RestService\nDescription The HeartbeatRestService class allows you to create services that return heartbeat via HTTP/REST protocol.\nImportant points\n The service responds on /heartbeat route (can be changed) with a string with the current time in UTC. This service route can be used to perform health checks by loadbalancers and container orchestrators.  Configuration parameters  base_route: base route for remote URI (default: \u0026ldquo;\u0026quot;) route: route to heartbeat operation (default: \u0026ldquo;heartbeat\u0026rdquo;) dependencies:  endpoint: override for HTTP Endpoint dependency   connection(s):  discovery_key: (optional) key to retrieve the connection from IDiscovery protocol: connection protocol: http or https host: host name or IP address port: port number uri: resource URI or connection string with all parameters in it    References  *:logger:*:*:1.0 - (optional) ILogger components to pass log messages *:counters:*:*:1.0 - (optional) ICounters components to pass collected measurements *:traces:*:*:1.0 - (optional) ITracer components to record traces *:discovery:*:*:1.0 - (optional) IDiscovery services to resolve connection  Instance methods Configure Configures component by passing configuration parameters.\n public override void Configure(ConfigParams config)\n  config: ConfigParams - configuration parameters to be set.  Register Registers all service routes in HTTP endpoint.\n public override void Register()\n Examples var service = new HeartbeatService(); service.Configure(ConfigParams.FromTuples( \u0026#34;route\u0026#34;, \u0026#34;ping\u0026#34;, \u0026#34;connection.protocol\u0026#34;, \u0026#34;http\u0026#34;, \u0026#34;connection.host\u0026#34;, \u0026#34;localhost\u0026#34;, \u0026#34;connection.port\u0026#34;, 8080 )); service.Open(\u0026#34;123\u0026#34;); Console.Out.WriteLine(\u0026#34;The Heartbeat service is accessible at http://+:8080/ping\u0026#34;); See also   RestService   RestClient   ","description":"Service returns heartbeat via HTTP/REST protocol.\n","image":null,"permalink":"/net/rpc/services/heartbeat_rest_service/","subtitle":null,"tags":null,"title":"HeartbeatRestService"},{"content":"Extends: RestService\nDescription The HeartbeatRestService class allows you to create services that return heartbeat via HTTP/REST protocol.\nImportant points\n The service responds on /heartbeat route (can be changed) with a string with the current time in UTC. This service route can be used to perform health checks by loadbalancers and container orchestrators.  Configuration parameters  base_route: base route for remote URI (default: \u0026ldquo;\u0026quot;) route: route to heartbeat operation (default: \u0026ldquo;heartbeat\u0026rdquo;) dependencies:  endpoint: override for HTTP Endpoint dependency   connection(s):  discovery_key: (optional) key to retrieve the connection from IDiscovery protocol: connection protocol: http or https host: host name or IP address port: port number uri: resource URI or connection string with all parameters in it    References  *:logger:*:*:1.0 - (optional) ILogger components to pass log messages *:counters:*:*:1.0 - (optional) ICounters components to pass collected measurements *:traces:*:*:1.0 - (optional) ITracer components to record traces *:discovery:*:*:1.0 - (optional) IDiscovery services to resolve connection  Instance methods configure Configures component by passing configuration parameters.\n public configure(config: ConfigParams): void\n  config: ConfigParams - configuration parameters to be set.  register Registers all service routes in HTTP endpoint.\n public register(): void\n Examples let service = new HeartbeatService(); service.configure(ConfigParams.fromTuples( \u0026#34;route\u0026#34;, \u0026#34;ping\u0026#34;, \u0026#34;connection.protocol\u0026#34;, \u0026#34;http\u0026#34;, \u0026#34;connection.host\u0026#34;, \u0026#34;localhost\u0026#34;, \u0026#34;connection.port\u0026#34;, 8080 )); await service.open(\u0026#34;123\u0026#34;); console.log(\u0026#34;The Heartbeat service is accessible at http://+:8080/ping\u0026#34;); See also   RestService   RestClient   ","description":"Service returns heartbeat via HTTP/REST protocol.\n","image":null,"permalink":"/node/rpc/services/heartbeat_rest_service/","subtitle":null,"tags":null,"title":"HeartbeatRestService"},{"content":"Implements: RestService\nDescription The HeartbeatRestService class allows you to create services that return heartbeat via HTTP/REST protocol.\nImportant points\n The service responds on /heartbeat route (can be changed) with a string with the current time in UTC. This service route can be used to perform health checks by loadbalancers and container orchestrators.  Configuration parameters  base_route: base route for remote URI (default: \u0026ldquo;\u0026quot;) route: route to heartbeat operation (default: \u0026ldquo;heartbeat\u0026rdquo;) dependencies:  endpoint: override for HTTP Endpoint dependency   connection(s):  discovery_key: (optional) key to retrieve the connection from IDiscovery protocol: connection protocol: http or https host: host name or IP address port: port number uri: resource URI or connection string with all parameters in it    References  *:logger:*:*:1.0 - (optional) ILogger components to pass log messages *:counters:*:*:1.0 - (optional) ICounters components to pass collected measurements *:traces:*:*:1.0 - (optional) ITracer components to record traces *:discovery:*:*:1.0 - (optional) IDiscovery services to resolve connection  Instance methods configure Configures component by passing configuration parameters.\n configure(config: ConfigParams)\n  config: ConfigParams - configuration parameters to be set.  register Registers all service routes in HTTP endpoint.\n register()\n heartbeat Handles heartbeat requests\n heartbeat(): str\n  returns: str - http response to the request.  Examples service = HeartbeatService() service.configure(ConfigParams.from_tuples(\u0026#34;route\u0026#34;, \u0026#34;ping\u0026#34;, \u0026#34;connection.protocol\u0026#34;, \u0026#34;http\u0026#34;, \u0026#34;connection.host\u0026#34;, \u0026#34;localhost\u0026#34;, \u0026#34;connection.port\u0026#34;, 8080)) service.open(\u0026#34;123\u0026#34;) # ... See also   RestService   RestClient   ","description":"Service returns heartbeat via HTTP/REST protocol.\n","image":null,"permalink":"/python/rpc/services/heartbeat_rest_service/","subtitle":null,"tags":null,"title":"HeartbeatRestService"},{"content":"Provides context help to application users broken by topics and articles. Each help:\n  Can be written in multiple languages\n  Can include one or more blocks of content with title, text and a picture\n  Supports editing lifecycle via status tracking\n  Server implementations: NodeJS, Dart\n  Communication protocols: Direct, Commandable HTTP, Commandable GRPC, GRPC\n  Persistence: Memory, Flat Files, MongoDB, Couchbase\n  Deployment options: Monolith, Process, Docker, AWS Lambda\n  Client implementations: NodeJS, Dart\n  This microservice has dependencies on the following microservices:\n Blob Attachments - to reference pictures and documents associates with help.  ","description":null,"image":null,"permalink":"/microservices/content/help/","subtitle":null,"tags":null,"title":"Help Microservice"},{"content":"Description The HttpConnectionResolver class is used to retrieve connections for HTTP-based services and clients.\nImportant points\n In addition to its regular functions, ConnectionResolver is able to parse http:// URIs and validate connection parameters before returning them.  Configuration parameters  connection:  discovery_key: (optional) key to retrieve the connection from IDiscovery \u0026hellip; : other connection parameters   connections: alternative to connection  [connection params 1]: first connection parameters \u0026hellip; [connection params N]: Nth connection parameters \u0026hellip;    References  *:discovery:*:*:1.0 - (optional) IDiscovery services to resolve a connection  Constructors NewHttpConnectionResolver NewHttpConnectionResolver creates new instance NewHttpConnectionResolver\n NewHttpConnectionResolver() *HttpConnectionResolver\n Fields ConnectionResolver Creates a connection resolver.\n ConnectionResolver: ConnectionResolver\n CredentialResolver The base credential resolver.\n CredentialResolver: CredentialResolver\n  Methods Configure Configures component by passing configuration parameters.\n (c *HttpConnectionResolver) Configure(config *cconf.ConfigParams)\n  config: *cconf.ConfigParams - configuration parameters to be set.  Register Registers the given connection in all referenced discovery services. This method can be used for dynamic service discovery.\n (c *HttpConnectionResolver) Register(correlationId string) error\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. returns: error - returns error if not registered  Resolve Resolves a single component connection. If the connections are configured to be retrieved from Discovery service, it finds a IDiscovery and resolves the connection there.\n (c *HttpConnectionResolver) Resolve(correlationId string) (connection *ccon.ConnectionParams, credential *cauth.CredentialParams, err error)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. returns: (connection *ccon.ConnectionParams, credential *cauth.CredentialParams, err error) - resolved connection and credential or error.  ResolveAll Resolves all component connections. If connections are configured to be retrieved from Discovery service it finds a IDiscovery and resolves the connection there.\n (c *HttpConnectionResolver) ResolveAll(correlationId string) (connections []*ccon.ConnectionParams, credential *cauth.CredentialParams, err error)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. returns: (connections []*ccon.ConnectionParams, credential *cauth.CredentialParams, err error) - resolved connections.  SetReferences Sets references to dependent components.\n (c *HttpConnectionResolver) SetReferences(references crefer.IReferences)\n  references: crefer.IReferences - references to locate the component dependencies.  Examples config := cconf.NewConfigParamsFromTuples( \u0026#34;connection.host\u0026#34;, \u0026#34;10.1.1.100\u0026#34;, \u0026#34;connection.port\u0026#34;, 8080, ); connectionResolver = NewHttpConnectionResolver(); connectionResolver.Configure(config); connectionResolver.SetReferences(references); connection, err := connectionResolver.Resolve(\u0026#34;123\u0026#34;) // Now use connection... See also   ConnectionParams   ConnectionResolver   ","description":"Helper class to retrieve connections for HTTP-based services and clients.\n","image":null,"permalink":"/golang/rpc/connect/http_connection_resolver/","subtitle":null,"tags":null,"title":"HttpConnectionResolver"},{"content":"Inherits: IReferenceable, IConfigurable\nDescription The HttpConnectionResolver class is used to retrieve connections for HTTP-based services and clients.\nImportant points\n In addition to its regular functions, ConnectionResolver is able to parse http:// URIs and validate connection parameters before returning them.  Configuration parameters  connection:  discovery_key: (optional) key to retrieve the connection from IDiscovery \u0026hellip; : other connection parameters   connections: alternative to connection  [connection params 1]: first connection parameters \u0026hellip; [connection params N]: Nth connection parameters \u0026hellip;    References  *:discovery:*:*:1.0 - (optional) IDiscovery services to resolve a connection  Fields _connectionResolver Creates a connection resolver.\n protected _credentialResolver: ConnectionResolver = ConnectionResolver()\n _credentialResolver The base credential resolver.\n protected _credentialResolver: CredentialResolver = CredentialResolver()\n  Instance methods Configure Configures component by passing configuration parameters.\n public void Configure(ConfigParams config)\n  config: ConfigParams - configuration parameters to be set.  RegisterAsync Registers the given connection in all referenced discovery services. This method can be used for dynamic service discovery.\n public Task RegisterAsync(string correlationId)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain.  ResolveAsync Resolves a single component connection. If the connections are configured to be retrieved from Discovery service, it finds a IDiscovery and resolves the connection there.\n public Task\u0026lt;ConnectionParams\u0026gt; ResolveAsync(string correlationId)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. returns: Task\u0026lt;ConnectionParams\u0026gt; - resolved connection.  ResolveAllAsync Resolves all component connections. If connections are configured to be retrieved from Discovery service it finds a IDiscovery and resolves the connection there.\n public Task\u0026lt;List\u0026lt;ConnectionParams\u0026gt;\u0026gt; ResolveAllAsync(string correlationId)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. returns: Task\u0026lt;List\u0026lt;ConnectionParams\u0026gt;\u0026gt; - resolved connections.  SetReferences Sets references to dependent components.\n public void SetReferences(IReferences references)\n  references: IReferences - references to locate the component dependencies.  Examples var config = ConfigParams.FromTuples( \u0026#34;connection.host\u0026#34;, \u0026#34;10.1.1.100\u0026#34;, \u0026#34;connection.port\u0026#34;, 8080 ); var connectionResolver = new HttpConnectionResolver(); connectionResolver.Configure(config); connectionResolver.SetReferences(references); var params = connectionResolver.ResolveAsync(\u0026#34;123\u0026#34;); See also   ConnectionParams   ConnectionResolver   ","description":"Helper class to retrieve connections for HTTP-based services and clients.\n","image":null,"permalink":"/net/rpc/connect/http_connection_resolver/","subtitle":null,"tags":null,"title":"HttpConnectionResolver"},{"content":"Implements: IReferenceable, IConfigurable\nDescription The HttpConnectionResolver class is used to retrieve connections for HTTP-based services and clients.\nImportant points\n In addition to its regular functions, ConnectionResolver is able to parse http:// URIs and validate connection parameters before returning them.  Configuration parameters  connection:  discovery_key: (optional) key to retrieve the connection from IDiscovery \u0026hellip; : other connection parameters   connections: alternative to connection  [connection params 1]: first connection parameters \u0026hellip; [connection params N]: Nth connection parameters \u0026hellip;    References  *:discovery:*:*:1.0 - (optional) IDiscovery services to resolve a connection  Fields _connectionResolver Creates a connection resolver.\n protected _credentialResolver: ConnectionResolver = ConnectionResolver()\n _credentialResolver The base credential resolver.\n protected _credentialResolver: CredentialResolver = CredentialResolver()\n  Instance methods configure Configures component by passing configuration parameters.\n public configure(config: ConfigParams): void\n  config: ConfigParams - configuration parameters to be set.  register Registers the given connection in all referenced discovery services. This method can be used for dynamic service discovery.\n public register(correlationId: string): void\n  correlationId: string - (optional) transaction id used to trace execution through the call chain.  resolve Resolves a single component connection. If the connections are configured to be retrieved from Discovery service, it finds a IDiscovery and resolves the connection there.\n public resolve(correlationId: string): Promise\u0026lt;ConfigParams\u0026gt;\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. returns: Promise\u0026lt;ConfigParams\u0026gt; - resolved connection.  resolveAll Resolves all component connections. If connections are configured to be retrieved from Discovery service it finds a IDiscovery and resolves the connection there.\n resolveAll(correlationId: string): Promise\u0026lt;ConfigParams\u0026gt;\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. returns: Promise\u0026lt;ConfigParams\u0026gt; - resolved connections.  setReferences Sets references to dependent components.\n public setReferences(references: IReferences): void\n  references: IReferences - references to locate the component dependencies.  Examples let config = ConfigParams.fromTuples( \u0026#34;connection.host\u0026#34;, \u0026#34;10.1.1.100\u0026#34;, \u0026#34;connection.port\u0026#34;, 8080 ); let connectionResolver = new HttpConnectionResolver(); connectionResolver.configure(config); connectionResolver.setReferences(references); let connection = await connectionResolver.resolve(\u0026#34;123\u0026#34;); // Now use connection... See also   ConnectionParams   ConnectionResolver   ","description":"Helper class to retrieve connections for HTTP-based services and clients.\n","image":null,"permalink":"/node/rpc/connect/http_connection_resolver/","subtitle":null,"tags":null,"title":"HttpConnectionResolver"},{"content":"Implements: IReferenceable, IConfigurable\nDescription The HttpConnectionResolver class is used to retrieve connections for HTTP-based services and clients.\nImportant points\n In addition to its regular functions, ConnectionResolver is able to parse http:// URIs and validate connection parameters before returning them.  Configuration parameters  connection:  discovery_key: (optional) key to retrieve the connection from IDiscovery \u0026hellip; : other connection parameters   connections: alternative to connection  [connection params 1]: first connection parameters \u0026hellip; [connection params N]: Nth connection parameters \u0026hellip;    References  *:discovery:*:*:1.0 - (optional) IDiscovery services to resolve a connection  Fields _connection_resolver Creates a connection resolver.\n _connection_resolver: ConnectionResolver = ConnectionResolver()\n _credential_resolver The base credential resolver.\n _credential_resolver: CredentialResolver = CredentialResolver()\n  Instance methods configure Configures component by passing configuration parameters.\n configure(config: ConfigParams)\n  config: ConfigParams - configuration parameters to be set.  register Registers the given connection in all referenced discovery services. This method can be used for dynamic service discovery.\n register(correlation_id: Optional[str])\n  correlation_id: Optional[str] - (optional) transaction id used to trace execution through the call chain.  resolve Resolves a single component connection. If the connections are configured to be retrieved from Discovery service, it finds a IDiscovery and resolves the connection there.\n resolve(correlation_id: Optional[str]): ConfigParams\n  correlation_id: Optional[str] - (optional) transaction id used to trace execution through the call chain. returns: ConfigParams - resolved connection.  resolve_all Resolves all component connections. If connections are configured to be retrieved from Discovery service it finds a IDiscovery and resolves the connection there.\n resolve_all(correlation_id: Optional[str]): ConfigParams\n  correlation_id: Optional[str] - (optional) transaction id used to trace execution through the call chain. returns: ConfigParams - resolved connections.  set_references Sets references to dependent components.\n set_references(references: IReferences)\n  references: IReferences - references to locate the component dependencies.  Examples config = ConfigParams.from_tuples(\u0026#34;connection.host\u0026#34;, \u0026#34;10.1.1.100\u0026#34;,\u0026#34;connection.port\u0026#34;, 8080) connectionResolver = HttpConnectionResolver() connectionResolver.configure(config) connectionResolver.set_references(references) params = connectionResolver.resolve(\u0026#34;123\u0026#34;) See also   ConnectionParams   ConnectionResolver   ","description":"Helper class to retrieve connections for HTTP-based services and clients.\n","image":null,"permalink":"/python/rpc/connect/http_connection_resolver/","subtitle":null,"tags":null,"title":"HttpConnectionResolver"},{"content":"Description The HttpEndpoint class allows you to create HTTP endpoints.\nImportant points\n An endpoint is a URL, at which a given service can be accessed by a client.  Configuration parameters Parameters to pass to the configure method for component configuration:\n connection(s): the connection resolver\u0026rsquo;s connections:  \u0026ldquo;connection.discovery_key\u0026rdquo;: key to use for connection resolving in a discovery service; \u0026ldquo;connection.protocol\u0026rdquo;: connection\u0026rsquo;s protocol; \u0026ldquo;connection.host\u0026rdquo;: target host; \u0026ldquo;connection.port\u0026rdquo;: target port; \u0026ldquo;connection.uri\u0026rdquo;: target URI.   credential: the HTTPS credentials:  \u0026ldquo;credential.ssl_key_file\u0026rdquo;: SSL private key in PEM \u0026ldquo;credential.ssl_crt_file\u0026rdquo;: SSL certificate in PEM \u0026ldquo;credential.ssl_ca_file\u0026rdquo;: certificate authorities (root cerfiticates) in PEM    References A logger, counters, and a connection resolver can be referenced by passing the following references to the object\u0026rsquo;s set_references method:\n *:logger:*:*:1.0 - (optional) ILogger components to pass log messages *:counters:*:*:1.0 - (optional) ICounters components to pass collected measurements *:discovery:*:*:1.0 - (optional) IDiscovery services to resolve connections  Constructors NewHttpEndpoint NewHttpEndpoint creates new HttpEndpoint\n NewHttpEndpoint() *HttpEndpoint\n Methods Close Closes this endpoint and the REST server (service) that was opened earlier.\n (c *HttpEndpoint) Close(correlationId string) error\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. returns: error - returns error if not closed  Configure Configures this HttpEndpoint using the given configuration parameters.\n (c *HttpEndpoint) Configure(config *cconf.ConfigParams)\n  config: *cconf.ConfigParams - configuration parameters, containing a \u0026ldquo;connection(s)\u0026rdquo; section.  IsOpen Checks if the component is open.\n (c *HttpEndpoint) IsOpen() bool\n  returns: bool - whether or not this endpoint is open with an actively listening REST server.  Register Registers a registerable object for dynamic endpoint discovery.\n (c *HttpEndpoint) Register(registration IRegisterable)\n  registration: IRegisterable - the registration to add.  RegisterInterceptor Registers a middleware action for the given route.\n (c *HttpEndpoint) RegisterInterceptor(route string, action func(w http.ResponseWriter, r *http.Request, next http.HandlerFunc))\n  route: string - route to register in this object\u0026rsquo;s REST server (service). action: func(w http.ResponseWriter, r *http.Request, next http.HandlerFunc) - middleware action to perform at the given route.  RegisterRoute Registers an action in this objects REST server (service) by the given method and route.\n (c *HttpEndpoint) RegisterRoute(method string, route string, schema *cvalid.Schema, action http.HandlerFunc)\n  method: string - HTTP method of the route. route: string - route to register in this object\u0026rsquo;s REST server (service). schema: *cvalid.Schema - schema to use for parameter validation. action: http.HandlerFunc - action to perform at the given route.  RegisterRouteWithAuth Registers an action with authorization in this objects REST server (service) by the given method and route.\n (c *HttpEndpoint) RegisterRouteWithAuth(method string, route string, schema *cvalid.Schema, authorize func(w http.ResponseWriter, r *http.Request, next http.HandlerFunc), action http.HandlerFunc)\n  method: string - HTTP method of the route. route: string - route to register in this object\u0026rsquo;s REST server (service). schema: *cvalid.Schema - schema to use for parameter validation. authorize: func(w http.ResponseWriter, r *http.Request, next http.HandlerFunc) - authorization interceptor action: http.HandlerFunc - action to perform at the given route.  SetReferences Sets references to this endpoint\u0026rsquo;s logger, counters, and connection resolver.\n (c *HttpEndpoint) SetReferences(references crefer.IReferences)\n  references: crefer.IReferences - IReferences object, containing references to a logger, counters, and a connection resolver.  Unregister Unregisters a registerable object, so that it is no longer used in dynamic endpoint discovery.\n (c *HttpEndpoint) Unregister(registration IRegisterable)\n  registration: IRegisterable - registration to remove.  Examples endpoint := NewHttpEndpoint(); endpoint.Configure(config); endpoint.SetReferences(references); ... endpoint.Open(correlationId) See also   IConfigurable   IReferenceable   IOpenable   ","description":"Used for creating HTTP endpoints. \n","image":null,"permalink":"/golang/rpc/services/http_endpoint/","subtitle":null,"tags":null,"title":"HttpEndpoint"},{"content":"Implements: IConfigurable, IReferenceable, IOpenable\nDescription The HttpEndpoint class allows you to create HTTP endpoints.\nImportant points\n An endpoint is a URL, at which a given service can be accessed by a client.  Configuration parameters Parameters to pass to the configure method for component configuration:\n connection(s): the connection resolver\u0026rsquo;s connections:  \u0026ldquo;connection.discovery_key\u0026rdquo;: key to use for connection resolving in a discovery service; \u0026ldquo;connection.protocol\u0026rdquo;: connection\u0026rsquo;s protocol; \u0026ldquo;connection.host\u0026rdquo;: target host; \u0026ldquo;connection.port\u0026rdquo;: target port; \u0026ldquo;connection.uri\u0026rdquo;: target URI.   credential: the HTTPS credentials:  \u0026ldquo;credential.ssl_key_file\u0026rdquo;: SSL private key in PEM \u0026ldquo;credential.ssl_crt_file\u0026rdquo;: SSL certificate in PEM \u0026ldquo;credential.ssl_ca_file\u0026rdquo;: certificate authorities (root cerfiticates) in PEM    References A logger, counters, and a connection resolver can be referenced by passing the following references to the object\u0026rsquo;s set_references method:\n *:logger:*:*:1.0 - (optional) ILogger components to pass log messages *:counters:*:*:1.0 - (optional) ICounters components to pass collected measurements *:discovery:*:*:1.0 - (optional) IDiscovery services to resolve connections  Instance methods CloseAsync Closes this endpoint and the REST server (service) that was opened earlier.\n public virtual Task CloseAsync(string correlationId)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain.  Configure Configures this HttpEndpoint using the given configuration parameters.\n public virtual void Configure(ConfigParams config)\n  config: ConfigParams - configuration parameters, containing a \u0026ldquo;connection(s)\u0026rdquo; section.  Initialize TODO: add description\n public void Initialize(IInitializable initialization)\n  initialization: IInitializable - TODO: add description  Instrument Adds instrumentation to log calls and measure call time. It returns a CounterTiming object that is used to end the time measurement.\n protected CounterTiming Instrument(string correlationId, string name)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. name: string - a method name. returns: CounterTiming - CounterTiming object to end the time measurement.  IsOpen Checks if the component is open.\n public virtual bool IsOpen()\n  returns: bool - whether or not this endpoint is open with an actively listening REST server.  Register Registers a registerable object for dynamic endpoint discovery.\n public void Register(IRegisterable registration)\n  registration: IRegisterable - the registration to add.  RegisterInterceptor Registers a middleware action for the given route.\n public void RegisterInterceptor(string route, Func\u0026lt;HttpRequest, HttpResponse, ClaimsPrincipal, RouteData, Func\u0026lt;HttpRequest, HttpResponse, ClaimsPrincipal, RouteData, Task\u0026gt;, Task\u0026gt; action)\n  route: string - route to register in this object\u0026rsquo;s REST server (service). action: Func\u0026lt;HttpRequest, HttpResponse, ClaimsPrincipal, RouteData, Func\u0026lt;HttpRequest, HttpResponse, ClaimsPrincipal, RouteData, Task\u0026gt;, Task\u0026gt; - middleware action to perform at the given route.  RegisterRoute Registers an action in this objects REST server (service) by the given method and route.\n public void RegisterRoute(string method, string route, Func\u0026lt;HttpRequest, HttpResponse, RouteData, Task\u0026gt; action)\n  method: string - HTTP method of the route. route: string - route to register in this object\u0026rsquo;s REST server (service). action: Func\u0026lt;HttpRequest, HttpResponse, RouteData, Task\u0026gt; - action to perform at the given route.  RegisterRouteWithAuth Registers an action with authorization in this objects REST server (service) by the given method and route.\n public void RegisterRouteWithAuth(string method, string route, Func\u0026lt;HttpRequest, HttpResponse, ClaimsPrincipal, RouteData, Func\u0026lt;Task\u0026gt;, Task\u0026gt; authorize, Func\u0026lt;HttpRequest, HttpResponse, ClaimsPrincipal, RouteData, Task\u0026gt; action)\n  method: string - HTTP method of the route. route: string - route to register in this object\u0026rsquo;s REST server (service). authorize: Func\u0026lt;HttpRequest, HttpResponse, ClaimsPrincipal, RouteData, Func\u0026lt;Task\u0026gt;, Task\u0026gt; - authorization interceptor action: Func\u0026lt;HttpRequest, HttpResponse, ClaimsPrincipal, RouteData, Task\u0026gt; - action to perform at the given route.  SetReferences Sets references to this endpoint\u0026rsquo;s logger, counters, and connection resolver.\n public virtual void SetReferences(IReferences references)\n  references: IReferences - IReferences object, containing references to a logger, counters, and a connection resolver.  Uninitialize TODO: add description\n public void Uninitialize(IInitializable initialization)\n  initialization: IInitializable - TODO: add description  Unregister Unregisters a registerable object, so that it is no longer used in dynamic endpoint discovery.\n public void Unregister(IRegisterable registration)\n  registration: IRegisterable - registration to remove.  Examples public MyMethod(string correlationId, ConfigParams _config, IReferences _references) { var endpoint = new HttpEndpoint(); if (this._config) endpoint.Configure(this._config); if (this._references) endpoint.SetReferences(this._references); ... this._endpoint.Open(correlationId); ... } See also   IConfigurable   IReferenceable   IOpenable   ","description":"Used for creating HTTP endpoints. \n","image":null,"permalink":"/net/rpc/services/http_endpoint/","subtitle":null,"tags":null,"title":"HttpEndpoint"},{"content":"Implements: IConfigurable, IReferenceable, IOpenable\nDescription The HttpEndpoint class allows you to create HTTP endpoints.\nImportant points\n An endpoint is a URL, at which a given service can be accessed by a client.  Configuration parameters Parameters to pass to the configure method for component configuration:\n connection(s): the connection resolver\u0026rsquo;s connections:  \u0026ldquo;connection.discovery_key\u0026rdquo;: key to use for connection resolving in a discovery service; \u0026ldquo;connection.protocol\u0026rdquo;: connection\u0026rsquo;s protocol; \u0026ldquo;connection.host\u0026rdquo;: target host; \u0026ldquo;connection.port\u0026rdquo;: target port; \u0026ldquo;connection.uri\u0026rdquo;: target URI.   credential: the HTTPS credentials:  \u0026ldquo;credential.ssl_key_file\u0026rdquo;: SSL private key in PEM \u0026ldquo;credential.ssl_crt_file\u0026rdquo;: SSL certificate in PEM \u0026ldquo;credential.ssl_ca_file\u0026rdquo;: certificate authorities (root cerfiticates) in PEM    References A logger, counters, and a connection resolver can be referenced by passing the following references to the object\u0026rsquo;s set_references method:\n *:logger:*:*:1.0 - (optional) ILogger components to pass log messages *:counters:*:*:1.0 - (optional) ICounters components to pass collected measurements *:discovery:*:*:1.0 - (optional) IDiscovery services to resolve connections  Instance methods close Closes this endpoint and the REST server (service) that was opened earlier.\n public close(correlationId: string): Promise\u0026lt;void\u0026gt;\n  correlationId: string - (optional) transaction id used to trace execution through the call chain.  configure Configures this HttpEndpoint using the given configuration parameters.\n public configure(config: ConfigParams): void\n  config: ConfigParams - configuration parameters, containing a \u0026ldquo;connection(s)\u0026rdquo; section.  getCorrelationId Returns correlationId from request\n public getCorrelationId(): string\n  returns: string - http response to the request.  isOpen Checks if the component is open.\n public isOpen(): boolean\n  returns: boolean - whether or not this endpoint is open with an actively listening REST server.  register Registers a registerable object for dynamic endpoint discovery.\n public register(registration: IRegisterable): void\n  registration: IRegisterable - the registration to add.  registerInterceptor Registers a middleware action for the given route.\n public registerInterceptor(route: string, action: (req: any, res: any, next: () =\u0026gt; void) =\u0026gt; void): void\n  route: string - route to register in this object\u0026rsquo;s REST server (service). action: (req: any, res: any, next: () =\u0026gt; void) =\u0026gt; void - middleware action to perform at the given route.  registerRoute Registers an action in this objects REST server (service) by the given method and route.\n public registerRoute(method: string, route: string, schema: Schema, action: (req: any, res: any) =\u0026gt; void): void\n  method: string - HTTP method of the route. route: string - route to register in this object\u0026rsquo;s REST server (service). schema: Schema - schema to use for parameter validation. action: (req: any, res: any) =\u0026gt; void - action to perform at the given route.  registerRouteWithAuth Registers an action with authorization in this objects REST server (service) by the given method and route.\n public registerRouteWithAuth(method: string, route: string, schema: Schema, authorize: (req: any, res: any, next: () =\u0026gt; void) =\u0026gt; void, action: (req: any, res: any) =\u0026gt; void): void\n  method: string - HTTP method of the route. route: string - route to register in this object\u0026rsquo;s REST server (service). schema: Schema - schema to use for parameter validation. authorize: (req: any, res: any, next: () =\u0026gt; void) =\u0026gt; void - authorization interceptor action: (req: any, res: any) =\u0026gt; void - action to perform at the given route.  setReferences Sets references to this endpoint\u0026rsquo;s logger, counters, and connection resolver.\n public setReferences(references: IReferences): void\n  references: IReferences - IReferences object, containing references to a logger, counters, and a connection resolver.  unregister Unregisters a registerable object, so that it is no longer used in dynamic endpoint discovery.\n public unregister(registration: IReferences): void\n  registration: IRegisterable - registration to remove.  Examples public MyMethod(_config: ConfigParams, _references: IReferences) { let endpoint = new HttpEndpoint(); if (this._config) endpoint.configure(this._config); if (this._references) endpoint.setReferences(this._references); ... await this._endpoint.open(correlationId); this._opened = true; ... } See also   IConfigurable   IReferenceable   IOpenable   ","description":"Used for creating HTTP endpoints. \n","image":null,"permalink":"/node/rpc/services/http_endpoint/","subtitle":null,"tags":null,"title":"HttpEndpoint"},{"content":"Implements: IConfigurable, IReferenceable, IOpenable\nDescription The HttpEndpoint class allows you to create HTTP endpoints.\nImportant points\n An endpoint is a URL, at which a given service can be accessed by a client.  Configuration parameters Parameters to pass to the configure method for component configuration:\n connection(s): the connection resolver\u0026rsquo;s connections:  \u0026ldquo;connection.discovery_key\u0026rdquo;: key to use for connection resolving in a discovery service; \u0026ldquo;connection.protocol\u0026rdquo;: connection\u0026rsquo;s protocol; \u0026ldquo;connection.host\u0026rdquo;: target host; \u0026ldquo;connection.port\u0026rdquo;: target port; \u0026ldquo;connection.uri\u0026rdquo;: target URI.   credential: the HTTPS credentials:  \u0026ldquo;credential.ssl_key_file\u0026rdquo;: SSL private key in PEM \u0026ldquo;credential.ssl_crt_file\u0026rdquo;: SSL certificate in PEM \u0026ldquo;credential.ssl_ca_file\u0026rdquo;: certificate authorities (root cerfiticates) in PEM    References A logger, counters, and a connection resolver can be referenced by passing the following references to the object\u0026rsquo;s set_references method:\n *:logger:*:*:1.0 - (optional) ILogger components to pass log messages *:counters:*:*:1.0 - (optional) ICounters components to pass collected measurements *:discovery:*:*:1.0 - (optional) IDiscovery services to resolve connections  Instance methods close Closes this endpoint and the REST server (service) that was opened earlier.\n close(correlation_id: Optional[str])\n  correlation_id: Optional[str] - (optional) transaction id used to trace execution through the call chain.  configure Configures this HttpEndpoint using the given configuration parameters.\n configure(config: ConfigParams)\n  config: ConfigParams - configuration parameters, containing a \u0026ldquo;connection(s)\u0026rdquo; section.  get_correlation_id Returns correlationId from request\n get_correlation_id(): Optional[str]\n  returns: Optional[str] - http response to the request.  is_open Checks if the component is open.\n is_open(): bool\n  returns: bool - whether or not this endpoint is open with an actively listening REST server.  register Registers a registerable object for dynamic endpoint discovery.\n register(registration: IRegisterable)\n  registration: IRegisterable - the registration to add.  register_interceptor Registers a middleware action for the given route.\n register_interceptor(route: str, action: Callable)\n  route: str - route to register in this object\u0026rsquo;s REST server (service). action: Callable - middleware action to perform at the given route.  register_route Registers an action in this objects REST server (service) by the given method and route.\n register_route(method: str, route: str, schema: Schema, handler: Callable)\n  method: str - HTTP method of the route. route: str - route to register in this object\u0026rsquo;s REST server (service). schema: Schema - schema to use for parameter validation. handler: Callable - action to perform at the given route.  register_route_with_auth Registers an action with authorization in this objects REST server (service) by the given method and route.\n register_route_with_auth(method: str, route: str, schema: Schema, authorize: Callable, action: Callable)\n  method: str - HTTP method of the route. route: str - route to register in this object\u0026rsquo;s REST server (service). schema: Schema - schema to use for parameter validation. authorize: Callable - authorization interceptor action: Callable - action to perform at the given route.  set_references Sets references to this endpoint\u0026rsquo;s logger, counters, and connection resolver.\n set_references(references: IReferences)\n  references: IReferences - IReferences object, containing references to a logger, counters, and a connection resolver.  unregister Unregisters a registerable object, so that it is no longer used in dynamic endpoint discovery.\n unregister(registration: IRegisterable)\n  registration: IRegisterable - registration to remove.  Examples def my_method(_config, _references): endpoint = HttpEndpoint() if (_config) endpoint.configure(_config) if (_references) endpoint.setReferences(_references) # ... endpoint.open(correlationId) # ... See also   IConfigurable   IReferenceable   IOpenable   ","description":"Used for creating HTTP endpoints. \n","image":null,"permalink":"/python/rpc/services/http_endpoint/","subtitle":null,"tags":null,"title":"HttpEndpoint"},{"content":"Description The HttpRequestDetector class allows you to retrieve parameters from HTTP requests.\nMethods DetectAddress Detects the IP address from where the given HTTP request was received.\n (c *THttpRequestDetector) DetectAddress(req *http.Request) string\n  req: *http.Request - HTTP request to process. returns: string - detected IP address (without a port). If no IP is detected - nil will be returned.  DetectBrowser Detects the browser (using \u0026ldquo;user-agent\u0026rdquo;) from where the given HTTP request was made.\n (c *THttpRequestDetector) DetectBrowser(req *http.Request) string\n  req: *http.Request - HTTP request to process. returns: string - detected browser. Detectable browsers: \u0026ldquo;chrome\u0026rdquo;, \u0026ldquo;msie\u0026rdquo;, \u0026ldquo;firefox\u0026rdquo;, \u0026ldquo;safari\u0026rdquo;. Otherwise - \u0026ldquo;unknown\u0026rdquo; will be returned.  DetectPlatform Detects the platform (using \u0026ldquo;user-agent\u0026rdquo;) from which the given HTTP request was made.\n (c *THttpRequestDetector) DetectPlatform(req *http.Request) string\n  req: *http.Request - HTTP request to process. returns: string - detected platform and version. Detectable platforms: \u0026ldquo;mobile\u0026rdquo;, \u0026ldquo;iphone\u0026rdquo;, \u0026ldquo;ipad\u0026rdquo;, \u0026ldquo;macosx\u0026rdquo;, \u0026ldquo;android\u0026rdquo;, \u0026ldquo;webos\u0026rdquo;, \u0026ldquo;mac\u0026rdquo;, \u0026ldquo;windows\u0026rdquo;. Otherwise - \u0026ldquo;unknown\u0026rdquo; will be returned.  DetectServerHost Detects the host name of the request\u0026rsquo;s destination server.\n (c *THttpRequestDetector) DetectServerHost(req *http.Request) string\n  req: *http.Request - HTTP request to process. returns: string - destination server\u0026rsquo;s host name.  DetectServerPort Detects the request\u0026rsquo;s destination port number.\n (c *THttpRequestDetector) DetectServerPort(req *http.Request) string\n  req: *http.Request - HTTP request to process. returns: string - detected port number or 80 (if none are detected).  ","description":"Helper class that retrieves parameters from HTTP requests.\n","image":null,"permalink":"/golang/rpc/services/http_request_detector/","subtitle":null,"tags":null,"title":"HttpRequestDetector"},{"content":"Description The HttpRequestDetector class allows you to retrieve parameters from HTTP requests.\nStatic methods detectAddress Detects the IP address from where the given HTTP request was received.\n public static detectAddress(req: any): string\n  req: any - HTTP request to process. returns: string - detected IP address (without a port). If no IP is detected - null will be returned.  detectBrowser Detects the browser (using \u0026ldquo;user-agent\u0026rdquo;) from where the given HTTP request was made.\n public static detectBrowser(req: any) -\u0026gt; string\n  req: any - HTTP request to process. returns: string - detected browser. Detectable browsers: \u0026ldquo;chrome\u0026rdquo;, \u0026ldquo;msie\u0026rdquo;, \u0026ldquo;firefox\u0026rdquo;, \u0026ldquo;safari\u0026rdquo;. Otherwise - \u0026ldquo;unknown\u0026rdquo; will be returned.  detectPlatform Detects the platform (using \u0026ldquo;user-agent\u0026rdquo;) from which the given HTTP request was made.\n public static detectPlatform(req: any): string\n  req: any - HTTP request to process. returns: string - detected platform and version. Detectable platforms: \u0026ldquo;mobile\u0026rdquo;, \u0026ldquo;iphone\u0026rdquo;, \u0026ldquo;ipad\u0026rdquo;, \u0026ldquo;macosx\u0026rdquo;, \u0026ldquo;android\u0026rdquo;, \u0026ldquo;webos\u0026rdquo;, \u0026ldquo;mac\u0026rdquo;, \u0026ldquo;windows\u0026rdquo;. Otherwise - \u0026ldquo;unknown\u0026rdquo; will be returned.  detectServerHost Detects the host name of the request\u0026rsquo;s destination server.\n public static detectServerHost(req: any): string\n  req: any - HTTP request to process. returns: string - destination server\u0026rsquo;s host name.  detectServerPort Detects the request\u0026rsquo;s destination port number.\n public static detectServerPort(req: any): string\n  req: any - HTTP request to process. returns: string - detected port number or 80 (if none are detected).  ","description":"Helper class that retrieves parameters from HTTP requests.\n","image":null,"permalink":"/node/rpc/services/http_request_detector/","subtitle":null,"tags":null,"title":"HttpRequestDetector"},{"content":"Description The HttpRequestDetector class allows you to retrieve parameters from HTTP requests.\nStatic methods detect_address Detects the IP address from where the given HTTP request was received.\n static detect_address(req: bottle.Request): str\n  req: bottle.Request - HTTP request to process. returns: str - detected IP address (without a port). If no IP is detected - None will be returned.  detect_browser Detects the browser (using \u0026ldquo;user-agent\u0026rdquo;) from where the given HTTP request was made.\n static detect_browser(req: bottle.Request) -\u0026gt; str\n  req: bottle.Request - HTTP request to process. returns: str - detected browser. Detectable browsers: \u0026ldquo;chrome\u0026rdquo;, \u0026ldquo;msie\u0026rdquo;, \u0026ldquo;firefox\u0026rdquo;, \u0026ldquo;safari\u0026rdquo;. Otherwise - \u0026ldquo;unknown\u0026rdquo; will be returned.  detect_platform Detects the platform (using \u0026ldquo;user-agent\u0026rdquo;) from which the given HTTP request was made.\n static detect_platform(req: bottle.Request): str\n  req: bottle.Request - HTTP request to process. returns: str - detected platform and version. Detectable platforms: \u0026ldquo;mobile\u0026rdquo;, \u0026ldquo;iphone\u0026rdquo;, \u0026ldquo;ipad\u0026rdquo;, \u0026ldquo;macosx\u0026rdquo;, \u0026ldquo;android\u0026rdquo;, \u0026ldquo;webos\u0026rdquo;, \u0026ldquo;mac\u0026rdquo;, \u0026ldquo;windows\u0026rdquo;. Otherwise - \u0026ldquo;unknown\u0026rdquo; will be returned.  detect_server_host Detects the host name of the request\u0026rsquo;s destination server.\n static detect_server_host(req: bottle.Request): str\n  req: bottle.Request - HTTP request to process. returns: str - destination server\u0026rsquo;s host name.  detect_server_port Detects the request\u0026rsquo;s destination port number.\n static detect_server_port(req: bottle.Request): str\n  req: bottle.Request - HTTP request to process. returns: string - detected port number or 80 (if none are detected).  ","description":"Helper class that retrieves parameters from HTTP requests.\n","image":null,"permalink":"/python/rpc/services/http_request_detector/","subtitle":null,"tags":null,"title":"HttpRequestDetector"},{"content":"Description TODO: add description\nStatic methods GetCorrelationId TODO: add description\n public static string GetCorrelationId(HttpRequest request)\n  request: HttpRequest - HTTP request to process. returns: string - TODO: add description  GetFilterParams TODO: add description\n public static FilterParams GetFilterParams(HttpRequest request)\n  request: HttpRequest - HTTP request to process. returns: FilterParams - TODO: add description  GetPagingParams TODO: add description\n public static PagingParams GetPagingParams(HttpRequest request)\n  request: HttpRequest - HTTP request to process. returns: PagingParams - TODO: add description  GetParameters TODO: add description\n public static RestOperationParameters GetParameters(HttpRequest request)\n  request: HttpRequest - HTTP request to process. returns: RestOperationParameters - TODO: add description  GetSortParams TODO: add description\n public static SortParams GetSortParams(HttpRequest request)\n  request: HttpRequest - HTTP request to process. returns: SortParams - TODO: add description  GetContextItem TODO: add description\n public static T GetContextItem\u0026lt;T\u0026gt;(HttpRequest request, string name)\n  request: HttpRequest - HTTP request to process. name: string - TODO: add description returns: T - TODO: add description  ExtractFromQuery TODO: add description\n public static string ExtractFromQuery(string parameter, HttpRequest request)\n  parameter: string - TODO: add description request: HttpRequest - HTTP request to process. returns: RestOperationParameters - TODO: add description  ","description":"Helper class that handles HTTP-based requests.\n","image":null,"permalink":"/net/rpc/services/http_request_detector/","subtitle":null,"tags":null,"title":"HttpRequestHelper"},{"content":"Description The HttpResponseSender class allows you to handle HTTP-based responses.\nMethods SendCreatedResult Creates a callback function that sends a newly created object as JSON. This callack function call be called directly or passed as a parameter to business logic components.\nIf the object is not nil, it returns 201 status code. For nil results, it returns 204 status code. If an error occurs, it sends ErrorDescription with approproate status code.\n (c *THttpResponseSender) SendCreatedResult(res http.ResponseWriter, req *http.Request, result interface{}, err error)\n  res: http.ResponseWriter - an HTTP request req: *http.Request - an HTTP response result: interface{} - an execution result error: error - (optional) error objrct to send  SendDeletedResult Creates a sendDeletedResult function that sends a deleted object as JSON. That callack function call be called directly or passed as a parameter to business logic components.\nIf object is not nil, it returns 201 status code. For nil results, it returns 204 status code. If an error occurs, it sends ErrorDescription with the approproate status code.\n (c *THttpResponseSender) SendDeletedResult(res http.ResponseWriter, req *http.Request, result interface{}, err error)\n  res: http.ResponseWriter - an HTTP request req: *http.Request - an HTTP response result: interface{} - an execution result error: error - (optional) error objrct to send  SendEmptyResult Creates a callback function that sends an empty result with 204 status code. If an error occurs, it sends ErrorDescription with approproate status code.\n (c *THttpResponseSender) SendEmptyResult(res http.ResponseWriter, req *http.Request, err error)\n  res: http.ResponseWriter - an HTTP request req: *http.Request - an HTTP response error: error - (optional) error objrct to send  SendError Sends an error serialized as ErrorDescription object and an appropriate HTTP status code. If status code is not defined, it uses 500 status code.\n (c *THttpResponseSender) SendError(res http.ResponseWriter, req *http.Request, err error)\n  res: http.ResponseWriter - an HTTP request req: *http.Request - an HTTP response error: error - (optional) error objrct to send  SendResult Creates a callback function that sends a result as a JSON object. That callack function call be called directly or passed as a parameter to business logic components.\nIf object is not nil, it returns 200 status code. For nil results, it returns 204 status code. If error occur, it sends ErrorDescription with the approproate status code.\n (c *THttpResponseSender) SendResult(res http.ResponseWriter, req *http.Request, result interface{}, err error)\n  res: http.ResponseWriter - an HTTP request req: *http.Request - an HTTP response result: interface{} - an execution result error: error - (optional) error objrct to send  ","description":"Helper class that handles HTTP-based responses.\n","image":null,"permalink":"/golang/rpc/services/http_response_sender/","subtitle":null,"tags":null,"title":"HttpResponseSender"},{"content":"Description The HttpResponseSender class allows you to handle HTTP-based responses.\nStatic methods SendCreatedResultAsync Creates a callback function that sends a newly created object as JSON. This callack function call be called directly or passed as a parameter to business logic components.\nIf the object is not null, it returns 201 status code. For null results, it returns 204 status code. If an error occurs, it sends ErrorDescription with approproate status code.\n public static Task SendCreatedResultAsync(HttpResponse response, object result)\n  response: HttpResponse - an HTTP request result: object - an HTTP response  SendDeletedResultAsync Creates a SendDeletedResult function that sends a deleted object as JSON. That callack function call be called directly or passed as a parameter to business logic components.\nIf object is not null, it returns 201 status code. For null results, it returns 204 status code. If an error occurs, it sends ErrorDescription with the approproate status code.\n public static Task SendDeletedResultAsync(HttpResponse response, object result)\n  response: HttpResponse - an HTTP response. result: object - execution result  SendEmptyResultAsync Creates a callback function that sends an empty result with 204 status code. If an error occurs, it sends ErrorDescription with approproate status code.\n public static Task SendEmptyResultAsync(HttpResponse response)\n  response: HttpResponse - an HTTP response  SendErrorAsync Sends an error serialized as ErrorDescription object and an appropriate HTTP status code. If status code is not defined, it uses 500 status code.\n public static Task SendErrorAsync(HttpResponse response, Exception ex)\n  response: HttpResponse - an HTTP response ex: Exception - execution result  SendResultAsync Creates a callback function that sends a result as a JSON object. That callack function call be called directly or passed as a parameter to business logic components.\nIf object is not null, it returns 200 status code. For null results, it returns 204 status code. If error occur, it sends ErrorDescription with the approproate status code.\n public static Task SendResultAsync(HttpResponse response, object result)\n  response: HttpResponse - an HTTP response result: object - execution result  ","description":"Helper class that handles HTTP-based responses.\n","image":null,"permalink":"/net/rpc/services/http_response_sender/","subtitle":null,"tags":null,"title":"HttpResponseSender"},{"content":"Description The HttpResponseSender class allows you to handle HTTP-based responses.\nStatic methods sendCreatedResult Creates a callback function that sends a newly created object as JSON. This callack function call be called directly or passed as a parameter to business logic components.\nIf the object is not null, it returns 201 status code. For null results, it returns 204 status code. If an error occurs, it sends ErrorDescription with approproate status code.\n public static sendCreatedResult(req: any, res: any, result: any): void\n  req: any - an HTTP request res: any - an HTTP response result: any - an execution result  sendDeletedResult Creates a sendDeletedResult function that sends a deleted object as JSON. That callack function call be called directly or passed as a parameter to business logic components.\nIf object is not null, it returns 201 status code. For null results, it returns 204 status code. If an error occurs, it sends ErrorDescription with the approproate status code.\n public static sendDeletedResult(req: any, res: any, result: any): void\n  req: any - an HTTP request res: any - an HTTP response result: any - execution result  sendEmptyResult Creates a callback function that sends an empty result with 204 status code. If an error occurs, it sends ErrorDescription with approproate status code.\n public static sendEmptyResult(req: any, res: any): void\n  req: any - an HTTP request res: any - an HTTP response result: any - an execution result  sendError Sends an error serialized as ErrorDescription object and an appropriate HTTP status code. If status code is not defined, it uses 500 status code.\n public static sendError(req: any, res: any, error: any): void\n  req: any - an HTTP request res: any - an HTTP response result: any - execution result  sendResult Creates a callback function that sends a result as a JSON object. That callack function call be called directly or passed as a parameter to business logic components.\nIf object is not null, it returns 200 status code. For null results, it returns 204 status code. If error occur, it sends ErrorDescription with the approproate status code.\n public static sendResult(req: any, res: any, result: any): void\n  req: any - an HTTP request res: any - an HTTP response result: any - execution result  ","description":"Helper class that handles HTTP-based responses.\n","image":null,"permalink":"/node/rpc/services/http_response_sender/","subtitle":null,"tags":null,"title":"HttpResponseSender"},{"content":"Description The HttpResponseSender class allows you to handle HTTP-based responses.\nStatic methods send_created_result Creates a callback function that sends a newly created object as JSON. This callack function call be called directly or passed as a parameter to business logic components.\nIf the object is not None, it returns 201 status code. For None results, it returns 204 status code. If an error occurs, it sends ErrorDescription with approproate status code.\n static send_created_result(result: Any): Optional[str]\n  result: Any - an execution result return: Optional[str] - JSON text response  send_deleted_result Creates a callback function that sends a deleted object as JSON. That callack function call be called directly or passed as a parameter to business logic components.\nIf object is not None, it returns 201 status code. For None results, it returns 204 status code. If an error occurs, it sends ErrorDescription with the approproate status code.\n static send_deleted_result(result: Any = None): Optional[str]\n  result: Any - execution result return: Optional[str] - JSON text response  send_empty_result Creates a callback function that sends an empty result with 204 status code. If an error occurs, it sends ErrorDescription with approproate status code.\n static send_empty_result(result: Any = None): Optional[str]\n  result: Any - an execution result return: Optional[str] - JSON text response  send_error Sends an error serialized as ErrorDescription object and an appropriate HTTP status code. If status code is not defined, it uses 500 status code.\n static send_error(error: Any): str\n  result: Any - execution result return: Optional[str] - JSON text response  send_result Creates a callback function that sends a result as a JSON object. That callack function call be called directly or passed as a parameter to business logic components.\nIf object is not None, it returns 200 status code. For None results, it returns 204 status code. If error occur, it sends ErrorDescription with the approproate status code.\n static send_result(result: Any): Optional[str]\n  result: Any - execution result return: Optional[str] - JSON text response  ","description":"Helper class that handles HTTP-based responses.\n","image":null,"permalink":"/python/rpc/services/http_response_sender/","subtitle":null,"tags":null,"title":"HttpResponseSender"},{"content":"Description TODO: add description\nInstance methods getActions Get all actions supported by the service.\n getActions(): AzureFunctionAction[]\n  returns: AzureFunctionAction[] - an array with supported actions.  ","description":"An interface that allows to integrate Azure Function services into Azure Function containers and connect their actions to the function calls.\n","image":null,"permalink":"/node/azure/services/iazure_function_service/","subtitle":null,"tags":null,"title":"IAzureFunctionService"},{"content":"Description The ICache interface defines methods for caches that are used to cache values, in order to improve performance.\nMethods Remove Removes a value from the cache by its key.\n Remove(correlationId string, key string) error\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. key: string - unique value key. returns: error - return error if not removed.  Retrieve Retrieves cached value from the cache using its key. If value is missing in the cache or expired it returns nil.\n Retrieve(correlationId string, key string) (interface{}, error)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. key: string - unique value key. returns: (interface{}, error) - cached value or nil if value wasn\u0026rsquo;t found or timeout expired.  Store Stores value in the cache with expiration time.\n Store(correlationId string, key string, value interface{}, timeout int64) (interface{}, error)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. key: string - unique value key. value: interface{} - value to store. timeout: int64 - expiration timeout in milliseconds. returns: (interface{}, error) - cached value stored in the cache.  ","description":"Interface for caches that are used to cache values to improve performance.\n","image":null,"permalink":"/golang/components/cache/icache/","subtitle":null,"tags":null,"title":"ICache"},{"content":"Description The ICache interface defines methods for caches that are used to cache values, in order to improve performance.\nInstance methods reRemoveAsyncmove Removes a value from the cache by its key.\n Task RemoveAsync(string correlationId, string key)\n  correlationId: string - (optional) transaction id to trace execution through call chain. key: string - a unique value key.  RetrieveAsync Retrieves cached value from the cache using its key. If value is missing in the cache or expired it returns null.\n Task\u0026lt;T\u0026gt; RetrieveAsync\u0026lt;T\u0026gt;(string correlationId, string key)\n  correlationId: string - (optional) transaction id to trace execution through call chain. key: string - a unique value key. returns: Task\u0026lt;T\u0026gt; - a cached value or null if value wasn\u0026rsquo;t found or timeout expired.  StoreAsync Stores value in the cache with expiration time.\n Task\u0026lt;T\u0026gt; StoreAsync(string correlationId, string key, T value, long timeout)\n  correlationId: string - (optional) transaction id to trace execution through call chain. key: string - a unique value key. value: T - a value to store. timeout: long - expiration timeout in milliseconds. returns: Task\u0026lt;T\u0026gt; - a cached value stored in the cache.  ","description":"Interface for caches that are used to cache values to improve performance.\n","image":null,"permalink":"/net/components/cache/icache/","subtitle":null,"tags":null,"title":"ICache"},{"content":"Description The ICache interface defines methods for caches that are used to cache values, in order to improve performance.\nInstance methods remove Removes a value from the cache by its key.\n remove(correlationId: string, key: string): Promise\u0026lt;void\u0026gt;\n  correlationId: string - (optional) transaction id to trace execution through call chain. key: string - a unique value key.  retrieve Retrieves cached value from the cache using its key. If value is missing in the cache or expired it returns null.\n retrieve(correlationId: string, key: string): Promise\u0026lt;any\u0026gt;\n  correlationId: string - (optional) transaction id to trace execution through call chain. key: string - a unique value key. returns: any - a cached value or null if value wasn\u0026rsquo;t found or timeout expired.  store Stores value in the cache with expiration time.\n store(correlationId: string, key: string, value: any, timeout: number): Promise\u0026lt;any\u0026gt;\n  correlationId: string - (optional) transaction id to trace execution through call chain. key: string - a unique value key. value: any - a value to store. timeout: number - expiration timeout in milliseconds. returns: Promise\u0026lt;any\u0026gt; - a cached value stored in the cache.  ","description":"Interface for caches that are used to cache values to improve performance.\n","image":null,"permalink":"/node/components/cache/icache/","subtitle":null,"tags":null,"title":"ICache"},{"content":"Description The ICache interface defines methods for caches that are used to cache values, in order to improve performance.\nInstance methods remove Removes a value from the cache by its key.\n remove(correlation_id: Optional[str], key: str)\n  correlation_id: Optional[str] - (optional) transaction id to trace execution through call chain. key: str - a unique value key.  retrieve Retrieves cached value from the cache using its key. If value is missing in the cache or expired it returns None.\n retrieve(correlation_id: Optional[str], key: str): Any\n  correlation_id: Optional[str] - (optional) transaction id to trace execution through call chain. key: str - a unique value key. returns: Any - a cached value or None if value wasn\u0026rsquo;t found or timeout expired.  store Stores value in the cache with expiration time.\n store(correlation_id: Optional[str], key: str, value: Any, timeout: int): Any\n  correlation_id: Optional[str] - (optional) transaction id to trace execution through call chain. key: str - a unique value key. value: Any - a value to store. timeout: int - expiration timeout in milliseconds. returns: Any - a cached value stored in the cache.  ","description":"Interface for caches that are used to cache values to improve performance.\n","image":null,"permalink":"/python/components/cache/icache/","subtitle":null,"tags":null,"title":"ICache"},{"content":"Description the ICachedCountersOverrides provides a save method for counters.\nMethods Save Save method for counters.\n Save(counters []*Counter) error\n  counters: []*Counter - counters returns: error - error if counters not saved  ","description":"Interface used to define a save method for counters.\n","image":null,"permalink":"/golang/components/count/icounters_saver/","subtitle":null,"tags":null,"title":"ICachedCountersOverrides"},{"content":"Description The IChangeable interface allows you to store the last modified date and time in the \u0026ldquo;change_time\u0026rdquo; parameter of a data object.\nFields change_time The UTC time at which the object was last changed (created or updated).\n public change_time: Date\n Examples export class MyData implements IStringIdentifiable, IChangeable { public id: string; public field1: string; public field2: number; public change_time: Date; ... }  ","description":"Interface for data objects that need to store the last modified date and time.\n","image":null,"permalink":"/node/commons/data/ichangeable/","subtitle":null,"tags":null,"title":"IChangeable"},{"content":"Description The IChangeable interface allows you to store the last modified date and time in the \u0026ldquo;change_time\u0026rdquo; parameter of a data object.\nFields change_time The UTC time at which the object was last changed (created or updated).\n change_time: datetime\n Examples class MyData(IStringIdentifiable, IChangeable): id: str = \u0026#39;1234567\u0026#39; field1: str = \u0026#39;field1\u0026#39; field2: int = 123 change_time: datetime = datetime.now()  ","description":"Interface for data objects that need to store the last modified date and time.\n","image":null,"permalink":"/python/commons/data/ichangeable/","subtitle":null,"tags":null,"title":"IChangeable"},{"content":"Description The IChangeable interface allows you to store the last modified date and time in the \u0026ldquo;change_time\u0026rdquo; parameter of a data object.\nFields change_time The UTC time at which the object was last changed (created or updated).\n public change_time: time.Time\n Examples type MyData struct { Id string `json:\u0026#34;id\u0026#34;` Field1 string `json:\u0026#34;field1\u0026#34;` Field2 int32 `json:\u0026#34;field2\u0026#34;` ChangeTime time.Time `json:\u0026#34;change_time\u0026#34;` ... }  ","description":"Interface for data objects that need to store the last modified date and time.\n","image":null,"permalink":"/golang/commons/data/ichangeable/","subtitle":null,"tags":null,"title":"IChangeable!"},{"content":"Description The IChangeable interface allows you to store the last modified date and time in the \u0026ldquo;change_time\u0026rdquo; parameter of a data object.\nFields changeTime The UTC time at which the object was last changed (created or updated).\n public DateTime changeTime\n Examples class MyData: IStringIdentifiable, IChangeable { public string id; public string field1; public int field2; public DateTime changeTime; ... }  ","description":"Interface for data objects that need to store the last modified date and time.\n\n**Note: this interface is not available for this language**\n","image":null,"permalink":"/net/commons/data/ichangeable/","subtitle":null,"tags":null,"title":"IChangeable!"},{"content":"Description The ICleanable interface allows you to create components with a method to clean their states.\nMethods Clear Clears a component\u0026rsquo;s state.\n Clear(correlationId string) error\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. returns: error - returns error if not cleared  Examples type MyObjectWithState { _state interface{} } ... func (mo * MyObjectWithState ) clear(correlationId string) { mo._state = interface{} } See also   Cleaner   ","description":"Interface that allows you to create components with a method to clean their states.\n","image":null,"permalink":"/golang/commons/run/icleanable/","subtitle":null,"tags":null,"title":"ICleanable"},{"content":"Description The ICleanable interface allows you to create components with a method to clean their states.\nInstance methods ClearAsync Clears a component\u0026rsquo;s state.\n Task ClearAsync(string correlationId)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain.  Examples class MyObjectWithState: ICleanable { var _state = new Object[]{}; ... public void Clear(string correlationId) { this._state = new Object[] { }; } } See also   Cleaner   ","description":"Interface that allows you to create components with a method to clean their states.\n","image":null,"permalink":"/net/commons/run/icleanable/","subtitle":null,"tags":null,"title":"ICleanable"},{"content":"Description The ICleanable interface allows you to create components with a method to clean their states.\nInstance methods clear Clears a component\u0026rsquo;s state.\n clear(correlationId: string): Promise\u0026lt;void\u0026gt;\n  correlationId: string - (optional) transaction id used to trace execution through the call chain.  Examples class MyObjectWithState implements ICleanable { private _state: any = {}; ... public async clear(correlationId: string): void { this._state = {}; } } See also   Cleaner   ","description":"Interface that allows you to create components with a method to clean their states.\n","image":null,"permalink":"/node/commons/run/icleanable/","subtitle":null,"tags":null,"title":"ICleanable"},{"content":"Description The ICleanable interface allows you to create components with a method to clean their states.\nInstance methods clear Clears component state.\n clear(correlation_id: Optional[str])\n  correlation_id: Optional[str] - (optional) transaction id to trace execution through call chain.  Examples class MyObjectWithState(ICleanable): _state = {} ... def clear(self, correlation_id): self._state = {} See also   Cleaner   ","description":"Interface that allows you to create components with a method to clean their states.\n","image":null,"permalink":"/python/commons/run/icleanable/","subtitle":null,"tags":null,"title":"ICleanable"},{"content":"Description The ICloneable interface allows you to create objects with binary clones.\nMethods clone Creates a binary clone of this object.\n Clone() interface{}\n  returns: interface{} - a clone of this object.  Examples type MyStruct struct { ... } func (c MyStruct) Clone() interface{} { cloneObj := new(MyStruct) // Copy every attribute from this to cloneObj here. \t... return cloneObj } ","description":"Interface to create objects with binary clones.\n","image":null,"permalink":"/golang/commons/data/icloneable/","subtitle":null,"tags":null,"title":"ICloneable"},{"content":"Description The ICloneable interface allows you to create objects with binary clones.\nInstance methods Clone Creates a binary clone of this object.\n object Clone()\n  returns: object - clone of this object.  Examples public class MyClass: IMyClass, ICloneable { MyClass() { }; public object clone() { var cloneObj = new Object(this); // Copy every attribute from this to cloneObj here.  ... return cloneObj; } } ","description":"Interface to create objects with binary clones.\n","image":null,"permalink":"/net/commons/data/icloneable/","subtitle":null,"tags":null,"title":"ICloneable"},{"content":"Description The ICloneable interface allows you to create objects with binary clones.\nInstance methods clone Creates a binary clone of this object.\n clone(): any\n  returns: any - clone of this object.  Examples export class MyClass implements IMyClass, ICloneable { constructor() { }; public clone(): any { var cloneObj = new (\u0026lt;any\u0026gt;this.constructor()); // Copy every attribute from this to cloneObj here.  ... return cloneObj; } } ","description":"Interface to create objects with binary clones.\n","image":null,"permalink":"/node/commons/data/icloneable/","subtitle":null,"tags":null,"title":"ICloneable"},{"content":"Description The ICloneable interface allows you to create objects with binary clones.\nInstance methods clone Creates a binary clone of this object.\n clone(): Any\n  returns: Any - a clone of this object.  Examples class MyClass(IMyClass, ICloneable): def __init__(): ... pass def clone(self): clone_obj = self.__init__() return clone_obj ","description":"Interface to create objects with binary clones.\n","image":null,"permalink":"/python/commons/data/icloneable/","subtitle":null,"tags":null,"title":"ICloneable"},{"content":"Description The IClosable interface allows you to create a component with a method that closes it and frees the used resources.\nMethods Close Closes a component and frees the used resources.\n Close(correlationId string) error\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. returns: error - returns an error if not cleared  Examples type MyConnector { _client interface{} } ... // The _client can be lazy created  func (mc *MyConnector) Close(correlationId: string):error { if (mc._client != nil) { mc._client.Close() mc._client = nil return nil } } See also   IOpenable   Closer   ","description":"Interface that allows you to create a component with a method that closes it and frees the used resources.\n","image":null,"permalink":"/golang/commons/run/iclosable/","subtitle":null,"tags":null,"title":"IClosable"},{"content":"Description The IClosable interface allows you to create a component with a method that closes it and frees used resources.\nInstance methods CloseAsync Closes component and frees used resources.\n Task CloseAsync(string correlationId)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain.  Examples class MyConnector: ICloseable { private object _client = null; ... // The _client can be lazy created  public void Close(string correlationId) { if (this._client != null) { this._client.Close(); this._client = null; } } } See also   IOpenable   Closer   ","description":"Interface that allows you to create a component with a method that closes it and frees used resources.\n","image":null,"permalink":"/net/commons/run/iclosable/","subtitle":null,"tags":null,"title":"IClosable"},{"content":"Description The IClosable interface allows you to create a component with a method that closes it and frees used resources.\nInstance methods close Closes a component and frees used resources.\n close(correlationId: string): Promise\u0026lt;void\u0026gt;\n  correlationId: string - (optional) transaction id used to trace execution through the call chain.  Examples class MyConnector implements ICloseable { private _client: any = null; ... // The _client can be lazy created  public async close(correlationId: string): Promise\\\u0026lt;void\\\u0026gt; { if (this._client != null) { this._client.close(); this._client = null; } } } See also   IOpenable   Closer   ","description":"Interface that allows you to create a component with a method that closes it and frees used resources.\n","image":null,"permalink":"/node/commons/run/iclosable/","subtitle":null,"tags":null,"title":"IClosable"},{"content":"Description The IClosable interface allows you to create a component with a method that closes it and frees used resources.\nInstance methods close Closes a component and frees used resources.\n close(correlation_id: Optional[str])\n  correlation_id: Optional[str] - (optional) transaction id to trace execution through call chain.  Examples class MyConnector(ICloseable): _client = None ... # The _client can be lazy created def close(self, correlation_id): if self._client is not None: self._client.close() self._client = None See also   IOpenable   Closer   ","description":"Interface that allows you to create a component with a method that closes it and frees used resources.\n","image":null,"permalink":"/python/commons/run/iclosable/","subtitle":null,"tags":null,"title":"IClosable"},{"content":"Implements: IExecutable\nDescription The ICommand interface is used to define Commands. Each command wraps a method or function and allows to call them in a uniform and safe manner.\nMethods Name Gets the command name.\n Name() string\n  returns: string - command name.  Validate Validates command arguments before execution using defined schema.\n Validate(args *run.Parameters) []*validate.ValidationResult\n  args: *run.Parameters - parameters (arguments) to validate. returns: []*validate.ValidationResult - command name.  See also   Command   IExecutable   ICommandInterceptor   InterceptedCommand   ","description":"An interface used to define Commands.\n","image":null,"permalink":"/golang/commons/commands/icommand/","subtitle":null,"tags":null,"title":"ICommand"},{"content":"Inherits: IExecutable\nDescription The ICommand interface is used to define Commands. Each command wraps a method or function and allows to call them in a uniform and safe manner.\nProperties Name Gets the command name.\n public string Name { get; }\n Schema Gets the command schema.\n public Schema Schema { get; }\n Instance methods Validate Validates command arguments before execution using a defined schema.\n IList\u0026lt;ValidationResult\u0026gt; Validate(args: Parameters)\n  args: Parameters - parameters (arguments) to validate. returns: ValidationResult[] - command name.  See also   Command   IExecutable   ICommandInterceptor   InterceptedCommand   ","description":"An interface used to define Commands.\n","image":null,"permalink":"/net/commons/commands/icommand/","subtitle":null,"tags":null,"title":"ICommand"},{"content":"Extends: IExecutable\nDescription The ICommand interface is used to define Commands. Each command wraps a method or function and allows calling them in a uniform and safe manner.\nInstance methods getName Gets the command name.\n getName(): string\n  returns: string - command name.  validate Validates command arguments before execution using a defined schema.\n validate(args: Parameters): ValidationResult[]\n  args: Parameters - parameters (arguments) to validate. returns: ValidationResult[] - command name.  See also   Command   IExecutable   ICommandInterceptor   InterceptedCommand   ","description":"An interface used to define Commands.\n","image":null,"permalink":"/node/commons/commands/icommand/","subtitle":null,"tags":null,"title":"ICommand"},{"content":"Implements: IExecutable\nDescription The ICommand interface is used to define Commands. Each command wraps a method or function and allows to call them in a uniform and safe manner.\nInstance methods get_name Gets the command name.\n get_name(): str\n  returns: str - the command name.  validate Validates command arguments before execution using a defined schema.\n validate(args: Parameters): List[ValidationResult]\n  args: Parameters - the parameters (arguments) to validate. returns: List[ValidationResult] - the command name.  See also   Command   IExecutable   ICommandInterceptor   InterceptedCommand   ","description":"An interface used to define Commands.\n","image":null,"permalink":"/python/commons/commands/icommand/","subtitle":null,"tags":null,"title":"ICommand"},{"content":"Description The ICommandable interface allows you to expose the functionality of commandable objects as commands and events grouped into a CommandSet object.\nImportant points\n This interface is typically implemented by controllers and is used to auto generate external interfaces.  Methods GetCommandSet Gets a command set with all supported commands and events.\n GetCommandSet() *CommandSet\n  returns: CommandSet - command set with commands and events.  Examples type MyDataController { _commandSet CommandSet; } func (dc *MyDataController) getCommandSet() CommandSet { if (dc._commandSet == nil) dc._commandSet = NewDataCommandSet(); return dc._commandSet; } See also   CommandSet   ","description":"An interface used to expose the functionality of commandable objects as commands and events grouped into a [CommandSet](../command_set) object.\n","image":null,"permalink":"/golang/commons/commands/icommandable/","subtitle":null,"tags":null,"title":"ICommandable"},{"content":"Description The ICommandable interface allows you to expose the functionality of commandable objects as commands and events grouped into a CommandSet object.\nImportant points\n This interface is typically implemented by controllers and is used to auto generate external interfaces.  Instance methods GetCommandSet Gets a command set with all supported commands and events.\n CommandSet GetCommandSet()\n  returns: CommandSet - command set with commands and events.  Examples public class MyDataController: ICommandable, IMyDataController { private MyDataCommandSet _commandSet; public CommandSet getCommandSet() { if (this._commandSet == null) this._commandSet = new MyDataCommandSet(this); return this._commandSet; } ... } See also   CommandSet   ","description":"An interface used to expose the functionality of commandable objects as commands and events grouped into a [CommandSet](../command_set) object.\n","image":null,"permalink":"/net/commons/commands/icommandable/","subtitle":null,"tags":null,"title":"ICommandable"},{"content":"Description The ICommandable interface allows you to expose the functionality of commandable objects as commands and events grouped into a CommandSet object.\nImportant points\n This interface is typically implemented by controllers and is used to auto generate external interfaces.  Instance methods getCommandSet Gets a command set with all supported commands and events.\n getCommandSet(): CommandSet\n  returns: CommandSet - command set with commands and events.  Examples export class MyDataController implements ICommandable, IMyDataController { private _commandSet : MyDataCommandSet; public getCommandSet(): CommandSet { if (this._commandSet == null) this._commandSet = new MyDataCommandSet(this); return this._commandSet; } ... } See also   CommandSet   ","description":"An interface used to expose the functionality of commandable objects as commands and events grouped into a [CommandSet](../command_set) object.\n","image":null,"permalink":"/node/commons/commands/icommandable/","subtitle":null,"tags":null,"title":"ICommandable"},{"content":"Description The ICommandable interface allows you to expose the functionality of commandable objects as commands and events grouped into a CommandSet object.\nImportant points\n This interface is typically implemented by controllers and is used to auto generate external interfaces.  Instance methods get_command_set Gets a command set with all supported commands and events.\n get_command_set(): CommandSet\n  returns: CommandSet - a command set with commands and events.  Examples class MyDataController(ICommandable, IMyDataController): _commandSet = None def get_command_set(self): if self._commandSet is None: _commandSet = MyDataCommandSet(self) return self._commandSet See also   CommandSet   ","description":"An interface used to expose the functionality of commandable objects as commands and events grouped into a [CommandSet](../command_set) object.\n","image":null,"permalink":"/python/commons/commands/icommandable/","subtitle":null,"tags":null,"title":"ICommandable"},{"content":"Description The ICommandInterceptor interface is used for stackable command interceptors, which can extend and modify the command call chain.\nImportant points\n This technique can be used for authentication, logging, and several other functions.  Methods Name Gets the name of the wrapped command.\nThe interceptor can use this method to override the command name. Otherwise it shall just delegate the call to the wrapped command.\n Name(command ICommand) string\n  command: ICommand - next command in the call chain. returns: string - name of the wrapped command.  Execute Executes the wrapped command with specified arguments.\nThe interceptor can use this method to intercept and alter the command execution. Otherwise it shall just delete the call to the wrapped command.\n Execute(correlationId string, command ICommand, args *run.Parameters) (interface{}, error)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. command: ICommand - next command in the call chain that is to be executed. args: *run.Parameters - parameters (arguments) to pass to the command for execution. returns: (interface{}, error) - execution result  Validate Validates arguments of the wrapped command before its execution.\nThe interceptor can use this method to intercept and alter validation of the command arguments. Otherwise it shall just delegate the call to the wrapped command.\n Validate(command ICommand, args *run.Parameters) []*validate.ValidationResult\n  command: ICommand - next command in the call chain to be validated against. args: *run.Parameters - parameters (arguments) to validate. returns: []*validate.ValidationResult - array of ValidationResults.  See also   ICommand   InterceptedCommand   ","description":"An interface for stackable command interceptors, which can extend and modify the command call chain.\n","image":null,"permalink":"/golang/commons/commands/icommand_interceptor/","subtitle":null,"tags":null,"title":"ICommandInterceptor"},{"content":"Description The ICommandInterceptor interface is used for stackable command interceptors, which can extend and modify the command call chain.\nImportant points\n This technique can be used for authentication, logging, and several other functions.  Instance methods GetName Gets the name of the wrapped command.\nThe interceptor can use this method to override the command name. Otherwise it shall just delegate the call to the wrapped command.\n string GetName(ICommand command)\n  command: ICommand - next command in the call chain. returns: string - name of the wrapped command.  ExecuteAsync Executes the wrapped command with the specified arguments.\nThe interceptor can use this method to intercept and alter the command execution. Otherwise it shall just delete the call to the wrapped command.\n Task\u0026lt;object\u0026gt; ExecuteAsync(string correlationId, ICommand command, : [Parameters](../../run/parameters args))\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. command: ICommand - next command in the call chain that is to be executed. args: Parameters - parameters (arguments) to pass to the command for execution. returns: Task\u0026lt;object\u0026gt; - execution result  Validate Validates arguments of the wrapped command before its execution.\nThe interceptor can use this method to intercept and alter a validation of the command arguments. Otherwise it shall just delegate the call to the wrapped command.\n List\u0026lt;ValidationResult\u0026gt; Validate(command: ICommand, args: Parameters)\n  command: ICommand - next command in the call chain to be validated against. args: Parameters - parameters (arguments) to validate. returns: ValidationResult[] - array of ValidationResults.  See also   ICommand   InterceptedCommand   ","description":"An interface for stackable command interceptors, which can extend and modify the command call chain.\n","image":null,"permalink":"/net/commons/commands/icommand_interceptor/","subtitle":null,"tags":null,"title":"ICommandInterceptor"},{"content":"Description The ICommandInterceptor interface is used for stackable command interceptors, which can extend and modify the command call chain.\nImportant points\n This technique can be used for authentication, logging, and several other functions.  Instance methods getName Gets the name of the wrapped command.\nThe interceptor can use this method to override the command name. Otherwise, it shall just delegate the call to the wrapped command.\n getName(command: ICommand): string\n  command: ICommand - next command in the call chain. returns: string - name of the wrapped command.  execute Executes the wrapped command with specified arguments.\nThe interceptor can use this method to intercept and alter the command execution. Otherwise, it shall just delete the call to the wrapped command.\n execute(correlationId: string, command: ICommand, args: Parameters): Promise\u0026lt;any\u0026gt;\n  correlationId: string - (optional) transaction id to used trace execution through the call chain. command: ICommand - next command in the call chain that is to be executed. args: Parameters - parameters (arguments) to pass to the command for execution. returns: Promise\u0026lt;any\u0026gt; - execution result.  validate Validates the arguments of the wrapped command before its execution.\nThe interceptor can use this method to intercept and alter validation of the command arguments. Otherwise, it shall just delegate the call to the wrapped command.\n validate(command: ICommand, args: Parameters): ValidationResult[]\n  command: ICommand - next command in the call chain to be validated against. args: Parameters - parameters (arguments) to validate. returns: ValidationResult[] - array of ValidationResults.  See also   ICommand   InterceptedCommand   ","description":"An interface for stackable command interceptors, which can extend and modify the command call chain.\n","image":null,"permalink":"/node/commons/commands/icommand_interceptor/","subtitle":null,"tags":null,"title":"ICommandInterceptor"},{"content":"Description The ICommandInterceptor interface is used for stackable command interceptors, which can extend and modify the command call chain.\nImportant points\n This technique can be used for authentiction, logging, and several other functions.  Instance methods get_name Gets the name of the wrapped command.\nThe interceptor can use this method to override the command name. Otherwise it shall just delegate the call to the wrapped command.\n get_name(command: ICommand): str\n  command: ICommand - the next command in the call chain. returns: str - the name of the wrapped command.  execute Executes the wrapped command with the specified arguments.\nThe interceptor can use this method to intercept and alter the command execution. Otherwise it shall just delete the call to the wrapped command.\n execute(correlation_id: Optional[str], command: ICommand, args: Parameters): Any\n  correlation_id: Optional[str] - (optional) transaction id to trace execution through call chain. command: ICommand - the next command in the call chain that is to be executed. args: Parameters - the parameters (arguments) to pass to the command for execution. returns: Any - the execution result  validate Validates arguments of the wrapped command before its execution.\nThe interceptor can use this method to intercept and alter validation of the command arguments. Otherwise it shall just delegate the call to the wrapped command.\n validate(command: ICommand, args: Parameters): List[ValidationResult]\n  command: ICommand - the next command in the call chain to be validated against. args: Parameters - the parameters (arguments) to validate. returns: List[ValidationResult] - an array of ValidationResults.  See also   ICommand   InterceptedCommand   ","description":"An interface for stackable command interceptors, which can extend and modify the command call chain.\n","image":null,"permalink":"/python/commons/commands/icommand_interceptor/","subtitle":null,"tags":null,"title":"ICommandInterceptor"},{"content":"Implements: ITokenizerState\nDescription The ICommentState interface is used for tokenizer states taht prcess comments.\n","description":"Defines an interface for tokenizer state that processes comments.\n","image":null,"permalink":"/node/expressions/tokenizers/icomment_state/","subtitle":null,"tags":null,"title":"ICommentState"},{"content":"Description The IConfigReader interface is used in configuration readers that retrieve a configuration from various sources and make it availale for other components.\nImportant points\n Some IConfigReader implementations may support configuration parameterization. The parameterization allows to use configuration as a template and inject there dynamic values. The values may come from application command like arguments or environment variables.  Methods ReadConfig Reads a configuration and parameterizes it with given values.\n ReadConfig(correlationId string, parameters *c.ConfigParams) (*c.ConfigParams, error)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. parameters: *c.ConfigParams - values to parameters the configuration or nil to skip parameterization. returns: *c.ConfigParams - ConfigParams configuration.  ","description":"Interface for configuration readers that retrieve a configuration from various sources and make it available for other components.\n","image":null,"permalink":"/golang/components/config/iconfig_reader/","subtitle":null,"tags":null,"title":"IConfigReader"},{"content":"Description The IConfigReader interface is used in configuration readers that retrieve a configuration from various sources and make it availale for other components.\nImportant points\n Some IConfigReader implementations may support configuration parameterization. The parameterization allows to use configuration as a template and inject there dynamic values. The values may come from application command like arguments or environment variables.  Instance methods ReadConfig Reads configuration and parameterizes it with given values.\n public ConfigParams ReadConfig(string correlationId, ConfigParams parameters)\n  correlationId: string - (optional) transaction id to trace execution through call chain. parameters: ConfigParams - values to parameters the configuration or null to skip parameterization. returns: ConfigParams - ConfigParams configuration.  ","description":"Interface for configuration readers that retrieve a configuration from various sources and make it available for other components.\n","image":null,"permalink":"/net/components/config/iconfig_reader/","subtitle":null,"tags":null,"title":"IConfigReader"},{"content":"Description The IConfigReader interface is used in configuration readers that retrieve a configuration from various sources and make it availale for other components.\nImportant points\n Some IConfigReader implementations may support configuration parameterization. The parameterization allows to use configuration as a template and inject there dynamic values. The values may come from application command like arguments or environment variables.  Instance methods readConfig Reads configuration and parameterizes it with given values.\n public readConfig(correlationId: string, parameters: ConfigParams): Promise\u0026lt;ConfigParams\u0026gt;\n  correlationId: string - (optional) transaction id to trace execution through call chain. parameters: ConfigParams - values to parameters the configuration or null to skip parameterization. returns: Promise\u0026lt;ConfigParams\u0026gt; - ConfigParams configuration.  ","description":"Interface for configuration readers that retrieve a configuration from various sources and make it available for other components.\n","image":null,"permalink":"/node/components/config/iconfig_reader/","subtitle":null,"tags":null,"title":"IConfigReader"},{"content":"Description The IConfigReader interface is used in configuration readers that retrieve a configuration from various sources and make it availale for other components.\nImportant points\n Some IConfigReader implementations may support configuration parameterization. The parameterization allows to use configuration as a template and inject there dynamic values. The values may come from application command like arguments or environment variables.  Abstract methods _read_config Reads configuration and parameterizes it with given values.\n abstractmethod _read_config(correlation_id: Optional[str], parameters: ConfigParams): ConfigParams\n  correlation_id: Optional[str] - (optional) transaction id to trace execution through call chain. parameters: ConfigParams - values to parameters the configuration or None to skip parameterization. returns: ConfigParams - ConfigParams configuration.  ","description":"Interface for configuration readers that retrieve a configuration from various sources and make it available for other components.\n","image":null,"permalink":"/python/components/config/iconfig_reader/","subtitle":null,"tags":null,"title":"IConfigReader"},{"content":"See also ConfigParams\nDescription IConfigurable is an interface used to set configuration parameters. It can be implemented by any class that needs to define configuration parameters, such as access control credentials.\nImportant points:\n A class that implements this interface needs to implement a single Configure() method. If you need to emphasize the fact that Configure() method can be called multiple times to change object configuration in runtime, use IReconfigurable interface instead.  Methods Configure Configures component by passing configuration parameters.\n Configure(config *ConfigParams)\n  config: *ConfigParams - configuration parameters to be set.  Examples type MyStruct struct { myParam string } func NewMyStruct() *MyStruct { return \u0026amp;MyStruct{ myParam: \u0026#34;default value\u0026#34;, }, } // Implement configure func (c* MyStruct) Configure(config *cconf.ConfigParams) { c.myParam = config.GetAsStringWithDefault(\u0026#34;options.param\u0026#34;, myParam); ... } See also   ConfigParams   ","description":"An interface used to set configuration parameters to an object. \n","image":null,"permalink":"/golang/commons/config/iconfigurable/","subtitle":null,"tags":null,"title":"IConfigurable"},{"content":"See also ConfigParams\nDescription IConfigurable is an interface used to set configuration parameters. It can be implemented by any class that needs to define configuration parameters, such as access control credentials.\nImportant points:\n A class that implements this interface needs to implement a single Configure() method. If you need to emphasize the fact that Configure() method can be called multiple times to change object configuration in runtime, use the IReconfigurable interface instead.  Instance methods Configure Configures a component by its passing configuration parameters.\n void Configure(ConfigParams config)\n  config: ConfigParams - configuration parameters to be set.  Examples public class MyClass: IConfigurable { private var _myParam = \u0026#34;default value\u0026#34;; public Task configure(ConfigParams config) { this._myParam = config.getAsStringWithDefault(\u0026#34;options.param\u0026#34;, myParam); ... } } See also   ConfigParams   ","description":"An interface used to set configuration parameters to an object. \n","image":null,"permalink":"/net/commons/config/iconfigurable/","subtitle":null,"tags":null,"title":"IConfigurable"},{"content":"See also ConfigParams\nDescription IConfigurable is an interface used to set configuration parameters. It can be implemented by any class that needs to define configuration parameters, such as access control credentials.\nImportant points:\n A class that implements this interface needs to implement a single configure() method. If you need to emphasize the fact that configure() method can be called multiple times to change object configuration in runtime, use IReconfigurable interface instead.  Instance methods configure Configures component by passing configuration parameters.\n configure(config: ConfigParams): void\n  config: ConfigParams - configuration parameters to be set.  Examples export class MyClass implements IConfigurable { private _myParam: string = \u0026#34;default value\u0026#34;; // Implement configure  public configure(config: ConfigParams): void { this._myParam = config.getAsStringWithDefault(\u0026#34;options.param\u0026#34;, myParam); ... } } See also   ConfigParams   ","description":"An interface used to set configuration parameters to an object. \n","image":null,"permalink":"/node/commons/config/iconfigurable/","subtitle":null,"tags":null,"title":"IConfigurable"},{"content":"See also ConfigParams\nDescription IConfigurable is an interface used to set configuration parameters. It can be implemented by any class that needs to define configuration parameters, such as access control credentials.\nImportant points:\n A class that implements this interface needs to implement a single configure() method. If you need to emphasize the fact that configure() method can be called multiple times to change object configuration in runtime, use IReconfigurable interface instead.  Instance methods configure Configures component by passing configuration parameters.\n configure(config: ConfigParams)\n  config: ConfigParams - configuration parameters to be set.  Examples class MyClass(IConfigurable): _myParam = \u0026#34;default args\u0026#34; # Implement configure def configure(self, config): self._myParam = config.get_as_string_with_default(\u0026#34;options.param\u0026#34;, myParam) See also   ConfigParams   ","description":"An interface used to set configuration parameters to an object. \n","image":null,"permalink":"/python/commons/config/iconfigurable/","subtitle":null,"tags":null,"title":"IConfigurable"},{"content":"Description The ICounters interface defines the methods for performance counters that measure execution metrics.\nImportant points\n The performance counters measure how code is performing; that is, how fast or slow is, how many transactions were performed, how many objects were stored, what was the latest transaction time and so on. They are critical to monitor and improve performance, scalability and reliability of code in production.  Methods BeginTiming Begins measurement of execution time interval. It returns CounterTiming object which has to be called at CounterTiming.EndTiming to end the measurement and update the counter.\n BeginTiming(name string) *CounterTiming\n  name: string - counter name of Interval type. returns: *CounterTiming - callback object to end timing.  Increment Increments counter by a given value.\n Increment(name string, value int)\n  name: string - counter name of Increment type. value: int - value to add to the counter.  IncrementOne Increments counter by 1.\n IncrementOne(name string)\n  name: string - counter name of Increment type.  Last Records the last calculated measurement value. Usually this method is used by metrics calculated externally.\n Last(name string, value float32)\n  name: string - counter name of Last type. value: float32 - last value to record.  Stats Calculates min/average/max statistics based on the current and previous values.\n Stats(name string, value float32)\n  name: string - counter name of Statistics type value: float32 - value to update statistics  Timestamp Records the given timestamp.\n Timestamp(name string, value time.Time)\n  name: string - counter name of Timestamp type. value: time.Time - timestamp to record.  TimestampNow Records the current time as a timestamp.\n TimestampNow(name string)\n  name: string - counter name of Timestamp type.  ","description":"Interface for performance counters that measure execution metrics.\n","image":null,"permalink":"/golang/components/count/icounters/","subtitle":null,"tags":null,"title":"ICounters"},{"content":"Description The ICounters interface defines the methods for performance counters that measure execution metrics.\nImportant points\n The performance counters measure how code is performing; that is, how fast or slow is, how many transactions were performed, how many objects were stored, what was the latest transaction time and so on. They are critical to monitor and improve performance, scalability and reliability of code in production.  Instance methods BeginTiming Begins measurement of execution time interval. It returns CounterTiming object which has to be called at CounterTiming.EndTiming to end the measurement and update the counter.\n CounterTiming BeginTiming(string name)\n  name: string - a counter name of Interval type. returns: CounterTiming - a callback object to end timing.  Increment Increments counter by a given value.\n void Increment(string name, int value)\n  name: string - a counter name of Increment type. value: int - a value to add to the counter.  IncrementOne Increments counter by 1.\n void IncrementOne(string name)\n  name: string - a counter name of Increment type.  Last Records the last calculated measurement value. Usually this method is used by metrics calculated externally.\n void last(string name, float value)\n  name: string - a counter name of Last type. value: float - a last value to record.  Stats Calculates min/average/max statistics based on the current and previous values.\n void Stats(string name, float value)\n  name: string - a counter name of Statistics type value: float - a value to update statistics  Timestamp Records the given timestamp.\n void Timestamp(string name, DateTime value)\n  name: string - a counter name of Timestamp type. value: DateTime - a timestamp to record.  TimestampNow Records the current time as a timestamp.\n void TimestampNow(string name)\n  name: string - a counter name of Timestamp type.  ","description":"Interface for performance counters that measure execution metrics.\n","image":null,"permalink":"/net/components/count/icounters/","subtitle":null,"tags":null,"title":"ICounters"},{"content":"Description The ICounters interface defines the methods for performance counters that measure execution metrics.\nImportant points\n The performance counters measure how code is performing; that is, how fast or slow is, how many transactions were performed, how many objects were stored, what was the latest transaction time and so on. They are critical to monitor and improve performance, scalability and reliability of code in production.  Instance methods beginTiming Begins measurement of execution time interval. It returns CounterTiming object which has to be called at CounterTiming.endTiming to end the measurement and update the counter.\n beginTiming(name: string): CounterTiming: void\n  name: string - a counter name of Interval type. returns: CounterTiming - a callback object to end timing.  increment Increments counter by a given value.\n increment(name: string, value: number): void\n  name: string - a counter name of Increment type. value: number - a value to add to the counter.  incrementOne Increments counter by 1.\n incrementOne(name: string): void\n  name: string - a counter name of Increment type.  last Records the last calculated measurement value. Usually this method is used by metrics calculated externally.\n last(name: string, value: number): void\n  name: string - a counter name of Last type. value: number - a last value to record.  stats Calculates min/average/max statistics based on the current and previous values.\n stats(name: string, value: number): void\n  name: string - a counter name of Statistics type value: number - a value to update statistics  timestamp Records the given timestamp.\n timestamp(name: string, value: Date): void\n  name: string - a counter name of Timestamp type. value: Date - a timestamp to record.  timestampNow Records the current time as a timestamp.\n timestampNow(name: string): void\n  name: string - a counter name of Timestamp type.  ","description":"Interface for performance counters that measure execution metrics.\n","image":null,"permalink":"/node/components/count/icounters/","subtitle":null,"tags":null,"title":"ICounters"},{"content":"Description The ICounters interface defines the methods for performance counters that measure execution metrics.\nImportant points\n The performance counters measure how code is performing; that is, how fast or slow is, how many transactions were performed, how many objects were stored, what was the latest transaction time and so on. They are critical to monitor and improve performance, scalability and reliability of code in production.  Instance methods begin_timing Begins measurement of execution time interval. It returns CounterTiming object which has to be called at CounterTiming.end_timing to end the measurement and update the counter.\n begin_timing(name: str): CounterTiming\n  name: str - a counter name of Interval type. returns: CounterTiming - a callback object to end timing.  increment Increments counter by a given value.\n increment(name: str, value: float)\n  name: str - a counter name of Increment type. value: float - a value to add to the counter.  increment_one Increments counter by 1.\n increment_one(name: str)\n  name: str - a counter name of Increment type.  last Records the last calculated measurement value. Usually this method is used by metrics calculated externally.\n last(name: str, value: float)\n  name: str - a counter name of Last type. value: float - a last value to record.  stats Calculates min/average/max statistics based on the current and previous values.\n stats(name: str, value: float)\n  name: str - a counter name of Statistics type value: float - a value to update statistics  timestamp Records the given timestamp.\n timestamp(name: str, value: datetime.datetime)\n  name: str - a counter name of Timestamp type. value: datetime.datetime - a timestamp to record.  timestamp_now Records the current time as a timestamp.\n timestamp_now(name: str)\n  name: str - a counter name of Timestamp type.  ","description":"Interface for performance counters that measure execution metrics.\n","image":null,"permalink":"/python/components/count/icounters/","subtitle":null,"tags":null,"title":"ICounters"},{"content":"Description The ICounterTimingCallback interface defines the method used for a callback to end the measurement of the execution elapsed time.\nMethods EndTiming Ends measurement of execution elapsed time and updates specified counter. See also CounterTiming.EndTiming\n EndTiming(name string, elapsed float32)\n  name: string - counter\u0026rsquo;s name elapsed: float32 - execution elapsed time (in milliseconds) to update the counter.  ","description":"Interface for a callback to end the measurement of the execution elapsed time.\n","image":null,"permalink":"/golang/components/count/icounter_timing_callback/","subtitle":null,"tags":null,"title":"ICounterTimingCallback"},{"content":"Description The ICounterTimingCallback interface defines the method used for a callback to end the measurement of the execution elapsed time.\nInstance methods EndTiming Ends measurement of execution elapsed time and updates specified counter. See also CounterTiming.EndTiming\n void EndTiming(string name, double elapsed)\n  name: string - a counter name elapsed: double - execution elapsed time in milliseconds to update the counter.  ","description":"Interface for a callback to end the measurement of the execution elapsed time.\n","image":null,"permalink":"/net/components/count/icounter_timing_callback/","subtitle":null,"tags":null,"title":"ICounterTimingCallback"},{"content":"Description The ICounterTimingCallback interface defines the method used for a callback to end the measurement of the execution elapsed time.\nInstance methods endTiming Ends measurement of execution elapsed time and updates specified counter. See also CounterTiming.endTiming\n endTiming(name: string, elapsed: number): void\n  name: string - a counter name elapsed: number - execution elapsed time in milliseconds to update the counter.  ","description":"Interface for a callback to end the measurement of the execution elapsed time.\n","image":null,"permalink":"/node/components/count/icounter_timing_callback/","subtitle":null,"tags":null,"title":"ICounterTimingCallback"},{"content":"Description The ICounterTimingCallback interface defines the method used for a callback to end the measurement of the execution elapsed time.\nInstance methods end_timing Ends measurement of execution elapsed time and updates specified counter. See also CounterTiming.end_timing\n end_timing(name: str, elapsed: float)\n  name: str - a counter name elapsed: float - execution elapsed time in milliseconds to update the counter.  ","description":"Interface for a callback to end the measurement of the execution elapsed time.\n","image":null,"permalink":"/python/components/count/icounter_timing_callback/","subtitle":null,"tags":null,"title":"ICounterTimingCallback"},{"content":"Description The ICredentialStore interface is used to store and look up credentials used to authenticate against external services.\nMethods Lookup Lookups credential parameters by its key.\n Lookup(correlationId string, key string) (*CredentialParams, error)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. key: string - key used to uniquely identify the credential. returns: (*CredentialParams, error) - found credential parameters or nil if nothing was found.  Store Stores credential parameters into the store.\n Store(correlationId string, key string, credential *CredentialParams) error\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. key: string - key used to uniquely identify the credential. credential: *CredentialParams - credential to be stored. returns: error - return error if not stored  See also   CredentialParams   ConnectionParams   ","description":"Interface for credential stores which are used to store and lookup credentials to authenticate against external services.\n","image":null,"permalink":"/golang/components/auth/icredential_store/","subtitle":null,"tags":null,"title":"ICredentialStore"},{"content":"Inherits: Factory\nDescription The ICredentialStore interface is used to store and look up credentials used to authenticate against external services.\nInstance methods LookupAsync Lookups credential parameters by its key.\n Task\u0026lt;CredentialParams\u0026gt; LookupAsync(string correlationId, stringkey)\n  correlationId: string - (optional) transaction id to trace execution through call chain. key: string - a key to uniquely identify the credential. returns: Task\u0026lt;CredentialParams\u0026gt; - found credential parameters or null if nothing was found.  StoreAsync Stores credential parameters into the store.\n Task StoreAsync(string correlationId, string key, CredentialParams credential)\n  correlationId: string - (optional) transaction id to trace execution through call chain. key: string - a key to uniquely identify the credential. credential: CredentialParams - a credential to be stored.  See also   CredentialParams   ConnectionParams   ","description":"Interface for credential stores which are used to store and lookup credentials to authenticate against external services.\n","image":null,"permalink":"/net/components/auth/icredential_store/","subtitle":null,"tags":null,"title":"ICredentialStore"},{"content":"Implements: Factory\nDescription The ICredentialStore interface is used to store and look up credentials used to authenticate against external services.\nInstance methods lookup Lookups credential parameters by its key.\n lookup(correlationId: string, key: string): Promise\u0026lt;CredentialParams\u0026gt;\n  correlationId: string - (optional) transaction id to trace execution through call chain. key: string - a key to uniquely identify the credential. returns: Promise\u0026lt;CredentialParams\u0026gt; - found credential parameters or null if nothing was found.  store Stores credential parameters into the store.\n store(correlationId: string, key: string, credential: CredentialParams): Promise\u0026lt;void\u0026gt;\n  correlationId: string - (optional) transaction id to trace execution through call chain. key: string - a key to uniquely identify the credential. credential: CredentialParams - a credential to be stored.  See also   CredentialParams   ConnectionParams   ","description":"Interface for credential stores which are used to store and lookup credentials to authenticate against external services.\n","image":null,"permalink":"/node/components/auth/icredential_store/","subtitle":null,"tags":null,"title":"ICredentialStore"},{"content":"Implements: Factory\nDescription The ICredentialStore interface is used to store and look up credentials used to authenticate against external services.\nInstance methods lookup Lookups credential parameters by its key.\n lookup(correlation_id: Optional[str], key: str): CredentialParams\n  correlation_id: Optional[str] - (optional) transaction id to trace execution through call chain. key: str - a key to uniquely identify the credential. returns: CredentialParams - found credential parameters or None if nothing was found.  store Stores credential parameters into the store.\n store(correlation_id: Optional[str], key: str, credential: CredentialParams)\n  correlation_id: Optional[str] - (optional) transaction id to trace execution through call chain. key: str - a key to uniquely identify the credential. credential: CredentialParams - a credential to be stored.  See also   CredentialParams   ConnectionParams   ","description":"Interface for credential stores which are used to store and lookup credentials to authenticate against external services.\n","image":null,"permalink":"/python/components/auth/icredential_store/","subtitle":null,"tags":null,"title":"ICredentialStore"},{"content":"Implements: IdentifiableMemoryPersistence\nDescription The IdentifiableFilePersistence class allows you to create persistence components that store data in flat files and implement a number of CRUD operations over data items with unique ids.\nImportant points\n The data items must implement the IIdentifiable interface. In basic scenarios child classes shall only override GetPageByFilter, GetListByFilter or DeleteByFilter operations with a specific filter function. All other operations can be used out of the box. In complex scenarios child classes can implement additional operations by accessing cached items via the self._items property and calling the Save method on updates.  Configuration parameters   path: path to the file where data is stored\n  options:\n max_page_size: maximum number of items returned in a single page (default: 100)    References  *:logger:*:*:1.0 - (optional) (../../../components/log/ilogger) components to pass log messages  Constructors NewIdentifiableFilePersistence Creates a new instance of the persistence.\n NewIdentifiableFilePersistence(prototype reflect.Type, persister *JsonFilePersister) *IdentifiableMemoryPersistence\n  persister: *JsonFilePersister - (optional) a persister component that loads and saves data from/to flat file.  Fields Persister JSON file persister.\n Persister: *JsonFilePersister\n  Methods Configure Configures component by passing configuration parameters.\n (c *IdentifiableMemoryPersistence) Configure(config *config.ConfigParams)\n  config: *config.ConfigParams - configuration parameters to be set.  Examples type MyFilePersistence struct { IdentifiableFilePersistence } func NewMyFilePersistence(path string)(mfp *MyFilePersistence) { mfp = MyFilePersistence{} prototype := reflect.TypeOf(MyData{}) mfp.IdentifiableFilePersistence = *NewJsonPersister(prototype,path) return mfp } func composeFilter(filter cdata.FilterParams)(func (item interface{})bool) { if \u0026amp;filter == nil { filter = NewFilterParams() } name := filter.GetAsNullableString(\u0026#34;name\u0026#34;); return func (item interface) bool { dummy, ok := item.(MyData) if *name != \u0026#34;\u0026#34; \u0026amp;\u0026amp; ok \u0026amp;\u0026amp; dummy.Name != *name { return false } return true } } func (c *MyFilePersistence ) GetPageByFilter(correlationId string, filter FilterParams, paging PagingParams)(pagecdata.MyDataPage, err error){ tempPage, err := c.GetPageByFilter(correlationId, composeFilter(filter), paging, nil, nil) dataLen := int64(len(tempPage.Data)) data := make([]MyData, dataLen) for i, v := range tempPage.Data { data[i] = v.(MyData) } page = *NewMyDataPage(\u0026amp;dataLen, data) return page, err } persistence := NewMyFilePersistence(\u0026#34;./data/data.json\u0026#34;) _, errc := persistence.Create(\u0026#34;123\u0026#34;, { Id: \u0026#34;1\u0026#34;, Name: \u0026#34;ABC\u0026#34; }) if (errc != nil) { panic() } page, errg := persistence.GetPageByFilter(\u0026#34;123\u0026#34;, NewFilterParamsFromTuples(\u0026#34;Name\u0026#34;, \u0026#34;ABC\u0026#34;), nil) if errg != nil { panic(\u0026#34;Error\u0026#34;) } fmt.Println(page.Data) // Result: { Id: \u0026#34;1\u0026#34;, Name: \u0026#34;ABC\u0026#34; ) persistence.DeleteById(\u0026#34;123\u0026#34;, \u0026#34;1\u0026#34;) See also   MemoryPersistence   ","description":"Abstract persistence component that stores data in flat files and implements a number of CRUD operations over data items with unique ids. \n","image":null,"permalink":"/golang/data/persistence/identifiable_file_persistence/","subtitle":null,"tags":null,"title":"IdentifiableFilePersistence"},{"content":"Inherits: IdentifiableMemoryPersistence\u0026lt;T, K\u0026gt;\nDescription The IdentifiableFilePersistence class allows you to create persistence components that store data in flat files and implement a number of CRUD operations over data items with unique ids.\nImportant points\nWhere T : IIdentifiable\u0026lt;K\u0026gt;.\nWhere K : class.\n The data items must implement the IIdentifiable interface. In basic scenarios child classes shall only override GetPageByFilter, GetListByFilter or DeleteByFilter operations with a specific filter function. All other operations can be used out of the box. In complex scenarios child classes can implement additional operations by accessing cached items via the self._items property and calling the save method on updates.  Configuration parameters   path: path to the file where data is stored\n  options:\n max_page_size: maximum number of items returned in a single page (default: 100)    References  *:logger:*:*:1.0 - (optional) (../../../components/log/ilogger) components to pass log messages  Constructors Creates a new instance of the persistence.\n public IdentifiableFilePersistence(JsonFilePersister persister)\n  persister: JsonFilePersister - (optional) a persister component that loads and saves data from/to flat file.  Creates a new instance of the persistence.\n public IdentifiableFilePersistence()\n Fields _persister JSON file persister.\n protected _persister: JsonFilePersister\n  Instance methods Configure Configures component by passing configuration parameters.\n public override void Configure(ConfigParams config)\n  config: ConfigParams - configuration parameters to be set.  Examples class MyFilePersistence: IdentifiableFilePersistence\u0026lt;MyData, string\u0026gt; { public MyFilePersistence(string path) { base(MyData.class, new JsonPersister(path)); private List\u0026lt;Func\u0026lt;MyData, bool\u0026gt;\u0026gt; ComposeFilter(FilterParams filter) { filter = filter != null ? filter : new FilterParams(); String name = filter.getAsNullableString(\u0026#34;name\u0026#34;); return List\u0026lt;Func\u0026lt;MyData, bool\u0026gt;\u0026gt;() { (item) =\u0026gt; { if (name != null \u0026amp;\u0026amp; item.name != name) return false; return true; } }; } public DataPage\u0026lt;MyData\u0026gt; GetPageByFilter(string correlationId, FilterParams filter, PagingParams paging) { base.GetPageByFilter(correlationId, this.composeFilter(filter), paging, null, null); } } var persistence = new MyFilePersistence(\u0026#34;./data/data.json\u0026#34;); var item = persistence.Create(\u0026#34;123\u0026#34;, new MyData(\u0026#34;1\u0026#34;, \u0026#34;ABC\u0026#34;)); var mydata = persistence.GetPageByFilter( \u0026#34;123\u0026#34;, FilterParams.fromTuples(\u0026#34;name\u0026#34;, \u0026#34;ABC\u0026#34;), null, null, null); Console.Out.WriteLine(page.Data); // Result: { id: \u0026#34;1\u0026#34;, name: \u0026#34;ABC\u0026#34; } persistence.DeleteById(\u0026#34;123\u0026#34;, \u0026#34;1\u0026#34;); ... See also   MemoryPersistence   ","description":"Abstract persistence component that stores data in flat files and implements a number of CRUD operations over data items with unique ids. \n","image":null,"permalink":"/net/data/persistence/identifiable_file_persistence/","subtitle":null,"tags":null,"title":"IdentifiableFilePersistence\u003cT, K\u003e"},{"content":"Extends: IdentifiableMemoryPersistence\u0026lt;T, K\u0026gt;\nDescription The IdentifiableFilePersistence class allows you to create persistence components that store data in flat files and implement a number of CRUD operations over data items with unique ids.\nImportant points\n The data items must implement the IIdentifiable interface. In basic scenarios child classes shall only override getPageByFilter, getListByFilter or deleteByFilter operations with a specific filter function. All other operations can be used out of the box. In complex scenarios child classes can implement additional operations by accessing cached items via the self._items property and calling the save method on updates.  Configuration parameters   path: path to the file where data is stored\n  options:\n max_page_size: maximum number of items returned in a single page (default: 100)    References  *:logger:*:*:1.0 - (optional) (../../../components/log/ilogger) components to pass log messages  Constructors Creates a new instance of the persistence.\n public constructor(persister?: JsonFilePersister)\n  persister: JsonFilePersister - (optional) a persister component that loads and saves data from/to flat file.  Fields _persister JSON file persister.\n protected _persister: JsonFilePersister\n  Instance methods configure Configures component by passing configuration parameters.\n public configure(config: ConfigParams): void\n  config: ConfigParams - configuration parameters to be set.  Examples class MyFilePersistence extends IdentifiableFilePersistence\u0026lt;MyData, string\u0026gt; { public constructor(path?: string) { super(new JsonPersister(path)); } private composeFilter(filter: FilterParams): any { filter = filter || new FilterParams(); let name = filter.getAsNullableString(\u0026#34;name\u0026#34;); return (item) =\u0026gt; { if (name != null \u0026amp;\u0026amp; item.name != name) return false; return true; }; } public async getPageByFilter(correlationId: string, filter: FilterParams, paging: PagingParams): Promise\u0026lt;DataPage\u0026lt;MyData\u0026gt;\u0026gt; { return await super.getPageByFilter(correlationId, this.composeFilter(filter), paging, null, null); } } let persistence = new MyFilePersistence(\u0026#34;./data/data.json\u0026#34;); let item = await persistence.create(\u0026#34;123\u0026#34;, { id: \u0026#34;1\u0026#34;, name: \u0026#34;ABC\u0026#34; }); let page = await persistence.getPageByFilter( \u0026#34;123\u0026#34;, FilterParams.fromTuples(\u0026#34;name\u0026#34;, \u0026#34;ABC\u0026#34;), null ); console.log(page.data); // Result: { id: \u0026#34;1\u0026#34;, name: \u0026#34;ABC\u0026#34; }  item = await persistence.deleteById(\u0026#34;123\u0026#34;, \u0026#34;1\u0026#34;); See also   MemoryPersistence   ","description":"Abstract persistence component that stores data in flat files and implements a number of CRUD operations over data items with unique ids. \n","image":null,"permalink":"/node/data/persistence/identifiable_file_persistence/","subtitle":null,"tags":null,"title":"IdentifiableFilePersistence\u003cT extends IIdentifiable\u003cK\u003e, K\u003e"},{"content":"Implements: IdentifiableMemoryPersistence, iidentifiable\nDescription The IdentifiableFilePersistence class allows you to create persistence components that store data in flat files and implement a number of CRUD operations over data items with unique ids.\nImportant points\n The data items must implement the IIdentifiable interface. In basic scenarios child classes shall only override get_page_by_filter, get_list_by_filter or delete_by_filter operations with a specific filter function. All other operations can be used out of the box. In complex scenarios child classes can implement additional operations by accessing cached items via the self._items property and calling the save method on updates.  Configuration parameters   path: path to the file where data is stored\n  options:\n max_page_size: maximum number of items returned in a single page (default: 100)    References  *:logger:*:*:1.0 - (optional) (../../../components/log/ilogger) components to pass log messages  Constructors Creates a new instance of the persistence.\n IdentifiableFilePersistence(persister: Optional[JsonFilePersister] = None)\n  persister: JsonFilePersister - (optional) a persister component that loads and saves data from/to flat file.  Fields _persister JSON file persister.\n _persister: JsonFilePersister\n  Instance methods configure Configures component by passing configuration parameters.\n configure(config: ConfigParams)\n  config: ConfigParams - configuration parameters to be set.  Examples class MyFilePersistence(IdentifiableFilePersistence): def __init__(self, path): super(MyFilePersistence, self).__init__(JsonPersister(path)) def get_page_by_filter(self, correlationId, filter, paging): super().get_page_by_filter(correlationId, filter, paging, None) persistence = MyFilePersistence(\u0026#34;./data/data.json\u0026#34;) item = persistence.create(\u0026#34;123\u0026#34;, MyData(\u0026#34;1\u0026#34;, \u0026#34;ABC\u0026#34;)) mydata = persistence.get_page_by_filter(\u0026#34;123\u0026#34;, FilterParams.from_tuples(\u0026#34;name\u0026#34;, \u0026#34;ABC\u0026#34;), None, None) print str(mydata.get_data()) persistence.delete_by_id(\u0026#34;123\u0026#34;, \u0026#34;1\u0026#34;) See also   MemoryPersistence   ","description":"Abstract persistence component that stores data in flat files and implements a number of CRUD operations over data items with unique ids. \n","image":null,"permalink":"/python/data/persistence/identifiable_file_persistence/","subtitle":null,"tags":null,"title":"IdentifiableFilePersistence"},{"content":"Inherits: IdentifiableMySqlPersistence\u0026lt;T, K\u0026gt;\nDescription The IdentifiableJsonMySqlPersistence class allows you to create persistence components that store data in JSON or JSONB fields and implement a number of CRUD operations over data items with unique ids.\nImportant points\nWhere T : IIdentifiable, new() Where K : class.\n The JSON table has only two fields: id and data. In basic scenarios child classes shall only override GetPageByFilterAsync, GetListByFilterAsync or DeleteByFilterAsync operations with a specific filter function. All other operations can be used out of the box. In complex scenarios child classes can implement additional operations by accessing this._collection and this._model properties.  Configuration parameters  collection: (optional) MySQL collection name  connection(s):\n discovery_key: (optional) key to retrieve the connection from IDiscovery host: host name or IP address port: port number (default: 27017) uri: resource URI or connection string with all parameters in it  credential(s):\n store_key: (optional) key to retrieve the credentials from ICredentialStore username: (optional) username password: (optional) user\u0026rsquo;s password  options:\n connect_timeout: (optional) number of milliseconds to wait before timing out when connecting a new client (default: 0) idle_timeout: (optional) number of milliseconds a client must sit idle in the pool and not be checked out (default: 10000) max_pool_size: (optional) maximum number of clients the pool can contain (default: 10)  References  *:logger:*:*:1.0 - (optional) ILogger components to pass log messages *:discovery:*:*:1.0 - (optional) IDiscovery services *:credential-store:*:*:1.0 - (optional) ICredentialStore to resolve credentials  Constructors Creates a new instance of the persistence component.\n public IdentifiableJsonMySqlPersistence(tableName: string)\n  tableName: string - (optional) collection name.  Instance methods ConvertFromPublic Converts object value from public to internal format.\n protected override AnyValueMap ConvertFromPublic(T value)\n  value: T - object in public format to convert. returns: AnyValueMap - converted object in internal format.  ConvertToPublic Converts object value from internal to public format.\n protected override T ConvertToPublic(AnyValueMap map)\n  value: AnyValueMap - object in internal format to convert. returns: T - converted object in public format.  EnsureTable Adds DML statement to automatically create a JSON(B) table\n protected void EnsureTable(string idType = \u0026ldquo;VARCHAR(32)\u0026rdquo;, string dataType = \u0026ldquo;JSON\u0026rdquo;)\n  idType: string - type of the id column (default: VARCHAR(32)) dataType: string - type of the data column (default: JSON)  UpdatePartially Updates only few selected fields in a data item.\n public override async Task\u0026lt;T\u0026gt; UpdatePartially(string correlationId, K id, AnyValueMap data)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. id: K - id of the data item to be updated. data: AnyValueMap - map with fields to be updated. return: Task\u0026lt;T\u0026gt; - updated item  Examples TODO: add example ","description":"Abstract persistence component that stores data in MySQL in JSON or JSONB fields and implements a number of CRUD operations over data items with unique ids.\n","image":null,"permalink":"/net/mysql/persistence/identifiable_json_mysql_persistence/","subtitle":null,"tags":null,"title":"IdentifiableJsonMySqlPersistence\u003cT, K\u003e"},{"content":"Extends: IdentifiableMySqlPersistence\u0026lt;T, K\u0026gt;\nDescription The IdentifiableJsonMySqlPersistence class allows you to create persistence components that store data in JSON or JSONB fields and implement a number of CRUD operations over data items with unique ids.\nImportant points\n The JSON table has only two fields: id and data. In basic scenarios child classes shall only override getPageByFilter, getListByFilter or deleteByFilter operations with a specific filter function. All other operations can be used out of the box. In complex scenarios child classes can implement additional operations by accessing this._collection and this._model properties.  Configuration parameters  collection: (optional) MySQL collection name  connection(s):\n discovery_key: (optional) key to retrieve the connection from IDiscovery host: host name or IP address port: port number (default: 27017) uri: resource URI or connection string with all parameters in it  credential(s):\n store_key: (optional) key to retrieve the credentials from ICredentialStore username: (optional) username password: (optional) user\u0026rsquo;s password  options:\n connect_timeout: (optional) number of milliseconds to wait before timing out when connecting a new client (default: 0) idle_timeout: (optional) number of milliseconds a client must sit idle in the pool and not be checked out (default: 10000) max_pool_size: (optional) maximum number of clients the pool can contain (default: 10)  References  *:logger:*:*:1.0 - (optional) ILogger components to pass log messages *:discovery:*:*:1.0 - (optional) IDiscovery services *:credential-store:*:*:1.0 - (optional) ICredentialStore to resolve credentials  Constructors Creates a new instance of the persistence component.\n public constructor(tableName: string)\n  tableName: string - (optional) collection name.  Instance methods convertFromPublic Converts object value from public to internal format.\n protected convertFromPublic(value: any): any\n  value: any - object in public format to convert. returns: any - converted object in internal format.  convertToPublic Converts object value from internal to public format.\n protected convertToPublic(value: any): any\n  value: any - object in internal format to convert. returns: any - converted object in public format.  ensureTable Adds DML statement to automatically create a JSON(B) table\n protected ensureTable(idType: string = \u0026lsquo;VARCHAR(32)\u0026rsquo;, dataType: string = \u0026lsquo;JSON\u0026rsquo;)\n  idType: string - type of the id column (default: VARCHAR(32)) dataType: string - type of the data column (default: JSON)  updatePartially Updates only few selected fields in a data item.\n public updatePartially(correlationId: string, id: K, data: AnyValueMap): Promise\u0026lt;T\u0026gt;\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. id: K - id of the data item to be updated. data: AnyValueMap - map with fields to be updated. return: Promise\u0026lt;T\u0026gt; - updated item  Examples class MyMySqlPersistence extends IdentifiableMySqlJsonPersistence\u0026lt;MyData, string\u0026gt; { public constructor() { base(\u0026#34;mydata\u0026#34;, new MyDataMySqlSchema()); } private composeFilter(filter: FilterParams): any { filter = filter || new FilterParams(); let criteria = []; let name = filter.getAsNullableString(\u0026#39;name\u0026#39;); if (name != null) criteria.push({ name: name }); return criteria.length \u0026gt; 0 ? { $and: criteria } : null; } public getPageByFilter(correlationId: string, filter: FilterParams, paging: PagingParams, callback: (err: any, page: DataPage\u0026lt;MyData\u0026gt;) =\u0026gt; void): void { base.getPageByFilter(correlationId, this.composeFilter(filter), paging, null, null, callback); } } let persistence = new MyMySqlPersistence(); persistence.configure(ConfigParams.fromTuples( \u0026#34;host\u0026#34;, \u0026#34;localhost\u0026#34;, \u0026#34;port\u0026#34;, 27017 )); persitence.open(\u0026#34;123\u0026#34;, (err) =\u0026gt; { ... }); persistence.create(\u0026#34;123\u0026#34;, { id: \u0026#34;1\u0026#34;, name: \u0026#34;ABC\u0026#34; }, (err, item) =\u0026gt; { persistence.getPageByFilter( \u0026#34;123\u0026#34;, FilterParams.fromTuples(\u0026#34;name\u0026#34;, \u0026#34;ABC\u0026#34;), null, (err, page) =\u0026gt; { console.log(page.data); // Result: { id: \u0026#34;1\u0026#34;, name: \u0026#34;ABC\u0026#34; }  persistence.deleteById(\u0026#34;123\u0026#34;, \u0026#34;1\u0026#34;, (err, item) =\u0026gt; { ... }); } ) }); ","description":"Abstract persistence component that stores data in MySQL in JSON or JSONB fields and implements a number of CRUD operations over data items with unique ids.\n","image":null,"permalink":"/node/mysql/persistence/identifiable_json_mysql_persistence/","subtitle":null,"tags":null,"title":"IdentifiableJsonMySqlPersistence\u003cT extends IIdentifiable\u003cK\u003e, K\u003e"},{"content":"Implements: IdentifiableMySqlPersistence, IIdentifiable\nDescription The IdentifiableJsonMySqlPersistence class allows you to create persistence components that store data in JSON or JSONB fields and implement a number of CRUD operations over data items with unique ids.\nImportant points\n The JSON table has only two fields: id and data. In basic scenarios child classes shall only override get_page_by_filter, get_list_by_filter or delete_by_filter operations with a specific filter function. All other operations can be used out of the box. In complex scenarios child classes can implement additional operations by accessing self._collection and self._model properties.  Configuration parameters  collection: (optional) MySQL collection name  connection(s):\n discovery_key: (optional) key to retrieve the connection from IDiscovery host: host name or IP address port: port number (default: 27017) uri: resource URI or connection string with all parameters in it  credential(s):\n store_key: (optional) key to retrieve the credentials from ICredentialStore username: (optional) username password: (optional) user\u0026rsquo;s password  options:\n connect_timeout: (optional) number of milliseconds to wait before timing out when connecting a new client (default: 0) idle_timeout: (optional) number of milliseconds a client must sit idle in the pool and not be checked out (default: 10000) max_pool_size: (optional) maximum number of clients the pool can contain (default: 10)  References  *:logger:*:*:1.0 - (optional) ILogger components to pass log messages *:discovery:*:*:1.0 - (optional) IDiscovery services *:credential-store:*:*:1.0 - (optional) ICredentialStore to resolve credentials  Constructors Creates a new instance of the persistence component.\n IdentifiableJsonMySqlPersistence(table_name: str = None)\n  table_name: str - (optional) collection name.  Instance methods _convert_from_public Converts object value from public to internal format.\n _convert_from_public(value: Any): Any\n  value: Any - object in public format to convert. returns: Any - converted object in internal format.  _convert_to_public Converts object value from internal to public format.\n _convert_to_public(value: Any): Any\n  value: Any - object in internal format to convert. returns: Any - converted object in public format.  _ensure_table Adds DML statement to automatically create a JSON(B) table\n _ensure_table(id_type: str = \u0026lsquo;VARCHAR(32)\u0026rsquo;, data_type: str = \u0026lsquo;JSON\u0026rsquo;)\n  id_type: str - type of the id column (default: VARCHAR(32)) data_type: str - type of the data column (default: JSON)  update_partially Updates only few selected fields in a data item.\n update_partially(correlation_id: Optional[str], id: Any, data: AnyValueMap): Optional[T]\n  correlation_id: Optional[str] - (optional) transaction id used to trace execution through the call chain. id: Any - id of the data item to be updated. data: AnyValueMap - map with fields to be updated. return: Optional[T] - updated item  Examples class MyMySqlPersistence(IdentifiableJsonMySqlPersistence): def __init__(self): super(MyMySqlPersistence, self).__init__(\u0026#34;mydata\u0026#34;, MyDataMySqlSchema()) def __compose_filter(self, filter): filter = filter or FilterParams() criteria = [] name = filter.get_as_nullable_string(\u0026#39;name\u0026#39;) if name: criteria.append({\u0026#39;name\u0026#39;: name}) return {\u0026#39;$and\u0026#39;: criteria} if len(criteria) \u0026gt; 0 else None def get_page_by_filter(self, correlation_id, filter, paging): return super().get_page_by_filter(correlation_id, self.__compose_filter(filter), paging, None, None) persistence = MyMySqlPersistence() persistence.configure(ConfigParams.from_tuples( \u0026#34;host\u0026#34;, \u0026#34;localhost\u0026#34;, \u0026#34;port\u0026#34;, 27017 )) persistence.open(\u0026#39;123\u0026#39;) persistence.create(\u0026#39;123\u0026#39;, {\u0026#39;id\u0026#39;: \u0026#34;1\u0026#34;, \u0026#39;name\u0026#39;: \u0026#34;ABC\u0026#34;}) page = persistence.get_page_by_filter(\u0026#39;123\u0026#39;, FilterParams.from_tuples(\u0026#39;name\u0026#39;, \u0026#39;ABC\u0026#39;), None) print(page.data) # Result: { id: \u0026#34;1\u0026#34;, name: \u0026#34;ABC\u0026#34; } persistence.delete_by_id(\u0026#34;123\u0026#34;, \u0026#34;1\u0026#34;) # ... ","description":"Abstract persistence component that stores data in MySQL in JSON or JSONB fields and implements a number of CRUD operations over data items with unique ids.\n","image":null,"permalink":"/python/mysql/persistence/identifiable_json_mysql_persistence/","subtitle":null,"tags":null,"title":"IdentifiableJsonMySqlPersistence"},{"content":"Implements: IdentifiablePostgresPersistence,\nDescription The IdentifiableJsonPostgresPersistence class allows you to create persistence components used to store data in PosgreSQL databases in JSON or JSONB fields and implement a number of CRUD operations over data items with unique ids.\nImportant points\n The data items must implement the IIdentifiable interface. In basic scenarios child classes shall only override the GetPageByFilter, GetListByFilter or DeleteByFilter operations with a specific filter function. All other operations can be used out of the box. In complex scenarios child classes can implement additional operations by accessing c.Db or c.Collection properties.  Configuration parameters  collection: (optional) PostgreSQL collection name connection(s): discovery_key: (optional) key used to retrieve the connection from IDiscovery host: host name or IP address port: port number (default: 27017) uri: resource URI or connection string with all parameters in it  credential(s):\n store_key: (optional) key to retrieve the credentials from ICredentialStore username: (optional) username password: (optional) user\u0026rsquo;s password  options:\n connect_timeout: (optional) number of milliseconds to wait before timing out when connecting a new client (default: 0) idle_timeout: (optional) number of milliseconds a client must sit idle in the pool and not be checked out (default: 10000) max_pool_size: (optional) maximum number of clients the pool can contain (default: 10)  References  *:logger:*:*:1.0 - (optional) ILogger components to pass log messages *:discovery:*:*:1.0 - (optional) IDiscovery services *:credential-store:*:*:1.0 - (optional) credential stores to resolve credentials (ICredentialStore)  Constructors Creates a new instance of the persistence component.\n InheritIdentifiableJsonPostgresPersistence(overrides IPostgresPersistenceOverrides, proto reflect.Type, tableName string) *IdentifiableJsonPostgresPersistence\n  overrides: IPostgresPersistenceOverrides - References to override virtual methods. proto: reflect.Type - TODO: add description. tableName: string - (optional) a collection name.  Methods ConvertFromPublic Converts object value from public to internal format.\n (c *IdentifiableJsonPostgresPersistence) ConvertFromPublic(value interface{}) interface{}\n  value: interface{} - object in public format to convert. returns: interface{} - converted object in internal format.  ConvertToPublic Converts object value from internal to public format.\n (c *IdentifiableJsonPostgresPersistence) ConvertToPublic(rows pgx.Rows) interface{}\n  rows: pgx.Rows - object in internal format to convert. returns: interface{} - converted object in public format.  EnsureTable Adds DML statement to automatically create a JSON(B) table\n (c *IdentifiableJsonPostgresPersistence) EnsureTable(idType string, dataType string)\n  idType: string - type of the id column dataType: string - type of the data column  UpdatePartially Updates only few selected fields in a data item.\n (c *IdentifiableJsonPostgresPersistence) UpdatePartially(correlationId string, id interface{}, data *cdata.AnyValueMap) (result interface{}, err error)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. id: interface{} - id of the data item to be updated. data: *cdata.AnyValueMap - map with fields to be updated. return: (result interface{}, err error) - updated item  Examples TODO: add example ","description":"Abstract persistence component that stores data in PostgreSQL in JSON or JSONB fields and implements a number of CRUD operations over data items with unique ids.\n","image":null,"permalink":"/golang/postgres/persistence/identifiable_json_postgres_persistence/","subtitle":null,"tags":null,"title":"IdentifiableJsonPostgresPersistence"},{"content":"Inherits: IdentifiablePostgresPersistence\u0026lt;T, K\u0026gt;,\nDescription The IdentifiableJsonPostgresPersistence class allows you to create persistence components used to store data in PosgreSQL databases in JSON or JSONB fields and implement a number of CRUD operations over data items with unique ids.\nImportant points\nWhere T : IIdentifiable, new().\n The data items must implement the IIdentifiable interface. In basic scenarios child classes shall only override the getPageByFilter, getListByFilter or deleteByFilter operations with a specific filter function. All other operations can be used out of the box. In complex scenarios child classes can implement additional operations by accessing this._collection and this._model properties.  Configuration parameters  collection: (optional) PostgreSQL collection name connection(s): discovery_key: (optional) key used to retrieve the connection from IDiscovery host: host name or IP address port: port number (default: 27017) uri: resource URI or connection string with all parameters in it  credential(s):\n store_key: (optional) key to retrieve the credentials from ICredentialStore username: (optional) username password: (optional) user\u0026rsquo;s password  options:\n connect_timeout: (optional) number of milliseconds to wait before timing out when connecting a new client (default: 0) idle_timeout: (optional) number of milliseconds a client must sit idle in the pool and not be checked out (default: 10000) max_pool_size: (optional) maximum number of clients the pool can contain (default: 10)  References  *:logger:*:*:1.0 - (optional) ILogger components to pass log messages *:discovery:*:*:1.0 - (optional) IDiscovery services *:credential-store:*:*:1.0 - (optional) credential stores to resolve credentials (ICredentialStore)  Constructors Creates a new instance of the persistence component.\n public IdentifiableJsonPostgresPersistence(string tableName)\n  tableName: string - (optional) a collection name.  Instance methods ConvertFromPublic Converts object value from public to internal format.\n protected override AnyValueMap ConvertFromPublic(T value)\n  value: T - object in public format to convert. returns: AnyValueMap - converted object in internal format.  ConvertToPublic Converts object value from internal to public format.\n protected override T ConvertToPublic(AnyValueMap map)\n  map: AnyValueMap - object in internal format to convert. returns: T - converted object in public format.  EnsureTable Adds DML statement to automatically create a JSON(B) table\n protected void EnsureTable(string idType = \u0026ldquo;TEXT\u0026rdquo;, string dataType = \u0026ldquo;JSONB\u0026rdquo;)\n  idType: string - type of the id column (default: TEXT) dataType: string - type of the data column (default: JSONB)  UpdatePartially Updates only few selected fields in a data item.\n public override Task\u0026lt;T\u0026gt; UpdatePartially(string correlationId, K id, AnyValueMap data)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. id: K - id of the data item to be updated. data: AnyValueMap - map with fields to be updated. return: Task\u0026lt;T\u0026gt; - updated item  Examples TODO: add example ","description":"Abstract persistence component that stores data in PostgreSQL in JSON or JSONB fields and implements a number of CRUD operations over data items with unique ids.\n","image":null,"permalink":"/net/postgres/persistence/identifiable_json_postgres_persistence/","subtitle":null,"tags":null,"title":"IdentifiableJsonPostgresPersistence\u003cT, K\u003e"},{"content":"Extends: IdentifiablePostgresPersistence\u0026lt;T, K\u0026gt;,\nDescription The IdentifiableJsonPostgresPersistence class allows you to create persistence components used to store data in PosgreSQL databases in JSON or JSONB fields and implement a number of CRUD operations over data items with unique ids.\nImportant points\n The data items must implement the IIdentifiable interface. In basic scenarios child classes shall only override the getPageByFilter, getListByFilter or deleteByFilter operations with a specific filter function. All other operations can be used out of the box. In complex scenarios child classes can implement additional operations by accessing this._collection and this._model properties.  Configuration parameters  collection: (optional) PostgreSQL collection name connection(s): discovery_key: (optional) key used to retrieve the connection from IDiscovery host: host name or IP address port: port number (default: 27017) uri: resource URI or connection string with all parameters in it  credential(s):\n store_key: (optional) key to retrieve the credentials from ICredentialStore username: (optional) username password: (optional) user\u0026rsquo;s password  options:\n connect_timeout: (optional) number of milliseconds to wait before timing out when connecting a new client (default: 0) idle_timeout: (optional) number of milliseconds a client must sit idle in the pool and not be checked out (default: 10000) max_pool_size: (optional) maximum number of clients the pool can contain (default: 10)  References  *:logger:*:*:1.0 - (optional) ILogger components to pass log messages *:discovery:*:*:1.0 - (optional) IDiscovery services *:credential-store:*:*:1.0 - (optional) credential stores to resolve credentials (ICredentialStore)  Constructors Creates a new instance of the persistence component.\n public constructor(tableName: string)\n  tableName: string - (optional) a collection name.  Instance methods convertFromPublic Converts object value from public to internal format.\n protected convertFromPublic(value: any): any\n  value: any - object in public format to convert. returns: any - converted object in internal format.  convertToPublic Converts object value from internal to public format.\n protected convertToPublic(value: any): any\n  value: any - object in internal format to convert. returns: any - converted object in public format.  ensureTable Adds DML statement to automatically create a JSON(B) table\n protected ensureTable(idType: string = \u0026lsquo;TEXT\u0026rsquo;, dataType: string = \u0026lsquo;JSONB\u0026rsquo;)\n  idType: string - type of the id column (default: TEXT) dataType: string - type of the data column (default: JSONB)  updatePartially Updates only few selected fields in a data item.\n public update_partially(correlationId: string, id: K, data: AnyValueMap): Promise\u0026lt;T\u0026gt;\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. id: any - id of the data item to be updated. data: AnyValueMap - map with fields to be updated. return: Promise\u0026lt;T\u0026gt; - updated item  Examples class MyPostgresPersistence extends IdentifiablePostgresJsonPersistence\u0026lt;MyData, string\u0026gt; { public constructor() { base(\u0026#34;mydata\u0026#34;, new MyDataPostgresSchema()); } private composeFilter(filter: FilterParams): any { filter = filter || new FilterParams(); let criteria = []; let name = filter.getAsNullableString(\u0026#39;name\u0026#39;); if (name != null) criteria.push({ name: name }); return criteria.length \u0026gt; 0 ? { $and: criteria } : null; } public getPageByFilter(correlationId: string, filter: FilterParams, paging: PagingParams): Promise\u0026lt;DataPage\u0026lt;MyData\u0026gt;\u0026gt; { return base.getPageByFilter(correlationId, this.composeFilter(filter), paging, null, null); } } let persistence = new MyPostgresPersistence(); persistence.configure(ConfigParams.fromTuples( \u0026#34;host\u0026#34;, \u0026#34;localhost\u0026#34;, \u0026#34;port\u0026#34;, 27017 )); await persitence.open(\u0026#34;123\u0026#34;); let item = await persistence.create(\u0026#34;123\u0026#34;, { id: \u0026#34;1\u0026#34;, name: \u0026#34;ABC\u0026#34; }); let page = await persistence.getPageByFilter( \u0026#34;123\u0026#34;, FilterParams.fromTuples(\u0026#34;name\u0026#34;, \u0026#34;ABC\u0026#34;), null ); console.log(page.data); // Result: { id: \u0026#34;1\u0026#34;, name: \u0026#34;ABC\u0026#34; } item = await persistence.deleteById(\u0026#34;123\u0026#34;, \u0026#34;1\u0026#34;); ... ","description":"Abstract persistence component that stores data in PostgreSQL in JSON or JSONB fields and implements a number of CRUD operations over data items with unique ids.\n","image":null,"permalink":"/node/postgres/persistence/identifiable_json_postgres_persistence/","subtitle":null,"tags":null,"title":"IdentifiableJsonPostgresPersistence\u003cT extends IIdentifiable\u003cK\u003e, K\u003e"},{"content":"Implements: IdentifiablePostgresPersistence, IIdentifiable\nDescription The IdentifiableJsonPostgresPersistence class allows you to create persistence components used to store data in PosgreSQL databases in JSON or JSONB fields and implement a number of CRUD operations over data items with unique ids.\nImportant points\n The data items must implement the IIdentifiable interface. In basic scenarios child classes shall only override the get_page_by_filter, get_list_by_filter or delete_by_filter operations with a specific filter function. All other operations can be used out of the box. In complex scenarios child classes can implement additional operations by accessing self._collection and self._model properties.  Configuration parameters  collection: (optional) PostgreSQL collection name connection(s): discovery_key: (optional) key used to retrieve the connection from IDiscovery host: host name or IP address port: port number (default: 27017) uri: resource URI or connection string with all parameters in it  credential(s):\n store_key: (optional) key to retrieve the credentials from ICredentialStore username: (optional) username password: (optional) user\u0026rsquo;s password  options:\n connect_timeout: (optional) number of milliseconds to wait before timing out when connecting a new client (default: 0) idle_timeout: (optional) number of milliseconds a client must sit idle in the pool and not be checked out (default: 10000) max_pool_size: (optional) maximum number of clients the pool can contain (default: 10)  References  *:logger:*:*:1.0 - (optional) ILogger components to pass log messages *:discovery:*:*:1.0 - (optional) IDiscovery services *:credential-store:*:*:1.0 - (optional) credential stores to resolve credentials (ICredentialStore)  Constructors Creates a new instance of the persistence component.\n IdentifiableJsonPostgresPersistence(table_name: str = None)\n  table_name: str - (optional) a collection name.  Instance methods _convert_from_public Converts object value from public to internal format.\n _convert_from_public(value: Any): Any\n  value: Any - object in public format to convert. returns: Any - converted object in internal format.  _convert_to_public Converts object value from internal to public format.\n _convert_to_public(value: Any): Any\n  value: Any - object in internal format to convert. returns: Any - converted object in public format.  _ensure_table Adds DML statement to automatically create a JSON(B) table\n _ensure_table(id_type: str = \u0026lsquo;TEXT\u0026rsquo;, data_type: str = \u0026lsquo;JSONB\u0026rsquo;)\n  id_type: str - type of the id column (default: TEXT) data_type: str - type of the data column (default: JSONB)  update_partially Updates only few selected fields in a data item.\n update_partially(correlation_id: Optional[str], id: Any, data: AnyValueMap): Optional[T]\n  correlation_id: Optional[str] - (optional) transaction id used to trace execution through the call chain. id: Any - id of the data item to be updated. data: AnyValueMap - map with fields to be updated. return: Optional[T] - updated item  Examples class MyPostgresPersistence(IdentifiablePostgresJsonPersistence): def __init__(self): super(MyPostgresPersistence, self).__init__(\u0026#39;mydata\u0026#39;, MyDataPostgresSchema()) def __compose_filter(self, filter): filter = filter or FilterParams() criteria = [] name = filter.get_as_nullable_string(\u0026#39;name\u0026#39;) if name is not None: criteria.append({\u0026#39;name\u0026#39;:name}) return { \u0026#39;$and\u0026#39;: criteria } if len(criteria) \u0026gt; 0 else None def get_page_by_filter(self, correlation_id, filter, paging): return super().get_page_by_filter(correlation_id, self.__compose_filter(filter), paging, None, None) persistence = MyPostgresPersistence() persistence.configure(ConfigParams.from_tuples( \u0026#34;host\u0026#34;, \u0026#34;localhost\u0026#34;, \u0026#34;port\u0026#34;, 27017 )) persistence.open(\u0026#34;123\u0026#34;) persistence.create(\u0026#34;123\u0026#34;, {\u0026#39;id\u0026#39;: \u0026#34;1\u0026#34;, \u0026#39;name\u0026#39;: \u0026#34;ABC\u0026#34;}) page = persistence.get_page_by_filter(\u0026#39;123\u0026#39;, FilterParams.from_tuples(\u0026#39;name\u0026#39;, \u0026#39;ABC\u0026#39;), None) print(page.data) # Result: { id: \u0026#34;1\u0026#34;, name: \u0026#34;ABC\u0026#34; } persistence.delete_by_id(\u0026#34;123\u0026#34;, \u0026#34;1\u0026#34;) # ... ","description":"Abstract persistence component that stores data in PostgreSQL in JSON or JSONB fields and implements a number of CRUD operations over data items with unique ids.\n","image":null,"permalink":"/python/postgres/persistence/identifiable_json_postgres_persistence/","subtitle":null,"tags":null,"title":"IdentifiableJsonPostgresPersistence"},{"content":"Inherits: IdentifiableSqlServerPersistence, IIdentifiable\nDescription The IdentifiableJsonSqlServerPersistence class allows you to create persistence components that store data in an SQLServer database in JSON or JSONB fields and implement a number of CRUD operations over data items with unique ids.\nImportant points\nWhere T : IIdentifiable, new().\nWhere K : class.\n The data items must implement the IIdentifiable interface. In basic scenarios child classes shall only override GetPageByFilterAsync, GetListByFilterAsync or DeleteByFilterAsync operations with an specific filter function. All other operations can be used out of the box. In complex scenarios child classes can implement additional operations by accessing this._collection and this._model properties.  Configuration parameters  collection: (optional) SQLServer collection name  connection(s):\n discovery_key: (optional) key to retrieve the connection from IDiscovery host: host name or IP address port: port number (default: 27017) uri: resource URI or connection string with all parameters in it  credential(s):\n store_key: (optional) key to retrieve the credentials from ICredentialStore username: (optional) username password: (optional) user\u0026rsquo;s password  options:\n connect_timeout: (optional) number of milliseconds to wait before timing out when connecting a new client (default: 0) idle_timeout: (optional) number of milliseconds a client must sit idle in the pool and not be checked out (default: 10000) max_pool_size: (optional) maximum number of clients the pool can contain (default: 10)  References  *:logger:*:*:1.0 - (optional) ILogger components to pass log messages *:discovery:*:*:1.0 - (optional) IDiscovery services *:credential-store:*:*:1.0 - (optional) ICredentialStore to resolve credentials  Constructors Creates a new instance of the persistence component.\n public IdentifiableJsonSqlServerPersistence(string tableName)\n  tableName: string - (optional) collection name.  Instance methods ConvertFromPublic Converts an object value from public to internal format.\n protected override AnyValueMap ConvertFromPublic(T value)\n  value: T - object in public format to convert. returns: AnyValueMap - converted object in internal format.  ConvertToPublic Converts object value from internal to public format.\n protected override T ConvertToPublic(AnyValueMap map)\n  map: AnyValueMap - an object in internal format to convert. returns: T - converted object in public format.  EnsureTable Adds DML statement to automatically create a JSON(B) table\n protected void EnsureTable(string idType = \u0026ldquo;VARCHAR(32)\u0026rdquo;, string dataType = \u0026ldquo;NVARCHAR(MAX)\u0026quot;)\n  idType: string - type of the id column (default: VARCHAR(32)) dataType: string - type of the data column (default: NVARCHAR(MAX))  UpdatePartially Updates only few selected fields in a data item.\n public override Task\u0026lt;T\u0026gt; UpdatePartially(string correlationId, K id, AnyValueMap data)\n  correlationId: string - (optional) transaction id used to trace execution through a call chain. id: K - id of data item to be updated. data: AnyValueMap - map with fields to be updated. return: Task\u0026lt;T\u0026gt; - updated item  Examples TODO: add example ","description":"Abstract persistence component that stores data in SQLServer in JSON or JSONB fields and implements a number of CRUD operations over data items with unique ids.\n","image":null,"permalink":"/net/sqlserver/persistence/identifiable_json_sqlserver_persistence/","subtitle":null,"tags":null,"title":"IdentifiableJsonSqlServerPersistence\u003cT, K\u003e"},{"content":"Implements: IdentifiableSqlServerPersistence, IIdentifiable\nDescription The IdentifiableJsonSqlServerPersistence class allows you to create persistence components that store data in an SQLServer database in JSON or JSONB fields and implement a number of CRUD operations over data items with unique ids.\nImportant points\n The data items must implement the IIdentifiable interface. In basic scenarios child classes shall only override getPageByFilter, getListByFilter or deleteByFilter operations with an specific filter function. All other operations can be used out of the box. In complex scenarios child classes can implement additional operations by accessing this._collection and this._model properties.  Configuration parameters  collection: (optional) SQLServer collection name connection(s): discovery_key: (optional) key to retrieve the connection from IDiscovery host: host name or IP address port: port number (default: 27017) uri: resource URI or connection string with all parameters in it\ncredential(s): store_key: (optional) key to retrieve the credentials from ICredentialStore username: (optional) username password: (optional) user\u0026rsquo;s password\noptions: connect_timeout: (optional) number of milliseconds to wait before timing out when connecting a new client (default: 0) idle_timeout: (optional) number of milliseconds a client must sit idle in the pool and not be checked out (default: 10000) max_pool_size: (optional) maximum number of clients the pool can contain (default: 10)  References  *:logger:*:*:1.0 - (optional) ILogger components to pass log messages *:discovery:*:*:1.0 - (optional) IDiscovery services *:credential-store:*:*:1.0 - (optional) ICredentialStore to resolve credentials  Constructors Creates a new instance of the persistence component.\n public constructor(tableName: string)\n  tableName: string - (optional) collection name.  Instance methods convertFromPublic Converts an object value from public to internal format.\n protected convertFromPublic(value: any): any\n  value: any - object in public format to convert. returns: any - converted object in internal format.  convertFromPublicPartial Converts the given object from the public partial format.\n protected convertFromPublicPartial(value: any): any\n  value: any - the object to convert from the public partial format. returns: any - the initial object.  convertToPublic Converts object value from internal to public format.\n protected convertToPublic(value: any): any\n  value: any - an object in internal format to convert. returns: any - converted object in public format.  ensureTable Adds DML statement to automatically create a JSON(B) table\n protected ensureTable(idType: string = \u0026lsquo;VARCHAR(32)\u0026rsquo;, dataType: string = \u0026lsquo;NVARCHAR(MAX)')\n  idType: string - type of the id column (default: VARCHAR(32)) dataType: string - type of the data column (default: NVARCHAR(MAX))  updatePartially Updates only few selected fields in a data item.\n public updatePartially(correlationId: string, id: K, data: AnyValueMap): Promise\u0026lt;T\u0026gt;\n  correlationId: string - (optional) transaction id used to trace execution through a call chain. id: K - id of data item to be updated. data: AnyValueMap - map with fields to be updated. return: Promise\u0026lt;T\u0026gt; - updated item  Examples class MySqlServerPersistence extends IdentifiableSqlServerJsonPersistence\u0026lt;MyData, string\u0026gt; { public constructor() { base(\u0026#34;mydata\u0026#34;); } private composeFilter(filter: FilterParams): any { filter = filter || new FilterParams(); let criteria = []; let name = filter.getAsNullableString(\u0026#39;name\u0026#39;); if (name != null) criteria.push({ name: name }); return criteria.length \u0026gt; 0 ? { $and: criteria } : null; } public getPageByFilter(correlationId: string, filter: FilterParams, paging: PagingParams): Promise\u0026lt;DataPage\u0026lt;MyData\u0026gt;\u0026gt; { return base.getPageByFilter(correlationId, this.composeFilter(filter), paging, null, null); } } let persistence = new MySqlServerPersistence(); persistence.configure(ConfigParams.fromTuples( \u0026#34;host\u0026#34;, \u0026#34;localhost\u0026#34;, \u0026#34;port\u0026#34;, 27017 )); await persitence.open(\u0026#34;123\u0026#34;); let item = await persistence.create(\u0026#34;123\u0026#34;, { id: \u0026#34;1\u0026#34;, name: \u0026#34;ABC\u0026#34; }); let page = await persistence.getPageByFilter( \u0026#34;123\u0026#34;, FilterParams.fromTuples(\u0026#34;name\u0026#34;, \u0026#34;ABC\u0026#34;), null ); console.log(page.data); // Result: { id: \u0026#34;1\u0026#34;, name: \u0026#34;ABC\u0026#34; }  await persistence.deleteById(\u0026#34;123\u0026#34;, \u0026#34;1\u0026#34;); ","description":"Abstract persistence component that stores data in SQLServer in JSON or JSONB fields and implements a number of CRUD operations over data items with unique ids.\n","image":null,"permalink":"/node/sqlserver/persistence/identifiable_json_sqlserver_persistence/","subtitle":null,"tags":null,"title":"IdentifiableJsonSqlServerPersistence\u003cT extends IIdentifiable\u003cK\u003e, K\u003e"},{"content":"Implements: IdentifiableSqlServerPersistence, IIdentifiable\nDescription The IdentifiableJsonSqlServerPersistence class allows you to create persistence components that store data in an SQLServer database in JSON or JSONB fields and implement a number of CRUD operations over data items with unique ids.\nImportant points\n The data items must implement the IIdentifiable interface. In basic scenarios child classes shall only override get_page_by_filter, get_list_by_filter or delete_by_filter operations with an specific filter function. All other operations can be used out of the box. In complex scenarios child classes can implement additional operations by accessing self._collection and self._model properties.  Configuration parameters  collection: (optional) SQLServer collection name connection(s): discovery_key: (optional) key to retrieve the connection from IDiscovery host: host name or IP address port: port number (default: 27017) uri: resource URI or connection string with all parameters in it\ncredential(s): store_key: (optional) key to retrieve the credentials from ICredentialStore username: (optional) username password: (optional) user\u0026rsquo;s password\noptions: connect_timeout: (optional) number of milliseconds to wait before timing out when connecting a new client (default: 0) idle_timeout: (optional) number of milliseconds a client must sit idle in the pool and not be checked out (default: 10000) max_pool_size: (optional) maximum number of clients the pool can contain (default: 10)  References  *:logger:*:*:1.0 - (optional) ILogger components to pass log messages *:discovery:*:*:1.0 - (optional) IDiscovery services *:credential-store:*:*:1.0 - (optional) ICredentialStore to resolve credentials  Constructors Creates a new instance of the persistence component.\n IdentifiableJsonSqlServerPersistence(table_name: str = None)\n  table_name: str - (optional) collection name.  Instance methods _convert_from_public Converts an object value from public to internal format.\n _convert_from_public(value: Any): Any\n  value: Any - object in public format to convert. returns: Any - converted object in internal format.  _convert_from_public_partial Converts the given object from the public partial format.\n _convert_from_public_partial(value: Any): Any\n  value: Any - the object to convert from the public partial format. returns: Any - the initial object.  _convert_to_public Converts object value from internal to public format.\n _convert_to_public(value: Any): Any\n  value: Any - an object in internal format to convert. returns: Any - converted object in public format.  _ensure_table Adds DML statement to automatically create a JSON(B) table\n _ensure_table(id_type: str = \u0026lsquo;VARCHAR(32)\u0026rsquo;, data_type: str = \u0026lsquo;NVARCHAR(MAX)')\n  id_type: str - type of the id column (default: VARCHAR(32)) data_type: str - type of the data column (default: NVARCHAR(MAX))  update_partially Updates only few selected fields in a data item.\n update_partially(correlation_id: Optional[str], id: Any, data: AnyValueMap): Optional[T]\n  correlation_id: Optional[str] - (optional) transaction id used to trace execution through a call chain. id: Any - id of data item to be updated. data: AnyValueMap - map with fields to be updated. return: Optional[T] - updated item  Examples class MySqlServerPersistence(IdentifiableJsonSqlServerPersistence): def __init__(self): super(MySqlServerPersistence, self).__init__(\u0026#34;mydata\u0026#34;, MyDataSqlServerSchema()) def __compose_filter(self, filter): filter = filter or FilterParams() criteria = [] name = filter.get_as_nullable_string(\u0026#39;name\u0026#39;) if name: criteria.append({\u0026#39;name\u0026#39;: name}) return {\u0026#39;$and\u0026#39;: criteria} if len(criteria) \u0026gt; 0 else None def get_page_by_filter(self, correlation_id, filter, paging): return super().get_page_by_filter(correlation_id, self.__compose_filter(filter), paging, None, None) persistence = MySqlServerPersistence() persistence.configure(ConfigParams.from_tuples( \u0026#34;host\u0026#34;, \u0026#34;localhost\u0026#34;, \u0026#34;port\u0026#34;, 27017 )) persistence.open(\u0026#39;123\u0026#39;) persistence.create(\u0026#39;123\u0026#39;, {\u0026#39;id\u0026#39;: \u0026#34;1\u0026#34;, \u0026#39;name\u0026#39;: \u0026#34;ABC\u0026#34;}) page = persistence.get_page_by_filter(\u0026#39;123\u0026#39;, FilterParams.from_tuples(\u0026#39;name\u0026#39;, \u0026#39;ABC\u0026#39;), None) print(page.data) # Result: { id: \u0026#34;1\u0026#34;, name: \u0026#34;ABC\u0026#34; } persistence.delete_by_id(\u0026#34;123\u0026#34;, \u0026#34;1\u0026#34;) # ... ","description":"Abstract persistence component that stores data in SQLServer in JSON or JSONB fields and implements a number of CRUD operations over data items with unique ids.\n","image":null,"permalink":"/python/sqlserver/persistence/identifiable_json_sqlserver_persistence/","subtitle":null,"tags":null,"title":"IdentifiableJsonSqlServerPersistence"},{"content":"Implements: MemoryPersistence\nDescription The IdentifiableMemoryPersistence class allows you to create persistence components that store data in memory and implement a number of CRUD operations over data items with unique ids.\nImportant points\n The data items must implement IIdentifiable. In basic scenarios child classes shall only override GetPageByFilter, GetListByFilter or DeleteByFilter operations with a specific filter function. All other operations can be used out of the box. In complex scenarios child classes can implement additional operations by accessing cached items via the this._items property and calling the Save method on updates.  Configuration parameters options:\n max_page_size: maximum number of items returned in a single page (default: 100)  References  *:logger:*:*:1.0 - (optional) (../../../components/log/ilogger) components to pass log messages  Constructors NewIdentifiableMemoryPersistence Creates a new instance of the identifiable file persistence component.\n NewIdentifiableMemoryPersistence(prototype reflect.Type) (c *IdentifiableMemoryPersistence)\n  prototype: reflect.Type - data type of contains items  Methods Create Creates a data item.\n (c *IdentifiableMemoryPersistence) Create(correlationId string, item interface{}) (result interface{}, err error)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. item: interface{} - item to be created. returns: (result interface{}, err error) - created item  DeleteById Deletes a data item based on it\u0026rsquo;s unique id.\n (c *IdentifiableMemoryPersistence) DeleteById(correlationId string, id interface{}) (result interface{}, err error)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. id: interface{} - id of the item to be deleted returns: (result interface{}, err error) - deleted item.  DeleteByIds Deletes multiple data items based on their unique ids.\n (c *IdentifiableMemoryPersistence) DeleteByIds(correlationId string, ids []interface{}) (err error)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. ids: []interface{} - ids of data items to be deleted. returns: error - returns error if not deleted  GetListByIds Gets a list of data items retrieved by given unique ids.\n (c *IdentifiableMemoryPersistence) GetListByIds(correlationId string, ids []interface{}) (result []interface{}, err error)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. ids: []interface{} - ids of data items to be retrieved returns: (result []interface{}, err error) - data list of results by ids.  GetOneById Gets a data item based on its unique id.\n (c *IdentifiableMemoryPersistence) GetOneById(correlationId string, id interface{}) (result interface{}, err error)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. id: interface{} - id of data item to be retrieved. returns: (result interface{}, err error) - data item by id.  Set Sets a data item. If the data item exists, it updates it; otherwise, it creates a new data item.\n (c *IdentifiableMemoryPersistence) Set(correlationId string, item interface{}) (result interface{}, err error)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. item: interface{} - item to be set. returns: (result interface{}, err error) - updated item  Update Updates a data item.\n (c *IdentifiableMemoryPersistence) Update(correlationId string, item interface{}) (result interface{}, err error)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. item: interface{} - item to be updated. returns: (result interface{}, err error) - updated item.  UpdatePartially Updates only a few selected fields in a data item.\n (c *IdentifiableMemoryPersistence) UpdatePartially(correlationId string, id interface{}, data *cdata.AnyValueMap) (result interface{}, err error)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. id: interface{} - id of a data item to be updated. data: *cdata.AnyValueMap - map with fields to be updated. returns: (result interface{}, err error) - updated item.  Examples type MyMemoryPersistence struct{ IdentifiableMemoryPersistence } func composeFilter(filter: FilterParams) (func (item interface{}) bool ) { if \u0026amp;filter == nil { filter = NewFilterParams() } name := filter.getAsNullableString(\u0026#34;Name\u0026#34;); return func(item interface{}) bool { dummy, ok := item.(MyData) if (*name != \u0026#34;\u0026#34; \u0026amp;\u0026amp; ok \u0026amp;\u0026amp; item.Name != *name) return false; return true; }; } func (mmp * MyMemoryPersistence) GetPageByFilter(correlationId string, filter FilterParams, paging PagingParams)(page DataPage, err error) { tempPage, err := c.GetPageByFilter(correlationId, composeFilter(filter), paging, nil, nil) dataLen := int64(len(tempPage.Data)) data := make([]MyData, dataLen) for i, v := range tempPage.Data { data[i] = v.(MyData) } page = *NewMyDataPage(\u0026amp;dataLen, data) return page, err } persistence := NewMyMemoryPersistence(); item, err := persistence.Create(\u0026#34;123\u0026#34;, { Id: \u0026#34;1\u0026#34;, Name: \u0026#34;ABC\u0026#34; }) ... page, err := persistence.GetPageByFilter(\u0026#34;123\u0026#34;, NewFilterParamsFromTuples(\u0026#34;Name\u0026#34;, \u0026#34;ABC\u0026#34;), nil) if err != nil { panic(\u0026#34;Error can\u0026#39;t get data\u0026#34;) } fmt.Prnitln(page.data) // Result: { Id: \u0026#34;1\u0026#34;, Name: \u0026#34;ABC\u0026#34; } item, err := persistence.DeleteById(\u0026#34;123\u0026#34;, \u0026#34;1\u0026#34;) ... See also   MemoryPersistence   ","description":"Abstract persistence component that stores data in memory and implements a number of CRUD operations over data items with unique ids.\n","image":null,"permalink":"/golang/data/persistence/identifiable_memory_persistence/","subtitle":null,"tags":null,"title":"IdentifiableMemoryPersistence"},{"content":"Inherits: MemoryPersistence, IWriter\u0026lt;T, K\u0026gt;, IGetter\u0026lt;T, K\u0026gt;, ISetter\nDescription The IdentifiableMemoryPersistence class allows you to create persistence components that store data in memory and implement a number of CRUD operations over data items with unique ids.\nImportant points\nWhere T : IIdentifiable\u0026lt;K\u0026gt;.\nWhere K : class.\n The data items must implement IIdentifiable. In basic scenarios child classes shall only override GetPageByFilter, GetListByFilter or DeleteByFilter operations with a specific filter function. All other operations can be used out of the box. In complex scenarios child classes can implement additional operations by accessing cached items via the this._items property and calling the Save method on updates.  Configuration parameters options:\n max_page_size: maximum number of items returned in a single page (default: 100)  References  *:logger:*:*:1.0 - (optional) (../../../components/log/ilogger) components to pass log messages  Constructors Creates a new instance of the identifiable file persistence component.\n protected IdentifiableMemoryPersistence(ILoader loader, ISaver saver)\n  loader: ILoader - (optional) loader used to load items from an external datasource. saver: ISaver - (optional) saver used to save items to and external datasource.  Creates a new instance of the persistence.\n public IdentifiableMemoryPersistence()\n Instance methods Create Creates a data item.\n public override Task\u0026lt;T\u0026gt; CreateAsync(string correlationId, T item)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. item: T - item to be created. returns: Task\u0026lt;T\u0026gt; - created item  DeleteByIdAsync Deletes a data item based on it\u0026rsquo;s unique id.\n public Task\u0026lt;T\u0026gt; DeleteByIdAsync(string correlationId, K id)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. id: K - id of the item to be deleted returns: Task\u0026lt;T\u0026gt; - deleted item.  DeleteByIdsAsync Deletes multiple data items based on their unique ids.\n public Task DeleteByIdAsync(string correlationId, K[] ids)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. ids: K[] - ids of data items to be deleted.  GetListByIds Gets a list of data items retrieved by given unique ids.\n public Task\u0026lt;List\u0026lt;T\u0026gt;\u0026gt; GetListByIdsAsync(string correlationId, K[] ids)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. ids: K[] - ids of data items to be retrieved returns: Task\u0026lt;List\u0026lt;T\u0026gt;\u0026gt; - data list of results by ids.  GetOneById Gets a data item based on its unique id.\n public Task\u0026lt;T\u0026gt; GetOneByIdAsync(string correlationId, K id)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. id: K - id of data item to be retrieved. returns: Task\u0026lt;T\u0026gt; - data item by id.  Set Sets a data item. If the data item exists, it updates it; otherwise, it creates a new data item.\n public Task\u0026lt;T\u0026gt; SetAsync(string correlationId, T item)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. item: T - item to be set. returns: Task\u0026lt;T\u0026gt; - updated item  Update Updates a data item.\n public Task\u0026lt;T\u0026gt; UpdateAsync(string correlationId, T item)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. item: T - item to be updated. returns: Task\u0026lt;T\u0026gt; - updated item.  UpdatePartially TODO: this method is not implemented yet\nUpdates only a few selected fields in a data item.\n public Task\u0026lt;T\u0026gt; UpdatePartially(correlationId: string, id: K, data: AnyValueMap): Task\u0026lt;T\u0026gt;\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. id: K - id of a data item to be updated. data: AnyValueMap - map with fields to be updated. returns: Task\u0026lt;T\u0026gt; - updated item.  Examples class MyMemoryPersistence: IdentifiableMemoryPersistence\u0026lt;MyData, string\u0026gt; { public MyFilePersistence(string path) { base(MyData.class, new JsonPersister(path)); private List\u0026lt;Func\u0026lt;MyData, bool\u0026gt;\u0026gt; ComposeFilter(FilterParams filter) { filter = filter != null ? filter : new FilterParams(); String name = filter.getAsNullableString(\u0026#34;name\u0026#34;); return List\u0026lt;Func\u0026lt;MyData, bool\u0026gt;\u0026gt;() { (item) =\u0026gt; { if (name != null \u0026amp;\u0026amp; item.name != name) return false; return true; } }; } public DataPage\u0026lt;MyData\u0026gt; GetPageByFilter(string correlationId, FilterParams filter, PagingParams paging) { base.GetPageByFilter(correlationId, this.composeFilter(filter), paging, null, null); } } var persistence = new MyMemoryPersistence(\u0026#34;./data/data.json\u0026#34;); var item = persistence.Create(\u0026#34;123\u0026#34;, new MyData(\u0026#34;1\u0026#34;, \u0026#34;ABC\u0026#34;)); var mydata = persistence.GetPageByFilter( \u0026#34;123\u0026#34;, FilterParams.fromTuples(\u0026#34;name\u0026#34;, \u0026#34;ABC\u0026#34;), null, null, null); Console.Out.WriteLine(page.Data); // Result: { id: \u0026#34;1\u0026#34;, name: \u0026#34;ABC\u0026#34; } persistence.DeleteById(\u0026#34;123\u0026#34;, \u0026#34;1\u0026#34;); ... See also   MemoryPersistence   ","description":"Abstract persistence component that stores data in memory and implements a number of CRUD operations over data items with unique ids.\n","image":null,"permalink":"/net/data/persistence/identifiable_memory_persistence/","subtitle":null,"tags":null,"title":"IdentifiableMemoryPersistence\u003cT, K\u003e"},{"content":"Extends: MemoryPersistence\nImplements: IWriter, IGetter, ISetter\nDescription The IdentifiableMemoryPersistence class allows you to create persistence components that store data in memory and implement a number of CRUD operations over data items with unique ids.\nImportant points\n The data items must implement IIdentifiable. In basic scenarios child classes shall only override getPageByFilter, getListByFilter or deleteByFilter operations with a specific filter function. All other operations can be used out of the box. In complex scenarios child classes can implement additional operations by accessing cached items via the this._items property and calling the save method on updates.  Configuration parameters options:\n max_page_size: maximum number of items returned in a single page (default: 100)  References  *:logger:*:*:1.0 - (optional) (../../../components/log/ilogger) components to pass log messages  Constructors Creates a new instance of the identifiable file persistence component.\n public constructor(loader?: ILoader, saver?: ISaver)\n  loader: ILoader - (optional) loader used to load items from an external datasource. saver: ISaver - (optional) saver used to save items to and external datasource.  Instance methods create Creates a data item.\n public create(correlationId: string, item: T): Promise\u0026lt;T\u0026gt;\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. item: T - item to be created. returns: Promise\u0026lt;T\u0026gt; - created item  deleteById Deletes a data item based on it\u0026rsquo;s unique id.\n public deleteById(correlationId: string, id: K): Promise\u0026lt;T\u0026gt;\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. id: K - id of the item to be deleted returns: Promise\u0026lt;T\u0026gt; - deleted item.  deleteByIds Deletes multiple data items based on their unique ids.\n public deleteByIds(correlationId: string, ids: K[]): Promise\u0026lt;void\u0026gt;\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. ids: K[] - ids of data items to be deleted.  getListByIds Gets a list of data items retrieved by given unique ids.\n public getListByIds(correlationId: string, ids: K[]): Promise\u0026lt;T[]\u0026gt;\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. ids: K[] - ids of data items to be retrieved returns: Promise\u0026lt;T[]\u0026gt; - data list of results by ids.  getOneById Gets a data item based on its unique id.\n public getOneById(correlationId: string, id: K): Promise\u0026lt;T\u0026gt;\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. id: K - id of data item to be retrieved. returns: Promise\u0026lt;T\u0026gt; - data item by id.  set Sets a data item. If the data item exists, it updates it; otherwise, it creates a new data item.\n public set(correlationId: string, item: T): Promise\u0026lt;T\u0026gt;\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. item: T - item to be set. returns: Promise\u0026lt;T\u0026gt; - updated item  update Updates a data item.\n public update(correlationId: string, item: T): Promise\u0026lt;T\u0026gt;\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. item: T - item to be updated. returns: Promise\u0026lt;T\u0026gt; - updated item.  updatePartially Updates only a few selected fields in a data item.\n public updatePartially(correlationId: string, id: K, data: AnyValueMap): Promise\u0026lt;T\u0026gt;\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. id: K - id of a data item to be updated. data: AnyValueMap - map with fields to be updated. returns: Promise\u0026lt;T\u0026gt; - updated item.  Examples class MyMemoryPersistence extends IdentifiableMemoryPersistence\u0026lt;MyData, string\u0026gt; { private composeFilter(filter: FilterParams): any { filter = filter || new FilterParams(); let name = filter.getAsNullableString(\u0026#34;name\u0026#34;); return (item) =\u0026gt; { if (name != null \u0026amp;\u0026amp; item.name != name) return false; return true; }; } public async getPageByFilter(correlationId: string, filter: FilterParams, paging: PagingParams): DataPage\u0026lt;MyData\u0026gt; { return await super.getPageByFilter(correlationId, this.composeFilter(filter), paging, null, null); } } let persistence = new MyMemoryPersistence(); let item = await persistence.create(\u0026#34;123\u0026#34;, { id: \u0026#34;1\u0026#34;, name: \u0026#34;ABC\u0026#34; }); let page = await persistence.getPageByFilter( \u0026#34;123\u0026#34;, FilterParams.fromTuples(\u0026#34;name\u0026#34;, \u0026#34;ABC\u0026#34;), null ); console.log(page.data); // Result: { id: \u0026#34;1\u0026#34;, name: \u0026#34;ABC\u0026#34; }  item = await persistence.deleteById(\u0026#34;123\u0026#34;, \u0026#34;1\u0026#34;); See also   MemoryPersistence   ","description":"Abstract persistence component that stores data in memory and implements a number of CRUD operations over data items with unique ids.\n","image":null,"permalink":"/node/data/persistence/identifiable_memory_persistence/","subtitle":null,"tags":null,"title":"IdentifiableMemoryPersistence\u003cT extends IIdentifiable\u003cK\u003e, K\u003e"},{"content":"Implements: MemoryPersistence, IWriter, IGetter, ISetter, iidentifiable\nDescription The IdentifiableMemoryPersistence class allows you to create persistence components that store data in memory and implement a number of CRUD operations over data items with unique ids.\nImportant points\n The data items must implement IIdentifiable. In basic scenarios child classes shall only override get_page_by_filter, get_list_by_filter or delete_by_filter operations with a specific filter function. All other operations can be used out of the box. In complex scenarios child classes can implement additional operations by accessing cached items via the this._items property and calling the save method on updates.  Configuration parameters options:\n max_page_size: maximum number of items returned in a single page (default: 100)  References  *:logger:*:*:1.0 - (optional) (../../../components/log/ilogger) components to pass log messages  Constructors Creates a new instance of the identifiable file persistence component.\n IdentifiableFilePersistence(loader: ILoader = None, saver: ISaver = None)\n  loader: ILoader - (optional) loader used to load items from an external datasource. saver: ISaver - (optional) saver used to save items to and external datasource.  Instance methods create Creates a data item.\n create(correlation_id: Optional[str], item: T): T\n  correlation_id: Optional[str] - (optional) transaction id used to trace execution through the call chain. item: T - item to be created. returns: T - created item  delete_by_id Deletes a data item based on it\u0026rsquo;s unique id.\n delete_by_id(correlation_id: Optional[str], id: Any): T\n  correlation_id: Optional[str] - (optional) transaction id used to trace execution through the call chain. id: Any - id of the item to be deleted returns: T - deleted item.  delete_by_ids Deletes multiple data items based on their unique ids.\n delete_by_ids(correlation_id: Optional[str], ids: List[Any])\n  correlation_id: Optional[str] - (optional) transaction id used to trace execution through the call chain. ids: List[Any] - ids of data items to be deleted.  get_list_by_ids Gets a list of data items retrieved by given unique ids.\n get_list_by_ids(correlation_id: Optional[str], ids: List[Any]): List[T]\n  correlation_id: Optional[str] - (optional) transaction id used to trace execution through the call chain. ids: List[Any] - ids of data items to be retrieved returns: List[T] - data list of results by ids.  get_one_by_id Gets a data item based on its unique id.\n get_one_by_id(correlation_id: Optional[str], id: Any): T\n  correlation_id: Optional[str] - (optional) transaction id used to trace execution through the call chain. id: Any - id of data item to be retrieved. returns: T - data item by id.  set Sets a data item. If the data item exists, it updates it; otherwise, it creates a new data item.\n set(correlation_id: Optional[str], item: T): T\n  correlation_id: Optional[str] - (optional) transaction id used to trace execution through the call chain. item: T - item to be set. returns: T - updated item  update Updates a data item.\n update(correlation_id: Optional[str], new_item: T): T\n  correlation_id: Optional[str] - (optional) transaction id used to trace execution through the call chain. new_item: T - item to be updated. returns: T - updated item.  update_partially Updates only a few selected fields in a data item.\n update_partially(correlation_id: Optional[str], id: Any, data: AnyValueMap): T\n  correlation_id: Optional[str] - (optional) transaction id used to trace execution through the call chain. id: Any - id of a data item to be updated. data: AnyValueMap - map with fields to be updated. returns: T - updated item.  Examples class MyMemoryPersistence(IdentifiableMemoryPersistence): def get_page_by_filter(self, correlationId, filter, paging): super().get_page_by_filter(correlationId, filter, paging, None) persistence = MyMemoryPersistence(\u0026#34;./data/data.json\u0026#34;) item = persistence.create(\u0026#34;123\u0026#34;, MyData(\u0026#34;1\u0026#34;, \u0026#34;ABC\u0026#34;)) mydata = persistence.get_page_by_filter(\u0026#34;123\u0026#34;, FilterParams.from_tuples(\u0026#34;name\u0026#34;, \u0026#34;ABC\u0026#34;), None, None) print(str(mydata.get_data()) persistence.delete_by_id(\u0026#34;123\u0026#34;, \u0026#34;1\u0026#34;) See also   MemoryPersistence   ","description":"Abstract persistence component that stores data in memory and implements a number of CRUD operations over data items with unique ids.\n","image":null,"permalink":"/python/data/persistence/identifiable_memory_persistence/","subtitle":null,"tags":null,"title":"IdentifiableMemoryPersistence"},{"content":"Implements: MongoDbPersistence\nDescription The IdentifiableMongoDbPersistence class allows you to create persistance components that store data in MongoDB databases and implement a number of CRUD operations over data items with unique ids.\nImportant points\n The data items must implement the IIdentifiable interface. In basic scenarios child classes shall only override getPageByFilter, getListByFilter or deleteByFilter operations with specific filter functions. All other operations can be used out of the box. In complex scenarios child classes can implement additional operations by accessing c.Db or c.Collection properties.  Configuration parameters connection(s):\n discovery_key: (optional) key to retrieve the connection from IDiscovery host: host name or IP address port: port number (default: 27017) uri: resource URI or connection string with all parameters in it  credential(s):\n store_key: (optional) key to retrieve the credentials from ICredentialStore username: (optional) username password: (optional) user\u0026rsquo;s password  options:\n max_pool_size: (optional) maximum connection pool size (default: 2) keep_alive: (optional) enable connection keep alive (default: true) connect_timeout: (optional) connection timeout in milliseconds (default: 5000) socket_timeout: (optional) socket timeout in milliseconds (default: 360000) auto_reconnect: (optional) enable auto reconnection (default: true) (not used) reconnect_interval: (optional) reconnection interval in milliseconds (default: 1000) (not used) max_page_size: (optional) maximum page size (default: 100) replica_set: (optional) name of replica set ssl: (optional) enable SSL connection (default: false) (not implements in this release) auth_source: (optional) authentication source auth_user: (optional) authentication user name auth_password: (optional) authentication user password debug: (optional) enable debug output (default: false). (not used)  References  *:logger:*:*:1.0 - (optional) ILogger components to pass log messages *:discovery:*:*:1.0 - (optional) IDiscovery services *:credential-store:*:*:1.0 - (optional) credential stores used to resolve credentials  Constructors InheritIdentifiableMongoDbPersistence Creates a new instance of the persistence component.\n InheritIdentifiableMongoDbPersistence(overrides IMongoDbPersistenceOverrides, proto reflect.Type, collection string) *IdentifiableMongoDbPersistence\n  overrides: IMongoDbPersistenceOverrides - TODO: add description proto: reflect.Type - TODO: add description collection: string - (optional) collection name.  Methods Create Creates a data item.\n (c *IdentifiableMongoDbPersistence) Create(correlationId string, item interface{}) (result interface{}, err error)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. item: interface{} - item to be created. returns: (result interface{}, err error) - created item  DeleteById Deletes a data item by it\u0026rsquo;s unique id.\n (c *IdentifiableMongoDbPersistence) DeleteById(correlationId string, id interface{}) (item interface{}, err error)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. id: interface{} - id of the item to be deleted return: (item interface{}, err error) - deleted item.  DeleteByIds Deletes multiple data items by their unique ids.\n (c *IdentifiableMongoDbPersistence) DeleteByIds(correlationId string, ids []interface{}) error\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. ids: []interface{} - ids of data items to be deleted. returns: error - error or nil no errors occured.  GetListByIds Gets a list of data items retrieved by given unique ids.\n (c *IdentifiableMongoDbPersistence) GetListByIds(correlationId string, ids []interface{}) (items []interface{}, err error)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. ids: []interface{} - ids of data items to be retrieved return: (items []interface{}, err error) - data list of results by ids.  GetOneById Gets a data item by its unique id.\n (c *IdentifiableMongoDbPersistence) GetOneById(correlationId string, id interface{}) (item interface{}, err error)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. id: interface{} - id of data item to be retrieved. returns: (item interface{}, err error) - data item by id.  Set Sets a data item. If the data item exists it updates it, otherwise it creates a new data item.\n (c *IdentifiableMongoDbPersistence) Set(correlationId string, item interface{}) (result interface{}, err error)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. item: interface{} - item to be set. returns: (result interface{}, err error) - updated item  Update Updates a data item.\n (c *IdentifiableMongoDbPersistence) Update(correlationId string, item interface{}) (result interface{}, err error)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. item: interface{} - item to be updated. returns: (result interface{}, err error) - updated item.  UpdatePartially Updates only few selected fields in a data item.\n (c *IdentifiableMongoDbPersistence) UpdatePartially(correlationId string, id interface{}, data *cdata.AnyValueMap) (item interface{}, err error)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. id: interface{} - id of data item to be updated. data: *cdata.AnyValueMap - map with fields to be updated. returns: (item interface{}, err error) - updated item.  Examples type MyMongoDbPersistence struct { IdentifiableMongoDbPersistence } func NewMyMongoDbPersistence() { proto := reflect.TypeOf(MyData{}) return \u0026amp;DummyMongoDbPersistence{*persist.NewIdentifiableMongoDbPersistence(proto, \u0026#34;mydata\u0026#34;)} } func composeFilter(filter cdata.FilterParams) interface{} { if \u0026amp;filter == nil { filter = *cdata.NewEmptyFilterParams() } name := filter.GetAsNullableString(\u0026#34;name\u0026#34;) var filterObj bson.M if *name != \u0026#34;\u0026#34; { filterObj = bson.M{\u0026#34;name\u0026#34;: *name} else { filterObj = bson.M{} } return filterObj } func (c *MyMongoDbPersistence) GetPageByFilter(correlationId string, filter cdata.FilterParams, paging) cdata.PagingParams) (page MyDataPage, err error){ tempPage, err := c.IdentifiableMongoDbPersistence.GetPageByFilter(correlationId, composeFilter(filter), paging, nil, nil) // Convert to MyDataPage \tdataLen := int64(len(tempPage.Data)) // For full release tempPage and delete this by GC \tdata := make([]MyData, dataLen) for i, v := range tempPage.Data { data[i] = v.(MyData) } page = *NewMyDataPage(\u0026amp;dataLen, data) return page, err } persistence = NewMyMongoDbPersistence() persistence.Configure(NewConfigParamsFromTuples( \u0026#34;host\u0026#34;, \u0026#34;localhost\u0026#34;, \u0026#34;port\u0026#34;, \u0026#34;27017\u0026#34; \u0026#34;database\u0026#34;, \u0026#34;test\u0026#34;, )) opnErr := persitence.Open(\u0026#34;123\u0026#34;) if opnErr != nil { ... } crtRes, crtErr := persistence.Create(\u0026#34;123\u0026#34;, MyData{ id: \u0026#34;1\u0026#34;, name: \u0026#34;ABC\u0026#34; }) if crtErr != nil { ... } getRes, getErr := persistence.GetPageByFilter(\u0026#34;123\u0026#34;, NewFilterParamsFromTuples(\u0026#34;name\u0026#34;, \u0026#34;ABC\u0026#34;), nil) if getErr != nil { ... } fmt.Println(getRes.Data); // Result: { id: \u0026#34;1\u0026#34;, name: \u0026#34;ABC\u0026#34; } persistence.deleteById(\u0026#34;123\u0026#34;, \u0026#34;1\u0026#34;) ... ","description":"Abstract persistence component that stores data in MongoDB and implements a number of CRUD operations over data items with unique ids.\n","image":null,"permalink":"/golang/mongodb/persistence/identifiable_mongodb_persistence/","subtitle":null,"tags":null,"title":"IdentifiableMongoDbPersistence"},{"content":"Inherits: MongoDbPersistence, IWriter\u0026lt;T, K\u0026gt;, IGetter\u0026lt;T, K\u0026gt;, ISetter\nDescription The IdentifiableMongoDbPersistence class allows you to create persistance components that store data in MongoDB databases and implement a number of CRUD operations over data items with unique ids.\nImportant points\nWhere T : IIdentifiable. Where K : class.\n The data items must implement the IIdentifiable interface. In basic scenarios child classes shall only override GetPageByFilterAsync, GetListByFilter or GeleteByFilter operations with specific filter functions. All other operations can be used out of the box. In complex scenarios child classes can implement additional operations by accessing this._collection and this._model properties.  Configuration parameters connection(s):\n discovery_key: (optional) key to retrieve the connection from IDiscovery host: host name or IP address port: port number (default: 27017) uri: resource URI or connection string with all parameters in it  credential(s):\n store_key: (optional) key to retrieve the credentials from ICredentialStore username: (optional) username password: (optional) user\u0026rsquo;s password  options:\n max_pool_size: (optional) maximum connection pool size (default: 2) keep_alive: (optional) enable connection keep alive (default: true) connect_timeout: (optional) connection timeout in milliseconds (default: 5 sec) auto_reconnect: (optional) enable auto reconnection (default: true) max_page_size: (optional) maximum page size (default: 100) debug: (optional) enable debug output (default: false).  References  *:logger:*:*:1.0 - (optional) ILogger components to pass log messages *:discovery:*:*:1.0 - (optional) IDiscovery services *:credential-store:*:*:1.0 - (optional) credential stores used to resolve credentials  Constructors Creates a new instance of the persistence component.\n public IdentifiableMongoDbPersistence(string collectionName)\n  collectionName: string - (optional) collection name.  Fields InternalIdFieldName TODO: add description\n protected InternalIdFieldName: string = = \u0026ldquo;_id\u0026rdquo;\n  Instance methods CreateAsync Creates a data item.\n public override Task\u0026lt;T\u0026gt; CreateAsync(string correlationId, T item)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. item: T - item to be created. returns: Task\u0026lt;T\u0026gt; - created item  DeleteByIdAsync Deletes a data item by it\u0026rsquo;s unique id.\n public virtual Task\u0026lt;T\u0026gt; DeleteByIdAsync(string correlationId, K id)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. id: K - id of the item to be deleted return: Task\u0026lt;T\u0026gt; - deleted item.  DeleteByIdsAsync Deletes multiple data items by their unique ids.\n public virtual Task DeleteByIdsAsync(string correlationId, K[] ids)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. ids: K[] - ids of data items to be deleted.  GetListByIdsAsync Gets a list of data items retrieved by given unique ids.\n public virtual Task\u0026lt;List\u0026lt;T\u0026gt;\u0026gt; GetListByIdsAsync(string correlationId, K[] ids)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. ids: K[] - ids of data items to be retrieved return: Task\u0026lt;List\u0026lt;T\u0026gt;\u0026gt; - data list of results by ids.  GetOneByIdAsync Gets a data item by its unique id.\n public virtual Task\u0026lt;T\u0026gt; GetOneByIdAsync(string correlationId, K id)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. id: K - id of data item to be retrieved. returns: Task\u0026lt;T\u0026gt; - data item by id.  SetAsync Sets a data item. If the data item exists it updates it, otherwise it creates a new data item.\n public virtual Task\u0026lt;T\u0026gt; SetAsync(string correlationId, T item)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. item: T - item to be set. returns: Task\u0026lt;T\u0026gt; - updated item  UpdateAsync Updates a data item.\n public virtual Task\u0026lt;T\u0026gt; UpdateAsync(string correlationId, T item)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. item: T - item to be updated. returns: Task\u0026lt;T\u0026gt; - updated item.  Examples class MyMongoDbPersistence: MongoDbPersistence\u0026lt;MyData, string\u0026gt; { public constructor() { base(\u0026#34;mydata\u0026#34;, MyData.class); } private FilterDefinition\u0026lt;MyData\u0026gt; ComposeFilter(FilterParams filter) { filterParams = filterParams ?? new FilterParams(); var builder = Builders\u0026lt;BeaconV1\u0026gt;.Filter; var filter = builder.Empty; String name = filter.getAsNullableString(\u0026#39;name\u0026#39;); if (name != null) filter \u0026amp;= builder.Eq(b =\u0026gt; b.Name, name); return filter; } public GetPageByFilter(String correlationId, FilterParams filter, PagingParams paging) { base.GetPageByFilter(correlationId, this.ComposeFilter(filter), paging, null, null); } } var persistence = new MyMongoDbPersistence(); persistence.Configure(ConfigParams.FromTuples( \u0026#34;host\u0026#34;, \u0026#34;localhost\u0026#34;, \u0026#34;port\u0026#34;, 27017 ) ); persitence.Open(\u0026#34;123\u0026#34;); persistence.Create(\u0026#34;123\u0026#34;, new MyData(\u0026#34;1\u0026#34;, \u0026#34;ABC\u0026#34;)); var mydata = persistence.GetPageByFilter( \u0026#34;123\u0026#34;, FilterParams.FromTuples(\u0026#34;name\u0026#34;, \u0026#34;ABC\u0026#34;) ); Console.Out.WriteLine(mydata.Data); // Result: { id: \u0026#34;1\u0026#34;, name: \u0026#34;ABC\u0026#34; }  persistence.DeleteById(\u0026#34;123\u0026#34;, \u0026#34;1\u0026#34;); ... ","description":"Abstract persistence component that stores data in MongoDB and implements a number of CRUD operations over data items with unique ids.\n","image":null,"permalink":"/net/mongodb/persistence/identifiable_mongodb_persistence/","subtitle":null,"tags":null,"title":" IdentifiableMongoDbPersistence\u003cT, K\u003e"},{"content":"Extends: MongoDbPersistence\nImplements: IWriter\u0026lt;T, K\u0026gt;, IGetter\u0026lt;T, K\u0026gt;, ISetter\nDescription The IdentifiableMongoDbPersistence class allows you to create persistance components that store data in MongoDB databases and implement a number of CRUD operations over data items with unique ids.\nImportant points\n The data items must implement the IIdentifiable interface. In basic scenarios child classes shall only override getPageByFilter, getListByFilter or deleteByFilter operations with specific filter functions. All other operations can be used out of the box. In complex scenarios child classes can implement additional operations by accessing this._collection and this._model properties.  Configuration parameters connection(s):\n discovery_key: (optional) key to retrieve the connection from IDiscovery host: host name or IP address port: port number (default: 27017) uri: resource URI or connection string with all parameters in it  credential(s):\n store_key: (optional) key to retrieve the credentials from ICredentialStore username: (optional) username password: (optional) user\u0026rsquo;s password  options:\n max_pool_size: (optional) maximum connection pool size (default: 2) keep_alive: (optional) enable connection keep alive (default: true) connect_timeout: (optional) connection timeout in milliseconds (default: 5000) socket_timeout: (optional) socket timeout in milliseconds (default: 360000) auto_reconnect: (optional) enable auto reconnection (default: true) (not used) reconnect_interval: (optional) reconnection interval in milliseconds (default: 1000) (not used) max_page_size: (optional) maximum page size (default: 100) replica_set: (optional) name of replica set ssl: (optional) enable SSL connection (default: false) (not implements in this release) auth_source: (optional) authentication source auth_user: (optional) authentication user name auth_password: (optional) authentication user password debug: (optional) enable debug output (default: false). (not used)  References  *:logger:*:*:1.0 - (optional) ILogger components to pass log messages *:discovery:*:*:1.0 - (optional) IDiscovery services *:credential-store:*:*:1.0 - (optional) credential stores used to resolve credentials  Constructors Creates a new instance of the persistence component.\n public constructor(collection: string)\n  collection: string - (optional) collection name.  Fields _autoGenerateId Flag to turn on automated string ID generation\n protected _autoGenerateId: boolean = true\n  Instance methods convertFromPublicPartial Converts the given object from the public partial format.\n protected convertFromPublicPartial(value: any): any\n  value: any - object to convert from the public partial format. returns: any - initial object.  create Creates a data item.\n public create(correlationId: string, item: T): Promise\u0026lt;T\u0026gt;\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. item: T - item to be created. returns: Promise\u0026lt;T\u0026gt; - created item  deleteById Deletes a data item by it\u0026rsquo;s unique id.\n public deleteById(correlationId: string, id: K): Promise\u0026lt;T\u0026gt;\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. id: K - id of the item to be deleted return: Promise\u0026lt;T\u0026gt; - deleted item.  deleteByIds Deletes multiple data items by their unique ids.\n public deleteByIds(correlationId: string, ids: K[]): Promise\u0026lt;void\u0026gt;\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. ids: K[] - ids of data items to be deleted.  getListByIds Gets a list of data items retrieved by given unique ids.\n public getListByIds(correlationId: string, ids: K[]): Promise\u0026lt;T[]\u0026gt;\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. ids: K[] - ids of data items to be retrieved return: Promise\u0026lt;T[]\u0026gt; - data list of results by ids.  getOneById Gets a data item by its unique id.\n public getOneById(correlationId: string, id: K): Promise\u0026lt;T\u0026gt;\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. id: K - id of data item to be retrieved. returns: Promise\u0026lt;T\u0026gt; - data item by id.  set Sets a data item. If the data item exists it updates it, otherwise it creates a new data item.\n public set(correlationId: string, item: T): Promise\u0026lt;T\u0026gt;\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. item: T - item to be set. returns: Promise\u0026lt;T\u0026gt; - updated item  update Updates a data item.\n public update(correlationId: string, item: T): Promise\u0026lt;T\u0026gt;\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. item: T - item to be updated. returns: Promise\u0026lt;T\u0026gt; - updated item.  updatePartially Updates only few selected fields in a data item.\n public updatePartially(correlationId: string, id: K, data: AnyValueMap): Promise\u0026lt;T\u0026gt;\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. id: K - id of data item to be updated. data: AnyValueMap - map with fields to be updated. returns: Promise\u0026lt;T\u0026gt; - updated item.  Examples class MyMongoDbPersistence extends MongoDbPersistence\u0026lt;MyData, string\u0026gt; { public constructor() { base(\u0026#34;mydata\u0026#34;, new MyDataMongoDbSchema()); } private composeFilter(filter: FilterParams): any { filter = filter || new FilterParams(); let criteria = []; let name = filter.getAsNullableString(\u0026#39;name\u0026#39;); if (name != null) criteria.push({ name: name }); return criteria.length \u0026gt; 0 ? { $and: criteria } : null; } public getPageByFilter(correlationId: string, filter: FilterParams, paging: PagingParams, callback: (err: any, page: DataPage\u0026lt;MyData\u0026gt;) =\u0026gt; void): void { base.getPageByFilter(correlationId, this.composeFilter(filter), paging, null, null, callback); } } let persistence = new MyMongoDbPersistence(); persistence.configure(ConfigParams.fromTuples( \u0026#34;host\u0026#34;, \u0026#34;localhost\u0026#34;, \u0026#34;port\u0026#34;, 27017 )); persitence.open(\u0026#34;123\u0026#34;, (err) =\u0026gt; { ... }); persistence.create(\u0026#34;123\u0026#34;, { id: \u0026#34;1\u0026#34;, name: \u0026#34;ABC\u0026#34; }, (err, item) =\u0026gt; { persistence.getPageByFilter( \u0026#34;123\u0026#34;, FilterParams.fromTuples(\u0026#34;name\u0026#34;, \u0026#34;ABC\u0026#34;), null, (err, page) =\u0026gt; { console.log(page.data); // Result: { id: \u0026#34;1\u0026#34;, name: \u0026#34;ABC\u0026#34; }  persistence.deleteById(\u0026#34;123\u0026#34;, \u0026#34;1\u0026#34;, (err, item) =\u0026gt; { ... }); } ) }); ","description":"Abstract persistence component that stores data in MongoDB and implements a number of CRUD operations over data items with unique ids.\n","image":null,"permalink":"/node/mongodb/persistence/identifiable_mongodb_persistence/","subtitle":null,"tags":null,"title":"IdentifiableMongoDbPersistence\u003cT extends IIdentifiable\u003cK\u003e, K\u003e"},{"content":"Implements: MongoDbPersistence, IIdentifiable\nDescription The IdentifiableMongoDbPersistence class allows you to create persistance components that store data in MongoDB databases and implement a number of CRUD operations over data items with unique ids.\nImportant points\n The data items must implement the IIdentifiable interface. In basic scenarios child classes shall only override get_page_by_filter, get_list_by_filter or delete_by_filter operations with specific filter functions. All other operations can be used out of the box. In complex scenarios child classes can implement additional operations by accessing self._collection and self._model properties.  Configuration parameters connection(s):\n discovery_key: (optional) key to retrieve the connection from IDiscovery host: host name or IP address port: port number (default: 27017) uri: resource URI or connection string with all parameters in it  credential(s):\n store_key: (optional) key to retrieve the credentials from ICredentialStore username: (optional) username password: (optional) user\u0026rsquo;s password  options:\n max_pool_size: (optional) maximum connection pool size (default: 2) keep_alive: (optional) enable connection keep alive (default: true) connect_timeout: (optional) connection timeout in milliseconds (default: 5000) socket_timeout: (optional) socket timeout in milliseconds (default: 360000) auto_reconnect: (optional) enable auto reconnection (default: true) (not used) reconnect_interval: (optional) reconnection interval in milliseconds (default: 1000) (not used) max_page_size: (optional) maximum page size (default: 100) replica_set: (optional) name of replica set ssl: (optional) enable SSL connection (default: false) (not implements in this release) auth_source: (optional) authentication source auth_user: (optional) authentication user name auth_password: (optional) authentication user password debug: (optional) enable debug output (default: false). (not used)  References  *:logger:*:*:1.0 - (optional) ILogger components to pass log messages *:discovery:*:*:1.0 - (optional) IDiscovery services *:credential-store:*:*:1.0 - (optional) credential stores used to resolve credentials  Constructors Creates a new instance of the persistence component.\n IdentifiableMongoDbPersistence(collection: str = None)\n  collection: str - (optional) collection name.  Instance methods _convert_from_public_partial Converts the given object from the public partial format.\n _convert_from_public_partial(value: Any): Any\n  value: Any - object to convert from the public partial format. returns: Any - initial object.  create Creates a data item.\n create(correlation_id: Optional[str], item: T): Optional[T]\n  correlation_id: Optional[str] - (optional) transaction id used to trace execution through the call chain. item: T - item to be created. returns: Optional[T] - created item  delete_by_id Deletes a data item by it\u0026rsquo;s unique id.\n delete_by_id(correlation_id: Optional[str], id: Any): T\n  correlation_id: Optional[str] - (optional) transaction id used to trace execution through the call chain. id: Any - id of the item to be deleted return: T - deleted item.  delete_by_ids Deletes multiple data items by their unique ids.\n delete_by_ids(correlation_id: Optional[str], ids: List[Any])\n  correlation_id: Optional[str] - (optional) transaction id used to trace execution through the call chain. ids: List[Any] - ids of data items to be deleted.  get_list_by_ids Gets a list of data items retrieved by given unique ids.\n get_list_by_ids(correlation_id: Optional[str], ids: List[Any]): List[T]\n  correlation_id: Optional[str] - (optional) transaction id used to trace execution through the call chain. ids: List[Any] - ids of data items to be retrieved return: List[T] - data list of results by ids.  get_one_by_id Gets a data item by its unique id.\n get_one_by_id(correlation_id: Optional[str], id: Any): Optional[T]\n  correlation_id: Optional[str] - (optional) transaction id used to trace execution through the call chain. id: Any - id of data item to be retrieved. returns: Optional[T] - data item by id.  set Sets a data item. If the data item exists it updates it, otherwise it creates a new data item.\n set(correlation_id: Optional[str], item: T): Optional[T]\n  correlation_id: Optional[str] - (optional) transaction id used to trace execution through the call chain. item: T - item to be set. returns: Optional[T] - updated item  update Updates a data item.\n update(correlation_id: Optional[str], item: T): Optional[T]\n  correlation_id: Optional[str] - (optional) transaction id used to trace execution through the call chain. item: T - item to be updated. returns: Optional[T] - updated item.  update_partially Updates only few selected fields in a data item.\n update_partially(correlation_id: Optional[str], id: Any, data: AnyValueMap): Optional[T]\n  correlation_id: Optional[str] - (optional) transaction id used to trace execution through the call chain. id: Any - id of data item to be updated. data: AnyValueMap - map with fields to be updated. returns: Optional[T] - updated item.  Examples class MyMongoDbPersistence(MongoDbPersistence): def __init__(self): super(MyMongoDbPersistence, self).__init__(\u0026#34;mydata\u0026#34;, MyData) def get_page_by_filter(self, correlation_id, filter, paging, sort = None, select = None): super().def get_page_by_filter(correlation_id, filter, paging, None, None): persistence = MyMongoDbPersistence() persistence.configure(ConfigParams.from_tuples(\u0026#34;host\u0026#34;, \u0026#34;localhost\u0026#34;, \u0026#34;port\u0026#34;, 27017)) persitence.open(\u0026#34;123\u0026#34;) persistence.create(\u0026#34;123\u0026#34;, { id: \u0026#34;1\u0026#34;, name: \u0026#34;ABC\u0026#34; }) mydata = persistence.get_page_by_filter(\u0026#34;123\u0026#34;, FilterParams.from_tuples(\u0026#34;name\u0026#34;, \u0026#34;ABC\u0026#34;), None, None) print(mydata) persistence.delete_by_id(\u0026#34;123\u0026#34;, \u0026#34;1\u0026#34;) # ... ","description":"Abstract persistence component that stores data in MongoDB and implements a number of CRUD operations over data items with unique ids.\n","image":null,"permalink":"/python/mongodb/persistence/identifiable_mongodb_persistence/","subtitle":null,"tags":null,"title":"IdentifiableMongoDbPersistence"},{"content":"Inherits: MySqlPersistence\nDescription The IdentifiableMySqlPersistence class allows you to create persistence components that store data in MySQL databases and implement a number of CRUD operations over data items with unique ids.\nImportant points\nwhere T : IIdentifiable, new()\nwhere K : class.\n The data items must implement the IIdentifiable interface. In basic scenarios, child classes shall only override GetPageByFilterAsync, GetListByFilterAsync or DeleteByFilterAsync operations with the specific filter function. All other operations can be used out of the box. In complex scenarios child classes can implement additional operations by accessing the this._collection and this._model properties.  Configuration parameters  collection: (optional) MySQL collection name  connection(s):\n discovery_key: (optional) key to retrieve the connection from IDiscovery host: host name or IP address port: port number (default: 27017) uri: resource URI or connection string with all parameters in it  credential(s):\n store_key: (optional) key to retrieve the credentials from ICredentialStore username: (optional) username password: (optional) user\u0026rsquo;s password  options:\n max_pool_size: (optional) maximum connection pool size (default keep_alive: (optional) enable connection keep alive (default connect_timeout: (optional) connection timeout in milliseconds (d auto_reconnect: (optional) enable auto reconnection (default: tr max_page_size: (optional) maximum page size (default: 100) debug: (optional) enable debug output (default: false).  References  *:logger:*:*:1.0 - (optional) ILogger components to pass log messages *:discovery:*:*:1.0 - (optional) IDiscovery services *:credential-store:*:*:1.0 - (optional) Credential stores to resolve credentials (ICredentialStore)  Constructors Creates a new instance of the persistence component.\n public IdentifiableMySqlPersistence(tableName: string)\n  tableName: string - (optional) collection name.  Instance methods CreateAsync Creates a data item.\n public override Task\u0026lt;T\u0026gt; CreateAsync(string correlationId, T item)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. item: T - item to be created. returns: Task\u0026lt;T\u0026gt; - created item  DeleteByIdAsync Deletes a data item by it\u0026rsquo;s unique id.\n public virtual Task\u0026lt;T\u0026gt; DeleteByIdAsync(string correlationId, K id)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. id: K - id of the item to be deleted returns: Task\u0026lt;T\u0026gt; - deleted item  DeleteByIdsAsync Deletes multiple data items by their unique ids.\n public virtual Task DeleteByIdsAsync(string correlationId, K[] ids)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. ids: K[] - ids of the data items to be deleted.  GetListByIdsAsync Gets a list of data items retrieved by given unique ids.\n public virtual Task\u0026lt;List\u0026lt;T\u0026gt;\u0026gt; GetListByIdsAsync(string correlationId, K[] ids)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. ids: K[] - ids of the data items to be retrieved returns: Task\u0026lt;List\u0026lt;T\u0026gt;\u0026gt; - data list  GetOneByIdAsync Gets a data item by its unique id.\n public virtual async Task\u0026lt;T\u0026gt; GetOneByIdAsync(string correlationId, K id)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. id: K - id of the data item to be retrieved. returns: Task\u0026lt;T\u0026gt; - data item  SetAsync Sets a data item. If the data item exists it updates it, otherwise it creates a new data item.\n public virtual async Task\u0026lt;T\u0026gt; SetAsync(string correlationId, T item)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. item: T - item to be set. returns: Task\u0026lt;T\u0026gt; - new or updated item  Update Updates a data item.\n public virtual async Task\u0026lt;T\u0026gt; UpdateAsync(string correlationId, T item)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. item: T - item to be updated. returns: Task\u0026lt;T\u0026gt; - updated item  UpdatePartially Updates only a few selected fields in a data item.\n public virtual Task\u0026lt;T\u0026gt; UpdatePartially(string correlationId, K id, AnyValueMap data)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. id: K - id of data item to be updated. data: AnyValueMap - map with fields to be updated. returns: Task\u0026lt;T\u0026gt; - updated item  Examples class MyMySqlPersistence: MySqlPersistence\u0026lt;MyData, string\u0026gt; { public MyMySqlPersistence() { base(\u0026#34;mydata\u0026#34;, MyData.class); } ///  private FilterDefinition\u0026lt;MyData\u0026gt; ComposeFilter(FilterParams filter) { filterParams = filterParams ?? new FilterParams(); var builder = Builders\u0026lt;BeaconV1\u0026gt;.Filter; var filter = builder.Empty; String name = filter.getAsNullableString(\u0026#39;name\u0026#39;); if (name != null) filter \u0026amp;= builder.Eq(b =\u0026gt; b.Name, name); return filter; } public GetPageByFilter(String correlationId, FilterParams filter, PagingParams paging) { base.GetPageByFilter(correlationId, this.ComposeFilter(filter), paging, null, null); } } var persistence = new MyMySqlPersistence(); persistence.Configure(ConfigParams.FromTuples( \u0026#34;host\u0026#34;, \u0026#34;localhost\u0026#34;, \u0026#34;port\u0026#34;, 27017 ) ); persitence.Open(\u0026#34;123\u0026#34;); persistence.Create(\u0026#34;123\u0026#34;, new MyData(\u0026#34;1\u0026#34;, \u0026#34;ABC\u0026#34;)); var mydata = persistence.GetPageByFilter( \u0026#34;123\u0026#34;, FilterParams.FromTuples(\u0026#34;name\u0026#34;, \u0026#34;ABC\u0026#34;) ); Console.Out.WriteLine(mydata.Data); // Result: { id: \u0026#34;1\u0026#34;, name: \u0026#34;ABC\u0026#34; }  persistence.DeleteById(\u0026#34;123\u0026#34;, \u0026#34;1\u0026#34;); ... ","description":"\nAbstract persistence component that stores data in MySQL and implements a number of CRUD operations over data items with unique ids.\n","image":null,"permalink":"/net/mysql/persistence/identifiable_mysql_persistence/","subtitle":null,"tags":null,"title":"IdentifiableMySqlPersistence\u003cT extends IIdentifiable\u003cK\u003e, K\u003e"},{"content":"Extends: MySqlPersistence\nDescription The IdentifiableMySqlPersistence class allows you to create persistence components that store data in MySQL databases and implement a number of CRUD operations over data items with unique ids.\nImportant points\n The data items must implement the IIdentifiable interface. In basic scenarios, child classes shall only override getPageByFilter, getListByFilter or deleteByFilter operations with the specific filter function. All other operations can be used out of the box. In complex scenarios child classes can implement additional operations by accessing the this._collection and this._model properties.  Configuration parameters  collection: (optional) MySQL collection name  connection(s):\n discovery_key: (optional) key to retrieve the connection from IDiscovery host: host name or IP address port: port number (default: 27017) uri: resource URI or connection string with all parameters in it  credential(s):\n store_key: (optional) key to retrieve the credentials from ICredentialStore username: (optional) username password: (optional) user\u0026rsquo;s password  options:\n connect_timeout: (optional) number of milliseconds to wait before timing out when connecting a new client (default: 0) idle_timeout: (optional) number of milliseconds a client must sit idle in the pool and not be checked out (default: 10000) max_pool_size: (optional) maximum number of clients the pool should contain (default: 10)  References  *:logger:*:*:1.0 - (optional) ILogger components to pass log messages *:discovery:*:*:1.0 - (optional) IDiscovery services *:credential-store:*:*:1.0 - (optional) Credential stores to resolve credentials (ICredentialStore)  Constructors Creates a new instance of the persistence component.\n public constructor(tableName: string)\n  tableName: string - (optional) collection name.  Instance methods convertFromPublicPartial Converts the given object from the public partial format.\n protected convertFromPublicPartial(value: any): any\n  value: any - the object to convert from the public partial format. returns: any - the initial object.  create Creates a data item.\n public create(correlationId: string, item: T): Promise\u0026lt;T\u0026gt;\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. item: T - item to be created. returns: Promise\u0026lt;T\u0026gt; - created item  deleteById Deletes a data item by it\u0026rsquo;s unique id.\n public deleteById(correlationId: string, id: K): Promise\u0026lt;T\u0026gt;\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. id: K - id of the item to be deleted returns: Promise\u0026lt;T\u0026gt; - deleted item  deleteByIds Deletes multiple data items by their unique ids.\n public deleteByIds(correlationId: string, ids: K[]): Promise\u0026lt;void\u0026gt;\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. ids: K[] - ids of the data items to be deleted.  getListByIds Gets a list of data items retrieved by given unique ids.\n public getListByIds(correlationId: string, ids: K[]): Promise\u0026lt;T[]\u0026gt;\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. ids: K[] - ids of the data items to be retrieved returns: Promise\u0026lt;T[]\u0026gt; - data list  getOneById Gets a data item by its unique id.\n public getOneById(correlationId: string, id: K): Promise\u0026lt;T\u0026gt;\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. id: K - id of the data item to be retrieved. returns: Promise\u0026lt;T\u0026gt; - data item  set Sets a data item. If the data item exists it updates it, otherwise it creates a new data item.\n public set(correlationId: string, item: T): Promise\u0026lt;T\u0026gt;\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. item: T - item to be set. returns: Promise\u0026lt;T\u0026gt; - new or updated item  update Updates a data item.\n public update(correlationId: string, item: T): Promise\u0026lt;T\u0026gt;\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. item: T - item to be updated. returns: Promise\u0026lt;T\u0026gt; - updated item  updatePartially Updates only a few selected fields in a data item.\n public updatePartially(correlationId: string, id: K, data: AnyValueMap): Promise\u0026lt;T\u0026gt;\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. id: any - id of data item to be updated. data: AnyValueMap - map with fields to be updated. returns: Promise\u0026lt;T\u0026gt; - updated item  Examples class MyMySqlPersistence extends IdentifiableMySqlPersistence\u0026lt;MyData, string\u0026gt; { public constructor() { base(\u0026#34;mydata\u0026#34;, new MyDataMySqlSchema()); } private composeFilter(filter: FilterParams): any { filter = filter || new FilterParams(); let criteria = []; let name = filter.getAsNullableString(\u0026#39;name\u0026#39;); if (name != null) criteria.push({ name: name }); return criteria.length \u0026gt; 0 ? { $and: criteria } : null; } public getPageByFilter(correlationId: string, filter: FilterParams, paging: PagingParams, callback: (err: any, page: DataPage\u0026lt;MyData\u0026gt;) =\u0026gt; void): void { base.getPageByFilter(correlationId, this.composeFilter(filter), paging, null, null, callback); } } let persistence = new MyMySqlPersistence(); persistence.configure(ConfigParams.fromTuples( \u0026#34;host\u0026#34;, \u0026#34;localhost\u0026#34;, \u0026#34;port\u0026#34;, 27017 )); persitence.open(\u0026#34;123\u0026#34;, (err) =\u0026gt; { ... }); persistence.create(\u0026#34;123\u0026#34;, { id: \u0026#34;1\u0026#34;, name: \u0026#34;ABC\u0026#34; }, (err, item) =\u0026gt; { persistence.getPageByFilter( \u0026#34;123\u0026#34;, FilterParams.fromTuples(\u0026#34;name\u0026#34;, \u0026#34;ABC\u0026#34;), null, (err, page) =\u0026gt; { console.log(page.data); // Result: { id: \u0026#34;1\u0026#34;, name: \u0026#34;ABC\u0026#34; }  persistence.deleteById(\u0026#34;123\u0026#34;, \u0026#34;1\u0026#34;, (err, item) =\u0026gt; { ... }); } ) }); ","description":"\nAbstract persistence component that stores data in MySQL and implements a number of CRUD operations over data items with unique ids.\n","image":null,"permalink":"/node/mysql/persistence/identifiable_mysql_persistence/","subtitle":null,"tags":null,"title":"IdentifiableMySqlPersistence\u003cT extends IIdentifiable\u003cK\u003e, K\u003e"},{"content":"Implements: MySqlPersistence, IIdentifiable\nDescription The IdentifiableMySqlPersistence class allows you to create persistence components that store data in MySQL databases and implement a number of CRUD operations over data items with unique ids.\nImportant points\n The data items must implement the IIdentifiable interface. In basic scenarios, child classes shall only override get_page_by_filter, get_list_by_filter or delete_by_filter operations with the specific filter function. All other operations can be used out of the box. In complex scenarios child classes can implement additional operations by accessing the self._collection and self._model properties.  Configuration parameters  collection: (optional) MySQL collection name  connection(s):\n discovery_key: (optional) key to retrieve the connection from IDiscovery host: host name or IP address port: port number (default: 27017) uri: resource URI or connection string with all parameters in it  credential(s):\n store_key: (optional) key to retrieve the credentials from ICredentialStore username: (optional) username password: (optional) user\u0026rsquo;s password  options:\n connect_timeout: (optional) number of milliseconds to wait before timing out when connecting a new client (default: 0) idle_timeout: (optional) number of milliseconds a client must sit idle in the pool and not be checked out (default: 10000) max_pool_size: (optional) maximum number of clients the pool should contain (default: 10)  References  *:logger:*:*:1.0 - (optional) ILogger components to pass log messages *:discovery:*:*:1.0 - (optional) IDiscovery services *:credential-store:*:*:1.0 - (optional) Credential stores to resolve credentials (ICredentialStore)  Constructors Creates a new instance of the persistence component.\n IdentifiableMySqlPersistence(table_name: str = None)\n  table_name: str - (optional) collection name.  Instance methods _convert_from_public_partial Converts the given object from the public partial format.\n _convert_from_public_partial(value: Any): Any\n  value: Any - the object to convert from the public partial format. returns: Any - the initial object.  create Creates a data item.\n create(correlation_id: Optional[str], item: T): Optional[T]\n  correlation_id: Optional[str] - (optional) transaction id used to trace execution through the call chain. item: T - item to be created. returns: Optional[T] - created item  delete_by_id Deletes a data item by it\u0026rsquo;s unique id.\n delete_by_id(correlation_id: Optional[str], id: Any): T\n  correlation_id: Optional[str] - (optional) transaction id used to trace execution through the call chain. id: Any - id of the item to be deleted returns: T - deleted item  delete_by_ids Deletes multiple data items by their unique ids.\n delete_by_ids(correlation_id: Optional[str], ids: List[Any])\n  correlation_id: Optional[str] - (optional) transaction id used to trace execution through the call chain. ids: List[Any] - ids of the data items to be deleted.  get_list_by_ids Gets a list of data items retrieved by given unique ids.\n get_list_by_ids(correlation_id: Optional[str], ids: List[Any]): List[T]\n  correlation_id: Optional[str] - (optional) transaction id used to trace execution through the call chain. ids: List[Any] - ids of the data items to be retrieved returns: List[T] - data list  get_one_by_id Gets a data item by its unique id.\n get_one_by_id(correlation_id: Optional[str], id: Any): T\n  correlation_id: Optional[str] - (optional) transaction id used to trace execution through the call chain. id: Any - id of the data item to be retrieved. returns: T - data item  set Sets a data item. If the data item exists it updates it, otherwise it creates a new data item.\n set(correlation_id: Optional[str], item: T): Optional[T]\n  correlation_id: Optional[str] - (optional) transaction id used to trace execution through the call chain. item: T - item to be set. returns: Optional[T] - new or updated item  update Updates a data item.\n update(correlation_id: Optional[str], item: T): Optional[T]\n  correlation_id: Optional[str] - (optional) transaction id used to trace execution through the call chain. item: T - item to be updated. returns: Optional[T] - updated item  update_partially Updates only a few selected fields in a data item.\n update_partially(correlation_id: Optional[str], id: Any, data: AnyValueMap): Optional[T]\n  correlation_id: Optional[str] - (optional) transaction id used to trace execution through the call chain. id: Any - id of data item to be updated. data: AnyValueMap - map with fields to be updated. returns: Optional[T] - updated item  Examples class MyMySqlPersistence(IdentifiableMySqlPersistence): def __init__(self): super(MyMySqlPersistence, self).__init__(\u0026#34;mydata\u0026#34;, MyDataMySqlSchema()) def __compose_filter(self, filter): filter = filter or FilterParams() criteria = [] name = filter.get_as_nullable_string(\u0026#39;name\u0026#39;) if name: criteria.append({\u0026#39;name\u0026#39;: name}) return {\u0026#39;$and\u0026#39;: criteria} if len(criteria) \u0026gt; 0 else None def get_page_by_filter(self, correlation_id, filter, paging): return super().get_page_by_filter(correlation_id, self.__compose_filter(filter), paging, None, None) persistence = MyMySqlPersistence() persistence.configure(ConfigParams.from_tuples( \u0026#34;host\u0026#34;, \u0026#34;localhost\u0026#34;, \u0026#34;port\u0026#34;, 27017 )) persistence.open(\u0026#39;123\u0026#39;) persistence.create(\u0026#39;123\u0026#39;, {\u0026#39;id\u0026#39;: \u0026#34;1\u0026#34;, \u0026#39;name\u0026#39;: \u0026#34;ABC\u0026#34;}) page = persistence.get_page_by_filter(\u0026#39;123\u0026#39;, FilterParams.from_tuples(\u0026#39;name\u0026#39;, \u0026#39;ABC\u0026#39;), None) print(page.data) # Result: { id: \u0026#34;1\u0026#34;, name: \u0026#34;ABC\u0026#34; } persistence.delete_by_id(\u0026#34;123\u0026#34;, \u0026#34;1\u0026#34;) # ... ","description":"\nAbstract persistence component that stores data in MySQL and implements a number of CRUD operations over data items with unique ids.\n","image":null,"permalink":"/python/mysql/persistence/identifiable_mysql_persistence/","subtitle":null,"tags":null,"title":"IdentifiableMySqlPersistence"},{"content":"Implements: PostgresPersistence\nDescription The IdentifiablePostgresPersistence class allows you to create persistence components that store data in PostgreSQL databases and implement a number of CRUD operations over data items with unique ids.\nImportant points\n The data items must implement the IIdentifiable interface. In basic scenarios child classes shall only override the GetPageByFilter, GetListByFilter or DeleteByFilter operations with a specific filter function. All other operations can be used out of the box. In complex scenarios child classes can implement additional operations by accessing c.Db or c.Collection properties.  Configuration parameters  collection: (optional) Postgres collection name  connection(s):\n discovery_key: (optional) key to retrieve the connection from IDiscovery host: host name or IP address port: port number (default: 27017) uri: resource URI or connection string with all parameters in it  credential(s):\n store_key: (optional) key to retrieve the credentials from ICredentialStore username: (optional) username password: (optional) user\u0026rsquo;s password  options:\n connect_timeout: (optional) number of milliseconds to wait before timing out when connecting a new client (default: 0) idle_timeout: (optional) number of milliseconds a client must sit idle in the pool and not be checked out (default: 10000) max_pool_size: (optional) maximum number of clients the pool can contain (default: 10)  References  *:logger:*:*:1.0 - (optional) ILogger components to pass log messages *:discovery:*:*:1.0 - (optional) IDiscovery services *:credential-store:*:*:1.0 - (optional) credential stores to resolve credentials (ICredentialStore)  Constructors InheritIdentifiablePostgresPersistence Creates a new instance of the persistence component.\n InheritIdentifiablePostgresPersistence(overrides IPostgresPersistenceOverrides, proto reflect.Type, tableName string) *IdentifiablePostgresPersistence\n  overrides: IPostgresPersistenceOverrides - References to override virtual methods. proto: reflect.Type - TODO: add description. tableName: string - (optional) a collection name.  Methods Create Creates a data item.\n (c *IdentifiablePostgresPersistence) Create(correlationId string, item interface{}) (result interface{}, err error)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. item: interface{} - item to be created. returns: (result interface{}, err error) - created item  DeleteById Deletes a data item by it\u0026rsquo;s unique id.\n (c *IdentifiablePostgresPersistence) DeleteById(correlationId string, id interface{}) (result interface{}, err error)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. id: interface{} - id of the item to be deleted returns: (result interface{}, err error) - deleted item  DeleteByIds Deletes multiple data items by their unique ids.\n (c *IdentifiablePostgresPersistence) DeleteByIds(correlationId string, ids []interface{}) error\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. ids: []interface{} - ids of data items to be deleted. returns: error - returns error if not received.  GetListByIds Gets a list of data items retrieved by given unique ids.\n (c *IdentifiablePostgresPersistence) GetListByIds(correlationId string, ids []interface{}) (items []interface{}, err error)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. ids: []interface{} - ids of data items to be retrieved returns: (items []interface{}, err error) - data list  GetOneById Gets a data item by its unique id.\n (c *IdentifiablePostgresPersistence) GetOneById(correlationId string, id interface{}) (item interface{}, err error)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. id: interface{} - id of data item to be retrieved. returns: (item interface{}, err error) - data item  Set Sets a data item. If the data item exists it updates it. Otherwise, it creates a new data item.\n (c *IdentifiablePostgresPersistence) Set(correlationId string, item interface{}) (result interface{}, err error)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. item: interface{} - item to be set. returns: (result interface{}, err error) - updated item  Update Updates a data item.\n (c *IdentifiablePostgresPersistence) Update(correlationId string, item interface{}) (result interface{}, err error)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. item: interface{} - item to be updated. returns: (result interface{}, err error) - updated item  UpdatePartially Updates only a few selected fields in a data item.\n (c *IdentifiablePostgresPersistence) UpdatePartially(correlationId string, id interface{}, data *cdata.AnyValueMap) (result interface{}, err error)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. id: interface{} - id of the data item to be updated. data: *cdata.AnyValueMap - map with fields to be updated. returns: (result interface{}, err error)- updated item  Examples TODO: add example ","description":"Abstract persistence component that stores data in PostgreSQL and implements a number of CRUD operations over data items with unique ids.\n","image":null,"permalink":"/golang/postgres/persistence/identifiable_postgres_persistence/","subtitle":null,"tags":null,"title":"IdentifiablePostgresPersistence"},{"content":"Inherits: PostgresPersistence\nDescription The IdentifiablePostgresPersistence class allows you to create persistence components that store data in PostgreSQL databases and implement a number of CRUD operations over data items with unique ids.\nImportant points\nWhere T : IItifiable, new().\n The data items must implement the IIdentifiable interface. In basic scenarios child classes shall only override the getPageByFilter, getListByFilter or deleteByFilter operations with a specific filter function. All other operations can be used out of the box. In complex scenarios child classes can implement additional operations by accessing this._collection and this._model properties.  Configuration parameters  collection: (optional) Postgres collection name  connection(s):\n discovery_key: (optional) key to retrieve the connection from IDiscovery host: host name or IP address port: port number (default: 27017) uri: resource URI or connection string with all parameters in it  credential(s):\n store_key: (optional) key to retrieve the credentials from ICredentialStore username: (optional) username password: (optional) user\u0026rsquo;s password  options:\n max_pool_size: (optional) maximum connection pool size (default: 2) keep_alive: (optional) enable connection keep alive (default: true) connect_timeout: (optional) connection timeout in milliseconds (default: 5 sec) auto_reconnect: (optional) enable auto reconnection (default: true) max_page_size: (optional) maximum page size (default: 100) debug: (optional) enable debug output (default: false).  References  *:logger:*:*:1.0 - (optional) ILogger components to pass log messages *:discovery:*:*:1.0 - (optional) IDiscovery services *:credential-store:*:*:1.0 - (optional) credential stores to resolve credentials (ICredentialStore)  Constructors Creates a new instance of the persistence component.\n public IdentifiablePostgresPersistence(string tableName)\n  tableName: string - (optional) a collection name.  Fields _autoGenerateId Flag to turn on auto generation of object ids.\n protected _autoGenerateId: bool\n  Instance methods CreateAsync Creates a data item.\n public override Task\u0026lt;T\u0026gt; CreateAsync(string correlationId, T item)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. item: T - item to be created. returns: Task\u0026lt;T\u0026gt; - created item  DeleteByIdAsync Deletes a data item by it\u0026rsquo;s unique id.\n public virtual Task\u0026lt;T\u0026gt; DeleteByIdAsync(string correlationId, K id)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. id: K - id of the item to be deleted returns: Task\u0026lt;T\u0026gt; - deleted item  DeleteByIdsAsync Deletes multiple data items by their unique ids.\n public virtual Task DeleteByIdsAsync(string correlationId, K[] ids)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. ids: K[] - ids of data items to be deleted.  GetListByIdsAsync Gets a list of data items retrieved by given unique ids.\n public virtual Task\u0026lt;List\u0026lt;T\u0026gt;\u0026gt; GetListByIdsAsync(string correlationId, K[] ids)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. ids: K[] - ids of data items to be retrieved returns: Task\u0026lt;List\u0026lt;T\u0026gt;\u0026gt; - data list  GetOneByIdAsync Gets a data item by its unique id.\n public virtual Task\u0026lt;T\u0026gt; GetOneByIdAsync(string correlationId, K id)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. id: K - id of data item to be retrieved. returns: Task\u0026lt;T\u0026gt; - data item  SetAsync Sets a data item. If the data item exists it updates it. Otherwise, it creates a new data item.\n public virtual Task\u0026lt;T\u0026gt; SetAsync(string correlationId, T item)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. item: T - item to be set. returns: Task\u0026lt;T\u0026gt; - updated item  UpdateAsync Updates a data item.\n public virtual Task\u0026lt;T\u0026gt; UpdateAsync(string correlationId, T item)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. item: T - item to be updated. returns: Task\u0026lt;T\u0026gt; - updated item  UpdatePartially Updates only a few selected fields in a data item.\n public virtual Task\u0026lt;T\u0026gt; UpdatePartially(string correlationId, K id, AnyValueMap data)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. id: K - id of the data item to be updated. data: AnyValueMap - map with fields to be updated. returns: Task\u0026lt;T\u0026gt; - updated item  Examples class MyPostgresPersistence: PostgresPersistence\u0026lt;MyData, string\u0026gt; { public MyPostgresPersistence() { base(\u0026#34;mydata\u0026#34;, MyData.class); } private FilterDefinition\u0026lt;MyData\u0026gt; ComposeFilter(FilterParams filter) { filterParams = filterParams ?? new FilterParams(); var builder = Builders\u0026lt;BeaconV1\u0026gt;.Filter; var filter = builder.Empty; String name = filter.getAsNullableString(\u0026#39;name\u0026#39;); if (name != null) filter \u0026amp;= builder.Eq(b =\u0026gt; b.Name, name); return filter; } public Task\u0026lt;MyData\u0026gt; GetPageByFilter(String correlationId, FilterParams filter, PagingParams paging) { return await base.GetPageByFilter(correlationId, this.ComposeFilter(filter), paging, null, null); } } var persistence = new MyPostgresPersistence(); persistence.Configure(ConfigParams.FromTuples( \u0026#34;host\u0026#34;, \u0026#34;localhost\u0026#34;, \u0026#34;port\u0026#34;, 27017 ) ); persitence.Open(\u0026#34;123\u0026#34;); persistence.Create(\u0026#34;123\u0026#34;, new MyData(\u0026#34;1\u0026#34;, \u0026#34;ABC\u0026#34;)); var mydata = persistence.GetPageByFilter( \u0026#34;123\u0026#34;, FilterParams.FromTuples(\u0026#34;name\u0026#34;, \u0026#34;ABC\u0026#34;) ); Console.Out.WriteLine(mydata.Data); // Result: { id: \u0026#34;1\u0026#34;, name: \u0026#34;ABC\u0026#34; }  persistence.DeleteById(\u0026#34;123\u0026#34;, \u0026#34;1\u0026#34;); ","description":"Abstract persistence component that stores data in PostgreSQL and implements a number of CRUD operations over data items with unique ids.\n","image":null,"permalink":"/net/postgres/persistence/identifiable_postgres_persistence/","subtitle":null,"tags":null,"title":"IdentifiablePostgresPersistence\u003cT, K\u003e"},{"content":"Extends: PostgresPersistence\nDescription The IdentifiablePostgresPersistence class allows you to create persistence components that store data in PostgreSQL databases and implement a number of CRUD operations over data items with unique ids.\nImportant points\n The data items must implement the IIdentifiable interface. In basic scenarios child classes shall only override the getPageByFilter, getListByFilter or deleteByFilter operations with a specific filter function. All other operations can be used out of the box. In complex scenarios child classes can implement additional operations by accessing this._collection and this._model properties.  Configuration parameters  collection: (optional) Postgres collection name  connection(s):\n discovery_key: (optional) key to retrieve the connection from IDiscovery host: host name or IP address port: port number (default: 27017) uri: resource URI or connection string with all parameters in it  credential(s):\n store_key: (optional) key to retrieve the credentials from ICredentialStore username: (optional) username password: (optional) user\u0026rsquo;s password  options:\n connect_timeout: (optional) number of milliseconds to wait before timing out when connecting a new client (default: 0) idle_timeout: (optional) number of milliseconds a client must sit idle in the pool and not be checked out (default: 10000) max_pool_size: (optional) maximum number of clients the pool can contain (default: 10)  References  *:logger:*:*:1.0 - (optional) ILogger components to pass log messages *:discovery:*:*:1.0 - (optional) IDiscovery services *:credential-store:*:*:1.0 - (optional) credential stores to resolve credentials (ICredentialStore)  Constructors Creates a new instance of the persistence component.\n public constructor(tableName: string)\n  tableName: string - (optional) a collection name.  Instance methods convertFromPublicPartial Converts the given object from the public partial format.\n protected convertFromPublicPartial(value: any): any\n  value: any - the object to convert from the public partial format. returns: any - the initial object.  create Creates a data item.\n public create(correlationId: string, item: T): Promise\u0026lt;T\u0026gt;\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. item: any - item to be created. returns: Promise\u0026lt;T\u0026gt; - created item  deleteById Deletes a data item by it\u0026rsquo;s unique id.\n public deleteById(correlationId: string, id: K): Promise\u0026lt;T\u0026gt;\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. id: K - id of the item to be deleted returns: Promise\u0026lt;T\u0026gt; - deleted item  deleteByIds Deletes multiple data items by their unique ids.\n public deleteByIds(correlationId: string, ids: K[]): Promise\u0026lt;void\u0026gt;\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. ids: K[] - ids of data items to be deleted.  getListByIds Gets a list of data items retrieved by given unique ids.\n public getListByIds(correlationId: string, ids: K[]): Promise\u0026lt;T[]\u0026gt;\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. ids: K[] - ids of data items to be retrieved returns: Promise\u0026lt;T[]\u0026gt; - data list  getOneById Gets a data item by its unique id.\n public getOneById(correlationId: string, id: K): Promise\u0026lt;T\u0026gt;\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. id: K - id of data item to be retrieved. returns: Promise\u0026lt;T\u0026gt; - data item  set Sets a data item. If the data item exists it updates it. Otherwise, it creates a new data item.\n public set(correlationId: string, item: T): Promise\u0026lt;T\u0026gt;\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. item: T - item to be set. returns: Promise\u0026lt;T\u0026gt; - updated item  update Updates a data item.\n public update(correlationId: string, item: T): Promise\u0026lt;T\u0026gt;\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. item: T - item to be updated. returns: Promise\u0026lt;T\u0026gt; - updated item  updatePartially Updates only a few selected fields in a data item.\n updatePartially(correlationId: string, id: K, data: AnyValueMap): Promise\u0026lt;T\u0026gt;\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. id: K - id of the data item to be updated. data: AnyValueMap - map with fields to be updated. returns: Promise\u0026lt;T\u0026gt; - updated item  Examples class MyPostgresPersistence extends IdentifiablePostgresPersistence\u0026lt;MyData, string\u0026gt; { public constructor() { base(\u0026#34;mydata\u0026#34;, new MyDataPostgresSchema()); } private composeFilter(filter: FilterParams): any { filter = filter || new FilterParams(); let criteria = []; let name = filter.getAsNullableString(\u0026#39;name\u0026#39;); if (name != null) criteria.push({ name: name }); return criteria.length \u0026gt; 0 ? { $and: criteria } : null; } public getPageByFilter(correlationId: string, filter: FilterParams, paging: PagingParams): Promise\u0026lt;DataPage\u0026lt;MyData\u0026gt;\u0026gt; { return base.getPageByFilter(correlationId, this.composeFilter(filter), paging, null, null); } } let persistence = new MyPostgresPersistence(); persistence.configure(ConfigParams.fromTuples( \u0026#34;host\u0026#34;, \u0026#34;localhost\u0026#34;, \u0026#34;port\u0026#34;, 27017 )); await persitence.open(\u0026#34;123\u0026#34;); let item = await persistence.create(\u0026#34;123\u0026#34;, { id: \u0026#34;1\u0026#34;, name: \u0026#34;ABC\u0026#34; }); let page = await persistence.getPageByFilter( \u0026#34;123\u0026#34;, FilterParams.fromTuples(\u0026#34;name\u0026#34;, \u0026#34;ABC\u0026#34;), null ); console.log(page.data); // Result: { id: \u0026#34;1\u0026#34;, name: \u0026#34;ABC\u0026#34; } await persistence.deleteById(\u0026#34;123\u0026#34;, \u0026#34;1\u0026#34;); ","description":"Abstract persistence component that stores data in PostgreSQL and implements a number of CRUD operations over data items with unique ids.\n","image":null,"permalink":"/node/postgres/persistence/identifiable_postgres_persistence/","subtitle":null,"tags":null,"title":"IdentifiablePostgresPersistence\u003cT extends IIdentifiable\u003cK\u003e, K\u003e"},{"content":"Implements: PostgresPersistence, IIdentifiable\nDescription The IdentifiablePostgresPersistence class allows you to create persistence components that store data in PostgreSQL databases and implement a number of CRUD operations over data items with unique ids.\nImportant points\n The data items must implement the IIdentifiable interface. In basic scenarios child classes shall only override the get_page_by_filter, get_list_by_filter or delete_by_filter operations with a specific filter function. All other operations can be used out of the box. In complex scenarios child classes can implement additional operations by accessing self._collection and self._model properties.  Configuration parameters  collection: (optional) Postgres collection name  connection(s):\n discovery_key: (optional) key to retrieve the connection from IDiscovery host: host name or IP address port: port number (default: 27017) uri: resource URI or connection string with all parameters in it  credential(s):\n store_key: (optional) key to retrieve the credentials from ICredentialStore username: (optional) username password: (optional) user\u0026rsquo;s password  options:\n connect_timeout: (optional) number of milliseconds to wait before timing out when connecting a new client (default: 0) idle_timeout: (optional) number of milliseconds a client must sit idle in the pool and not be checked out (default: 10000) max_pool_size: (optional) maximum number of clients the pool can contain (default: 10)  References  *:logger:*:*:1.0 - (optional) ILogger components to pass log messages *:discovery:*:*:1.0 - (optional) IDiscovery services *:credential-store:*:*:1.0 - (optional) credential stores to resolve credentials (ICredentialStore)  Constructors Creates a new instance of the persistence component.\n IdentifiablePostgresPersistence(table_name: str = None)\n  table_name: str - (optional) a collection name.  Instance methods _convert_from_public_partial Converts the given object from the public partial format.\n _convert_from_public_partial(value: Any): Any\n  value: Any - the object to convert from the public partial format. returns: Any - the initial object.  create Creates a data item.\n create(correlation_id: Optional[str], item: T): Optional[T]\n  correlation_id: Optional[str] - (optional) transaction id used to trace execution through the call chain. item: T - item to be created. returns: Optional[T] - created item  delete_by_id Deletes a data item by it\u0026rsquo;s unique id.\n delete_by_id(correlation_id: Optional[str], id: Any): T\n  correlation_id: Optional[str] - (optional) transaction id used to trace execution through the call chain. id: Any - id of the item to be deleted returns: T - deleted item  delete_by_ids Deletes multiple data items by their unique ids.\n delete_by_ids(correlation_id: Optional[str], ids: List[Any])\n  correlation_id: Optional[str] - (optional) transaction id used to trace execution through the call chain. ids: List[Any] - ids of data items to be deleted.  get_list_by_ids Gets a list of data items retrieved by given unique ids.\n get_list_by_ids(correlation_id: Optional[str], ids: List[Any]): List[T]\n  correlation_id: Optional[str] - (optional) transaction id used to trace execution through the call chain. ids: List[Any] - ids of data items to be retrieved returns: List[T] - data list  get_one_by_id Gets a data item by its unique id.\n get_one_by_id(correlation_id: Optional[str], id: Any): T\n  correlation_id: Optional[str] - (optional) transaction id used to trace execution through the call chain. id: Any - id of data item to be retrieved. returns: T - data item  set Sets a data item. If the data item exists it updates it. Otherwise, it creates a new data item.\n set(correlation_id: Optional[str], item: T): Optional[T]\n  correlation_id: Optional[str] - (optional) transaction id used to trace execution through the call chain. item: T - item to be set. returns: Optional[T] - updated item  update Updates a data item.\n update(correlation_id: Optional[str], item: T): Optional[T]\n  correlation_id: Optional[str] - (optional) transaction id used to trace execution through the call chain. item: T - item to be updated. returns: Optional[T] - updated item  update_partially Updates only a few selected fields in a data item.\n update_partially(correlation_id: Optional[str], id: Any, data: AnyValueMap): Optional[T]\n  correlation_id: Optional[str] - (optional) transaction id used to trace execution through the call chain. id: Any - id of the data item to be updated. data: AnyValueMap - map with fields to be updated. returns: Optional[T] - updated item  Examples class MyPostgresPersistence(IdentifiablePostgresJsonPersistence): def __init__(self): super(MyPostgresPersistence, self).__init__(\u0026#39;mydata\u0026#39;, MyDataPostgresSchema()) def __compose_filter(self, filter): filter = filter or FilterParams() criteria = [] name = filter.get_as_nullable_string(\u0026#39;name\u0026#39;) if name is not None: criteria.append({\u0026#39;name\u0026#39;:name}) return { \u0026#39;$and\u0026#39;: criteria } if len(criteria) \u0026gt; 0 else None def get_page_by_filter(self, correlation_id, filter, paging): return super().get_page_by_filter(correlation_id, self.__compose_filter(filter), paging, None, None) persistence = MyPostgresPersistence() persistence.configure(ConfigParams.from_tuples( \u0026#34;host\u0026#34;, \u0026#34;localhost\u0026#34;, \u0026#34;port\u0026#34;, 27017 )) persistence.open(\u0026#34;123\u0026#34;) persistence.create(\u0026#34;123\u0026#34;, {\u0026#39;id\u0026#39;: \u0026#34;1\u0026#34;, \u0026#39;name\u0026#39;: \u0026#34;ABC\u0026#34;}) page = persistence.get_page_by_filter(\u0026#39;123\u0026#39;, FilterParams.from_tuples(\u0026#39;name\u0026#39;, \u0026#39;ABC\u0026#39;), None) print(page.data) # Result: { id: \u0026#34;1\u0026#34;, name: \u0026#34;ABC\u0026#34; } persistence.delete_by_id(\u0026#34;123\u0026#34;, \u0026#34;1\u0026#34;) # ... ","description":"Abstract persistence component that stores data in PostgreSQL and implements a number of CRUD operations over data items with unique ids.\n","image":null,"permalink":"/python/postgres/persistence/identifiable_postgres_persistence/","subtitle":null,"tags":null,"title":"IdentifiablePostgresPersistence"},{"content":"Inherits: SqlServerPersistence\nDescription The IdentifiableSqlServerPersistence class allows you to create persistence components that store data in SQLServer databases and implement a number of CRUD operations over data items with unique ids.\nImportant points\nWhere T : IIdentifiable, new(). Where K : class.\n The data items must implement the IIdentifiable interface. In basic scenarios child classes shall only override GetPageByFilterAsync, GetListByFilterAsync or DeleteByFilterAsync operations with a specific filter function. All other operations can be used out of the box. In complex scenarios child classes can implement additional operations by accessing this._collection and this._model properties.  Configuration parameters  collection: (optional) SQLServer collection name  connection(s):\n discovery_key: (optional) key to retrieve the connection from IDiscovery host: host name or IP address port: port number (default: 27017) uri: resource URI or connection string with all parameters in it  credential(s):\n store_key: (optional) key to retrieve the credentials from ICredentialStore username: (optional) username password: (optional) user\u0026rsquo;s password  options:\n max_pool_size: (optional) maximum connection pool size (default: 2) keep_alive: (optional) enable connection keep alive (default: true) connect_timeout: (optional) connection timeout in milliseconds (default: 5 sec) auto_reconnect: (optional) enable auto reconnection (default: true) max_page_size: (optional) maximum page size (default: 100) debug: (optional) enable debug output (default: false).  References  *:logger:*:*:1.0 - (optional) ILogger components to pass log messages *:discovery:*:*:1.0 - (optional) IDiscovery services *:credential-store:*:*:1.0 - (optional) Credential stores to resolve credentials (ICredentialStore)  Constructors Creates a new instance of the persistence component.\n public IdentifiableSqlServerPersistence(string tableName)\n  tableName: string - (optional) a collection name.  Instance methods CreateAsync Creates a data item.\n public override async Task\u0026lt;T\u0026gt; CreateAsync(string correlationId, T item)\n  correlationId: string - (optional) transaction id used to trace execution through a call chain. item: T - item to be created. returns: Task\u0026lt;T\u0026gt; - created item  DeleteByIdAsync Deleted a data item by it\u0026rsquo;s unique id.\n public virtual Task\u0026lt;T\u0026gt; DeleteByIdAsync(string correlationId, K id)\n  correlationId: string - (optional) transaction id used to trace execution through a call chain. id: K - id of the item to be deleted returns: Task\u0026lt;T\u0026gt; - deleted item  DeleteByIdsAsync Deletes multiple data items based on their unique ids.\n public virtual Task DeleteByIdsAsync(string correlationId, K[] ids)\n  correlationId: string - (optional) transaction id used to trace execution through a call chain. ids: K[] - ids of data items to be deleted.  GetListByIdsAsync Gets a list of data items retrieved based on given unique ids.\n public virtual Task\u0026lt;List\u0026lt;T\u0026gt;\u0026gt; GetListByIdsAsync(string correlationId, K[] ids)\n  correlationId: string - (optional) transaction id used to trace execution through a call chain. ids: K[] - ids of data items to be retrieved returns: Promise\u0026lt;\\T[]\u0026gt; - data list  GetOneByIdAsync Gets a data item by its unique id.\n public virtual Task\u0026lt;T\u0026gt; GetOneByIdAsync(string correlationId, K id)\n  correlationId: string - (optional) transaction id used to trace execution through a call chain. id: K - id of data item to be retrieved. returns: Task\u0026lt;T\u0026gt; - data item  SetAsync Sets a data item. If the data item exists it updates it, otherwise it creates a new data item.\n public virtual Task\u0026lt;T\u0026gt; SetAsync(string correlationId, T item)\n  correlationId: string - (optional) transaction id used to trace execution through a call chain. item: T - item to be set. returns: Task\u0026lt;T\u0026gt; - updated item  UpdateAsync Updates a data item.\n public virtual Task\u0026lt;T\u0026gt; UpdateAsync(string correlationId, T item)\n  correlationId: string - (optional) transaction id used to trace execution through a call chain. item: T - item to be updated. returns: Task\u0026lt;T\u0026gt; - updated item  UpdatePartially Updates only few selected fields in a data item.\n public virtual Task\u0026lt;T\u0026gt; UpdatePartially(string correlationId, K id, AnyValueMap data)\n  correlationId: string - (optional) transaction id used to trace execution through a call chain. id: K - id of data item to be updated. data: AnyValueMap - map with fields to be updated. returns: Task\u0026lt;T\u0026gt; - updated item  Examples class MySqlServerPersistence: SqlServerPersistence\u0026lt;MyData, string\u0026gt; { public constructor() { base(\u0026#34;mydata\u0026#34;, MyData.class); } ///  private FilterDefinition\u0026lt;MyData\u0026gt; ComposeFilter(FilterParams filter) { filterParams = filterParams ?? new FilterParams(); var builder = Builders\u0026lt;BeaconV1\u0026gt;.Filter; var filter = builder.Empty; String name = filter.getAsNullableString(\u0026#39;name\u0026#39;); if (name != null) filter \u0026amp;= builder.Eq(b =\u0026gt; b.Name, name); return filter; } public GetPageByFilter(String correlationId, FilterParams filter, PagingParams paging) { base.GetPageByFilter(correlationId, this.ComposeFilter(filter), paging, null, null); } } var persistence = new MySqlServerPersistence(); persistence.Configure(ConfigParams.fromTuples( \u0026#34;host\u0026#34;, \u0026#34;localhost\u0026#34;, \u0026#34;port\u0026#34;, 27017 )); persitence.Open(\u0026#34;123\u0026#34;); persistence.Create(\u0026#34;123\u0026#34;, new MyData(\u0026#34;1\u0026#34;, \u0026#34;ABC\u0026#34;)); var mydata = persistence.GetPageByFilter( \u0026#34;123\u0026#34;, FilterParams.FromTuples(\u0026#34;name\u0026#34;, \u0026#34;ABC\u0026#34;)); Console.Out.WriteLine(mydata.Data); // Result: { id: \u0026#34;1\u0026#34;, name: \u0026#34;ABC\u0026#34; }  persistence.DeleteById(\u0026#34;123\u0026#34;, \u0026#34;1\u0026#34;); ... ","description":"Abstract persistence component that stores data in SQLServer and implements a number of CRUD operations over data items with unique ids.\n","image":null,"permalink":"/net/sqlserver/persistence/identifiable_sqlserver_persistence/","subtitle":null,"tags":null,"title":"IdentifiableSqlServerPersistence\u003cT, K\u003e"},{"content":"Extends: SqlServerPersistence\nDescription The IdentifiableSqlServerPersistence class allows you to create persistence components that store data in SQLServer databases and implement a number of CRUD operations over data items with unique ids.\nImportant points\n The data items must implement the IIdentifiable interface. In basic scenarios child classes shall only override getPageByFilter, getListByFilter or deleteByFilter operations with a specific filter function. All other operations can be used out of the box. In complex scenarios child classes can implement additional operations by accessing this._collection and this._model properties.  Configuration parameters  collection: (optional) SQLServer collection name\nconnection(s): discovery_key: (optional) key to retrieve the connection from IDiscovery host: host name or IP address port: port number (default: 27017) uri: resource URI or connection string with all parameters in it\ncredential(s): store_key: (optional) key to retrieve the credentials from ICredentialStore username: (optional) username password: (optional) user\u0026rsquo;s password\noptions: connect_timeout: (optional) number of milliseconds to wait before timing out when connecting a new client (default: 0) idle_timeout: (optional) number of milliseconds a client must sit idle in the pool and not be checked out (default: 10000) max_pool_size: (optional) maximum number of clients the pool can contain (default: 10)  References  *:logger:*:*:1.0 - (optional) ILogger components to pass log messages *:discovery:*:*:1.0 - (optional) IDiscovery services *:credential-store:*:*:1.0 - (optional) Credential stores to resolve credentials (ICredentialStore)  Constructors Creates a new instance of the persistence component.\n public constructor(tableName: string)\n  tableName: string - (optional) a collection name.  Instance methods convertFromPublicPartial Converts the given object from the public partial format.\n protected convertFromPublicPartial(value: any): any\n  value: any - the object to convert from the public partial format. returns: any - the initial object.  create Creates a data item.\n public create(correlationId: string, item: T): Promise\u0026lt;T\u0026gt;\n  correlationId: string - (optional) transaction id used to trace execution through a call chain. item: T - item to be created. returns: Promise\u0026lt;T\u0026gt; - created item  deleteById Deleted a data item by it\u0026rsquo;s unique id.\n public deleteById(correlationId: string, id: K): Promise\u0026lt;T\u0026gt;\n  correlationId: string - (optional) transaction id used to trace execution through a call chain. id: K - id of the item to be deleted returns: Promise\u0026lt;T\u0026gt; - deleted item  deleteByIds Deletes multiple data items based on their unique ids.\n public deleteByIds(correlationId: string, ids: K[]): Promise\u0026lt;void\u0026gt;\n  correlationId: string - (optional) transaction id used to trace execution through a call chain. ids: K[] - ids of data items to be deleted.  getListByIds Gets a list of data items retrieved based on given unique ids.\n public getListByIds(correlationId: string, ids: K[]): Promise\u0026lt;\\T[]\u0026gt;\n  correlationId: string - (optional) transaction id used to trace execution through a call chain. ids: K[] - ids of data items to be retrieved returns: Promise\u0026lt;\\T[]\u0026gt; - data list  getOneById Gets a data item by its unique id.\n public getOneById(correlationId: string, id: K): Promise\u0026lt;T\u0026gt;\n  correlationId: string - (optional) transaction id used to trace execution through a call chain. id: K - id of data item to be retrieved. returns: Promise\u0026lt;T\u0026gt; - data item  set Sets a data item. If the data item exists it updates it, otherwise it creates a new data item.\n public set(correlationId: string, item: T): Promise\u0026lt;T\u0026gt;\n  correlationId: string - (optional) transaction id used to trace execution through a call chain. item: T - item to be set. returns: Promise\u0026lt;T\u0026gt; - updated item  update Updates a data item.\n public update(correlationId: string, item: T): Promise\u0026lt;T\u0026gt;\n  correlationId: string - (optional) transaction id used to trace execution through a call chain. item: T - item to be updated. returns: Promise\u0026lt;T\u0026gt; - updated item  updatePartially Updates only few selected fields in a data item.\n public updatePartially(correlationId: string, id: K, data: AnyValueMap): Promise\u0026lt;T\u0026gt;\n  correlationId: string - (optional) transaction id used to trace execution through a call chain. id: any - id of data item to be updated. data: AnyValueMap - map with fields to be updated. returns: Promise\u0026lt;T\u0026gt; - updated item  Examples class MySqlServerPersistence extends IdentifiableSqlServerPersistence\u0026lt;MyData, string\u0026gt; { public constructor() { base(\u0026#34;mydata\u0026#34;); } private composeFilter(filter: FilterParams): string { filter = filter || new FilterParams(); let criteria = []; let name = filter.getAsNullableString(\u0026#39;name\u0026#39;); if (name != null) criteria.push(\u0026#34;[name]=\u0026#39;\u0026#34; + name + \u0026#34;\u0026#39;\u0026#34;); return criteria.length \u0026gt; 0 ? criteria.join(\u0026#34; AND \u0026#34;) : null; } public getPageByFilter(correlationId: string, filter: FilterParams, paging: PagingParams): Promise\u0026lt;DataPage\u0026lt;MyData\u0026gt;\u0026gt; { return base.getPageByFilter(correlationId, this.composeFilter(filter), paging, null, null) } } let persistence = new MySqlServerPersistence(); persistence.configure(ConfigParams.fromTuples( \u0026#34;host\u0026#34;, \u0026#34;localhost\u0026#34;, \u0026#34;port\u0026#34;, 27017 )); await persitence.open(\u0026#34;123\u0026#34;); let item = await persistence.create(\u0026#34;123\u0026#34;, { id: \u0026#34;1\u0026#34;, name: \u0026#34;ABC\u0026#34; }); let page = await persistence.getPageByFilter( \u0026#34;123\u0026#34;, FilterParams.fromTuples(\u0026#34;name\u0026#34;, \u0026#34;ABC\u0026#34;), null ); console.log(page.data); // Result: { id: \u0026#34;1\u0026#34;, name: \u0026#34;ABC\u0026#34; } await persistence.deleteById(\u0026#34;123\u0026#34;, \u0026#34;1\u0026#34;); ","description":"Abstract persistence component that stores data in SQLServer and implements a number of CRUD operations over data items with unique ids.\n","image":null,"permalink":"/node/sqlserver/persistence/identifiable_sqlserver_persistence/","subtitle":null,"tags":null,"title":"IdentifiableSqlServerPersistence\u003cT extends IIdentifiable\u003cK\u003e, K\u003e"},{"content":"Implements: SqlServerPersistence, IIdentifiable\nDescription The IdentifiableSqlServerPersistence class allows you to create persistence components that store data in SQLServer databases and implement a number of CRUD operations over data items with unique ids.\nImportant points\n The data items must implement the IIdentifiable interface. In basic scenarios child classes shall only override get_page_by_filter, get_list_by_filter or delete_by_filter operations with a specific filter function. All other operations can be used out of the box. In complex scenarios child classes can implement additional operations by accessing self._collection and self._model properties.  Configuration parameters  collection: (optional) SQLServer collection name\nconnection(s): discovery_key: (optional) key to retrieve the connection from IDiscovery host: host name or IP address port: port number (default: 27017) uri: resource URI or connection string with all parameters in it\ncredential(s): store_key: (optional) key to retrieve the credentials from ICredentialStore username: (optional) username password: (optional) user\u0026rsquo;s password\noptions: connect_timeout: (optional) number of milliseconds to wait before timing out when connecting a new client (default: 0) idle_timeout: (optional) number of milliseconds a client must sit idle in the pool and not be checked out (default: 10000) max_pool_size: (optional) maximum number of clients the pool can contain (default: 10)  References  *:logger:*:*:1.0 - (optional) ILogger components to pass log messages *:discovery:*:*:1.0 - (optional) IDiscovery services *:credential-store:*:*:1.0 - (optional) Credential stores to resolve credentials (ICredentialStore)  Constructors Creates a new instance of the persistence component.\n IdentifiableSqlServerPersistence(table_name: str = None)\n  table_name: str - (optional) a collection name.  Instance methods _convert_from_public_partial Converts the given object from the public partial format.\n _convert_from_public_partial(value: Any): Any\n  value: Any - the object to convert from the public partial format. returns: Any - the initial object.  create Creates a data item.\n create(correlation_id: Optional[str], item: T): T\n  correlation_id: Optional[str] - (optional) transaction id used to trace execution through a call chain. item: T - item to be created. returns: T - created item  delete_by_id Deleted a data item by it\u0026rsquo;s unique id.\n delete_by_id(correlation_id: Optional[str], id: Any): T\n  correlation_id: Optional[str] - (optional) transaction id used to trace execution through a call chain. id: Any - id of the item to be deleted returns: T - deleted item  delete_by_ids Deletes multiple data items based on their unique ids.\n delete_by_ids(correlation_id: Optional[str], ids: List[Any])\n  correlation_id: Optional[str] - (optional) transaction id used to trace execution through a call chain. ids: List[Any] - ids of data items to be deleted.  get_list_by_ids Gets a list of data items retrieved based on given unique ids.\n get_list_by_ids(correlation_id: Optional[str], ids: List[Any]): List[T]\n  correlation_id: Optional[str] - (optional) transaction id used to trace execution through a call chain. ids: List[Any] - ids of data items to be retrieved returns: List[T] - data list  get_one_by_id Gets a data item by its unique id.\n get_one_by_id(correlation_id: Optional[str], id: Any): T\n  correlation_id: Optional[str] - (optional) transaction id used to trace execution through a call chain. id: Any - id of data item to be retrieved. returns: T - data item  set Sets a data item. If the data item exists it updates it, otherwise it creates a new data item.\n set(correlation_id: Optional[str], item: T): Optional[T]\n  correlation_id: Optional[str] - (optional) transaction id used to trace execution through a call chain. item: T - item to be set. returns: Optional[T] - updated item  update Updates a data item.\n update(correlation_id: Optional[str], item: T): Optional[T]\n  correlation_id: Optional[str] - (optional) transaction id used to trace execution through a call chain. item: T - item to be updated. returns: Optional[T] - updated item  update_partially Updates only few selected fields in a data item.\n update_partially(correlation_id: Optional[str], id: Any, data: AnyValueMap): Optional[T]\n  correlation_id: Optional[str] - (optional) transaction id used to trace execution through a call chain. id: Any - id of data item to be updated. data: AnyValueMap - map with fields to be updated. returns: Optional[T] - updated item  Examples class MySqlServerPersistence(IdentifiableSqlServerPersistence): def __init__(self): super(MySqlServerPersistence, self).__init__(\u0026#34;mydata\u0026#34;, MyDataSqlServerSchema()) def __compose_filter(self, filter): filter = filter or FilterParams() criteria = [] name = filter.get_as_nullable_string(\u0026#39;name\u0026#39;) if name: criteria.append({\u0026#39;name\u0026#39;: name}) return {\u0026#39;$and\u0026#39;: criteria} if len(criteria) \u0026gt; 0 else None def get_page_by_filter(self, correlation_id, filter, paging): return super().get_page_by_filter(correlation_id, self.__compose_filter(filter), paging, None, None) persistence = MySqlServerPersistence() persistence.configure(ConfigParams.from_tuples( \u0026#34;host\u0026#34;, \u0026#34;localhost\u0026#34;, \u0026#34;port\u0026#34;, 27017 )) persistence.open(\u0026#39;123\u0026#39;) persistence.create(\u0026#39;123\u0026#39;, {\u0026#39;id\u0026#39;: \u0026#34;1\u0026#34;, \u0026#39;name\u0026#39;: \u0026#34;ABC\u0026#34;}) page = persistence.get_page_by_filter(\u0026#39;123\u0026#39;, FilterParams.from_tuples(\u0026#39;name\u0026#39;, \u0026#39;ABC\u0026#39;), None) print(page.data) # Result: { id: \u0026#34;1\u0026#34;, name: \u0026#34;ABC\u0026#34; } persistence.delete_by_id(\u0026#34;123\u0026#34;, \u0026#34;1\u0026#34;) # ... ","description":"Abstract persistence component that stores data in SQLServer and implements a number of CRUD operations over data items with unique ids.\n","image":null,"permalink":"/python/sqlserver/persistence/identifiable_sqlserver_persistence/","subtitle":null,"tags":null,"title":"IdentifiableSqlServerPersistence"},{"content":"Description The IdGenerator class allows you to generate IDs for objects.\nImportant points\n It supports two types of IDs: short and long. ShortIDs are 9-digit random numbers. They are not guaranteed be unique. Long IDs are string GUIDs. They are globally unique and 32-character long.  Methods NextLong Generates a globally unique 32-digit object ID. The value is a string representation of a GUID value.\n (c *TIdGenerator) NextLong() string\n  returns: string - a generated 32-digit object ID  NextShort Generates a random 9-digit random ID (code).\nNote: The returned value is not guaranteed to be unique.\n (c *TIdGenerator) NextShort() string\n  returns: string - generated random 9-digit code  Examples IdGenerator.NextLong(); // Possible result: \u0026#34;234ab342c56a2b49c2ab42bf23ff991ac\u0026#34; IdGenerator.NextShort(); // Possible result: \u0026#34;23495247\u0026#34; ","description":"Helper class used to generate object IDs.\n","image":null,"permalink":"/golang/commons/data/id_generator/","subtitle":null,"tags":null,"title":"IdGenerator"},{"content":"Description The IdGenerator class allows you to generate IDs for objects.\nImportant points\n It supports two types of IDs: short and long. ShortIDs are 9-digit random numbers. They are not guaranteed be unique. Long IDs are string GUIDs. They are globally unique and 32-character long.  Static methods NextLong Generates a globally unique 32-digit object ID. The value is a string representation of a GUID value.\n public static string NextLong()\n  returns: string - generated 32-digit object ID  NextShort Generates a random 9-digit random ID (code).\nRemember: The returned value is not guaranteed to be unique.\n public static string NextShort()\n  returns: string - generated random 9-digit code  Examples IdGenerator.NextLong(); // Possible result: \u0026#34;234ab342c56a2b49c2ab42bf23ff991ac\u0026#34; IdGenerator.NextShort(); // Possible result: \u0026#34;23495247\u0026#34; ","description":"Helper class used to generate object IDs.\n","image":null,"permalink":"/net/commons/data/id_generator/","subtitle":null,"tags":null,"title":"IdGenerator"},{"content":"Description The IdGenerator class allows you to generate IDs for objects.\nImportant points\n It supports two types of IDs: short and long. ShortIDs are 9-digit random numbers. They are not guaranteed be unique. Long IDs are string GUIDs. They are globally unique and 32-character long.  Static methods nextLong Generates a globally unique 32-digit object ID. The value is a string representation of a GUID value.\n public static nextLong(): string\n  returns: string - generated 32-digit object ID  nextShort Generates a random 9-digit random ID (code).\nNote: The returned value is not guaranteed to be unique.\n public static nextShort(): string\n  returns: string - generated random 9-digit code  Examples IdGenerator.nextLong(); // Possible result: \u0026#34;234ab342c56a2b49c2ab42bf23ff991ac\u0026#34; IdGenerator.nextShort(); // Possible result: \u0026#34;23495247\u0026#34; ","description":"Helper class used to generate object IDs.\n","image":null,"permalink":"/node/commons/data/id_generator/","subtitle":null,"tags":null,"title":"IdGenerator"},{"content":"Description The IdGenerator class allows you to generate IDs for objects.\nImportant points\n It supports two types of IDs: short and long. ShortIDs are 9-digit random numbers. They are not guaranteed be unique. Long IDs are string GUIDs. They are globally unique and 32-character long.  Static methods next_long Generates a globally unique 32-digit object ID. The value is a string representation of a GUID value.\n static next_long(): str\n  returns: str - a generated 32-digit object ID  next_short Generates a random 9-digit random ID (code).\nRemember: The returned value is not guaranteed to be unique.\n static next_short(): str\n  returns: str - a generated random 9-digit code  Examples IdGenerator.next_long() # Possible result: \u0026#34;234ab342c56a2b49c2ab42bf23ff991ac\u0026#34; IdGenerator.next_short() # Possible result: \u0026#34;23495247\u0026#34; ","description":"Helper class used to generate object IDs.\n","image":null,"permalink":"/python/commons/data/id_generator/","subtitle":null,"tags":null,"title":"IdGenerator"},{"content":"Description The IDiscovery interface is used to create discovery services which are used to store and resolve connection parameters used to connect to external services.\nMethods Register Registers connection parameters into the discovery service.\n Register(correlationId string, key string, connection *ConnectionParams) (result *ConnectionParams, err error)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. key: string - key to uniquely identify the connection parameters. connection: *ConnectionParams - connection to be registered. returns: (result *ConnectionParams, err error) - registered connection parameters.  ResolveAll Resolves all connection parameters by their key.\n ResolveAll(correlationId string, key string) (result []*ConnectionParams, err error)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. key: string - key to uniquely identify the connections. returns: (result []*ConnectionParams, err error) - list with resolved connections.  ResolveOne Resolves a single connection parameters by its key.\n ResolveOne(correlationId string, key string) (result *ConnectionParams, err error)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. key: string - key used to uniquely identify the connection. returns: (result *ConnectionParams, err error) - resolved connection.  ","description":"Interface for discovery services which are used to store and resolve connection parameters to connect to external services.\n","image":null,"permalink":"/golang/components/connect/idiscovery/","subtitle":null,"tags":null,"title":"IDiscovery"},{"content":"Description The IDiscovery interface is used to create discovery services which are used to store and resolve connection parameters used to connect to external services.\nInstance methods RegisterAsync Registers connection parameters into the discovery service.\n Task\u0026lt;ConnectionParams\u0026gt; RegisterAsync(string correlationId, string key, ConnectionParams connection)\n  correlationId: string - (optional) transaction id to trace execution through call chain. key: string - a key to uniquely identify the connection parameters. connection: ConnectionParams - a connection to be registered. returns: Task\u0026lt;ConnectionParams\u0026gt; - the registered connection parameters.  ResolveAllAsync Resolves all connection parameters by their key.\n Task\u0026lt;List\u0026lt;ConnectionParams\u0026gt;\u0026gt; ResolveAllAsync(string correlationId, string key)\n  correlationId: string - (optional) transaction id to trace execution through call chain. key: string - a key to uniquely identify the connections. returns: Task\u0026lt;List\u0026lt;ConnectionParams\u0026gt;\u0026gt; - a list with resolved connections.  ResolveOneAsync Resolves a single connection parameters by its key.\n Task\u0026lt;ConnectionParams\u0026gt; ResolveOneAsync(string correlationId, string key)\n  correlationId: string - (optional) transaction id to trace execution through a call chain. key: string - a key to uniquely identify the connection. returns: Task\u0026lt;ConnectionParams\u0026gt; - a resolved connection.  ","description":"Interface for discovery services which are used to store and resolve connection parameters to connect to external services.\n","image":null,"permalink":"/net/components/connect/idiscovery/","subtitle":null,"tags":null,"title":"IDiscovery"},{"content":"Description The IDiscovery interface is used to create discovery services which are used to store and resolve connection parameters used to connect to external services.\nInstance methods register Registers connection parameters into the discovery service.\n register(correlationId: string, key: string, connection: ConnectionParams): Promise\u0026lt;ConnectionParams\u0026gt;\n  correlationId: string - (optional) transaction id to trace execution through call chain. key: string - a key to uniquely identify the connection parameters. connection: ConnectionParams - a connection to be registered. returns: Promise\u0026lt;ConnectionParams\u0026gt; - the registered connection parameters.  resolveAll Resolves all connection parameters by their key.\n resolveAll(correlationId: string, key: string): Promise\u0026lt;ConnectionParams[]\u0026gt;\n  correlationId: string - (optional) transaction id to trace execution through call chain. key: string - a key to uniquely identify the connections. returns: Promise\u0026lt;ConnectionParams[]\u0026gt; - a list with resolved connections.  resolveOne Resolves a single connection parameters by its key.\n resolveOne(correlationId: string, key: string): Promise\u0026lt;ConnectionParams\u0026gt;\n  correlationId: string - (optional) transaction id to trace execution through a call chain. key: string - a key to uniquely identify the connection. returns: Promise\u0026lt;ConnectionParams\u0026gt; - a resolved connection.  ","description":"Interface for discovery services which are used to store and resolve connection parameters to connect to external services.\n","image":null,"permalink":"/node/components/connect/idiscovery/","subtitle":null,"tags":null,"title":"IDiscovery"},{"content":"Description The IDiscovery interface is used to create discovery services which are used to store and resolve connection parameters used to connect to external services.\nInstance methods register Registers connection parameters into the discovery service.\n register(correlation_id: Optional[str], key: str, connection: ConnectionParams): ConnectionParams\n  correlation_id: Optional[str] - (optional) transaction id to trace execution through call chain. key: str - a key to uniquely identify the connection parameters. connection: ConnectionParams - a connection to be registered. returns: ConnectionParams - the registered connection parameters.  resolve_all Resolves all connection parameters by their key.\n resolve_all(correlation_id: Optional[str], key: str): List[ConnectionParams]\n  correlation_id: Optional[str] - (optional) transaction id to trace execution through call chain. key: str - a key to uniquely identify the connections. returns: List[ConnectionParams] - a list with resolved connections.  resolve_one Resolves a single connection parameters by its key.\n resolve_one(correlation_id: Optional[str], key: str): ConnectionParams\n  correlation_id: Optional[str] - (optional) transaction id to trace execution through a call chain. key: str - a key to uniquely identify the connection. returns: ConnectionParams - a resolved connection.  ","description":"Interface for discovery services which are used to store and resolve connection parameters to connect to external services.\n","image":null,"permalink":"/python/components/connect/idiscovery/","subtitle":null,"tags":null,"title":"IDiscovery"},{"content":"Description The IEquatable interface is used by those classes that need an equal method.\nMethods Equals Method used to compare two values. Returns true if these values are equal, and false otherwise.\n Equals(value interface{}) bool\n  value: interface{} - value to compare returns: bool - boolean result of the evaluation  ","description":"Interface for those classes that need an equal method.\n","image":null,"permalink":"/golang/commons/data/iequatable/","subtitle":null,"tags":null,"title":"IEquatable"},{"content":"Implements: INotifiable\nDescription The IEvent interface allows you to define events that can send asynchronous notifications to multiple subscribed listeners.\nMethods Name Gets the event\u0026rsquo;s name.\n Name() string\n  returns: string - name of the event.  getListeners Gets all subscribed listeners.\n Listeners() []IEventListener\n  returns: []IEventListener - list of listeners.  AddListener Adds a listener to receive notifications for this event.\n AddListener(listener IEventListener)\n  listener: IEventListener - listener reference to add.  RemoveListener Removes a listener, so that it no longer receives notifications for this event.\n RemoveListener(listener IEventListener)\n  listener: IEventListener - listener reference to remove.  See also   IEventListener   ","description":"An interface for Events that can send asynchronious notifications to multiple subscribed listeners.\n","image":null,"permalink":"/golang/commons/commands/ievent/","subtitle":null,"tags":null,"title":"IEvent"},{"content":"Inherits: INotifiable\nDescription The IEvent interface allows you to define events that can send asynchronous notifications to multiple subscribed listeners.\nProperties Name Gets the name of the event.\n public string Name { get; }\n Listeners Gets all listeners registered in this event.\n public List\u0026lt;IEventListener\u0026gt; Listeners { get; }\n Instance methods AddListener Adds a listener to receive notifications for this event.\n void AddListener(IEventListener listener)\n  listener: IEventListener - listener reference to add.  removeListener Removes a listener, so that it no longer receives notifications for this event.\n void RemoveListener(IEventListener listener)\n  listener: IEventListener - listener reference to remove.  See also   IEventListener   ","description":"An interface for Events that can send asynchronious notifications to multiple subscribed listeners.\n","image":null,"permalink":"/net/commons/commands/ievent/","subtitle":null,"tags":null,"title":"IEvent"},{"content":"Extends: INotifiable\nDescription The IEvent interface allows you to define events that can send asynchronous notifications to multiple subscribed listeners.\nInstance methods getName Gets the event name.\n getName(): string\n  returns: string - name of the event.  getListeners Gets all subscribed listeners.\n getListeners(): IEventListener[]\n  returns: IEventListener[] - list of listeners.  addListener Adds a listener to receive notifications for this event.\n addListener(listener: IEventListener): void\n  listener: IEventListener - listener reference to add.  removeListener Removes a listener, so that it no longer receives notifications for this event.\n removeListener(listener: IEventListener): void\n  listener: IEventListener - listener reference to remove.  See also   IEventListener   ","description":"An interface for Events that can send asynchronious notifications to multiple subscribed listeners.\n","image":null,"permalink":"/node/commons/commands/ievent/","subtitle":null,"tags":null,"title":"IEvent"},{"content":"Implements: INotifiable\nDescription The IEvent interface allows you to define events that can send asynchronous notifications to multiple subscribed listeners.\nInstance methods get_name Gets the event name.\n get_name(): str\n  returns: str - the name of the event.  get_listeners Gets all subscribed listeners.\n get_listeners(): List[IEventListener]\n  returns: List[IEventListener] - a list of listeners.  add_listener Adds a listener to receive notifications for this event.\n add_listener(listener: IEventListener)\n  listener: IEventListener - the listener reference to add.  remove_listener Removes a listener, so that it no longer receives notifications for this event.\n remove_listener(listener: IEventListener)\n  listener: IEventListener - the listener reference to remove.  See also   IEventListener   ","description":"An interface for Events that can send asynchronious notifications to multiple subscribed listeners.\n","image":null,"permalink":"/python/commons/commands/ievent/","subtitle":null,"tags":null,"title":"IEvent"},{"content":"Description The IEventListener interface allows you to define actions to be taken by listener objects after receiving a notification on a fired event.\nMethods OnEvent A method called when events this listener is subscrubed to are fired.\n OnEvent(correlationId string, e IEvent, value *run.Parameters)\n  correlationId: string - a fired evemt e: IEvent - (optional) transaction id to used trace execution through the call chain. value: *run.Parameters - event arguments.  Examples type MyListener { msg string; } func (l* MyListener) onEvent(correlationId string, event IEvent, args Parameters) { fmt.Println(\u0026#34;Fired event \u0026#34; + event.Name()); } let event = NewEvent(\u0026#34;myevent\u0026#34;); _listener := MyListener{}; event.addListener(_listener); event.notify(\u0026#34;123\u0026#34;, Parameters.FromTuples(\u0026#34;param1\u0026#34;, \u0026#34;ABC\u0026#34;)); // Console output: Fired event myevent  See also   IEvent   Event   ","description":"An interface for listener objects that receive notifications on fired events.\n","image":null,"permalink":"/golang/commons/commands/ievent_listener/","subtitle":null,"tags":null,"title":"IEventListener"},{"content":"Description The IEventListener interface allows you to define actions to be taken by listener objects after receiving a notification on a fired event.\nInstance methods OnEvent A method called when events this listener is subscrubed to are fired.\n void OnEvent(string correlationId, IEvent event, Parameters args)\n  correlationId: string - fired evemt event: IEvent - (optional) transaction id used to trace execution through the call chain. args: Parameters - event arguments.  Examples public class MyListener: IEventListener { private Task onEvent(String correlationId, IEvent event, Parameters args) { Console.WriteLine(\u0026#34;Fired event \u0026#34; + event.getName()); }} Event event = new Event(\u0026#34;myevent\u0026#34;); event.addListener(new MyListener()); event.notify(\u0026#34;123\u0026#34;, Parameters.fromTuples(\u0026#34;param1\u0026#34;, \u0026#34;ABC\u0026#34;)); // Console output: Fired event myevent  See also   IEvent   Event   ","description":"An interface for listener objects that receive notifications on fired events.\n","image":null,"permalink":"/net/commons/commands/ievent_listener/","subtitle":null,"tags":null,"title":"IEventListener"},{"content":"Description The IEventListener interface allows you to define actions to be taken by listener objects after receiving a notification on a fired event.\nInstance methods onEvent A method called when events this listener is subscribed to are fired.\n onEvent(correlationId: string, event: IEvent, args: Parameters): void\n  correlationId: string - fired evemt event: IEvent - (optional) transaction id used to trace execution through the call chain. args: Parameters - event arguments.  Examples export class MyListener implements IEventListener { private onEvent(correlationId: string, event: IEvent, args: Parameters): void { console.log(\u0026#34;Fired event \u0026#34; + event.getName()); } } let event = new Event(\u0026#34;myevent\u0026#34;); event.addListener(new MyListener()); event.notify(\u0026#34;123\u0026#34;, Parameters.fromTuples(\u0026#34;param1\u0026#34;, \u0026#34;ABC\u0026#34;)); // Console output: Fired event myevent  See also   IEvent   Event   ","description":"An interface for listener objects that receive notifications on fired events.\n","image":null,"permalink":"/node/commons/commands/ievent_listener/","subtitle":null,"tags":null,"title":"IEventListener"},{"content":"Description The IEventListener interface allows you to define actions to be taken by listener objects after receiving a notification on a fired event.\nInstance methods on_event A method called when events this listener is subscrubed to are fired.\n on_event(correlation_id: Optional[str], event: IEvent, args: Parameters)\n  correlation_id: Optional[str] - a fired evemt event: IEvent - (optional) transaction id to trace execution through call chain. args: Parameters - event arguments.  Examples class MyListener(IEventListener): def on_event(self, correlation_id, event_name, args): print \u0026#34;Fired event_name \u0026#34; + event_name.get_name() event = Event(\u0026#34;myevent\u0026#34;) event.addListener(MyListener()) event.notify(\u0026#34;123\u0026#34;, Parameters.from_tuples(\u0026#34;param1\u0026#34;, \u0026#34;ABC\u0026#34;)) See also   IEvent   Event   ","description":"An interface for listener objects that receive notifications on fired events.\n","image":null,"permalink":"/python/commons/commands/ievent_listener/","subtitle":null,"tags":null,"title":"IEventListener"},{"content":"Description The IExecutable interface allows you to create a component that can be called to execute work.\nMethods Execute Executes a component with arguments and receives the execution result.\n Execute(correlationId string, args *Parameters) (result interface{}, err error)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. args: *Parameters - execution arguments. returns: (result interface{}, err error) - execution result.  Examples type EchoComponent {} ... func (ec* EchoComponent) Execute(correlationId: string, args: Parameters) (result interface{}, err error) { return nil, result = args.getAsObject(\u0026#34;message\u0026#34;) } echo := EchoComponent{}; message = \u0026#34;Test\u0026#34;; res, err = echo.Execute(\u0026#34;123\u0026#34;, NewParametersFromTuples(\u0026#34;message\u0026#34;, message)); fmt.Println(res); See also   Executor   INotifiable   Parameters   ","description":"Interface that allows you to create a component that can be called to execute work.\n","image":null,"permalink":"/golang/commons/run/iexecutable/","subtitle":null,"tags":null,"title":"IExecutable"},{"content":"Description The IExecutable interface allows you to create a component that can be called to execute work.\nInstance methods ExecuteAsync Executes a component with arguments and receives an execution result.\n Task\u0026lt;object\u0026gt; ExecuteAsync(string correlationId, Parameters args)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. args: Parameters - execution arguments. returns: Task\u0026lt;object\u0026gt; - execution result.  Examples class EchoComponent: IExecutable { ... public void Execute(string correlationId, Parameters args) { var result = args.GetAsObject(\u0026#34;message\u0026#34;); } } var echo = new EchoComponent(); string message = \u0026#34;Test\u0026#34;; echo.Execute(\u0026#34;123\u0026#34;, Parameters.FromTuples(\u0026#34;message\u0026#34;, message)); See also   Executor   INotifiable   Parameters   ","description":"Interface that allows you to create a component that can be called to execute work.\n","image":null,"permalink":"/net/commons/run/iexecutable/","subtitle":null,"tags":null,"title":"IExecutable"},{"content":"Description The IExecutable interface allows you to create a component that can be called to execute work.\nInstance methods execute Executes a component with arguments and receives the execution result.\n execute(correlationId: string, args: Parameters): Promise\u0026lt;any\u0026gt;\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. args: Parameters - execution arguments. returns: Promise\u0026lt;any\u0026gt; - execution result.  Examples class EchoComponent implements IExecutable { ... public async execute(correlationId: string, args: Parameters): Promise\u0026lt;any\u0026gt; { let result = args.getAsObject(\u0026#34;message\u0026#34;); return result; } } let echo = new EchoComponent(); let message = \u0026#34;Test\u0026#34;; let result = await echo.execute(\u0026#34;123\u0026#34;, Parameters.fromTuples(\u0026#34;message\u0026#34;, message)) console.log(\u0026#34;Request: \u0026#34; + message + \u0026#34; Response: \u0026#34; + result); See also   Executor   INotifiable   Parameters   ","description":"Interface that allows you to create a component that can be called to execute work.\n","image":null,"permalink":"/node/commons/run/iexecutable/","subtitle":null,"tags":null,"title":"IExecutable"},{"content":"Description The IExecutable interface allows you to create a component that can be called to execute work.\nInstance methods execute Executes a component with arguments and receives the execution result.\n execute(correlationId: str, args: Parameters)\n  correlation_id: Optional[str] - (optional) transaction id to trace execution through call chain. args: Parameters - execution arguments.  Examples class EchoComponent(IExecutable): ... def execute(self, correlation_id: Optional[str], args: Parameters): result = args.get_as_object(\u0026#34;message\u0026#34;) return result echo = new EchoComponent() message = \u0026#34;Test\u0026#34;; result = echo.execute(\u0026#34;123\u0026#34;, Parameters.from_tuples(\u0026#34;message\u0026#34;, message)) print(\u0026#34;Request: \u0026#34; + message + \u0026#34; Response: \u0026#34; + result) See also   Executor   INotifiable   Parameters   ","description":"Interface that allows you to create a component that can be called to execute work.\n","image":null,"permalink":"/python/commons/run/iexecutable/","subtitle":null,"tags":null,"title":"IExecutable"},{"content":"Description The IFactory interface defines methods used by component factories to create components.\nImportant points\n Factories use locators to identify the components to be created. The locators are similar to those used to locate components in references. They can be of any type, like strings or integers. However the Pip.Services toolkit most often uses Descriptor objects as component locators.  Methods CanCreate Checks if this factory is able to create a component by given locator.\nThis method searches for all registered components and returns a locator for a component it is able to create that matches the given locator. If the factory is not able to create a requested component it returns nil.\n CanCreate(locator interface{}) interface{}\n  locator: interface{} - locator used to identify the component to be created. returns: interface{} - locator for the component that the factory is able to create.  Create Creates a component identified by given locator. Throws a CreateError if the factory is not able to create the component.\n Create(locator interface{}) (interface{}, error)\n  locator: interface{} - locator used to identify the component to be created. returns: (interface{}, error) - created component.  See also   Descriptor   IFactory   ","description":"Interface for component factories.\n","image":null,"permalink":"/golang/components/build/ifactory/","subtitle":null,"tags":null,"title":"IFactory"},{"content":"Description The IFactory interface defines methods used by component factories to create components.\nImportant points\n Factories use locators to identify components to be created. The locators are similar to those used to locate components in references. They can be of any type, like strings or integers. However the Pip.Services toolkit most often uses Descriptor objects as component locators.  Instance methods CanCreate Checks if this factory is able to create component by given locator.\nThis method searches for all registered components and returns a locator for component it is able to create that matches the given locator. If the factory is not able to create a requested component it returns null.\n object CanCreate(object locator)\n  locator: object - a locator to identify component to be created. returns: object - a locator for a component that the factory is able to create.  Create Creates a component identified by given locator. Throws a CreateException if the factory is not able to create the component.\n object Create(object locator)\n  locator: object - a locator to identify component to be created. returns: object - the created component.  See also   Descriptor   IFactory   ","description":"Interface for component factories.\n","image":null,"permalink":"/net/components/build/ifactory/","subtitle":null,"tags":null,"title":"IFactory"},{"content":"Description The IFactory interface defines methods used by component factories to create components.\nImportant points\n Factories use locators to identify components to be created. The locators are similar to those used to locate components in references. They can be of any type, like strings or integers. However the Pip.Services toolkit most often uses Descriptor objects as component locators.  Instance methods canCreate Checks if this factory is able to create component by given locator.\nThis method searches for all registered components and returns a locator for component it is able to create that matches the given locator. If the factory is not able to create a requested component it returns null.\n canCreate(locator: any): any\n  locator: any - a locator to identify component to be created. returns: any - a locator for a component that the factory is able to create.  create Creates a component identified by given locator. Throws a CreateException if the factory is not able to create the component.\n create(locator: any): any\n  locator: any - a locator to identify component to be created. returns: any - the created component.  See also   Descriptor   IFactory   ","description":"Interface for component factories.\n","image":null,"permalink":"/node/components/build/ifactory/","subtitle":null,"tags":null,"title":"IFactory"},{"content":"Description The IFactory interface defines methods used by component factories to create components.\nImportant points\n Factories use locators to identify components to be created. The locators are similar to those used to locate components in references. They can be of any type, like strings or integers. However the Pip.Services toolkit most often uses Descriptor objects as component locators.  Instance methods can_create Checks if this factory is able to create component by given locator.\nThis method searches for all registered components and returns a locator for component it is able to create that matches the given locator. If the factory is not able to create a requested component it returns None.\n can_create(locator: Any): Any\n  locator: Any - a locator to identify component to be created. returns: Any - a locator for a component that the factory is able to create.  create Creates a component identified by given locator. Throws a CreateException if the factory is not able to create the component.\n create(locator: Any): Any\n  locator: Any - a locator to identify component to be created. returns: Any - the created component.  See also   Descriptor   IFactory   ","description":"Interface for component factories.\n","image":null,"permalink":"/python/components/build/ifactory/","subtitle":null,"tags":null,"title":"IFactory"},{"content":"Description The IFilteredPageReader interface is used by data processing components that can retrieve a page of data items through the use of a filter.\nMethods getPageByFilter Gets a page of data items using filter parameters.\n GetPageByFilter(correlation_id string, filter *data.FilterParams, paging *data.PagingParams, sort *data.SortParams) (page interface{}, err error)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. filter: *data.FilterParams - (optional) filter parameters paging: *data.PagingParams - (optional) paging parameters sort: *data.SortParams - (optional) sort parameters returns: (page interface{}, err error) - list of items  ","description":"Interface for data processing components that can retrieve a page of data items by a filter.\n","image":null,"permalink":"/golang/data/persistence/ifiltered_page_reader/","subtitle":null,"tags":null,"title":"IFilteredPageReader"},{"content":"Description Where T : class.\nThe IFilteredPageReader interface is used by data processing components that can retrieve a page of data items through the use of a filter.\nInstance methods GetPageByFilterAsync Gets a page of data items using filter parameters.\n Task\u0026lt;DataPage\u0026lt;T\u0026gt;\u0026gt; GetPageByFilterAsync(string correlationId, FilterParams filter, PagingParams paging, SortParams sort)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. filter: FilterParams - (optional) filter parameters paging: PagingParams - (optional) paging parameters sort: SortParams - (optional) sort parameters returns: Task\u0026lt;DataPage\u0026lt;T\u0026gt;\u0026gt; - list of items  ","description":"Interface for data processing components that can retrieve a page of data items by a filter.\n","image":null,"permalink":"/net/data/core/ifiltered_page_reader/","subtitle":null,"tags":null,"title":"IFilteredPageReader\u003cT\u003e"},{"content":"Description The IFilteredPageReader interface is used by data processing components that can retrieve a page of data items through the use of a filter.\nInstance methods getPageByFilter Gets a page of data items using filter parameters.\n getPageByFilter(correlationId: string, filter: FilterParams, paging: PagingParams, sort: SortParams): Promise\u0026lt;DataPage\u0026lt;T\u0026gt;\u0026gt;\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. filter: FilterParams - (optional) filter parameters paging: PagingParams - (optional) paging parameters sort: SortParams - (optional) sort parameters returns: Promise\u0026lt;DataPage\u0026lt;T\u0026gt;\u0026gt; - list of items  ","description":"Interface for data processing components that can retrieve a page of data items by a filter.\n","image":null,"permalink":"/node/data/core/ifiltered_page_reader/","subtitle":null,"tags":null,"title":"IFilteredPageReader\u003cT\u003e"},{"content":"Description The IFilteredPageReader interface is used by data processing components that can retrieve a page of data items through the use of a filter.\nInstance methods get_page_by_filter Gets a page of data items using filter parameters.\n get_page_by_filter(correlation_id: Optional[str], filter: Optional[FilterParams], paging: Optional[PagingParams], sort: Optional[SortParams] = None): DataPage\n  correlation_id: Optional[str] - (optional) transaction id used to trace execution through the call chain. filter: Optional[FilterParams] - (optional) filter parameters paging: Optional[PagingParams] - (optional) paging parameters sort: Optional[SortParams] - (optional) sort parameters returns: DataPage - list of items  ","description":"Interface for data processing components that can retrieve a page of data items by a filter.\n","image":null,"permalink":"/python/data/core/ifiltered_page_reader/","subtitle":null,"tags":null,"title":"IFilteredPageReader"},{"content":"Description The IFilteredReader interface is used by data processing components that can retrieve a list of data items through the use of a filter.\nMethods GetListByFilter Gets a list of data items using filter parameters.\n GetListByFilter(correlation_id string, filter *data.FilterParams, sort *data.SortParams) (items []interface{}, err error)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. filter: *data.FilterParams - (optional) filter parameters sort: *data.SortParams - (optional) sort parameters returns: (items []interface{}, err error) - list of items  ","description":"Interface for data processing components that can retrieve a list of data items through the use of a filter.\n","image":null,"permalink":"/golang/data/persistence/ifiltered_reader/","subtitle":null,"tags":null,"title":"IFilteredReader"},{"content":"Description The IFilteredReader interface is used by data processing components that can retrieve a list of data items through the use of a filter.\nInstance methods Where T : class.\nGetListByFilterAsync Gets a list of data items using filter parameters.\n Task\u0026lt;List\u0026lt;T\u0026gt;\u0026gt; GetListByFilterAsync(string correlationId, FilterParams filter, SortParams sort)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. filter: FilterParams - (optional) filter parameters sort: SortParams - (optional) sort parameters returns: Task\u0026lt;List\u0026lt;T\u0026gt;\u0026gt; - list of items  ","description":"Interface for data processing components that can retrieve a list of data items through the use of a filter.\n","image":null,"permalink":"/net/data/core/ifiltered_reader/","subtitle":null,"tags":null,"title":"IFilteredReader\u003cT\u003e"},{"content":"Description The IFilteredReader interface is used by data processing components that can retrieve a list of data items through the use of a filter.\nInstance methods getListByFilter Gets a list of data items using filter parameters.\n getListByFilter(correlationId: string, filter: FilterParams, paging: PagingParams, sort: SortParams): DataPage\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. filter: FilterParams - (optional) filter parameters sort: SortParams - (optional) sort parameters returns: Promise\u0026lt;T[]\u0026gt; - list of items  ","description":"Interface for data processing components that can retrieve a list of data items through the use of a filter.\n","image":null,"permalink":"/node/data/core/ifiltered_reader/","subtitle":null,"tags":null,"title":"IFilteredReader\u003cT\u003e"},{"content":"Description The IFilteredReader interface is used by data processing components that can retrieve a list of data items through the use of a filter.\nInstance methods get_list_by_filter Gets a list of data items using filter parameters.\n get_list_by_filter(correlation_id: Optional[str], filter: Optional[FilterParams], paging: Optional[PagingParams], sort: Optional[SortParams] = None): DataPage\n  correlation_id: Optional[str] - (optional) transaction id used to trace execution through the call chain. filter: Optional[FilterParams] - (optional) filter parameters sort: Optional[SortParams] - (optional) sort parameters returns: List[T] - list of items  ","description":"Interface for data processing components that can retrieve a list of data items through the use of a filter.\n","image":null,"permalink":"/python/data/core/ifiltered_reader/","subtitle":null,"tags":null,"title":"IFilteredReader"},{"content":"Description The IFunction is an interface for expression functions.\nProperties name Function\u0026rsquo;s name.\n name(): string\n  retuns: string - function\u0026rsquo;s name.  Instance methods calculate Function calculation method.\n calculate(params: Variant[], variantOperations: IVariantOperations): Promise\u0026lt;Variant\u0026gt;\n  params: Variant[] - array with function parameters. variantOperations: IVariantOperations - variants operations manager. returns: Promise\u0026lt;Variant\u0026gt; - returned function\u0026rsquo;s result.  ","description":"An interface for expression functions.\n","image":null,"permalink":"/node/expressions/calculator/functions/ifunction/","subtitle":null,"tags":null,"title":"IFunction"},{"content":"Description TODO: add description\nProperties length Gets a number of functions stored in the collection.\n length(): number\n  retuns: number - a number of stored functions.  Instance methods add Adds a new function to the collection.\n add(func: IFunction): void\n  func: IFunction - an array with function parameters.  clear Clears the collection.\n clear(): void\n findByName Finds function in the list by it\u0026rsquo;s name.\n findByName(name: string): IFunction\n  name: string - The function name to be found. returns: IFunction - A function or null if function was not found.  findIndexByName Finds function index in the list by it\u0026rsquo;s name.\n findIndexByName(name: string): number\n  name: string - The function name to be found. returns: number - Function index in the list or -1 if function was not found.  get Get a function by its index.\n get(index: number): IFunction\n  index: number - a function index. returns: IFunction - a retrieved function.  getAll Get all functions stores in the collection\n getAll(): IFunction[]\n  returns: IFunction[] - a list with functions.  remove Removes a function by its index.\n remove(index: number): void\n  index: number - a index of the function to be removed.  removeByName  removeByName(name: string): void\n  name: string -The function name to be removed.  ","description":"Implements a functions list.\n","image":null,"permalink":"/node/expressions/calculator/functions/ifunction_collection/","subtitle":null,"tags":null,"title":"IFunctionCollection"},{"content":"Description The IGetter interface is used by data processing components that are capable of getting data items.\nMethods GetOneById Gets a data item by its unique id.\n GetOneById(correlation_id string, id interface{}) (item interface{}, err error)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. id: interface{} - id of the item to be retrieved. returns: (item interface{}, err error) - returned item.  ","description":"Interface for data processing components that can get data items.\n","image":null,"permalink":"/golang/data/persistence/igetter/","subtitle":null,"tags":null,"title":"IGetter"},{"content":"Description where T : IIdentifiable\u0026lt;K\u0026gt;\nThe IGetter interface is used by data processing components that are capable of getting data items.\nInstance methods GetOneByIdAsync Gets a data item by its unique id.\n Task\u0026lt;T\u0026gt; GetOneByIdAsync(string correlationId, K id)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. id: K - id of the item to be retrieved. returns: Task\u0026lt;T\u0026gt; - returned item.  ","description":"Interface for data processing components that can get data items.\n","image":null,"permalink":"/net/data/core/igetter/","subtitle":null,"tags":null,"title":"IGetter\u003cT, in K\u003e"},{"content":"Description The IGetter interface is used by data processing components that are capable of getting data items.\nInstance methods getOneById Gets a data item by its unique id.\n getOneById(correlationId: string, id: K): Promise\u0026lt;T\u0026gt;\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. id: K - id of the item to be retrieved. returns: Promise\u0026lt;T\u0026gt; - returned item.  ","description":"Interface for data processing components that can get data items.\n","image":null,"permalink":"/node/data/core/igetter/","subtitle":null,"tags":null,"title":"IGetter\u003cT extends IIdentifiable\u003cK\u003e, K\u003e"},{"content":"Implements: IIdentifiable\nDescription The IGetter interface is used by data processing components that are capable of getting data items.\nInstance methods get_one_by_id Gets a data item by its unique id.\n get_one_by_id(correlation_id: Optional[str], id: Any): T\n  correlation_id: Optional[str] - (optional) transaction id used to trace execution through the call chain. id: Any - id of the item to be retrieved. returns: T - returned item.  ","description":"Interface for data processing components that can get data items.\n","image":null,"permalink":"/python/data/core/igetter/","subtitle":null,"tags":null,"title":"IGetter"},{"content":"Description The IIdentifiable interface is used to create data objects that can be uniquely idendified by an ID.\nImportant points\n The type specified in the interface defines the type of the ID field.  Properties Id The unique object identifier of type K.\n T Id { get; set; }\n Examples public class MyData: IIdentifiable\u0026lt;String\u0026gt; { string id {get; set;} string field1; int field2; ... } ","description":"Interface used to create data objects that can be uniquely idendified by an ID.\n","image":null,"permalink":"/net/commons/data/iidentifiable/","subtitle":null,"tags":null,"title":"IIdentifiable\u003cK\u003e"},{"content":"Description The IIdentifiable interface is used to create data objects that can be uniquely idendified by an ID.\nImportant points\n The type specified in the interface defines the type of the ID field.  Fields id Unique object identifier of type K.\n id: K\n Examples export class MyData implements IIdentifiable\u0026lt;string\u0026gt; { public id: string; public field1: string; public field2: number; ... }  ","description":"Interface used to create data objects that can be uniquely idendified by an ID.\n","image":null,"permalink":"/node/commons/data/iidentifiable/","subtitle":null,"tags":null,"title":"IIdentifiable\u003cK\u003e"},{"content":"Description The IIdentifiable interface is used to create data objects that can be uniquely idendified by an ID.\nImportant points\n The type specified in the interface defines the type of the ID field.  Fields id The unique object identifier of type K.\n id: K\n Examples class MyData(IIdentifiable): id = None  ","description":"Interface used to create data objects that can be uniquely idendified by an ID.\n","image":null,"permalink":"/python/commons/data/iidentifiable/","subtitle":null,"tags":null,"title":"IIdentifiable"},{"content":"Description The IIdentifiable interface is used to create data objects that can be uniquely idendified by an ID.\nImportant points\n The type specified in the interface defines the type of the ID field.  Fields id The unique object identifier.\nExamples type MyData struct { Id int32 `json:\u0026#34;id\u0026#34;` Field1 string `json:\u0026#34;field1\u0026#34;` Field2 int32 `json:\u0026#34;field2\u0026#34;` ... }  ","description":"Interface used to create data objects that can be uniquely idendified by an ID.\n","image":null,"permalink":"/golang/commons/data/iidentifiable/","subtitle":null,"tags":null,"title":"IIdentifiable!"},{"content":"Description TODO: add description\nInstance methods Initialize TODO: add description\n void Initialize(IApplicationBuilder applicationBuilder)\n  applicationBuilder: IApplicationBuilder - TODO: add description  ","description":"TODO: add description\n","image":null,"permalink":"/net/rpc/services/iinitializable/","subtitle":null,"tags":null,"title":"IInitializable"},{"content":"Description The ILambdaService interface that allows to integrate lambda services into lambda function containers and connect their actions to the function calls.\nInstance methods getActions Gets all actions supported by the service.\n getActions(): LambdaAction[]\n  returns: LambdaAction[] - array with supported actions.  ","description":"An interface that allows to integrate lambda services into lambda function containers and connect their actions to the function calls.\n","image":null,"permalink":"/node/aws/services/ilambda_service/","subtitle":null,"tags":null,"title":"ILambdaService"},{"content":"Description The ILoader interface is used by data processing components that load data items.\nMethods Load Loads data items.\n Load(correlation_id string) (items []interface{}, err error)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. returns: (items []interface{}, err error) - list of data items  ","description":"Interface for data processing components that load data items.\n","image":null,"permalink":"/golang/data/persistence/iloader/","subtitle":null,"tags":null,"title":"ILoader"},{"content":"Description The ILoader interface is used by data processing components that load data items.\nInstance methods LoadAsync Loads data items.\n Task\u0026lt;List\u0026lt;T\u0026gt;\u0026gt; LoadAsync(string correlationId)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. returns: Task\u0026lt;List\u0026lt;T\u0026gt;\u0026gt; - list of data items  ","description":"Interface for data processing components that load data items.\n","image":null,"permalink":"/net/data/core/iloader/","subtitle":null,"tags":null,"title":"ILoader\u003cT\u003e"},{"content":"Description The ILoader interface is used by data processing components that load data items.\nInstance methods load Loads data items.\n load(correlationId: string): Promise\u0026lt;T[]\u0026gt;\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. returns: Promise\u0026lt;T[]\u0026gt; - list of data items  ","description":"Interface for data processing components that load data items.\n","image":null,"permalink":"/node/data/core/iloader/","subtitle":null,"tags":null,"title":"ILoader\u003cT\u003e"},{"content":"Description The ILoader interface is used by data processing components that load data items.\nInstance methods load Loads data items.\n load(correlation_id: Optional[str]): List[T]\n  correlation_id: Optional[str] - (optional) transaction id used to trace execution through the call chain. returns: List[T] - list of data items  ","description":"Interface for data processing components that load data items.\n","image":null,"permalink":"/python/data/core/iloader/","subtitle":null,"tags":null,"title":"ILoader"},{"content":"Description The ILock interface provides the methods to create locks used to synchronize work or parallel processes and to prevent collisions.\nImportant points\n The interface allows to manage multiple locks identified by unique keys.  Methods AcquireLock Makes a single attempt to acquire a lock by its key. It returns immediately a positive or negative result.\n AcquireLock(correlationId string, key string, ttl int64, timeout int64) error\n  correlationId: string -(optional) transaction id used to trace execution through the call chain. key: string - unique lock key to acquire. ttl: int64 - lock timeout (time to live) in milliseconds. timeout: int64 - lock acquisition timeout. returns: error - returns error if not acquired  TryAcquireLock Makes a single attempt to acquire a lock by its key. It returns immediately a positive or negative result.\n TryAcquireLock(correlationId string, key string, ttl int64) (bool, error)\n  correlationId: string -(optional) transaction id used to trace execution through the call chain. key: string - unique lock key to acquire. ttl: int64 - lock timeout (time to live) in milliseconds. return: (bool, error) - lock result  ReleaseLock Releases prevously acquired lock by its key.\n ReleaseLock(correlationId string, key string) error\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. key: string - unique lock key to release. returns: error - returns error if not released  ","description":"Interface for locks used to synchronize work or parallel processes and to prevent collisions.\n","image":null,"permalink":"/golang/components/lock/ilock/","subtitle":null,"tags":null,"title":"ILock"},{"content":"Description The ILock interface provides the methods to create locks used to synchronize work or parallel processes and to prevent collisions.\nImportant points\n The interface allows to manage multiple locks identified by unique keys.  Instance methods AcquireLock Makes a single attempt to acquire a lock by its key. It returns immediately a positive or negative result.\n void AcquireLock(string correlationId, string key, long ttl, long timeout)\n  correlationId: string -(optional) transaction id to trace execution through a call chain. key: string - a unique lock key to acquire. ttl: long - a lock timeout (time to live) in milliseconds. timeout: long - a lock acquisition timeout.  TryAcquireLock Makes a single attempt to acquire a lock by its key. It returns immediately a positive or negative result.\n bool TryAcquireLock(string correlationId, string key, long ttl)\n  correlationId: string -(optional) transaction id to trace execution through call chain. key: string - a unique lock key to acquire. ttl: long - a lock timeout (time to live) in milliseconds. return: bool - lock result  ReleaseLock Releases prevously acquired lock by its key.\n void ReleaseLock(string correlationId, string key)\n  correlationId: string - (optional) transaction id to trace execution through call chain. key: string - a unique lock key to release.  ","description":"Interface for locks used to synchronize work or parallel processes and to prevent collisions.\n","image":null,"permalink":"/net/components/lock/ilock/","subtitle":null,"tags":null,"title":"ILock"},{"content":"Description The ILock interface provides the methods to create locks used to synchronize work or parallel processes and to prevent collisions.\nImportant points\n The interface allows to manage multiple locks identified by unique keys.  Instance methods acquireLock Makes a single attempt to acquire a lock by its key. It returns immediately a positive or negative result.\n acquireLock(correlationId: string, key: string, ttl: number, timeout: number): Promise\u0026lt;void\u0026gt;\n  correlationId: string -(optional) transaction id to trace execution through a call chain. key: string - a unique lock key to acquire. ttl: number - a lock timeout (time to live) in milliseconds. timeout: number - a lock acquisition timeout.  tryAcquireLock Makes a single attempt to acquire a lock by its key. It returns immediately a positive or negative result.\n tryAcquireLock(correlationId: string, key: string, ttl: number): Promise\u0026lt;boolean\u0026gt;\n  correlationId: string -(optional) transaction id to trace execution through call chain. key: string - a unique lock key to acquire. ttl: number - a lock timeout (time to live) in milliseconds. return: Promise\u0026lt;boolean\u0026gt; - lock result  releaseLock Releases prevously acquired lock by its key.\n releaseLock(correlationId: string, key: string) :Promise\u0026lt;void\u0026gt;\n  correlationId: string - (optional) transaction id to trace execution through call chain. key: string - a unique lock key to release.  ","description":"Interface for locks used to synchronize work or parallel processes and to prevent collisions.\n","image":null,"permalink":"/node/components/lock/ilock/","subtitle":null,"tags":null,"title":"ILock"},{"content":"Description The ILock interface provides the methods to create locks used to synchronize work or parallel processes and to prevent collisions.\nImportant points\n The interface allows to manage multiple locks identified by unique keys.  Instance methods acquire_lock Makes a single attempt to acquire a lock by its key. It returns immediately a positive or negative result.\n acquire_lock(correlation_id: Optional[str], key: str, ttl: float, timeout: float)\n  correlation_id: Optional[str] -(optional) transaction id to trace execution through a call chain. key: str - a unique lock key to acquire. ttl: float - a lock timeout (time to live) in milliseconds. timeout: float - a lock acquisition timeout.  try_acquire_lock Makes a single attempt to acquire a lock by its key. It returns immediately a positive or negative result.\n try_acquire_lock(correlation_id: Optional[str], key: str, ttl: float): bool\n  correlation_id: Optional[str] -(optional) transaction id to trace execution through call chain. key: str - a unique lock key to acquire. ttl: float - a lock timeout (time to live) in milliseconds. return: bool - lock result  release_lock Releases prevously acquired lock by its key.\n release_lock(correlation_id: Optional[str], key: str)\n  correlation_id: Optional[str] - (optional) transaction id to trace execution through call chain. key: str - a unique lock key to release.  ","description":"Interface for locks used to synchronize work or parallel processes and to prevent collisions.\n","image":null,"permalink":"/python/components/lock/ilock/","subtitle":null,"tags":null,"title":"ILock"},{"content":"Description The ILogger interface provides a set of methods for logger components that capture log messages.\nMethods Debug Logs high-level debug information for troubleshooting.\n Debug(correlationId string, message string, args \u0026hellip;interface{})\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. message: string - human-readable message to log. args: \u0026hellip;interface{} - arguments to parameterize the message.  Error Logs' recoverable application error.\n Error(correlationId string, err error, message string, args \u0026hellip;interface{})\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. err: error - error object associated with this message. message: string - human-readable message to log. args: \u0026hellip;interface{} - arguments to parameterize the message.  Fatal Logs fatal (unrecoverable) message that caused the process to crash.\n Fatal(correlationId string, err error, message string, args \u0026hellip;interface{})\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. err: error - error object associated with this message. message: string - human-readable message to log. args: \u0026hellip;interface{} - arguments to parameterize the message.  Info Logs an important information message.\n Info(correlationId string, message string, args \u0026hellip;interface{})\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. message: string - human-readable message to log. args: \u0026hellip;interface{} - arguments to parameterize the message.  Log Logs a message at a specified log level.\n Log(level int, correlationId string, err error, message string, args \u0026hellip;interface{})\n  level: int - log level. correlationId: string - (optional) transaction id used to trace execution through the call chain. err: error - error object associated with this message. message: string - human-readable message to log. args: \u0026hellip;interface{} - arguments to parameterize the message.  SetLevel Sets the maximum log level.\n SetLevel(value int)\n  level: int - new maximum log level.  Trace Logs low-level debug information for troubleshooting.\n Trace(correlationId string, message string, args \u0026hellip;interface{})\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. message: string - human-readable message to log. args: \u0026hellip;interface{} - arguments to parameterize the message.  Warn Logs a warning that may or may not have a negative impact.\n Warn(correlationId string, message string, args \u0026hellip;interface{})\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. message: string - human-readable message to log. args: \u0026hellip;interface{} - arguments to parameterize the message.  ","description":"Interface for logger components that capture execution log messages.\n","image":null,"permalink":"/golang/components/log/ilogger/","subtitle":null,"tags":null,"title":"ILogger"},{"content":"Description The ILogger interface provides a set of methods for logger components that capture log messages.\nProperties Level Gets or sets the maximum log level. Messages with higher log level are filtered out.\n LogLevel Level { get; set; }\n Instance methods Debug Logs high-level debug information for troubleshooting.\n void Debug(string correlationId, string message, params object[] args)\n  correlationId: string - (optional) transaction id to trace execution through a call chain. message: string - a human-readable message to log. args: object[] - arguments to parameterize the message.  Debug Logs high-level debug information for troubleshooting.\n void Debug(string correlationId, Exception error, string message = null, params object[] args)\n  correlationId: string - (optional) transaction id to trace execution through a call chain. error: Exception - an error object associated with this message. message: string - a human-readable message to log. args: object[] - arguments to parameterize the message.  Error Logs recoverable application error.\n void Error(string correlationId, string message, params object[] args)\n  correlationId: string - (optional) transaction id to trace execution through a call chain. message: string - a human-readable message to log. args: object[] - arguments to parameterize the message.  Error Logs recoverable application error.\n void Error(string correlationId, Exception error, string message = null, params object[] args)\n  correlationId: string - (optional) transaction id to trace execution through a call chain. error: Exception - an error object associated with this message. message: string - a human-readable message to log. args: object[] - arguments to parameterize the message.  Fatal Logs fatal (unrecoverable) message that caused the process to crash.\n void Fatal(string correlationId, string message, params object[] args)\n  correlationId: string - (optional) transaction id to trace execution through a call chain. message: string - a human-readable message to log. args: object[] - arguments to parameterize the message.  Fatal Logs fatal (unrecoverable) message that caused the process to crash.\n void Fatal(string correlationId, Exception error, string message = null, params object[] args)\n  correlationId: string - (optional) transaction id to trace execution through a call chain. error: Exception - an error object associated with this message. message: string - a human-readable message to log. args: object[] - arguments to parameterize the message.  Info Logs an important information message\n void Info(string correlationId, string message, params object[] args)\n  correlationId: string - (optional) transaction id to trace execution through a call chain. message: string - a human-readable message to log. args: object[] - arguments to parameterize the message.  Info Logs an important information message\n void Info(string correlationId, Exception error, string message = null, params object[] args): void\n  correlationId: string - (optional) transaction id to trace execution through a call chain. error: Exception - an error object associated with this message. message: string - a human-readable message to log. args: object[] - arguments to parameterize the message.  Log Logs a message at a specified log level.\n void Log(LogLevel level, string correlationId, Exception error, string message, params object[] args)\n  level: LogLevel - a log level. correlationId: string - (optional) transaction id to trace execution through a call chain. error: Exception - an error object associated with this message. message: string - a human-readable message to log. args: object[] - arguments to parameterize the message.  Trace Logs low-level debug information for troubleshooting.\n void Trace(string correlationId, string message, params object[] args)\n  correlationId: string - (optional) transaction id to trace execution through call chain. message: string - a human-readable message to log. args: object[] - arguments to parameterize the message.  Trace Logs low-level debug information for troubleshooting.\n void Trace(string correlationId, Exception error, string message = null, params object[] args)\n  correlationId: string - (optional) transaction id to trace execution through call chain. error: Exception - an error object associated with this message. message: string - a human-readable message to log. args: object[] - arguments to parameterize the message.  Warn Logs a warning that may or may not have a negative impact.\n void Warn(string correlationId, string message, params object[] args)\n  correlationId: string - (optional) transaction id to trace execution through call chain. message: string - a human-readable message to log. args: object[] - arguments to parameterize the message.  Warn Logs a warning that may or may not have a negative impact.\n void Warn(string correlationId, Exception error, string message = null, params object[] args)\n  correlationId: string - (optional) transaction id to trace execution through call chain. error: Exception - an error object associated with this message message: string - a human-readable message to log. args: object[] - arguments to parameterize the message.  ","description":"Interface for logger components that capture execution log messages.\n","image":null,"permalink":"/net/components/log/ilogger/","subtitle":null,"tags":null,"title":"ILogger"},{"content":"Description The ILogger interface provides a set of methods for logger components that capture log messages.\nInstance methods debug Logs high-level debug information for troubleshooting.\n debug(correlationId: string, message: string, \u0026hellip;args: any[]): void\n  correlationId: string - (optional) transaction id to trace execution through a call chain. message: string - a human-readable message to log. args: any[] - arguments to parameterize the message.  error Logs recoverable application error.\n error(correlationId: string, error: Error, message: string, \u0026hellip;args: any[]): void\n  correlationId: string - (optional) transaction id to trace execution through a call chain. error: Error - an error object associated with this message. message: string - a human-readable message to log. args: any[] - arguments to parameterize the message.  fatal Logs fatal (unrecoverable) message that caused the process to crash.\n fatal(correlationId: string, error: Error, message: string, \u0026hellip;args: any[]): void\n  correlationId: string - (optional) transaction id to trace execution through a call chain. error: Error - an error object associated with this message. message: string - a human-readable message to log. args: any[] - arguments to parameterize the message.  getLevel Gets the maximum log level. Messages with higher log level are filtered out.\n getLevel(): LogLevel\n  returns: LogLevel - the maximum log level.  info Logs an important information message\n info(correlationId: string, message: string, \u0026hellip;args: any[]): void\n  correlationId: string - (optional) transaction id to trace execution through a call chain. message: string - a human-readable message to log. args: any[] - arguments to parameterize the message.  log Logs a message at a specified log level.\n log(level: LogLevel, correlationId: string, error: Error, message: string, \u0026hellip;args: any[]): void\n  level: LogLevel - a log level. correlationId: string - (optional) transaction id to trace execution through a call chain. error: Error - an error object associated with this message. message: string - a human-readable message to log. args: any[] - arguments to parameterize the message.  setLevel Set the maximum log level.\n setLevel(level: LogLevel): void\n  level: LogLevel - a new maximum log level.  trace Logs low-level debug information for troubleshooting.\n trace(correlationId: string, message: string, \u0026hellip;args: any[]): void\n  correlationId: string - (optional) transaction id to trace execution through call chain. message: string - a human-readable message to log. args: any[] - arguments to parameterize the message.  warn Logs a warning that may or may not have a negative impact.\n warn(correlationId: string, message: string, \u0026hellip;args: any[]): void\n  correlationId: string - (optional) transaction id to trace execution through call chain. message: string - a human-readable message to log. args: any[] - arguments to parameterize the message.  ","description":"Interface for logger components that capture execution log messages.\n","image":null,"permalink":"/node/components/log/ilogger/","subtitle":null,"tags":null,"title":"ILogger"},{"content":"Description The ILogger interface provides a set of methods for logger components that capture log messages.\nInstance methods debug Logs high-level debug information for troubleshooting.\n debug(correlation_id: Optional[str], message: str, *args: Any, **kwargs: Any)\n  correlation_id: Optional[str] - (optional) transaction id to trace execution through a call chain. message: str - a human-readable message to log. args: Any - arguments to parameterize the message. kwargs: Any - arguments to parameterize the message.  error Logs recoverable application error.\n error(correlation_id: Optional[str], error: Exception, message: str, *args: Any, **kwargs: Any)\n  correlation_id: Optional[str] - (optional) transaction id to trace execution through a call chain. error: Exception - an error object associated with this message. message: str - a human-readable message to log. args: Any - arguments to parameterize the message. kwargs: Any - arguments to parameterize the message.  fatal Logs fatal (unrecoverable) message that caused the process to crash.\n fatal(correlation_id: Optional[str], error: Exception, message: str, *args: Any, **kwargs: Any)\n  correlation_id: Optional[str] - (optional) transaction id to trace execution through a call chain. error: Exception - an error object associated with this message. message: str - a human-readable message to log. args: Any - arguments to parameterize the message. kwargs: Any - arguments to parameterize the message.  get_level Gets the maximum log level. Messages with higher log level are filtered out.\n get_level(): LogLevel\n  returns: LogLevel - the maximum log level.  info Logs an important information message\n info(correlation_id: Optional[str], message: str, *args: Any, **kwargs: Any)\n  correlation_id: Optional[str] - (optional) transaction id to trace execution through a call chain. message: str - a human-readable message to log. args: Any - arguments to parameterize the message. kwargs: Any - arguments to parameterize the message.  log Logs a message at a specified log level.\n log(level: LogLevel, correlation_id: Optional[str], error: Optional[Exception], message: Optional[str], *args: Any, **kwargs: Any)\n  level: LogLevel - a log level. correlation_id: Optional[str] - (optional) transaction id to trace execution through a call chain. error: Optional[Exception] - an error object associated with this message. message: Optional[str] - a human-readable message to log. args: Any - arguments to parameterize the message. kwargs: Any - arguments to parameterize the message.  set_level Set the maximum log level.\n set_level(level: LogLevel)\n  level: LogLevel - a new maximum log level.  trace Logs low-level debug information for troubleshooting.\n trace(correlation_id: Optional[str], message: str, *args: Any, **kwargs: Any)\n  correlation_id: Optional[str] - (optional) transaction id to trace execution through call chain. message: str - a human-readable message to log. args: Any - arguments to parameterize the message. kwargs: Any - arguments to parameterize the message.  warn Logs a warning that may or may not have a negative impact.\n warn(correlation_id: Optional[str], message: str, *args: Any, **kwargs: Any)\n  correlation_id: Optional[str] - (optional) transaction id to trace execution through call chain. message: str - a human-readable message to log. args: Any - arguments to parameterize the message. kwargs: Any - arguments to parameterize the message.  ","description":"Interface for logger components that capture execution log messages.\n","image":null,"permalink":"/python/components/log/ilogger/","subtitle":null,"tags":null,"title":"ILogger"},{"content":"Allows system administrators and product owners to communicate to users key system events and product updates. Each imageset:\n  Can be written in multiple languages\n  Can include pictures and document attachments\n  Supports editing lifecycle via status tracking\n  Server implementations: NodeJS, Dart\n  Communication protocols: Direct, Commandable HTTP, Commandable GRPC, GRPC\n  Persistence: Memory, Flat Files, MongoDB, Couchbase\n  Deployment options: Monolith, Process, Docker, AWS Lambda\n  Client implementations: NodeJS, Dart\n  This microservice has dependencies on the following microservices:\n Blob Attachments - to reference pictures and documents associates with imagesets  ","description":null,"image":null,"permalink":"/microservices/content/imagesets/","subtitle":null,"tags":null,"title":"ImageSets Microservice"},{"content":"Description The IMap interface is used to create a map data structure.\nMethods Get Gets a value related to a given key.\n Get(key string) interface{}\n  key: string - TODO add description returns: interface{} - TODO add description  Put Inserts the given value and key.\n Put(key string, value interface{})\n  key: string - TODO add description value: interface{} - TODO add description  Remove Removes a value related to a given key.\n Remove(key string)\n  key string - value\u0026rsquo;s key  Contains TODO add description\n Contains(key string) bool\n  key: string - TODO add description returns: bool - TODO add description  ","description":"Interface used to create a map data structure.\n","image":null,"permalink":"/golang/commons/data/imap/","subtitle":null,"tags":null,"title":"IMap"},{"content":"Implements: IOpenable\nDescription The IMessageQueue interface is used for asynchronous message queues.\nImportant points\n Not all queues may implement all the methods. An ttempt to call a non-supported method will result in a NotImplemented exception. To verify if a specific method is supported check MessagingCapabilities.  Methods Abandon Returns a message into the queue and makes it available for all subscribers to receive it again. This method is usually used to return a message which could not be processed at the moment, to repeat the attempt. Messages that cause unrecoverable errors shall be removed permanently or/and sent to dead letter queue.\n Abandon(message *MessageEnvelope) error\n  message: *MessageEnvelope - message to return. returns: error - error or nil no errors occured.  BeginListen Listens for incoming messages without blocking the current thread.\nSee also IMessageReceiver, listen\n BeginListen(correlationId string, receiver IMessageReceiver)\n  correlationId: string - (optional) transaction id used to trace execution through a the call chain. receiver: IMessageReceiver - receiver used to receive incoming messages.  Complete Permanently removes a message from the queue. This method is usually used to remove the message after successful processing.\n Complete(message *MessageEnvelope) error\n  message: *MessageEnvelope - message to remove. returns: error - error or nil no errors occured.  EndListen Ends listening for incoming messages. When this method is called, listen unblocks the thread and execution continues.\n EndListen(correlationId string)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain.  Capabilities Gets the queue capabilities\n Capabilities() *MessagingCapabilities\n  returns: *MessagingCapabilities - queue\u0026rsquo;s capabilities object.  Name Gets the queue name\n Name() string\n  returns: string - queue name.  Listen Listens for incoming messages and blocks the current thread until queue is closed.\nSee also IMessageReceiver, Receive\n Listen(correlationId string, receiver IMessageReceiver) error\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. receiver: IMessageReceiver - receiver used to receive incoming messages. returns: error - error or nil no errors occured.  MoveToDeadLetter Permanently removes a message from the queue and sends it to the dead letter queue.\n MoveToDeadLetter(message *MessageEnvelope) error\n  message: *MessageEnvelope - message to be removed. returns: error - error or nil no errors occured.  Peek Peeks a single incoming message from the queue without removing it. If there are no messages available in the queue, it returns nil.\n Peek(correlationId string) (result *MessageEnvelope, err error)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. returns: (result *MessageEnvelope, err error) - peeked message or nil.  PeekBatch Peeks multiple incoming messages from the queue without removing them. If there are no messages available in the queue, it returns an empty list.\n PeekBatch(correlationId string, messageCount int64) (result []*MessageEnvelope, err error)\n  orrelation_id: string - (optional) transaction id used to trace execution through the call chain. messageCount: int64 - maximum number of messages to peek. returns: (result []*MessageEnvelope, err error) - peeked list with messages.  ReadMessageCount Reads the current number of messages in the queue to be delivered.\n ReadMessageCount() (count int64, err error)\n  returns: (count int64, err error) - number of messages.  Receive Receives an incoming message and removes it from the queue.\n Receive(correlationId string, waitTimeout time.Duration) (result *MessageEnvelope, err error)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. waitTimeout: time.Duration - timeout in milliseconds to wait for a message to come. returns: (result *MessageEnvelope, err error) - received message or nil.  RenewLock Renews a lock on a message that makes it invisible from other receivers in the queue. This method is usually used to extend the message processing time.\n RenewLock(message *MessageEnvelope, lockTimeout time.Duration) error\n  message: *MessageEnvelope - message to extend its lock. lockTimeout: time.Duration - locking timeout in milliseconds. returns: error - error or nil no errors occured.  Send Sends a message into the queue.\n Send(correlationId string, envelope *MessageEnvelope) error\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. envelope: *MessageEnvelope - message envelop to be sent. returns: error - error or nil no errors occured.  SendAsObject Sends an object into the queue. Before being sent, the object is converted into JSON string and wrapped in a MessageEnvelope.\n SendAsObject(correlationId string, messageType string, value interface{}) error\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. messageType: string - message type. value: interface{} - object value to be sent. returns: error - error or nil no errors occured.  See also   MessageEnvelope   MessagingCapabilities   ","description":"Interface for asynchronous message queues.\n\n \n","image":null,"permalink":"/golang/messaging/queues/imessage_queue/","subtitle":null,"tags":null,"title":"IMessageQueue"},{"content":"Inherits: IOpenable\nDescription The IMessageQueue interface is used for asynchronous message queues.\nImportant points\n Not all queues may implement all the methods. An ttempt to call a non-supported method will result in a NotImplemented exception. To verify if a specific method is supported check MessagingCapabilities.  Properties Name Gets the queue name\n string Name { get; }\n MessagingCapabilities Gets the queue capabilities\n MessagingCapabilities Capabilities { get; }\n Instance methods Abandon Returns a message into the queue and makes it available for all subscribers to receive it again. This method is usually used to return a message which could not be processed at the moment, to repeat the attempt. Messages that cause unrecoverable errors shall be removed permanently or/and sent to dead letter queue.\n Task AbandonAsync(MessageEnvelope message)\n  message: MessageEnvelope - message to return.  BeginListen Listens for incoming messages without blocking the current thread.\nSee also IMessageReceiver, ListenAsync\n void BeginListen(string correlationId, IMessageReceiver receiver)\n  correlationId: string - (optional) transaction id used to trace execution through a the call chain. receiver: IMessageReceiver - receiver used to receive incoming messages.  Listens for incoming messages without blocking the current thread.\n void BeginListen(string correlationId, Func\u0026lt;MessageEnvelope, IMessageQueue, Task\u0026gt; callback)\n  correlationId: string - (optional) transaction id used to trace execution through a the call chain. callback: Func\u0026lt;MessageEnvelope, IMessageQueue, Task\u0026gt; - receiver used to receive incoming messages.  Complete Permanently removes a message from the queue. This method is usually used to remove the message after successful processing.\n Task CompleteAsync([MessageEnvelope](../message_envelope message)\n  message: MessageEnvelope - message to remove.  EndListen Ends listening for incoming messages. When this method is called, listen unblocks the thread and execution continues.\n void EndListen(string correlationId)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain.  ListenAsync Listens for incoming messages and blocks the current thread until queue is closed.\nSee also IMessageReceiver, ReceiveAsync\n Task ListenAsync(string correlationId, IMessageReceiver receiver)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. receiver: IMessageReceiver - receiver used to receive incoming messages.  Listens for incoming messages and blocks the current thread until queue is closed.\n Task ListenAsync(string correlationId, Func\u0026lt;MessageEnvelope, IMessageReceiver, Task\u0026gt; callback)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. receiver: Func\u0026lt;MessageEnvelope, IMessageReceiver, Task\u0026gt; - receiver used to receive incoming messages.  MoveToDeadLetter Permanently removes a message from the queue and sends it to the dead letter queue.\n Task MoveToDeadLetterAsync(MessageEnvelope message)\n  message: MessageEnvelope - message to be removed.  PeekAsync Peeks a single incoming message from the queue without removing it. If there are no messages available in the queue, it returns null.\n Task\u0026lt;MessageEnvelope\u0026gt; PeekAsync(string correlationId)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. returns: Task\u0026lt;MessageEnvelope\u0026gt; - peeked message or null.  PeekBatchAsync Peeks multiple incoming messages from the queue without removing them. If there are no messages available in the queue, it returns an empty list.\n Task\u0026lt;List\u0026lt;MessageEnvelope\u0026gt;\u0026gt; PeekBatchAsync(string correlationId, int messageCount)\n  orrelation_id: string - (optional) transaction id used to trace execution through the call chain. messageCount: int - maximum number of messages to peek. returns: Task\u0026lt;List\u0026lt;MessageEnvelope\u0026gt;\u0026gt; - peeked list with messages.  ReadMessageCountAsync Reads the current number of messages in the queue to be delivered.\n Task\u0026lt;long\u0026gt; ReadMessageCountAsync()\n  returns: Task\u0026lt;long\u0026gt; - number of messages.  ReceiveAsync Receives an incoming message and removes it from the queue.\n Task\u0026lt;[MessageEnvelope](../message_envelope)\u0026gt; ReceiveAsync(string correlationId, long waitTimeout)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. waitTimeout: long - timeout in milliseconds to wait for a message to come. returns: Task\u0026lt;[MessageEnvelope](../message_envelope)\u0026gt; - received message or null.  RenewLockAsync Renews a lock on a message that makes it invisible from other receivers in the queue. This method is usually used to extend the message processing time.\n Task RenewLockAsync(MessageEnvelope message, long lockTimeout)\n  message: MessageEnvelope - message to extend its lock. lockTimeout: long - locking timeout in milliseconds.  SendAsync Sends a message into the queue.\n Task SendAsync(string correlationId, MessageEnvelope envelope)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. envelope: MessageEnvelope - message envelop to be sent.  SendAsObjectAsync Sends an object into the queue. Before being sent, the object is converted into JSON string and wrapped in a MessageEnvelope.\n Task SendAsObjectAsync(string correlationId, string messageType, object message)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. messageType: string - message type message: object - an object value to be sent  See also   MessageEnvelope   MessagingCapabilities   ","description":"Interface for asynchronous message queues.\n\n \n","image":null,"permalink":"/net/messaging/queues/imessage_queue/","subtitle":null,"tags":null,"title":"IMessageQueue"},{"content":"Extends: IOpenable, IClosable\nDescription The IMessageQueue interface is used for asynchronous message queues.\nImportant points\n Not all queues may implement all the methods. An ttempt to call a non-supported method will result in a NotImplemented exception. To verify if a specific method is supported check MessagingCapabilities.  Instance methods abandon Returns a message into the queue and makes it available for all subscribers to receive it again. This method is usually used to return a message which could not be processed at the moment, to repeat the attempt. Messages that cause unrecoverable errors shall be removed permanently or/and sent to dead letter queue.\n abandon(message: MessageEnvelope): Promise\u0026lt;void\u0026gt;\n  message: MessageEnvelope - message to return.  beginListen Listens for incoming messages without blocking the current thread.\nSee also IMessageReceiver, listen\n beginListen(correlationId: string, receiver: IMessageReceiver): void\n  correlationId: string - (optional) transaction id used to trace execution through a the call chain. receiver: IMessageReceiver - receiver used to receive incoming messages.  complete Permanently removes a message from the queue. This method is usually used to remove the message after successful processing.\n complete(message: MessageEnvelope): Promise\u0026lt;void\u0026gt;\n  message: MessageEnvelope - message to remove.  endListen Ends listening for incoming messages. When this method is called, listen unblocks the thread and execution continues.\n endListen(correlationId: string): void\n  correlationId: string - (optional) transaction id used to trace execution through the call chain.  getCapabilities Gets the queue capabilities\n getCapabilities(): MessagingCapabilities\n  returns: MessagingCapabilities - queue\u0026rsquo;s capabilities object.  getName Gets the queue name\n getName(): string\n  returns: string - queue name.  listen Listens for incoming messages and blocks the current thread until queue is closed.\nSee also IMessageReceiver, receive\n listen(correlationId: string, receiver: IMessageReceiver): void\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. receiver: IMessageReceiver - receiver used to receive incoming messages.  moveToDeadLetter Permanently removes a message from the queue and sends it to the dead letter queue.\n moveToDeadLetter(message: MessagingCapabilities): Promise\u0026lt;void\u0026gt;\n  message: MessageEnvelope - message to be removed.  peek Peeks a single incoming message from the queue without removing it. If there are no messages available in the queue, it returns null.\n peek(correlationId: string): Promise\u0026lt;MessageEnvelope\u0026gt;\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. returns: Promise\u0026lt;MessageEnvelope\u0026gt; - peeked message or null.  peekBatch Peeks multiple incoming messages from the queue without removing them. If there are no messages available in the queue, it returns an empty list.\n peekBatch(orrelation_id: string, messageCount: number): Promise\u0026lt;MessageEnvelope[]\u0026gt;\n  orrelation_id: string - (optional) transaction id used to trace execution through the call chain. messageCount: number - maximum number of messages to peek. returns: Promise\u0026lt;MessageEnvelope[]\u0026gt; - peeked list with messages.  readMessageCount Reads the current number of messages in the queue to be delivered.\n readMessageCount(): Promise\u0026lt;number\u0026gt;\n  returns: Promise\u0026lt;number\u0026gt; - number of messages.  receive Receives an incoming message and removes it from the queue.\n receive(correlationId: string, waitTimeout: number): Promise\u0026lt;MessageEnvelope\u0026gt;\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. waitTimeout: number - timeout in milliseconds to wait for a message to come. returns: MessageEnvelope - received message or null.  renewLock Renews a lock on a message that makes it invisible from other receivers in the queue. This method is usually used to extend the message processing time.\n renewLock(message: MessageEnvelope, lockTimeout: number): Promise\u0026lt;void\u0026gt;\n  message: MessageEnvelope - message to extend its lock. lockTimeout: number - locking timeout in milliseconds.  send Sends a message into the queue.\n send(correlationId: string, envelope: MessageEnvelope): Promise\u0026lt;void\u0026gt;\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. envelope: MessageEnvelope - message envelop to be sent.  sendAsObject Sends an object into the queue. Before being sent, the object is converted into JSON string and wrapped in a MessageEnvelope.\n sendAsObject(correlationId: string, messageType: string, value: any)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. messageType: string - message type value: any - object value to be sent  See also   MessageEnvelope   MessagingCapabilities   ","description":"Interface for asynchronous message queues.\n\n \n","image":null,"permalink":"/node/messaging/queues/imessage_queue/","subtitle":null,"tags":null,"title":"IMessageQueue"},{"content":"Implements: IOpenable, IClosable\nDescription The IMessageQueue interface is used for asynchronous message queues.\nImportant points\n Not all queues may implement all the methods. An ttempt to call a non-supported method will result in a NotImplemented exception. To verify if a specific method is supported check MessagingCapabilities.  Instance methods abandon Returns a message into the queue and makes it available for all subscribers to receive it again. This method is usually used to return a message which could not be processed at the moment, to repeat the attempt. Messages that cause unrecoverable errors shall be removed permanently or/and sent to dead letter queue.\n abandon(message: MessageEnvelope)\n  message: MessageEnvelope - message to return.  begin_listen Listens for incoming messages without blocking the current thread.\nSee also IMessageReceiver, listen\n begin_listen(correlation_id: Optional[str], receiver: IMessageReceiver)\n  correlation_id: Optional[str] - (optional) transaction id used to trace execution through a the call chain. receiver: IMessageReceiver - receiver used to receive incoming messages.  complete Permanently removes a message from the queue. This method is usually used to remove the message after successful processing.\n complete(message: MessageEnvelope)\n  message: MessageEnvelope - message to remove.  end_listen Ends listening for incoming messages. When this method is called, listen unblocks the thread and execution continues.\n end_listen(correlation_id: Optional[str])\n  correlation_id: Optional[str] - (optional) transaction id used to trace execution through the call chain.  get_capabilities Gets the queue capabilities\n get_capabilities(): MessagingCapabilities\n  returns: MessagingCapabilities - queue\u0026rsquo;s capabilities object.  get_name Gets the queue name\n get_name(): str\n  returns: str - queue name.  listen Listens for incoming messages and blocks the current thread until queue is closed.\nSee also IMessageReceiver, receive\n listen(correlation_id: Optional[str], receiver: IMessageReceiver)\n  correlation_id: Optional[str] - (optional) transaction id used to trace execution through the call chain. receiver: IMessageReceiver - receiver used to receive incoming messages.  move_to_dead_letter Permanently removes a message from the queue and sends it to the dead letter queue.\n move_to_dead_letter(message: MessagingCapabilities)\n  message: MessageEnvelope - message to be removed.  peek Peeks a single incoming message from the queue without removing it. If there are no messages available in the queue, it returns None.\n peek(correlation_id: Optional[str]): MessageEnvelope\n  correlation_id: Optional[str] - (optional) transaction id used to trace execution through the call chain. returns: MessageEnvelope - peeked message or None.  peekBatch Peeks multiple incoming messages from the queue without removing them. If there are no messages available in the queue, it returns an empty list.\n peekBatch(orrelation_id: Optional[str], message_count: int): List[MessageEnvelope]\n  orrelation_id: Optional[str] - (optional) transaction id used to trace execution through the call chain. message_count: int - maximum number of messages to peek. returns: List[MessageEnvelope] - peeked list with messages.  read_message_count Reads the current number of messages in the queue to be delivered.\n read_message_count(): int\n  returns: int - number of messages.  receive Receives an incoming message and removes it from the queue.\n receive(correlation_id: Optional[str], wait_timeout: int): MessageEnvelope\n  correlation_id: Optional[str] - (optional) transaction id used to trace execution through the call chain. wait_timeout: int - timeout in milliseconds to wait for a message to come. returns: MessageEnvelope - received message or None.  renew_lock Renews a lock on a message that makes it invisible from other receivers in the queue. This method is usually used to extend the message processing time.\n renew_lock(message: MessageEnvelope, lock_timeout: int)\n  message: MessageEnvelope - message to extend its lock. lock_timeout: int - locking timeout in milliseconds.  send Sends a message into the queue.\n send(correlation_id: Optional[str], envelope: MessageEnvelope)\n  correlation_id: Optional[str] - (optional) transaction id used to trace execution through the call chain. envelope: MessageEnvelope - message envelop to be sent.  send_as_object Sends an object into the queue. Before being sent, the object is converted into JSON string and wrapped in a MessageEnvelope.\n send_as_object(correlation_id: Optional[str], message_type: str, value: Any):\n  correlation_id: Optional[str] - (optional) transaction id used to trace execution through the call chain. message_type: str - message type value: Any - object value to be sent  See also   MessageEnvelope   MessagingCapabilities   ","description":"Interface for asynchronous message queues.\n\n \n","image":null,"permalink":"/python/messaging/queues/imessage_queue/","subtitle":null,"tags":null,"title":"IMessageQueue"},{"content":"Description The IMessageQueueConnection interface is used to create message queue connections.\nMethods CreateQueue Creates a message queue. If connection doesn\u0026rsquo;t support this function, it exits without error.\n CreateQueue(name string) error\n  name: string - name of the queue to be created. returns: error - returns error if not created.  DeleteQueue Deletes a message queue. If connection doesn\u0026rsquo;t support this function, it exits without error.\n DeleteQueue(name string) error\n  name: string - name of the queue to be deleted. returns: error - returns error if not deleted.  ReadQueueNames Reads a list of registered queue names. If connection doesn\u0026rsquo;t support this function returns an empty list.\n ReadQueueNames() ([]string, error)\n  returns: ([]string, error) - list with registered queue names.  ","description":"Defines an interface for message queue connections\n","image":null,"permalink":"/golang/messaging/connect/imessage_queue_connection/","subtitle":null,"tags":null,"title":"IMessageQueueConnection"},{"content":"Description The IMessageQueueConnection interface is used to create message queue connections.\nInstance methods CreateQueueAsync Creates a message queue. If connection doesn\u0026rsquo;t support this function, it exits without error.\n Task CreateQueueAsync(string name)\n  name: string - name of the queue to be created.  DeleteQueueAsync Deletes a message queue. If connection doesn\u0026rsquo;t support this function, it exits without error.\n Task DeleteQueueAsync(string name)\n  name: string - name of the queue to be deleted.  ReadQueueNamesAsync Reads a list of registered queue names. If connection doesn\u0026rsquo;t support this function returns an empty list.\n Task\u0026lt;List\u0026lt;string\u0026gt;\u0026gt; ReadQueueNamesAsync()\n  returns: Task\u0026lt;List\u0026lt;string\u0026gt;\u0026gt; - list with registered queue names.  ","description":"Defines an interface for message queue connections\n","image":null,"permalink":"/net/messaging/connect/imessage_queue_connection/","subtitle":null,"tags":null,"title":"IMessageQueueConnection"},{"content":"Description The IMessageQueueConnection interface is used to create message queue connections.\nInstance methods createQueue Creates a message queue. If connection doesn\u0026rsquo;t support this function, it exits without error.\n createQueue(name: string)\n  name: string - name of the queue to be created.  deleteQueue Deletes a message queue. If connection doesn\u0026rsquo;t support this function, it exits without error.\n deleteQueue(name: string)\n  name: string - name of the queue to be deleted.  readQueueNames Reads a list of registered queue names. If connection doesn\u0026rsquo;t support this function returns an empty list.\n readQueueNames(): Promise\u0026lt;string[]\u0026gt;\n  returns: Promise\u0026lt;string[]\u0026gt; - list with registered queue names.  ","description":"Defines an interface for message queue connections\n","image":null,"permalink":"/node/messaging/connect/imessage_queue_connection/","subtitle":null,"tags":null,"title":"IMessageQueueConnection"},{"content":"Description The IMessageQueueConnection interface is used to create message queue connections.\nInstance methods create_queue Creates a message queue. If connection doesn\u0026rsquo;t support this function, it exits without error.\n create_queue(name: str)\n  name: str - name of the queue to be created.  delete_queue Deletes a message queue. If connection doesn\u0026rsquo;t support this function, it exits without error.\n delete_queue(name: str)\n  name: str - name of the queue to be deleted.  read_queue_names Reads a list of registered queue names. If connection doesn\u0026rsquo;t support this function returns an empty list.\n read_queue_names(): List[str]\n  returns: List[str] - list with registered queue names.  ","description":"Defines an interface for message queue connections\n","image":null,"permalink":"/python/messaging/connect/imessage_queue_connection/","subtitle":null,"tags":null,"title":"IMessageQueueConnection"},{"content":"Description The IMessageQueueFactory interface allows you to create message queue components.\nMethods CreateQueue Creates a message queue component and assigns its name.\n CreateQueue(name string) queues.IMessageQueue\n  name: string - name of the created message queue. returns: queues.IMessageQueue - message queue  See also   IMessageQueue   ","description":"Creates message queue componens.\n","image":null,"permalink":"/golang/messaging/build/imemory_message_queue_factory/","subtitle":null,"tags":null,"title":"IMessageQueueFactory"},{"content":"Description The IMessageQueueFactory interface allows you to create message queue components.\nInstance methods CreateQueue Creates a message queue component and assigns its name.\n IMessageQueue CreateQueue(string name)\n  name: string - name of the created message queue. returns: IMessageQueue - message queue  See also   IMessageQueue   ","description":"Creates message queue componens.\n","image":null,"permalink":"/net/messaging/build/imemory_message_queue_factory/","subtitle":null,"tags":null,"title":"IMessageQueueFactory"},{"content":"Description The IMessageQueueFactory interface allows you to create message queue components.\nInstance methods createQueue Creates a message queue component and assigns its name.\n createQueue(name: string): IMessageQueue\n  name: string - name of the created message queue. returns: IMessageQueue - message queue  See also   IMessageQueue   ","description":"Creates message queue componens.\n","image":null,"permalink":"/node/messaging/build/imemory_message_queue_factory/","subtitle":null,"tags":null,"title":"IMessageQueueFactory"},{"content":"Description The IMessageQueueFactory interface allows you to create message queue components.\nInstance methods create_queue Creates a message queue component and assigns its name.\n create_queue(name: str): IMessageQueue\n  name: str - name of the created message queue. returns: IMessageQueue - message queue  See also   IMessageQueue   ","description":"Creates message queue componens.\n","image":null,"permalink":"/python/messaging/build/imemory_message_queue_factory/","subtitle":null,"tags":null,"title":"IMessageQueueFactory"},{"content":"Description The IMessageReceive interface is used to receive incoming messages.\nMethods ReceiveMessage Receives an incoming message from the queue.\nSee also MessageEnvelope, IMessageQueue\n ReceiveMessage(envelope *MessageEnvelope, queue IMessageQueue) (err error)\n  envelope: *MessageEnvelope - incoming message, queue: IMessageQueue - queue where the message comes from. returns: (err error) - error or nil no errors occured.  Examples type MyMessageReceiver struct { func (c*MyMessageReceiver) ReceiveMessage(envelop MessageEnvelop, queue IMessageQueue) { fmt.Println(\u0026#34;Received message: \u0026#34; + envelop.GetMessageAsString()); } } messageQueue := NewMemoryMessageQueue(); messageQueue.Listen(\u0026#34;123\u0026#34;, NewMyMessageReceiver()); opnErr := messageQueue.Open(\u0026#34;123\u0026#34;) if opnErr == nil{ messageQueue.Send(\u0026#34;123\u0026#34;, NewMessageEnvelop(\u0026#34;\u0026#34;, \u0026#34;mymessage\u0026#34;, \u0026#34;ABC\u0026#34;)); // Output in console: \u0026#34;Received message: ABC\u0026#34; } ","description":"Callback interface to receive incoming messages.\n","image":null,"permalink":"/golang/messaging/queues/imessage_receiver/","subtitle":null,"tags":null,"title":"IMessageReceive"},{"content":"Description The IMessageReceive interface is used to receive incoming messages.\nInstance methods receiveMessage Receives an incoming message from the queue.\nSee also MessageEnvelope, IMessageQueue\n Task ReceiveMessageAsync(MessageEnvelope envelope, IMessageQueue queue)\n  envelope: MessageEnvelope - incoming message queue: IMessageQueue - queue where the message comes from  Examples class MyMessageReceiver: IMessageReceiver { public void ReceiveMessage(MessageEnvelop envelop, IMessageQueue queue) { Console.Out.WriteLine(\u0026#34;Received message: \u0026#34; + envelop.getMessageAsString()); ... } } var messageQueue = new MemoryMessageQueue(); messageQueue.Listen(\u0026#34;123\u0026#34;, new MyMessageReceiver()); messageQueue.Open(\u0026#34;123\u0026#34;); messageQueue.Send(\u0026#34;123\u0026#34;, new MessageEnvelop(null, \u0026#34;mymessage\u0026#34;, \u0026#34;ABC\u0026#34;)); // Output in console: \u0026#34;ABC\u0026#34; ","description":"Callback interface to receive incoming messages.\n","image":null,"permalink":"/net/messaging/queues/imessage_receiver/","subtitle":null,"tags":null,"title":"IMessageReceive"},{"content":"Description The IMessageReceive interface is used to receive incoming messages.\nInstance methods receiveMessage Receives an incoming message from the queue.\nSee also MessageEnvelope, IMessageQueue\n receiveMessage(envelope: MessageEnvelope, queue: IMessageQueue): Promise\u0026lt;void\u0026gt;\n  envelope: MessageEnvelope - incoming message queue: IMessageQueue - queue where the message comes from  Examples class MyMessageReceiver implements IMessageReceiver { public async receiveMessage(envelop: MessageEnvelop, queue: IMessageQueue): Promise\\\u0026lt;void\\\u0026gt; { console.log(\u0026#34;Received message: \u0026#34; + envelop.getMessageAsString()); } } let messageQueue = new MemoryMessageQueue(); messageQueue.listen(\u0026#34;123\u0026#34;, new MyMessageReceiver()); await messageQueue.open(\u0026#34;123\u0026#34;) await messageQueue.send(\u0026#34;123\u0026#34;, new MessageEnvelop(null, \u0026#34;mymessage\u0026#34;, \u0026#34;ABC\u0026#34;)); // Output in console: \u0026#34;ABC\u0026#34; ","description":"Callback interface to receive incoming messages.\n","image":null,"permalink":"/node/messaging/queues/imessage_receiver/","subtitle":null,"tags":null,"title":"IMessageReceive"},{"content":"Description The IMessageReceive interface is used to receive incoming messages.\nInstance methods receive_message Receives an incoming message from the queue.\nSee also MessageEnvelope, IMessageQueue\n receive_message(envelope: MessageEnvelope, queue: IMessageQueue)\n  envelope: MessageEnvelope - incoming message queue: IMessageQueue - queue where the message comes from  Examples class MyMessageReceiver(IMessageReceiver): def receive_message(self, envelop, queue): print \u0026#34;Received message: \u0026#34; + envelop.get_message_as_string() messageQueue = MemoryMessageQueue() messageQueue.listen(\u0026#34;123\u0026#34;, MyMessageReceiver()) messageQueue.open(\u0026#34;123\u0026#34;) messageQueue.send(\u0026#34;123\u0026#34;, MessageEnvelope(None, \u0026#34;mymessage\u0026#34;, \u0026#34;ABC\u0026#34;)) # Output in console: \u0026#34;ABC\u0026#34; ","description":"Callback interface to receive incoming messages.\n","image":null,"permalink":"/python/messaging/queues/imessage_receiver/","subtitle":null,"tags":null,"title":"IMessageReceive"},{"content":"Description The INamed interface is used to define data objects that have a human-readable name.\nProperties Name The object\u0026rsquo;s humand-readable name.\n string Name { get; set; }\n Examples public class MyData: IStringIdentifiable, INamed { string id {get; set;} string name {get; set;} string field1; int field2; ... } ","description":"Interface for data objects that have human-readable names.\n","image":null,"permalink":"/net/commons/data/inamed/","subtitle":null,"tags":null,"title":"INamed"},{"content":"Description The INamed interface is used to define data objects containing a human-readable name.\nFields name Object\u0026rsquo;s humand-readable name.\n name: string\n Examples export class MyData implements IStringIdentifiable, INamed { public id: string; public name: string; public field1: string; public field2: number; ... }  ","description":"Interface for data objects that have human-readable names.\n","image":null,"permalink":"/node/commons/data/inamed/","subtitle":null,"tags":null,"title":"INamed"},{"content":"Description The INamed interface is used to define data objects containing a human-readable name.\nFields name The object\u0026rsquo;s humand-readable name.\n name: str\n Examples class MyData(IIdentifiable, INamed): id = None name = None  ","description":"Interface for data objects that have human-readable names.\n","image":null,"permalink":"/python/commons/data/inamed/","subtitle":null,"tags":null,"title":"INamed"},{"content":"Description The INamed interface is used to define data objects containing a human-readable name.\nFields name The object\u0026rsquo;s humand-readable name.\n name: string\n Examples type MyData struct { Id string `json:\u0026#34;id\u0026#34;` Name string `json:\u0026#34;name\u0026#34;` Field1 string `json:\u0026#34;field1\u0026#34;` Field2 int32 `json:\u0026#34;field2\u0026#34;` ... }  ","description":"Interface for data objects that have human-readable names.\n","image":null,"permalink":"/golang/commons/data/inamed/","subtitle":null,"tags":null,"title":"INamed!"},{"content":"Implements: IValidationRule\nDescription The InclidedRule class allows you to check that a list contains only specified values.\nConstructors NewIncludedRule Creates a new validation rule and sets its values.\n NewIncludedRule(values \u0026hellip;interface{}) *IncludedRule\n  values: \u0026hellip;interface{} - list of constants that value must be included to  Methods validate Validates a given value against this rule.\n (c *IncludedRule) Validate(path string, schema ISchema, value interface{}) []*ValidationResult\n  path: string - dot notation path to the value. schema: ISchema - schema this rule is called from value: interface{} - value to be validated. results: []*ValidationResult - list with validation results to add new results.  Examples var schema = NewSchema() .WithRule(NewIncludedRule(1, 2, 3)); schema.Validate(2); // Result: no errors schema.Validate(10); // Result: 10 must be one of 1, 2, 3 See also   IValidationRule   ","description":"Validation rule to check that a list contains only specified values.\n","image":null,"permalink":"/golang/commons/validate/included_rule/","subtitle":null,"tags":null,"title":"IncludedRule"},{"content":"Inherits: IValidationRule\nDescription The InclidedRule class allows you to check that a list contains only specified values.\nConstructors Creates a new validation rule and sets its values.\n public IncludedRule(params object[] values)\n  values: object[] - list of constants that value must be included to  Instance methods Validate Validates a given value against this rule.\n public void Validate(string path, Schema schema, object value, List\u0026lt;ValidationResult\u0026gt; results)\n  path: string - dot notation path to the value. schema: Schema - schema this rule is called from value: object - value to be validated. results: List\u0026lt;ValidationResult\u0026gt; - list with validation results.  Examples var schema = new Schema().WithRule(new IncludedRule(1, 2, 3)); schema.Validate(2); // Result: no errors schema.Validate(10); // Result: 10 must be one of 1, 2, 3 See also   IValidationRule   ","description":"Validation rule used to check that a list contains only specified values.\n","image":null,"permalink":"/net/commons/validate/included_rule/","subtitle":null,"tags":null,"title":"IncludedRule"},{"content":"Implements: IValidationRule\nDescription The InclidedRule class allows you to check that a list contains only specified values.\nConstructors Creates a new validation rule and sets its values.\n public constructor(\u0026hellip;values: any[])\n  values: any[] - list of constants that value must be included to.  Instance methods validate Validates a given value against this rule.\n public validate(path: string, schema: Schema, value: any, results: ValidationResult[]): void\n  path: string - dot notation path to the value. schema: Schema - schema this rule is called from. value: any - value to be validated. results: ValidationResult[] - list with validation results.  Examples let schema = new Schema() .withRule(new IncludedRule(1, 2, 3)); schema.validate(2); // Result: no errors schema.validate(10); // Result: 10 must be one of 1, 2, 3 See also   IValidationRule   ","description":"Validation rule used to check that a list contains only specified values.\n","image":null,"permalink":"/node/commons/validate/included_rule/","subtitle":null,"tags":null,"title":"IncludedRule"},{"content":"Implements: IValidationRule\nDescription The InclidedRule class allows you to check that a list contains only specified values.\nConstructors Creates a new validation rule and sets its values.\n IncludedRule(*values: Any)\n  values: Any - a list of constants that value must be included to  Instance methods validate Validates a given value against this rule.\n validate(path: str, schema: Schema, value: Any, results: List[ValidationResult])\n  path: str - a dot notation path to the value. schema: Schema - a schema this rule is called from value: Any - a value to be validated. results: List[ValidationResult] - a list with validation results to add new results.  Examples schema = new Schema().with_rule(IncludedRule(1, 2, 3)) schema.validate(2) # Result: no errors schema.validate(10) # Result: 10 must be one of 1, 2, 3 See also   IValidationRule   ","description":"Validation rule to check that a list contains only specified values.\n","image":null,"permalink":"/python/commons/validate/included_rule/","subtitle":null,"tags":null,"title":"IncludedRule"},{"content":"Description TODO add description\nProperties Unique TODO add description\n public bool Unique { get; set; }\n Type TODO add description\n public string Type { get; set; }\n ","description":"TODO add description\n","image":null,"permalink":"/net/mysql/persistence/index_options/","subtitle":null,"tags":null,"title":"IndexOptions"},{"content":"Description TODO add description\nProperties Unique TODO add description\n public bool Unique { get; set; }\n Type TODO add description\n public string Type { get; set; }\n ","description":"TODO add description\n","image":null,"permalink":"/net/postgres/persistence/index_options/","subtitle":null,"tags":null,"title":"IndexOptions"},{"content":"Description TODO add description\nProperties Unique TODO add description\n public bool Unique { get; set; }\n Type TODO add description\n public string Type { get; set; }\n ","description":"TODO add description\n","image":null,"permalink":"/net/sqlserver/persistence/index_options/","subtitle":null,"tags":null,"title":"IndexOptions"},{"content":"Description The INotifiable interface allows you to create components that can be asynchronously notified.\nImportant points\n The notification can include an optional argument that describes an occurred event.  Methods Notify Notifies the component about an occured event.\n Notify(correlationId string, args *Parameters)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. args: *Parameters - notification arguments.  Examples type MyComponent {} ... func (mc *MyComponent)Notify(correlationId: string, args: Parameters){ fmt.Println(\u0026#34;Occured event \u0026#34; + args.GetAsString(\u0026#34;event\u0026#34;)); } myComponent := MyComponent{}; myComponent.Notify(\u0026#34;123\u0026#34;, NewParametersFromTuples(\u0026#34;event\u0026#34;, \u0026#34;Test Event\u0026#34;)); See also   Notifier   IExecutable   ","description":"Interface that allows you to create components that can be asynchronously notified.\n","image":null,"permalink":"/golang/commons/run/inotifiable/","subtitle":null,"tags":null,"title":"INotifiable"},{"content":"Description The INotifiable interface allows you to create components that can be asynchronously notified.\nImportant points\n The notification can include an optional argument that describes an occurred event.  Instance methods NotifyAsync Notifies the component about an occured event.\n Task NotifyAsync(string correlationId, Parameters args)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. args: Parameters - notification arguments.  Examples class MyComponent: INotifable { ... public void Notify(string correlationId, Parameters args) { Console.WriteLine(\u0026#34;Occured event \u0026#34; + args.GetAsString(\u0026#34;event\u0026#34;)); } } var myComponent = new MyComponent(); myComponent.Notify(\u0026#34;123\u0026#34;, Parameters.FromTuples(\u0026#34;event\u0026#34;, \u0026#34;Test Event\u0026#34;)); See also   Notifier   IExecutable   ","description":"Interface that allows you to create components that can be asynchronously notified.\n","image":null,"permalink":"/net/commons/run/inotifiable/","subtitle":null,"tags":null,"title":"INotifiable"},{"content":"Description The INotifiable interface allows you to create components that can be asynchronously notified.\nImportant points\n The notification can include an optional argument that describes an occurred event.  Instance methods notify Notifies the component about an occured event.\n notify(correlationId: string, args: Parameters): void\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. args: Parameters - notification arguments.  Examples class MyComponent implements INotifable { ... public notify(correlationId: string, args: Parameters): void { console.log(\u0026#34;Occured event \u0026#34; + args.getAsString(\u0026#34;event\u0026#34;)); } } let myComponent = new MyComponent(); myComponent.notify(\u0026#34;123\u0026#34;, Parameters.fromTuples(\u0026#34;event\u0026#34;, \u0026#34;Test Event\u0026#34;)); See also   Notifier   IExecutable   ","description":"Interface that allows you to create components that can be asynchronously notified.\n","image":null,"permalink":"/node/commons/run/inotifiable/","subtitle":null,"tags":null,"title":"INotifiable"},{"content":"Description The INotifiable interface allows you to create components that can be asynchronously notified.\nImportant points\n The notification can include an optional argument that describes an occurred event.  Instance methods notify Notifies the component about an occured event.\n notify(correlation_id: Optional[str], args: Parameters)\n  correlation_id: Optional[str] - (optional) transaction id to trace execution through the call chain. args: Parameters - notification arguments.  Examples class MyComponent(INotifable): ... def notify(correlationId, args): print(\u0026#34;Occured event \u0026#34; + args.get_as_string(\u0026#34;event\u0026#34;)) my_component = MyComponent() my_component.notify(\u0026#34;123\u0026#34;, Parameters.from_tuples(\u0026#34;event\u0026#34;, \u0026#34;Test Event\u0026#34;)); See also   Notifier   IExecutable   ","description":"Interface that allows you to create components that can be asynchronously notified.\n","image":null,"permalink":"/python/commons/run/inotifiable/","subtitle":null,"tags":null,"title":"INotifiable"},{"content":"Description The InstrumentTiming class allows you to create logs, countes and timings for methods that call Instrument.\nConstructors NewInstrumentTiming Creates a new instance of InstrumentTiming.\n NewInstrumentTiming(correlationId string, name string, verb string, logger ILogger, counters ICounters, counterTiming CounterTiming, traceTiming TraceTiming) *InstrumentTiming\n  correlationId: string - transaction id used to trace execution through the call chain. name: string - name verb: string - verb or \u0026lsquo;call\u0026rsquo; logger: ILogger - logger counters: ICounters - counters counterTiming: CounterTiming - counter traceTiming: TraceTiming - time tracer  Methods EndFailure Manages a failed service end.\n (c *InstrumentTiming) EndFailure(err error)\n  err: error - exception  EndTiming Ends the service.\n (c *InstrumentTiming) EndTiming(err error)\n  err: error - exception  EndSuccess Manages a successful service end.\n (c *InstrumentTiming) EndSuccess()\n ","description":"Creates logs, counters and timings for methods that call  Instrument.\n","image":null,"permalink":"/golang/rpc/services/instrument_timing/","subtitle":null,"tags":null,"title":"InstrumentTiming"},{"content":"Description The InstrumentTiming class allows you to create logs, countes and timings for methods that call instrument.\nConstructors Creates a new instance of InstrumentTiming.\n public constructor((correlationId: string, name: string, verb: string, logger: ILogger, counters: ICounters, counterTiming: CounterTiming, traceTiming: TraceTiming)\n  correlationId: string - transaction id used to trace execution through the call chain. name: string - name verb: string - verb or \u0026lsquo;call\u0026rsquo; logger: ILogger - logger counters: ICounters - counters counterTiming: CounterTiming - counter traceTiming: TraceTiming - time tracer  Instance methods endFailure Manages a failed service end.\n endFailure(err: Error): void\n  err: Error - exception  endTiming Ends the service.\n endTiming(err?: Error): void\n  err: Error - exception  endSuccess Manages a successful service end.\n endSuccess(): void\n ","description":"Creates logs, counters and timings for methods that call  instrument.\n","image":null,"permalink":"/net/rpc/services/instrument_timing/","subtitle":null,"tags":null,"title":"InstrumentTiming"},{"content":"Description The InstrumentTiming class allows you to create logs, countes and timings for methods that call instrument.\nConstructors Creates a new instance of InstrumentTiming.\n public constructor((correlationId: string, name: string, verb: string, logger: ILogger, counters: ICounters, counterTiming: CounterTiming, traceTiming: TraceTiming)\n  correlationId: string - transaction id used to trace execution through the call chain. name: string - name verb: string - verb or \u0026lsquo;call\u0026rsquo; logger: ILogger - logger counters: ICounters - counters counterTiming: CounterTiming - counter traceTiming: TraceTiming - time tracer  Instance methods endFailure Manages a failed service end.\n endFailure(err: Error): void\n  err: Error - exception  endTiming Ends the service.\n endTiming(err?: Error): void\n  err: Error - exception  endSuccess Manages a successful service end.\n endSuccess(): void\n ","description":"Creates logs, counters and timings for methods that call  instrument.\n","image":null,"permalink":"/node/rpc/services/instrument_timing/","subtitle":null,"tags":null,"title":"InstrumentTiming"},{"content":"Description The InstrumentTiming class allows you to create logs, countes and timings for methods that call _instrument.\nConstructors Creates a new instance of InstrumentTiming.\n InstrumentTiming(correlation_id: Optional[str], name: str, verb: str, logger: ILogger, counters: ICounters, counter_timing: Optional[CounterTiming], trace_timing: Optional[TraceTiming])\n  correlation_id: Optional[str] - transaction id used to trace execution through the call chain. name: str - name verb: str - verb or \u0026lsquo;call\u0026rsquo; logger: ILogger - logger counters: ICounters - counters counter_timing: Optional[CounterTiming] - counter trace_timing: Optional[TraceTiming] - time tracer  Instance methods end_failure Manages a failed service end.\n end_failure(err: Exception)\n  err: Exception - exception  end_timing Ends the service.\n end_timing(err: Exception = None)\n  err: Exception - TODO add description  end_success Manages a successful service end.\n end_success()\n ","description":"Creates logs, counters and timings for methods that call  _instrument.\n","image":null,"permalink":"/python/rpc/services/instrument_timing/","subtitle":null,"tags":null,"title":"InstrumentTiming"},{"content":"Description The IntegerConverter class allows you to convert arbitrary values into integers using the following extended conversion rules:\n Strings are converted to floats, then to integers DateTime: total number of milliseconds since unix epoсh Boolean: 1 for true and 0 for False  Methods toInteger Converts value into integer or returns 0 when conversion is not possible.\nSee LongConverter.ToLong,\nLongConverter.ToLongWithDefault\n ToInteger(value interface{}) int\n  value: interface{} - value to convert. returns: int - integer value or 0 when conversion is not supported.  ToIntegerWithDefault Converts value into integer or returns default value when conversion is not possible. See LongConverter.ToLongWithDefault,\nLongConverter.ToNullableLong\n ToIntegerWithDefault(value interface{}, defaultValue int) int\n  value: interface{} - value to convert. defaultValue: int - default value. returns: int - integer value or default when conversion is not supported.  ToNullableInteger Converts value into integer or returns nil when conversion is not possible. See LongConverter.toNullableLong\n ToNullableInteger(value interface{}) *int\n  value: interface{} - value to convert. returns: *int - integer value or nil when conversion is not supported.  ToUInteger Converts value into unsigned integer or returns 0 when conversion is not possible.\n ToUInteger(value interface{}) uint\n  value: interface{} - value to convert. returns: uint - integer value or 0 when conversion is not supported.  ToUIntegerWithDefault Converts value into unsigned integer or returns the default value when conversion is not possible.\n ToUIntegerWithDefault(value interface{}, defaultValue uint) uint\n  value: interface{} - value to convert. defaultValue: uint - default value. returns: uint - integer value or default when conversion is not supported.  ToNullableUInteger Converts value into integer or returns nil when conversion is not possible. See LongConverter.toNullableLong\n ToNullableUInteger(value interface{}) *uint\n  value: interface{} - value to convert. returns: *uint - integer value or nil when conversion is not supported.  Examples value1 := convert.IntegerConverter.ToNullableInteger(\u0026#34;ABC\u0026#34;) value2 := convert.IntegerConverter.ToNullableInteger(\u0026#34;123.456\u0026#34;) value3 := convert.IntegerConverter.ToNullableInteger(true) value4 := convert.IntegerConverter.ToNullableInteger(time.Now()) fmt.Println(value1) // \u0026lt;nil\u0026gt; fmt.Println(*value2) // 123 fmt.Println(*value3) // 1 fmt.Println(*value4) // current milliseconds (e.g. 1566333428)  ","description":"The IntegerConverter class allows you to convert arbitrary values into integers using extended conversion rules.\n","image":null,"permalink":"/golang/commons/convert/integer_converter/","subtitle":null,"tags":null,"title":"IntegerConverter"},{"content":"Description The IntegerConverter class allows you to convert arbitrary values to integers using the following extended conversion rules:\n Strings are converted to floats, then to integers DateTime: total number of milliseconds since unix epoсh Boolean: 1 for True and 0 for False  Static methods ToInteger Converts value into integer or returns 0 when the conversion is not possible.\nSee LongConverter.ToLong,\nLongConverter.ToLongWithDefault\n public static int ToInteger(object value)\n  value: object - value to convert. returns: int - integer value or 0 when the conversion is not supported.  ToIntegerWithDefault Converts value into integer or returns a given default value when the conversion is not possible. See LongConverter.ToLongWithDefault,\nLongConverter.ToNullableLong\n public static int ToIntegerWithDefault(object value, int defaultValue)\n  value: object - the value to convert. defaultValue: int - the default value. returns: int - integer value or default when the conversion is not supported.  ToNullableInteger Converts value into integer or returns null when conversion is not possible. See LongConverter.ToNullableLong\n public static int ToNullableInteger(object value)\n  value: object - the value to convert. returns: int - integer value or null when the conversion is not supported.  Examples var value1 = IntegerConverter.ToNullableInteger(\u0026#34;ABC\u0026#34;); // Result: null var value2 = IntegerConverter.ToNullableInteger(\u0026#34;123.456\u0026#34;); // Result: 123.456 var value3 = IntegerConverter.ToNullableInteger(true); // Result: 1 var value4 = IntegerConverter.ToNullableInteger(new Date()); // Result: current milliseconds  ","description":"The IntegerConverter class allows you to convert arbitrary values to integers using extended conversion rules.\n","image":null,"permalink":"/net/commons/convert/integer_converter/","subtitle":null,"tags":null,"title":"IntegerConverter"},{"content":"Description The IntegerConverter class allows you to convert arbitrary values into integers using the following extended conversion rules:\n Strings are converted to floats, then to integers DateTime: total number of milliseconds since unix epoсh Boolean: 1 for True and 0 for False  Static methods toInteger Converts a value into an integer or returns 0 when the conversion is not possible.\nSee LongConverter.toLong,\nLongConverter.toLongWithDefault\n public static toInteger(value: any): number\n  value: any - value to convert. returns: number - integer value or 0 when the conversion is not supported.  toIntegerWithDefault Converts a value into an integer or returns a given default value when the conversion is not possible. See LongConverter.toLongWithDefault,\nLongConverter.toNullableLong\n public static toIntegerWithDefault(value: any, defaultValue: number): number\n  value: any - value to convert. defaultValue: number - default value. returns: number - integer value or given default when the conversion is not supported.  toNullableInteger Converts a value into an integer or returns null when the conversion is not possible. See LongConverter.toNullableLong\n public static toNullableInteger(value: any): number\n  value: any - value to convert. returns: number - integer value or null when the conversion is not supported.  Examples let value1 = IntegerConverter.toNullableInteger(\u0026#34;ABC\u0026#34;); // Result: null let value2 = IntegerConverter.toNullableInteger(\u0026#34;123.456\u0026#34;); // Result: 123 let value3 = IntegerConverter.toNullableInteger(true); // Result: 1 let value4 = IntegerConverter.toNullableInteger(new Date()); // Result: current milliseconds (E.g. 1619869474907)  ","description":"The IntegerConverter class allows you to convert arbitrary values into integers using extended conversion rules.\n","image":null,"permalink":"/node/commons/convert/integer_converter/","subtitle":null,"tags":null,"title":"IntegerConverter"},{"content":"Description The IntegerConverter class allows you to convert arbitrary values into integers using the following extended conversion rules:\n Strings are converted to floats, then to integers DateTime: total number of milliseconds since unix epoсh Boolean: 1 for True and 0 for False  Static methods to_integer Converts value into integer or returns 0 when conversion is not possible.\nSee LongConverter.toLong,\nLongConverter.to_long_with_default\n static toInteger(value: Any): int\n  value: Any - the value to convert. returns: int - integer value or 0 when conversion is not supported.  to_integer_with_default Converts value into integer or returns default value when conversion is not possible. See LongConverter.to_long_with_default,\nLongConverter.to_nullable_long\n static to_integer_with_default(value: Any, default_value: int): int\n  value: Any - the value to convert. default_value: int - the default value. returns: int - integer value or default when conversion is not supported.  to_nullable_integer Converts value into integer or returns None when conversion is not possible. See LongConverter.to_nullable_long\n static to_nullable_integer(value: Any): int\n  value: Any - the value to convert. returns: int - integer value or None when conversion is not supported.  Examples value1 = IntegerConverter.to_nullable_integer(\u0026#34;ABC\u0026#34;) # Returns None value2 = IntegerConverter.to_nullable_integer(\u0026#34;123.456\u0026#34;) # Returns 123 value3 = IntegerConverter.to_nullable_integer(True) # Returns 1 value4 = IntegerConverter.to_nullable_integer(datetime.datetime.now()) # Returns current milliseconds (E.g. 1619867293411) ","description":"The IntegerConverter class allows you to convert arbitrary values into integers using extended conversion rules.\n","image":null,"permalink":"/python/commons/convert/integer_converter/","subtitle":null,"tags":null,"title":"IntegerConverter"},{"content":"Description The InterceptedCommand allows you to implement a command wrapped by an interceptor. Thus, it allows you to build command call chains, where the interceptor can alter execution and delegate calls to a next command, which can then be intercepted or not.\nConstructors NewInterceptedCommand Creates a new InterceptedCommand, which serves as a link in an execution chain. Contains information about the interceptor that is being used and the next command in the chain.\n NewInterceptedCommand(interceptor ICommandInterceptor, next ICommand) *InterceptedCommand\n  interceptor: ICommandInterceptor - interceptor that is intercepting the command. next: ICommand - (link to) the next command in the command\u0026rsquo;s execution chain.  Methods Execute Executes the next command in the execution chain using the given parameters (arguments).\nSee Parameters\n (c *InterceptedCommand) Execute(correlationId string, args *run.Parameters) (result interface{}, err error)\n  correlationId: string - unique transaction id used to trace calls across components. args: *run.Parameters - parameters (arguments) to pass to the command for execution. returns: (result interface{}, err error) - execution result  Name Returns string the name of the command that is being intercepted.\n (c *InterceptedCommand) Name() string\n  returns: string - name of the command that is being intercepted.  Validate Validates the parameters (arguments) that are to be passed to the command that is next in the execution chain.\nSee Parameters, ValidationResult\n (c *InterceptedCommand) Validate(args *run.Parameters) []*validate.ValidationResult\n  args: *run.Parameters - parameters (arguments) to validate for the next command. returns: []*validate.ValidationResult - array of ValidationResults.  Examples type CommandLogger { msg string } func (cl * CommandLogger) Name(command ICommand) string { return command.Name(); } func (cl * CommandLogger) Execute(correlationId string, command ICommand, args Parameters) (res interface{}, err error){ fmt.Println(\u0026#34;Executed command \u0026#34; + command.Name()); return command.Execute(correlationId, args); } func (cl * CommandLogger) Validate(command: ICommand, args: Parameters): ValidationResult[] { return command.Validate(args); } logger := CommandLogger{mgs:\u0026#34;CommandLoger\u0026#34;}; loggedCommand = NewInterceptedCommand(logger, command); // Each called command will output: Executed command \u0026lt;command name\u0026gt;  See also   ICommand   ICommandInterceptor   ","description":"Implements a [command](../icommand) wrapped by an interceptor.\n","image":null,"permalink":"/golang/commons/commands/intercepted_command/","subtitle":null,"tags":null,"title":"InterceptedCommand"},{"content":"Inherits: ICommand\nDescription The InterceptedCommand allows you to implement a command wrapped by an interceptor. Thus, it allows you to build command call chains, where the interceptor can alter execution and delegate calls to a next command, which can then be intercepted or not.\nConstructors Creates a new InterceptedCommand, which serves as a link in an execution chain. Contains information about the interceptor that is being used and the next command in the chain.\n public InterceptedCommand(ICommandInterceptor interceptor, ICommand next)\n  interceptor: ICommandInterceptor - interceptor that is intercepting the command. next: ICommand - (link to) next command in the command\u0026rsquo;s execution chain.  Properties Name Gets the command name.\n public string Name { get; }\n Schema Gets the command schema.\n public Schema Schema { get; }\n Instance methods ExecuteAsync Executes the next command in the execution chain using the given parameters (arguments).\nSee Parameters\n public Task\u0026lt;object\u0026gt; ExecuteAsync(string correlationId, Parameters args)\n  correlationId: string - unique transaction id used to trace calls across components. args: Parameters - parameters (arguments) to pass to the command for execution. returns: Task\u0026lt;object\u0026gt; - execution result  Validate Validates the parameters (arguments) that are to be passed to the command that is next in the execution chain.\nSee Parameters, ValidationResult\n public IList\u0026lt;ValidationResult\u0026gt; Validate(Parameters args)\n  args: Parameters - parameters (arguments) used to validate for the next command. returns: IList\u0026lt;ValidationResult\u0026gt; - array of ValidationResults.  Examples public class CommandLogger: ICommandInterceptor { public String GetName(ICommand command) { return command.GetName(); } public Task\u0026lt;object\u0026gt; ExecuteAsync(string correlationId, ICommand command, Parameters args) { Console.WriteLine(\u0026#34;Executed command \u0026#34; + command.getName()); return command.ExecuteAsync(correlationId, args); } private IList\u0026lt;ValidationResult\u0026gt; validate(ICommand command, Parameters args) { return command.validate(args); } } var logger = new CommandLogger(); var loggedCommand = new InterceptedCommand(logger, command); // Each called command will output: Executed command \u0026lt;command name\u0026gt;  See also   ICommand   ICommandInterceptor   ","description":"Implements a [command](../icommand) wrapped by an interceptor.\n","image":null,"permalink":"/net/commons/commands/intercepted_command/","subtitle":null,"tags":null,"title":"InterceptedCommand"},{"content":"Implements: ICommand\nDescription The InterceptedCommand allows you to implement a command wrapped by an interceptor. Thus, it allows you to build command call chains, where the interceptor can alter execution and delegate calls to a next command, which can then be intercepted or not.\nConstructors Creates a new InterceptedCommand, which serves as a link in an execution chain. Contains information about the interceptor that is being used and the next command in the chain.\n public constructor(interceptor: ICommandInterceptor, next: ICommand)\n  interceptor: ICommandInterceptor - interceptor that is intercepting the command. next: ICommand - (link to) the next command in the command\u0026rsquo;s execution chain.  Instance methods execute Executes the next command in the execution chain using the given parameters (arguments).\nSee Parameters\n public execute(correlationId: string, args: Parameters): Promise\u0026lt;any\u0026gt;\n  correlationId: string - unique transaction id used to trace calls across components. args: Parameters - parameters (arguments) to pass to the command for execution. returns: Promise\u0026lt;any\u0026gt; - execution result  getName Returns a string with the name of the command that is being intercepted.\n public getName(c): string\n  returns: string - name of the command that is being intercepted.  validate Validates the parameters (arguments) that are to be passed to the command that is next in the execution chain.\nSee Parameters, ValidationResult\n public validate(args: Parameters): ValidationResult[]\n  args: Parameters - parameters (arguments) to validate for the next command. returns: ValidationResult[] - array of ValidationResults.  Examples export class CommandLogger implements ICommandInterceptor { public getName(command: ICommand): string { return command.getName(); } public async execute(correlationId: string, command: ICommand, args: Parameters): Promise\u0026lt;any\u0026gt; { console.log(\u0026#34;Executed command \u0026#34; + command.getName()); await command.execute(correlationId, args); } private validate(command: ICommand, args: Parameters): ValidationResult[] { return command.validate(args); } } let logger = new CommandLogger(); let loggedCommand = new InterceptedCommand(logger, command); // Each called command will output: Executed command \u0026lt;command name\u0026gt;  See also   ICommand   ICommandInterceptor   ","description":"Implements a [command](../icommand) wrapped by an interceptor.\n","image":null,"permalink":"/node/commons/commands/intercepted_command/","subtitle":null,"tags":null,"title":"InterceptedCommand"},{"content":"Implements: ICommand\nDescription The InterceptedCommand allows you to implement a command wrapped by an interceptor. Thus, it allows you to build command call chains, where the interceptor can alter execution and delegate calls to a next command, which can then be intercepted or not.\nConstructors Creates a new InterceptedCommand, which serves as a link in an execution chain. Contains information about the interceptor that is being used and the next command in the chain.\n InterceptedCommand(interceptor: ICommandInterceptor, next: ICommand)\n  interceptor: ICommandInterceptor - the interceptor that is intercepting the command. next: ICommand - (link to) the next command in the command\u0026rsquo;s execution chain.  Instance methods execute Executes the next command in the execution chain using the given parameters (arguments).\nSee Parameters\n execute(correlation_id: Optional[str], args: Parameters): Any\n  correlation_id: Optional[str] - unique transaction id to trace calls across components. args: Parameters - the parameters (arguments) to pass to the command for execution. returns: Any - the execution result  get_name Gets the command_name name.\n get_name(): str\n  returns: str - the name of the command that is being intercepted.  validate Validates the parameters (arguments) that are to be passed to the command that is next in the execution chain.\nSee Parameters, ValidationResult\n validate(args: Parameters): List[ValidationResult]\n  args: Parameters - the parameters (arguments) to validate for the next command. returns: List[ValidationResult] - an array of ValidationResults.  Examples class CommandLogger(ICommandInterceptor): def get_name(self, command_name): return command_name.get_name() def execute(): # do something def validate(): # do something logger = new CommandLogger() logged_command = InterceptedCommand(logger, command) # Each called command will output: Executed command \u0026lt;command name\u0026gt; See also   ICommand   ICommandInterceptor   ","description":"Implements a [command](../icommand) wrapped by an interceptor.\n","image":null,"permalink":"/python/commons/commands/intercepted_command/","subtitle":null,"tags":null,"title":"InterceptedCommand"},{"content":"Description TODO: add description\nProperties Route TODO: add description\n public string Route { get; set; }\n Action TODO: add description\n public Func\u0026lt;HttpRequest, HttpResponse, ClaimsPrincipal, RouteData, Func\u0026lt;HttpRequest, HttpResponse, ClaimsPrincipal, RouteData, Task\u0026gt;, Task\u0026gt; Action { get; set; }\n ","description":"TODO: add description\n","image":null,"permalink":"/net/rpc/services/interceptor/","subtitle":null,"tags":null,"title":"Interceptor"},{"content":"Description The InternalError class is used to manage errors caused by programming mistakes.\nConstructors NewInternalError Creates an error instance and assigns its values.\n NewInternalError(correlationId, code, message string) *ApplicationError\n  correlationId: string - (optional) unique transaction id used to trace execution through the call chain. code: string - (optional) unique error code. Default: \u0026ldquo;UNKNOWN\u0026rdquo; message: string - (optional) a human-readable description of the error.  ","description":"Errors caused by programming mistakes.\n","image":null,"permalink":"/golang/commons/errors/internal_error/","subtitle":null,"tags":null,"title":"InternalError"},{"content":"Inherits: ApplicationException\nDescription The InternalException class is used to manage errors caused by programming mistakes.\nConstructors Creates an error instance and assigns its values.\n public InternalException(string correlationId = null, string code = null, string message = null)\n  correlationId: string - (optional) unique transaction id to trace execution through the call chain. code: string - (optional) unique error code. Default: \u0026ldquo;UNKNOWN\u0026rdquo; message: string - (optional) human-readable description of the error.  Creates an error instance with error message\n public InternalException(string message)\n  message: string - human-readable description of the error.  Creates an error instance and assigns its values.\n public InternalException()\n Creates an error instance and assigns its values.\n public InternalException(Exception innerException)\n  innerException: Exception - error object  Creates an error instance by processing native C# Exceptions.\n protected InternalException(SerializationInfo info, StreamingContext context)\n  info: SerializationInfo - serialized information containing the serialized object data about the exception being thrown. context: StreamingContext - streaming context containing contextual information about the source or destination.  ","description":"Errors caused by programming mistakes.\n","image":null,"permalink":"/net/commons/errors/internal_exception/","subtitle":null,"tags":null,"title":"InternalException"},{"content":"Extends: ApplicationException\nDescription The InternalException class is used to manage errors caused by programming mistakes.\nConstructors Creates an error instance and assigns its values.\n public constructor(correlation_id: string = null, code: string = null, message: string = null)\n  correlation_id: string - (optional) unique transaction id used to trace execution through a call chain. code: string - (optional) unique error code. Default: \u0026ldquo;UNKNOWN\u0026rdquo; message: string - (optional) human-readable description of the error.  ","description":"Errors caused by programming mistakes.\n","image":null,"permalink":"/node/commons/errors/internal_exception/","subtitle":null,"tags":null,"title":"InternalException"},{"content":"Implements: ApplicationException\nDescription The InternalException class is used to manage errors caused by programming mistakes.\nConstructors Creates an error instance and assigns its values.\n InternalException(correlation_id: Optional[str] = None, code: str = None, message: str = None)\n  correlation_id: Optional[str] - (optional) a unique transaction id to trace execution through call chain. code: str - (optional) a unique error code. Default: \u0026ldquo;UNKNOWN\u0026rdquo; message: str - (optional) a human-readable description of the error.  ","description":"Errors caused by programming mistakes.\n","image":null,"permalink":"/python/commons/errors/internal_exception/","subtitle":null,"tags":null,"title":"InternalException"},{"content":"Implements: ITokenizerState\nDescription The INumberState interface is used by tokenizer states that process numbers, such as Integers, Floats, HexDex, etc.\n","description":"Defines interface for tokenizer state that processes numbers - Integers, Floats, HexDec.\n","image":null,"permalink":"/node/expressions/tokenizers/inumber_state/","subtitle":null,"tags":null,"title":"INumberState"},{"content":"Description The InvalidStateError class is used to manage errors related to calling opertaions that require the component to be in a specific state. For example, business calls when the component is not ready.\nConstructors NewInvalidStateError Creates an error instance and assigns its values.\n NewInvalidStateError(correlationId, code, message string) *ApplicationError\n  correlationId: string - (optional) unique transaction id used to trace execution through the call chain. code: string - (optional) unique error code. Default: \u0026ldquo;UNKNOWN\u0026rdquo; message: string - (optional) a human-readable description of the error.  ","description":"Errors related to calling operations, which require the component to be in a specific state. For instance: business calls when the component is not ready.\n","image":null,"permalink":"/golang/commons/errors/invalid_state_error/","subtitle":null,"tags":null,"title":"InvalidStateError"},{"content":"Inherits: ApplicationException\nDescription The InvalidStateException class is used to manage errors related to calling opertaions that require the component to be in a specific state. For example, business calls when the component is not reay.\nConstructors Creates an error instance and assigns its values.\n public InvalidStateException(string correlationId = null, string code = null, string message = null)\n  correlationId: string - (optional) unique transaction id used to trace execution through the call chain. code: string - (optional) unique error code. Default: \u0026ldquo;UNKNOWN\u0026rdquo; message: string - (optional) human-readable description of the error.  Creates an error instance with error message.\n public InvalidStateException(string message)\n  message: string - human-readable description of the error.  Creates an error instance and assigns its values.\n public InvalidStateException(Exception innerException)\n  innerException: Exception - error object  Creates an error instance by processing native C# Exceptions.\n protected InvalidStateException(SerializationInfo info, StreamingContext context)\n  info: SerializationInfo - serialized information containing the serialized object data about the exception being thrown. context: StreamingContext - streaming context containing contextual information about the source or destination.  ","description":"Errors related to calling operations, which require the component to be in a specific state. For instance: business calls when the component is not ready.\n","image":null,"permalink":"/net/commons/errors/invalid_state_exception/","subtitle":null,"tags":null,"title":"InvalidStateException"},{"content":"Extends: ApplicationException\nDescription The InvalidStateException class is used to manage errors related to calling operations that require the component to be in a specific state. For example, business calls when the component is not ready.\nConstructors Creates an error instance and assigns its values.\n public constructor(correlation_id: string = null, code: string = null, message: string = null)\n  correlation_id: string - (optional) unique transaction id used to trace execution through a call chain. code: string - (optional) unique error code. Default: \u0026ldquo;UNKNOWN\u0026rdquo;. message: string - (optional) human-readable description of the error.  ","description":"Errors related to calling operations, which require the component to be in a specific state. For instance: business calls when the component is not ready.\n","image":null,"permalink":"/node/commons/errors/invalid_state_exception/","subtitle":null,"tags":null,"title":"InvalidStateException"},{"content":"Implements: ApplicationException\nDescription The InvalidStateException class is used to manage errors related to calling opertaions that require the component to be in a specific state. For example, business calls when the component is not reay.\nConstructors Creates an error instance and assigns its values.\n InvalidStateException(correlation_id: Optional[str] = None, code: str = None, message: str = None)\n  correlation_id: Optional[str] - (optional) a unique transaction id to trace execution through call chain. code: str - (optional) a unique error code. Default: \u0026ldquo;UNKNOWN\u0026rdquo; message: str - (optional) a human-readable description of the error.  ","description":"Errors related to calling operations, which require the component to be in a specific state. For instance: business calls when the component is not ready.\n","image":null,"permalink":"/python/commons/errors/invalid_state_exception/","subtitle":null,"tags":null,"title":"InvalidStateException"},{"content":"Description The InvocationError class is used to manage errors returned by remote services or by the network during call attempts.\nConstructors NewInvocationError Creates an error instance and assigns its values.\n NewInvocationError(correlationId, code, message string) *ApplicationError\n  correlationId: string - (optional) unique transaction id used to trace execution through the call chain. code: string - (optional) unique error code. Default: \u0026ldquo;UNKNOWN\u0026rdquo; message: string - (optional) a human-readable description of the error.  ","description":"Errors returned by remote services or by the network during call attempts.\n","image":null,"permalink":"/golang/commons/errors/invocation_error/","subtitle":null,"tags":null,"title":"InvocationError"},{"content":"Inherits: ApplicationException\nDescription The InvocationException class is used to manage errors returned by remote services or by the network during call attempts.\nConstructors Creates an error instance and assigns its values.\n public InvocationException(string correlationId = null, string code = null, string message = null)\n  correlationId: string - (optional) unique transaction id used to trace execution through the call chain. code: string - (optional) unique error code. Default: \u0026ldquo;UNKNOWN\u0026rdquo; message: string - (optional) human-readable description of the error.  Creates an error instance with error message\n public InvocationException(string message)\n  message: string - human-readable description of the error.  Creates an error instance and assigns its values.\n public InvocationException(Exception innerException)\n  innerException: Exception - error object  Creates an error instance by processing native C# Exceptions.\n protected InvocationException(SerializationInfo info, StreamingContext context)\n  info: SerializationInfo - serialized information containing the serialized object data about the exception being thrown. context: StreamingContext - streaming context containing contextual information about the source or destination.  ","description":"Errors returned by remote services or by the network during call attempts.\n","image":null,"permalink":"/net/commons/errors/invocation_exception/","subtitle":null,"tags":null,"title":"InvocationException"},{"content":"Extends: ApplicationException\nDescription The InvocationException class is used to manage errors returned by remote services or by the network during call attempts.\nConstructors Creates an error instance and assigns its values.\n public constructor(correlation_id: string = null, code: string = null, message: string = null)\n  correlation_id: string - (optional) unique transaction id to trace execution through a call chain. code: string - (optional) unique error code. Default: \u0026ldquo;UNKNOWN\u0026rdquo;. message: string - (optional) human-readable description of the error.  ","description":"Errors returned by remote services or by the network during call attempts.\n","image":null,"permalink":"/node/commons/errors/invocation_exception/","subtitle":null,"tags":null,"title":"InvocationException"},{"content":"Implements: ApplicationException\nDescription The InvocationException class is used to manage errors returned by remote services or by the network during call attempts.\nConstructors Creates an error instance and assigns its values.\n InvocationException(correlation_id: Optional[str] = None, code: str = None, message: str = None)\n  correlation_id: Optional[str] - (optional) a unique transaction id to trace execution through call chain. code: str - (optional) a unique error code. Default: \u0026ldquo;UNKNOWN\u0026rdquo; message: str - (optional) a human-readable description of the error.  ","description":"Errors returned by remote services or by the network during call attempts.\n","image":null,"permalink":"/python/commons/errors/invocation_exception/","subtitle":null,"tags":null,"title":"InvocationException"},{"content":"Impements: IClosable\nDescription The IOpenable interface allows you to create components with explicit opening and closing.\nImportant points\n For components that perform opening on demand consider using IClosable interface instead.  Methods IsOpen Checks if the component is opened.\n IsOpen() bool\n  returns: bool - true if the component has been opened and false otherwise.  open Opens the component.\n Open(correlationId string) error\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. returns: error - error returned if not opened  Examples type MyPersistence { _client interface{} } func (mp* MyPersistence)IsOpen() bool { return mp._client != nil; } (mp* MyPersistence) Open(correlationId: string) error { if (mp.isOpen()) { return nil; } } (mp* MyPersistence) Close(correlationId: string) { if (mp._client != nil) { mp._client.close(); mp._client = nil; } } See also   IOpenable   Opener   ","description":"Interface that allows you to create components with explicit opening and closing.\n","image":null,"permalink":"/golang/commons/run/iopenable/","subtitle":null,"tags":null,"title":"IOpenable"},{"content":"Inherits: IClosable\nDescription The IOpenable interface allows you to create components with explicit opening and closing.\nImportant points\n For components that perform opening on demand consider using IClosable interface instead.  Instance methods IsOpen Checks if the component is opened.\n bool IsOpen()\n  returns: bool - true if the component has been opened and false otherwise.  OpenAsync Opens the component.\n Task OpenAsync(string correlationId)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain.  Examples class MyPersistence: IOpenable { private object _client; ... public bool IsOpen() { return this._client != null; } public void Open(string correlationId) { if (this.isOpen()) { return; } ... } public void Close(string correlationId) { if (this._client != null) { this._client.Close(); this._client = null; } } ... } See also   IOpenable   Opener   ","description":"Interface that allows you to create components with explicit opening and closing.\n","image":null,"permalink":"/net/commons/run/iopenable/","subtitle":null,"tags":null,"title":"IOpenable"},{"content":"Extends: IClosable\nDescription The IOpenable interface allows you to create components with explicit opening and closing.\nImportant points\n For components that perform opening on demand consider using IClosable interface instead.  Instance methods isOpen Checks if the component is opened.\n public isOpen(): boolean\n  returns: boolean - true if the component has been opened and false otherwise.  open Opens the component.\n open(correlationId: string): Promise\u0026lt;void\u0026gt;\n  correlationId: string - (optional) transaction id used to trace execution through the call chain.  Examples class MyPersistence implements IOpenable { private _client: any; ... public isOpen(): boolean { return this._client != null; } public async open(correlationId: string): Promise\\\u0026lt;void\\\u0026gt; { if (this.isOpen()) { return; } ... } public async close(correlationId: string): Promise\\\u0026lt;void\\\u0026gt; { if (this._client != null) { this._client.close(); this._client = null; } } ... } See also   IOpenable   Opener   ","description":"Interface that allows you to create components with explicit opening and closing.\n","image":null,"permalink":"/node/commons/run/iopenable/","subtitle":null,"tags":null,"title":"IOpenable"},{"content":"Implements: IClosable\nDescription The IOpenable interface allows you to create components with explicit opening and closing.\nImportant points\n For components that perform opening on demand consider using IClosable interface instead.  Instance methods is_open Checks if the component is opened.\n is_open(): bool\n  returns: bool - true if the component has been opened and false otherwise.  open Opens the component.\n open(correlation_id: Optional[str])\n  correlation_id: Optional[str] - (optional) transaction id to trace execution through call chain.  Examples class MyPersistence(IOpenable): _client = None ... def is_open(self): return self._client is not None def open(correlation_id): if self.is_opened() return ... def close(self, correlation_id): if self._client is not None: self._client.close() self._client = None ... See also   IOpenable   Opener   ","description":"Interface that allows you to create components with explicit opening and closing.\n","image":null,"permalink":"/python/commons/run/iopenable/","subtitle":null,"tags":null,"title":"IOpenable"},{"content":"Description The IParameterized interface allows you to create components with execution parameters.\nMethods SetParameters Sets execution parameters.\n SetParameters(parameters *Parameters)\n  parameters: *Parameters - execution parameters.  See also   IConfigurable   ","description":"Interface that allows you to create components with execution parameters.\n","image":null,"permalink":"/golang/commons/run/iparameterized/","subtitle":null,"tags":null,"title":"IParameterized"},{"content":"Description The IParameterized interface allows you to create components with execution parameters.\nInstance methods SetParameters Sets execution parameters.\n void SetParameters(Parameters parameters)\n  parameters: Parameters - execution parameters.  See also   IConfigurable   ","description":"Interface that allows you to create components with execution parameters.\n","image":null,"permalink":"/net/commons/run/iparameterized/","subtitle":null,"tags":null,"title":"IParameterized"},{"content":"Description The IParameterized interface allows you to create components with execution parameters.\nInstance methods setParameters Sets execution parameters.\n setParameters(parameters: Parameters): void\n  parameters: Parameters - execution parameters.  See also   IConfigurable   ","description":"Interface that allows you to create components with execution parameters.\n","image":null,"permalink":"/node/commons/run/iparameterized/","subtitle":null,"tags":null,"title":"IParameterized"},{"content":"Description The IParameterized interface allows you to create components with execution parameters.\nInstance methods set_parameters Sets execution parameters.\n set_parameters(parameters: Parameters)\n  parameters: Parameters - execution parameters.  See also   IConfigurable   ","description":"Interface that allows you to create components with execution parameters.\n","image":null,"permalink":"/python/commons/run/iparameterized/","subtitle":null,"tags":null,"title":"IParameterized"},{"content":"Description The IPartialUpdater interface is used by data processing components to update data items partially.\nMethods UpdatePartially Updates only few selected fields in a data item.\n UpdatePartially(correlation_id string, id interface{}, data *data.AnyValueMap) (item interface{}, err error)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. id: interface{} - id of the data item to be updated. data: *data.AnyValueMap - map with fields to be updated. returns: (item interface{}, err error) - updated item  ","description":"Interface for data processing components to update data items partially.\n","image":null,"permalink":"/golang/data/persistence/ipartial_updater/","subtitle":null,"tags":null,"title":"IPartialUpdater"},{"content":"Description The IPartialUpdater interface is used by data processing components to update data items partially.\nInstance methods UpdatePartially Updates only few selected fields in a data item.\n Task\u0026lt;T\u0026gt; UpdatePartially(string correlation_id, K id, AnyValueMap data)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. id: K - id of the data item to be updated. data: AnyValueMap - map with fields to be updated. returns: Task\u0026lt;T\u0026gt; - updated item  ","description":"Interface for data processing components to update data items partially.\n","image":null,"permalink":"/net/data/core/ipartial_updater/","subtitle":null,"tags":null,"title":"IPartialUpdater\u003cT, in K\u003e"},{"content":"Description The IPartialUpdater interface is used by data processing components to update data items partially.\nInstance methods updatePartially Updates only few selected fields in a data item.\n updatePartially(correlationId: string, id: K, data: AnyValueMap): Promise\u0026lt;T\u0026gt;\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. id: K - id of the data item to be updated. data: AnyValueMap - map with fields to be updated. returns: Promise\u0026lt;T\u0026gt; - updated item  ","description":"Interface for data processing components to update data items partially.\n","image":null,"permalink":"/node/data/core/ipartial_updater/","subtitle":null,"tags":null,"title":"IPartialUpdater\u003cT, K\u003e"},{"content":"Description The IPartialUpdater interface is used by data processing components to update data items partially.\nInstance methods update_partially Updates only few selected fields in a data item.\n update_partially(correlation_id: Optional[str], id: Any, data: AnyValueMap): T\n  correlation_id: Optional[str] - (optional) transaction id used to trace execution through the call chain. id: Any - id of the data item to be updated. data: AnyValueMap - map with fields to be updated. returns: T - updated item  ","description":"Interface for data processing components to update data items partially.\n","image":null,"permalink":"/python/data/core/ipartial_updater/","subtitle":null,"tags":null,"title":"IPartialUpdater"},{"content":"Description This interface provides methods to get and set the properties of a class.\nInstance methods GetPropertyNames Gets all the property names.\n List\u0026lt;string\u0026gt; GetPropertyNames()\n  returns: List\u0026lt;string\u0026gt; - list with property names  GetProperty Gets a property\u0026rsquo;s value\n object GetProperty(string name)\n  name: string - property\u0026rsquo;s name returns: object - property\u0026rsquo;s value  SetProperty Sets the value of a property.\n void SetProperty(string name, object value)\n  name: string - property\u0026rsquo;s name value: object - property\u0026rsquo;s value  ","description":"This interface provides methods to get and set the properties of a class.\n","image":null,"permalink":"/net/commons/reflect/iproperties/","subtitle":null,"tags":null,"title":"IProperties"},{"content":"Description The IQuerablePageReader interface is used by data processing components that can query a page of data items.\nMethods GetPageByQuery Gets a page of data items using a query string.\n GetPageByQuery(correlation_id string, query string, paging *data.PagingParams, sort *data.SortParams) (page interface{}, err error)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. query: string - (optional) query string paging: *data.PagingParams - (optional) paging parameters sort: *data.SortParams - (optional) sorting parameters returns: (page interface{}, err error) - list of items  ","description":"Interface for data processing components that can query a page of data items.\n","image":null,"permalink":"/golang/data/persistence/iquerable_page_reader/","subtitle":null,"tags":null,"title":"IQuerablePageReader"},{"content":"Description Where T : class.\nThe IQuerablePageReader interface is used by data processing components that can query a page of data items.\nInstance methods GetPageByQueryAsync Gets a page of data items using a query string.\n Task\u0026lt;DataPage\u0026lt;T\u0026gt;\u0026gt; GetPageByQueryAsync(string correlationId, string query, PagingParams paging, SortParams sort)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. query: string - (optional) query string paging: PagingParams - (optional) paging parameters sort: SortParams - (optional) sorting parameters returns: Task\u0026lt;DataPage\u0026lt;T\u0026gt;\u0026gt; - list of items  ","description":"Interface for data processing components that can query a page of data items.\n","image":null,"permalink":"/net/data/core/iquerable_page_reader/","subtitle":null,"tags":null,"title":"IQuerablePageReader\u003cT\u003e"},{"content":"Description The IQuerablePageReader interface is used by data processing components that can query a page of data items.\nInstance methods getPageByQuery Gets a page of data items using a query string.\n getPageByQuery(correlationId: string, query: string, paging: PagingParams, sort: SortParams): Promise\u0026lt;DataPage\u0026lt;T\u0026gt;\u0026gt;\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. query: string - (optional) query string paging: PagingParams - (optional) paging parameters sort: SortParams - (optional) sorting parameters returns: Promise\u0026lt;DataPage\u0026lt;T\u0026gt;\u0026gt; - list of items  ","description":"Interface for data processing components that can query a page of data items.\n","image":null,"permalink":"/node/data/core/iquerable_page_reader/","subtitle":null,"tags":null,"title":"IQuerablePageReader\u003cT\u003e"},{"content":"Description The IQuerablePageReader interface is used by data processing components that can query a page of data items.\nInstance methods get_page_by_query Gets a page of data items using a query string.\n get_page_by_query(correlation_id: Optional[str], query: Optional[str], paging: Optional[PagingParams], sort: Optional[SortParams] = None): DataPage\n  correlation_id: Optional[str] - (optional) transaction id used to trace execution through the call chain. query: Optional[str] - (optional) query string paging: Optional[PagingParams] - (optional) paging parameters sort: Optional[SortParams] - (optional) sorting parameters returns: DataPage - list of items  ","description":"Interface for data processing components that can query a page of data items.\n","image":null,"permalink":"/python/data/core/iquerable_page_reader/","subtitle":null,"tags":null,"title":"IQuerablePageReader"},{"content":"Description The IQuerableReader interface is used by data processing components that can query a list of data items.\nMethods GetListByQuery Gets a list of data items using a query string.\n GetListByQuery(correlation_id string, query string, sort *data.SortParams) (items []interface{}, err error)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. query: string - (optional) query string sort: *data.SortParams - (optional) sorting parameters returns: (items []interface{}, err error) - list of items  ","description":"Interface for data processing components that can query a list of data items.\n","image":null,"permalink":"/golang/data/persistence/iquerable_reader/","subtitle":null,"tags":null,"title":"IQuerableReader"},{"content":"Description The IQuerableReader interface is used by data processing components that can query a list of data items.\nInstance methods getListByQuery Gets a list of data items using a query string.\n Task\u0026lt;List\u0026lt;T\u0026gt;\u0026gt; GetListByQueryAsync(string correlationId, string query, SortParams sort)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. query: string - (optional) query string sort: SortParams - (optional) sorting parameters returns: Task\u0026lt;List\u0026lt;T\u0026gt;\u0026gt; - list of items  ","description":"Interface for data processing components that can query a list of data items.\n","image":null,"permalink":"/net/data/core/iquerable_reader/","subtitle":null,"tags":null,"title":"IQuerableReader\u003cT\u003e"},{"content":"Description The IQuerableReader interface is used by data processing components that can query a list of data items.\nInstance methods getListByQuery Gets a list of data items using a query string.\n getListByQuery(correlationId: string, query: string, sort: SortParams): Promise\u0026lt;T[]\u0026gt;\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. query: string - (optional) query string sort: SortParams - (optional) sorting parameters returns: Promise\u0026lt;T[]\u0026gt; - list of items  ","description":"Interface for data processing components that can query a list of data items.\n","image":null,"permalink":"/node/data/core/iquerable_reader/","subtitle":null,"tags":null,"title":"IQuerableReader\u003cT\u003e"},{"content":"Description The IQuerableReader interface is used by data processing components that can query a list of data items.\nInstance methods get_list_by_query Gets a list of data items using a query string.\n get_list_by_query(correlation_id: Optional[str], query: Optional[str], sort: Optional[SortParams] = None): List[Any]\n  correlation_id: Optional[str] - (optional) transaction id used to trace execution through the call chain. query: Optional[str] - (optional) query string sort: Optional[SortParams] - (optional) sorting parameters returns: List[T] - list of items  ","description":"Interface for data processing components that can query a list of data items.\n","image":null,"permalink":"/python/data/core/iquerable_reader/","subtitle":null,"tags":null,"title":"IQuerableReader"},{"content":"Implements: ITokenizerState\nDescription The IQuoteState interface is used for tokenizer states that process quoted strings.\nInstance methods decodeString Decodes a string value.\n decodeString(value: string, quoteSymbol: number): string\n  value: string - string value to be decoded. quoteSymbol: number - string quote character. returns: string - decoded string.  encodeString Encodes a string value.\n encodeString(value: string, quoteSymbol: number): string\n  value: string - string value to be encoded. quoteSymbol: number - string quote character. returns: string - encoded string.  ","description":"Defines an interface for tokenizer state that processes quoted strings.\n","image":null,"permalink":"/node/expressions/tokenizers/iquote_state/","subtitle":null,"tags":null,"title":"IQuoteState"},{"content":"Implements: IConfigurable\nSee also IConfigurable\nDescription The IReconfigurable interface is used to set configuration parameters to an object.\nImportant points:\n It is similar to IConfigurable interface, but emphasises the fact that the configure() method can be called more than once to change an object configuration in runtime.  Examples type MyClass struct { myParam string } func NewMyClass() *MyClass { return \u0026amp;MyClass{ myParam: \u0026#34;default args\u0026#34;, }, } // Implement configure func (c * MyClass) Configure(config *cconf.ConfigParams) { c.myParam = config.GetAsStringWithDefault(\u0026#34;options.param\u0026#34;, myParam); ... } See also   IConfigurable   ","description":"An interface used to set configuration parameters to an object.  \n","image":null,"permalink":"/golang/commons/config/ireconfigurable/","subtitle":null,"tags":null,"title":"IReconfigurable"},{"content":"Inherits: IConfigurable\nSee also IConfigurable\nDescription The IReconfigurable interface is used to set configuration parameters to an object.\nImportant points:\n It is similar to the IConfigurable interface, but emphasises the fact that the configure() method can be called more than once to change an object configuration in runtime.  Examples public class MyClass:IReconfigurable { private var _myParam = \u0026#34;default args\u0026#34;; // Implement configure \tpublic Task Configure(ConfigParams config) { this._myParam = config.GetAsStringWithDefault(\u0026#34;options.param\u0026#34;, myParam); ... } } See also   IConfigurable   ","description":"An interface used to set configuration parameters to an object.  \n","image":null,"permalink":"/net/commons/config/ireconfigurable/","subtitle":null,"tags":null,"title":"IReconfigurable"},{"content":"Extends: IConfigurable\nSee also IConfigurable\nDescription The IReconfigurable interface is used to set configuration parameters to an object.\nImportant points:\n It is similar to IConfigurable interface, but emphasises the fact that the configure() method can be called more than once to change an object configuration in runtime.  Examples export class MyClass implements IReconfigurable { private _myParam: string = \u0026#34;default args\u0026#34;; // Implement configure \tpublic configure(config: ConfigParams): void { this._myParam = config.getAsStringWithDefault(\u0026#34;options.param\u0026#34;, myParam); ... } } See also   IConfigurable   ","description":"An interface used to set configuration parameters to an object.  \n","image":null,"permalink":"/node/commons/config/ireconfigurable/","subtitle":null,"tags":null,"title":"IReconfigurable"},{"content":"Description The IReconfigurable interface is used to set configuration parameters to an object.\nImportant points:\n It is similar to IConfigurable interface, but emphasises the fact that the configure() method can be called more than once to change an object configuration in runtime.  Implements: IConfigurable\nExamples class MyClass(IReconfigurable): _myParam = \u0026#34;default args\u0026#34; # Implement configure def configure(self, config): self._myParam = config.get_as_string_with_default(\u0026#34;options.param\u0026#34;, myParam) See also   IConfigurable   ","description":"An interface used to set configuration parameters to an object.  \n","image":null,"permalink":"/python/commons/config/ireconfigurable/","subtitle":null,"tags":null,"title":"IReconfigurable"},{"content":"Description The IReferenceable interface allows you to set references for components that depend on other components.\nImportant points\n If component requires explicit notification to unset references, it must also implement the IUnreferenceable interface.  Methods SetReferences Sets references to dependent components.\n SetReferences(references IReferences)\n  references: IReferences - references to locate the component dependencies.  Examples type MyController { _persistence IPersistence } func (mc* MyController) setReferences(references IReferences) { mc._persistence = references.getOneRequired( NewDescriptor(\u0026#34;mygroup\u0026#34;, \u0026#34;persistence\u0026#34;, \u0026#34;*\u0026#34;, \u0026#34;*\u0026#34;, \u0026#34;1.0\u0026#34;)) ); } ... See also   IReferences   IUnreferenceable   Referencer   ","description":"Interface with methods to set refernces for components that depend on other components. \n","image":null,"permalink":"/golang/commons/refer/ireferenceable/","subtitle":null,"tags":null,"title":"IReferenceable"},{"content":"Description The IReferenceable interface allows you to set references for components that depend on other components.\nImportant points\n If a component requires explicit notification to unset references, it must also implement the IUnreferenceable interface.  Instance methods SetReferences Sets references to dependent components.\n void SetReferences(IReferences references)\n  references: IReferences - references to locate the component dependencies.  Examples public class MyController: IReferenceable { public IMyPersistence _persistence; ... public void SetReferences(IReferences references) { this._persistence = references.getOneRequired\u0026lt;IMyPersistence\u0026gt;( new Descriptor(\u0026#34;mygroup\u0026#34;, \u0026#34;persistence\u0026#34;, \u0026#34;*\u0026#34;, \u0026#34;*\u0026#34;, \u0026#34;1.0\u0026#34;) ); } ... } See also   IReferences   IUnreferenceable   Referencer   ","description":"Interface with methods to set refernces for components that depend on other components. \n","image":null,"permalink":"/net/commons/refer/ireferenceable/","subtitle":null,"tags":null,"title":"IReferenceable"},{"content":"Description The IReferenceable interface allows you to set references for components that depend on other components.\nImportant points\n If a component requires explicit notification to unset references, it must also implement the IUnreferenceable interface.  Instance methods setReferences Sets references to dependent components.\n setReferences(references: IReferences): void\n  references: IReferences - references to locate the component\u0026rsquo;s dependencies.  Examples export class MyController implements IReferenceable { public _persistence: IMyPersistence; ... public setReferences(references: IReferences): void { this._persistence = references.getOneRequired\u0026lt;IMyPersistence\u0026gt;( new Descriptor(\u0026#34;mygroup\u0026#34;, \u0026#34;persistence\u0026#34;, \u0026#34;*\u0026#34;, \u0026#34;*\u0026#34;, \u0026#34;1.0\u0026#34;) ); } ... } See also   IReferences   IUnreferenceable   Referencer   ","description":"Interface with methods used to set references for components that depend on other components. \n","image":null,"permalink":"/node/commons/refer/ireferenceable/","subtitle":null,"tags":null,"title":"IReferenceable"},{"content":"Description The IReferenceable interface allows you to set references for components that depend on other components.\nImportant points\n If component requires explicit notification to unset references, it must also implement the IUnreferenceable interface.  Instance methods set_references Sets references to dependent components.\n set_references(references: IReferences)\n  references: IReferences - references to locate the component dependencies.  Examples class MyController(IReferenceable): _persistence = None def set_references(self, references): self._persistence = references.get_one_required(Descriptor(\u0026#34;mygroup\u0026#34;, \u0026#34;persistence\u0026#34;, \u0026#34;*\u0026#34;, \u0026#34;*\u0026#34;, \u0026#34;1.0\u0026#34;)) See also   IReferences   IUnreferenceable   Referencer   ","description":"Interface with methods to set refernces for components that depend on other components. \n","image":null,"permalink":"/python/commons/refer/ireferenceable/","subtitle":null,"tags":null,"title":"IReferenceable"},{"content":"Description The IReferences interface can be used to manage references stored in a map, and which can be passed to other components to establish dependencies between them.\nGenerally speaking, an IReferences object is a simple map, where keys are locators and values are component references. Thus, it allows you to add, remove and find components by their locators. Locators can be any values like integers, strings or component types.\nImportant points\n Together with IReferenceable and IUnreferenceable interfaces it implements a Locator pattern that is used by PipServices toolkit for Inversion of Control to assign external dependencies to components. Generally, the PipServices toolkit uses Descriptor as locators that match according to the following fields: group, type, kind, name and version.  Methods Find Gets all component references that match a specified locator.\nThrows a ReferenceError when required is set to true but no references found.\n Find(locator interface{}, required bool) ([]interface{}, error)\n  locator: interface{} - locator to find a reference by. required: bool - forces to raise an exception if no reference is found. returns: ([]interface{}, error) - list with matching component references.  GetAll Gets all component references registered in this reference map.\n GetAll() []interface{}\n  returns: []interface{} - list with component references.  GetAllLocators Gets locators for all registered component references in this reference map.\n GetAllLocators() []interface{}\n  returns: []interface{} - list with component locators.  GetOneOptional Gets an optional component reference that matches specified locator.\n GetOneOptional(locator interface{}) interface{}\n  locator: interface{} - locator to find references by. returns: interface{} - matching component reference or nil if nothing was found.  GetOneRequired Gets a required component reference that matches a specified locator.\nThrows a ReferenceError when no references found.\n GetOneRequired(locator interface{}) (interface{}, error)\n  locator: interface{} - locator to find a reference by. returns: (interface{}, error) - matching component reference.  GetOptional Gets all component references that match specified locator.\n GetOptional(locator interface{}) []interface{}\n  locator: interface{} - locator to find references by. returns: []interface{} - list with matching component references or empty list if nothing was found.  GetRequired Gets all component references that match a specified locator. At least one component reference must be present. If it doesn\u0026rsquo;t the method throws an error.\nThrows a ReferenceError when no references found.\n GetRequired(locator interface{}) ([]interface{}, error)\n  locator: ([]interface{}, error) - locator to find references by. returns: interface{} - list with matching component references.  Put Puts a new reference into this reference map.\n Put(locator interface{}, component interface{})\n  locator: interface{} - locator to find the reference by. component: interface{} - component reference to be added.  Remove Removes a previously added reference that matches a specified locator. If many references match the locator, it removes only the first one. When all references shall be removed, use removeAll method instead.\n Remove(locator interface{}) interface{}\n  locator: interface{} - locator to remove reference returns: interface{} - removed component reference.  RemoveAll Removes all component references that match the specified locator.\n RemoveAll(locator interface{}) []interface{}\n  locator: interface{} - locator to remove references by. returns: []interface{} - list, containing all removed references.  See also   Descriptor   References   ","description":"Interface to manage references stored in a map.\n","image":null,"permalink":"/golang/commons/refer/ireferences/","subtitle":null,"tags":null,"title":"IReferences"},{"content":"Description The IReferences interface can be used to manage references stored in a map, and which can be passed to other components to establish dependencies between them.\nGenerally speaking, an IReferences object is a simple map, where keys are locators and values are component references. Thus, it allows you to add, remove and find components by their locators. Locators can be any values like integers, strings or component types.\nImportant points\n Together with the IReferenceable and IUnreferenceable interfaces, it implements a Locator pattern that is used by the PipServices toolkit for Inversion of Control to assign external dependencies to components. Generally, the PipServices toolkit uses Descriptor as locators that match according to the following fields: group, type, kind, name and version.  Instance methods Find Gets all component references that match a specified locator. Throws a ReferenceException when required is set to true but no references were found.\n List\u0026lt;object\u0026gt; Find(object locator, bool required)\n  locator: object - locator to find a reference by. required: bool - forces to raise an exception if no reference is found. returns: List\u0026lt;object\u0026gt; - list with matching component references.  Find Gets all component references that match a specified locator and matching to the specified type. Throws a ReferenceException when required is set to true but no references were found. T - the class type.\n List\u0026lt;T\u0026gt; Find\u0026lt;T\u0026gt;(object locator, bool required)\n  locator: object - locator used to find a reference by. required: bool - forces to raise an exception if no reference is found. returns: List\u0026lt;T\u0026gt; - list with matching component references.  GetAll Gets all component references registered in this reference map.\n List\u0026lt;object\u0026gt; GetAll()\n  returns: List\u0026lt;object\u0026gt; - list with component references.  GetAllLocators Gets locators for all registered component references in this reference map.\n List\u0026lt;object\u0026gt; GetAllLocators()\n  returns: List\u0026lt;object\u0026gt; - list with component locators.  GetOneOptional Gets an optional component reference that matches a specified locator.\n object GetOneOptional(object locator)\n  locator: object - locator used to find references by. returns: object - matching component reference or null if nothing was found.  GetOneOptional Gets an optional component reference that matches a specified locator and matching to the specified type.\n T GetOneOptional\u0026lt;T\u0026gt;(object locator)\n  locator: object - locator used to find references by. returns: T - matching component reference or null if nothing was found.  GetOneRequired Gets a required component reference that matches a specified locator.\nThrows a ReferenceException when no references were found.\n object GetOneRequired(object locator)\n  locator: object - locator to find a reference by. returns: object - matching component reference.  GetOneRequired Gets a required component reference that matches a specified locator and matching to the specified type. Throws a ReferenceException when no references were found. T - class type\n T GetOneRequired\u0026lt;T\u0026gt;(object locator)\n  locator: object - locator used to find a reference by. returns: T - matching component reference.  GetOptional Gets all component references that match a specified locator.\n List\u0026lt;object\u0026gt; GetOptional(object locator)\n  locator: object - locator used to find references by. returns: List\u0026lt;object\u0026gt; - list with matching component references or empty list if nothing was found.  GetOptional Gets all component references that match a specified locator and matching to the specified type. T - class type\n List\u0026lt;T\u0026gt; GetOptional\u0026lt;T\u0026gt;(object locator)\n  locator: object - locator used to find references by. returns: List\u0026lt;T\u0026gt; - list with matching component references or empty list if nothing was found.  GetRequired Gets all component references that match a specified locator. At least one component reference must be present. If it doesn\u0026rsquo;t, the method throws an error. Throws a ReferenceException when no references were found.\n List\u0026lt;object\u0026gt; GetRequired(object locator)\n  locator: object - locator used to find references by. returns: List\u0026lt;object\u0026gt;- list with matching component references.  GetRequired Gets all component references that match a specified locator. At least one component reference must be present and matching to the specified type. Throws a ReferenceException when no references were found. T - class type\n List\u0026lt;T\u0026gt; GetRequired\u0026lt;T\u0026gt;(object locator)\n  locator: object - locator used to find references by. returns: List\u0026lt;T\u0026gt; - list with matching component references.  Put Puts a new reference into this reference map.\n void Put(object locator, object component)\n  locator: object - locator used to find the reference by. component: object - component reference to be added.  Remove Removes a previously added reference that matches a specified locator. If many references match the locator, it removes only the first one. When all references shall be removed, use removeAll method instead.\n object Remove(object locator)\n  locator: object - locator used to remove reference returns: object - removed component reference.  RemoveAll Removes all component references that match the specified locator.\n List\u0026lt;object\u0026gt; RemoveAll(object locator)\n  locator: object - locator used to remove references by. returns: List\u0026lt;object\u0026gt; - list containing all the removed references.  Examples public class MyController: IReferenceable { public IMyPersistence _persistence; ... public void SetReferences(IReferences references) { this._persistence = references.getOneRequired\u0026lt;IMyPersistence\u0026gt;( new Descriptor(\u0026#34;mygroup\u0026#34;, \u0026#34;persistence\u0026#34;, \u0026#34;*\u0026#34;, \u0026#34;*\u0026#34;, \u0026#34;1.0\u0026#34;) ); } ... } var persistence = new MyMongoDbPersistence(); var controller = new MyController(); var references = References.FromTuples( new Descriptor(\u0026#34;mygroup\u0026#34;, \u0026#34;persistence\u0026#34;, \u0026#34;mongodb\u0026#34;, \u0026#34;default\u0026#34;, \u0026#34;1.0\u0026#34;), persistence, new Descriptor(\u0026#34;mygroup\u0026#34;, \u0026#34;controller\u0026#34;, \u0026#34;default\u0026#34;, \u0026#34;default\u0026#34;, \u0026#34;1.0\u0026#34;), controller ); controller.SetReferences(references); See also   Descriptor   References   ","description":"Interface to manage references stored in a map.\n","image":null,"permalink":"/net/commons/refer/ireferences/","subtitle":null,"tags":null,"title":"IReferences"},{"content":"Description The IReferences interface can be used to manage references stored in a map, and which can be passed to other components to establish dependencies between them.\nGenerally speaking, an IReferences object is a simple map, where keys are locators and values are component references. Thus, it allows you to add, remove and find components by their locators. Locators can be any values like integers, strings or component types.\nImportant points\n Together with IReferenceable and IUnreferenceable interfaces it implements a Locator pattern that is used by PipServices toolkit for Inversion of Control to assign external dependencies to components. Generally, the PipServices toolkit uses Descriptor as locators that match according to the following fields: group, type, kind, name and version.  Instance methods find Gets all component references that match specified locator.\nThrows a ReferenceException when required is set to true but no references found.\n find\u0026lt;T\u0026gt;(locator: any, required: boolean): T[]\n  locator: any - the locator to find a reference by. required: boolean - forces to raise an exception if no reference is found. returns: T[] - a list with matching component references.  getAll Gets all component references registered in this reference map.\n getAll(): any[]\n  returns: any[] - a list with component references.  getAllLocators Gets locators for all registered component references in this reference map.\n getAllLocators(): any[]\n  returns: any[] - a list with component locators.  getOneOptional Gets an optional component reference that matches specified locator.\n getOneOptional\u0026lt;T\u0026gt;(locator: any): T\n  locator: any - the locator to find references by. returns: T - a matching component reference or null if nothing was found.  getOneRequired Gets a required component reference that matches specified locator.\nThrows a ReferenceException when no references found.\n getOneRequired\u0026lt;T\u0026gt;(locator: any): T\n  locator: any - the locator to find a reference by. returns: T - a matching component reference.  getOptional Gets all component references that match specified locator.\n getOptional\u0026lt;T\u0026gt;(locator: any): T[]\n  locator: any - the locator to find references by. returns: T[] - a list with matching component references or empty list if nothing was found.  getRequired Gets all component references that match specified locator. At least one component reference must be present. If it doesn\u0026rsquo;t the method throws an error.\nThrows a ReferenceException when no references found.\n getRequired\u0026lt;T\u0026gt;(locator: any): T[]\n  locator: any - the locator to find references by. returns: T[] - a list with matching component references.  put Puts a new reference into this reference map.\n put(locator: any, component: any): void\n  locator: any - a locator to find the reference by. component: any - a component reference to be added.  remove Removes a previously added reference that matches specified locator. If many references match the locator, it removes only the first one. When all references shall be removed, use removeAll method instead.\n remove(locator: any): any\n  locator: any - a locator to remove reference returns: any - the removed component reference.  removeAll Removes all component references that match the specified locator.\n removeAll(locator: any): any[]\n  locator: any - the locator to remove references by. returns: any[] - a list, containing all removed references.  Examples export class MyController implements IReferenceable { public _persistence: IMyPersistence; ... public setReferences(references: IReferences): void { this._persistence = references.getOneRequired\u0026lt;IMyPersistence\u0026gt;( new Descriptor(\u0026#34;mygroup\u0026#34;, \u0026#34;persistence\u0026#34;, \u0026#34;*\u0026#34;, \u0026#34;*\u0026#34;, \u0026#34;1.0\u0026#34;) ); } ... } let persistence = new MyMongoDbPersistence(); let controller = new MyController(); let references = References.fromTuples( new Descriptor(\u0026#34;mygroup\u0026#34;, \u0026#34;persistence\u0026#34;, \u0026#34;mongodb\u0026#34;, \u0026#34;default\u0026#34;, \u0026#34;1.0\u0026#34;), persistence, new Descriptor(\u0026#34;mygroup\u0026#34;, \u0026#34;controller\u0026#34;, \u0026#34;default\u0026#34;, \u0026#34;default\u0026#34;, \u0026#34;1.0\u0026#34;), controller ); controller.setReferences(references); See also   Descriptor   References   ","description":"Interface to manage references stored in a map.\n","image":null,"permalink":"/node/commons/refer/ireferences/","subtitle":null,"tags":null,"title":"IReferences"},{"content":"Description The IReferences interface can be used to manage references stored in a map, and which can be passed to other components to establish dependencies between them.\nGenerally speaking, an IReferences object is a simple map, where keys are locators and values are component references. Thus, it allows you to add, remove and find components by their locators. Locators can be any values like integers, strings or component types.\nImportant points\n Together with IReferenceable and IUnreferenceable interfaces it implements a Locator pattern that is used by PipServices toolkit for Inversion of Control to assign external dependencies to components. Generally, the PipServices toolkit uses Descriptor as locators that match according to the following fields: group, type, kind, name and version.  Instance methods find Gets all component references that match specified locator.\nThrows a ReferenceException when required is set to true but no references found.\n find(locator: Any, required: bool): List[Any]\n  locator: Any - the locator to find a reference by. required: bool - forces to raise an exception if no reference is found. returns:List[Any] - a list with matching component references.  get_all Gets all component references registered in this reference map.\n get_all(): List[Any]\n  returns: List[Any] - a list with component references.  get_all_locators Gets locators for all registered component references in this reference map.\n get_all_locators(): List[Any]\n  returns: List[Any] - a list with component locators.  get_one_optional Gets an optional component reference that matches specified locator.\n get_one_optional(locator: Any): Any\n  locator: Any - the locator to find references by. returns: Any - a matching component reference or None if nothing was found.  get_one_required Gets a required component reference that matches specified locator.\nThrows a ReferenceException when no references found.\n get_one_required(locator: Any): Any\n  locator: Any - the locator to find a reference by. returns: Any - a matching component reference.  get_optional Gets all component references that match specified locator.\n get_optional(locator: Any): List[Any]\n  locator: Any - the locator to find references by. returns: List[Any] - a list with matching component references or empty list if nothing was found.  get_required Gets all component references that match specified locator. At least one component reference must be present. If it doesn\u0026rsquo;t the method throws an error.\nThrows a ReferenceException when no references found.\n get_required(locator: Any): List[Any]\n  locator: Any - the locator to find references by. returns: List[Any] - a list with matching component references.  put Puts a new reference into this reference map.\n put(locator: Any, component: Any)\n  locator: Any - a locator to find the reference by. component: Any - a component reference to be added.  remove Removes a previously added reference that matches specified locator. If many references match the locator, it removes only the first one. When all references shall be removed, use removeAll method instead.\n remove(locator: Any): Any\n  locator: Any - a locator to remove reference returns: Any - the removed component reference.  remove_all Removes all component references that match the specified locator.\n remove_all(locator: Any): List[Any]\n  locator: Any - the locator to remove references by. returns: List[Any] - a list, containing all removed references.  Examples class MyController(IReferences): _persistence = None def set_references(self, references): self._persistence = references.get_one_required(Descriptor(\u0026#34;mygroup\u0026#34;, \u0026#34;persistence\u0026#34;, \u0026#34;*\u0026#34;, \u0026#34;*\u0026#34;, \u0026#34;1.0\u0026#34;)) persistence = MyMongoDbPersistence() references = References.from_tuples( Descriptor(\u0026#34;mygroup\u0026#34;, \u0026#34;persistence\u0026#34;, \u0026#34;mongodb\u0026#34;, \u0026#34;default\u0026#34;, \u0026#34;1.0\u0026#34;), persistence, Descriptor(\u0026#34;mygroup\u0026#34;, \u0026#34;controller\u0026#34;, \u0026#34;default\u0026#34;, \u0026#34;default\u0026#34;, \u0026#34;1.0\u0026#34;), controller ) controller.set_references(references) See also   Descriptor   References   ","description":"Interface to manage references stored in a map.\n","image":null,"permalink":"/python/commons/refer/ireferences/","subtitle":null,"tags":null,"title":"IReferences"},{"content":"Description The IRegisterable is used to perform on-demand registration.\nInstance methods register Perform required registration steps.\n register()\n ","description":"Interface to perform on-demand registrations.\n","image":null,"permalink":"/golang/grpc/services/iregisterable/","subtitle":null,"tags":null,"title":"IRegisterable"},{"content":"Description The IRegisterable interface is used to perform on-demand registrations.\nMethods Register Performs the required registration steps.\n Register()\n ","description":"Interface to perform on-demand registrations.\n","image":null,"permalink":"/golang/rpc/services/iregisterable/","subtitle":null,"tags":null,"title":"IRegisterable"},{"content":"Description The IRegisterable is used to perform on-demand registration.\nInstance methods Register Perform required registration steps.\n void Register()\n ","description":"Interface to perform on-demand registrations.\n","image":null,"permalink":"/net/grpc/services/iregisterable/","subtitle":null,"tags":null,"title":"IRegisterable"},{"content":"Description The IRegisterable interface is used to perform on-demand registrations.\nInstance methods Register Performs the required registration steps.\n void Register()\n ","description":"Interface to perform on-demand registrations.\n","image":null,"permalink":"/net/rpc/services/iregisterable/","subtitle":null,"tags":null,"title":"IRegisterable"},{"content":"Description The IRegisterable is used to perform on-demand registration.\nInstance methods register Perform required registration steps.\n register()\n ","description":"Interface to perform on-demand registrations.\n","image":null,"permalink":"/node/grpc/services/iregisterable/","subtitle":null,"tags":null,"title":"IRegisterable"},{"content":"Description The IRegisterable interface is used to perform on-demand registrations.\nInstance methods register Performs the required registration steps.\n register(): void\n ","description":"Interface to perform on-demand registrations.\n","image":null,"permalink":"/node/rpc/services/iregisterable/","subtitle":null,"tags":null,"title":"IRegisterable"},{"content":"Description The IRegisterable is used to perform on-demand registration.\nInstance methods register Perform required registration steps.\n register()\n ","description":"Interface to perform on-demand registrations.\n","image":null,"permalink":"/python/grpc/services/iregisterable/","subtitle":null,"tags":null,"title":"IRegisterable"},{"content":"Description The IRegisterable interface is used to perform on-demand registrations.\nInstance methods register Performs the required registration steps.\n register()\n ","description":"Interface to perform on-demand registrations.\n","image":null,"permalink":"/python/rpc/services/iregisterable/","subtitle":null,"tags":null,"title":"IRegisterable"},{"content":"Description The ISaver interface is used by data processing components that save data items.\nMethods Save Saves given data items.\n Save(correlation_id string, items []interface{}) error\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. items: T[] - a list of items to save. returns: error - returns error if not saved  ","description":"Interface for data processing components that save data items.\n","image":null,"permalink":"/golang/data/persistence/isaver/","subtitle":null,"tags":null,"title":"ISaver"},{"content":"Description The ISaver interface is used by data processing components that save data items.\nInstance methods SaveAsync Saves given data items.\n Task SaveAsync(string correlationId, IEnumerable\u0026lt;T\u0026gt; items)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. items: IEnumerable\u0026lt;T\u0026gt; - a list of items to save.  ","description":"Interface for data processing components that save data items.\n","image":null,"permalink":"/net/data/core/isaver/","subtitle":null,"tags":null,"title":"ISaver\u003cin T\u003e"},{"content":"Description The ISaver interface is used by data processing components that save data items.\nInstance methods save Saves given data items.\n save(correlationId: string, items: T[]): Promise\u0026lt;void\u0026gt;\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. items: T[] - a list of items to save.  ","description":"Interface for data processing components that save data items.\n","image":null,"permalink":"/node/data/core/isaver/","subtitle":null,"tags":null,"title":"ISaver\u003cT\u003e"},{"content":"Description The ISaver interface is used by data processing components that save data items.\nInstance methods save Saves given data items.\n save(correlation_id: Optional[str], items: List[T])\n  correlation_id: Optional[str] - (optional) transaction id used to trace execution through the call chain. items: List[T] - list of items to save.  ","description":"Interface for data processing components that save data items.\n","image":null,"permalink":"/python/data/core/isaver/","subtitle":null,"tags":null,"title":"ISaver"},{"content":"Description The IScanner interface defines a scanner that can read and unread characters and count lines.\nInstance methods column Gets the column in the current line.\n column(): number\n  returns: number - Column in the current line in the stream.  line Gets the current line number\n line(): number\n  returns: number - Current line number in the stream  peek Returns the character from the top of the stream without moving the stream pointer.\n peek(): number\n  returns: number - Character from the top of the stream or -1 if the stream is empty.  peekColumn Gets the next character column number.\n peekColumn(): number\n  returns: number - Next character column number in the stream.  peekLine Gets the next character line number.\n peekLine(): number\n  returns: number - Next character line number in the stream.  read Reads a character from the top of the stream.\n read(): number\n  returns: number - Read character or -1 if the stream is processed to the end.  reset Resets a scanner to the initial position.\n reset(): void\n unread Puts a character back into the stream.\n unread(): void\n unreadMany Pushes the specified number of characters to the top of the stream.\n unreadMany(count: number): void\n  count: number - number of characcted to be pushed back.  ","description":"Defines scanner that can read and unread characters and count lines. This scanner is used by tokenizers to process input streams.\n","image":null,"permalink":"/node/expressions/io/iscanner/","subtitle":null,"tags":null,"title":"IScanner"},{"content":"Description The ISchema interface contains several validation methods.\nMethods Validate Validates the given value and returns validation results\n Validate(value interface{}) []*ValidationResult\n  value: interface{} - value to be validated. returns: []*ValidationResult - list with validation results  ValidateAndReturnError Validates the given value and returns a ValidationException if errors were found.\n ValidateAndReturnError(correlationId string, value interface{}, strict bool) *errors.ApplicationError\n  correlationId: string - (optional) unique transaction id used to trace execution through the call chain. value: interface{} - value to be validated. strict: bool - if true,warnings will also raise validation exceptions. returns: *errors.ApplicationError - validation exception  ValidateAndThrowError Validates the given value and throws a ValidationException if errors were found.\n ValidateAndThrowError(correlationId string, value interface{}, strict bool)\n  correlationId: string - (optional) unique transaction id used to trace execution through the call chain. value: interface{} - value to be validated. strict: bool - if true,warnings will also raise validation exceptions.  ","description":"Validation schema interface\n","image":null,"permalink":"/golang/commons/validate/ischema/","subtitle":null,"tags":null,"title":"ISchema"},{"content":"Description The ISchemaBase interface is used by classes that need to perform a validation against a schema.\nMethods PerformValidation Validates a given value against the schema and configured validation rules..\n PerformValidation(path string, value interface{}) []*ValidationResult\n  path: interface{} - dot notation path to the value returns: []*ValidationResult - list with validation results  ","description":"Interface with a method to perform a validation.\n","image":null,"permalink":"/golang/commons/validate/ischema_base/","subtitle":null,"tags":null,"title":"ISchemaBase"},{"content":"Description The ISetter interface is used by data processing components that can set (create or update) data items.\nMethods Set Sets a data item. If the data item exists it updates it, otherwise it creates a new data item.\n Set(correlation_id string, item interface{}) (value interface{}, err error)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. item: interface{} - item to be set. returns: (value interface{}, err error) - updated item  ","description":"Interface for data processing components that can set (create or update) data items.\n","image":null,"permalink":"/golang/data/persistence/isetter/","subtitle":null,"tags":null,"title":"ISetter"},{"content":"Description The ISetter interface is used by data processing components that can set (create or update) data items.\nInstance methods SetAsync Sets a data item. If the data item exists it updates it, otherwise it creates a new data item.\n Task\u0026lt;T\u0026gt; SetAsync(string correlationId, T item)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. item: T - item to be set. returns: Task\u0026lt;T\u0026gt; - updated item  ","description":"Interface for data processing components that can set (create or update) data items.\n","image":null,"permalink":"/net/data/core/isetter/","subtitle":null,"tags":null,"title":"ISetter\u003cT\u003e"},{"content":"Description The ISetter interface is used by data processing components that can set (create or update) data items.\nInstance methods set Sets a data item. If the data item exists it updates it, otherwise it creates a new data item.\n set(correlationId: string, item: T): Promise\u0026lt;T\u0026gt;\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. item: T - item to be set. returns: Promise\u0026lt;T\u0026gt; - updated item  ","description":"Interface for data processing components that can set (create or update) data items.\n","image":null,"permalink":"/node/data/core/isetter/","subtitle":null,"tags":null,"title":"ISetter\u003cT\u003e"},{"content":"Description The ISetter interface is used by data processing components that can set (create or update) data items.\nInstance methods set Sets a data item. If the data item exists it updates it, otherwise it creates a new data item.\n set(correlation_id: Optional[str], item: T): T\n  correlation_id: Optional[str] - (optional) transaction id used to trace execution through the call chain. item: T - item to be set. returns: T - updated item  ","description":"Interface for data processing components that can set (create or update) data items.\n","image":null,"permalink":"/python/data/core/isetter/","subtitle":null,"tags":null,"title":"ISetter"},{"content":"Inherits: IIdentifiable\nDescription The IStringIdentifiable interface extends hte IIdentifiable interface hardcode id type to string.\nImportant points\n It is common to use a string GUID as the id, generated by IdGenerator.  Examples public class MyData: IIdentifiable\u0026lt;String\u0026gt; { string id {get; set;} string field1; int field2; ... } See also   IIdentifiable   IdGenerator   ","description":"Interface for data objects that can be uniquely identifed by a string id. \n","image":null,"permalink":"/net/commons/data/istring_identifiable/","subtitle":null,"tags":null,"title":"IStringIdentifiable"},{"content":"Extends: IIdentifiable\nDescription The IIdentifiable interface extends IIdentifiable to hardcode id type to string.\nImportant points\n It is common to use a string GUID as the id, generated by IdGenerator. The interface extends IIdentifiable hardcode id type to string.  Fields id Object\u0026rsquo;s unique string id.\n id: string\n  Examples export class MyData implements IStringIdentifiable { public id: string; public field1: string; public field2: number; ... } See also   IIdentifiable   IdGenerator   ","description":"Interface for data objects that can be uniquely identifed by a string id. \n","image":null,"permalink":"/node/commons/data/istring_identifiable/","subtitle":null,"tags":null,"title":"IStringIdentifiable"},{"content":"Implements: IIdentifiable\nDescription The IIdentifiable interface extends IIdentifiable to hardcode id type to string.\nImportant points\n It is common to use a string GUID as the id, generated by IdGenerator.  Fields id The object\u0026rsquo;s unique string id.\n id: str\n  Examples class MyData(IStringIdentifiable): id = None See also   IIdentifiable   IdGenerator   ","description":"Interface for data objects that can be uniquely identifed by a string id. \n\nThe interface extends [IIdentifiable](../iidentifiable) to hardcode id type to string.\n","image":null,"permalink":"/python/commons/data/istring_identifiable/","subtitle":null,"tags":null,"title":"IStringIdentifiable"},{"content":"Extends: IIdentifiable\nDescription The IIdentifiable interface extends IIdentifiable to hardcode id type to string.\nImportant points\n It is common to use a string GUID as the id, generated by IdGenerator.  Fields id The object\u0026rsquo;s unique string id.\n id: string\n  Examples type MyData struct { Id string `json:\u0026#34;id\u0026#34;` Field1 string `json:\u0026#34;field1\u0026#34;` Field2 int32 `json:\u0026#34;field2\u0026#34;` ... } See also   IIdentifiable   IdGenerator   ","description":"Interface for data objects that can be uniquely identifed by a string id. \nThe interface extends [IIdentifiable](../iidentifiable) to hardcode id type to string.\n","image":null,"permalink":"/golang/commons/data/istring_identifiable/","subtitle":null,"tags":null,"title":"IStringIdentifiable!"},{"content":"Description The ISwaggerService interface is used to perform Swagger registrations.\nMethods RegisterOpenApiSpec Performs the required Swagger registration steps.\n RegisterOpenApiSpec(baseRoute string, swaggerRoute string)\n  baseRoute: string - base route swaggerRoute: string - Swagger route  ","description":"Interface to perform Swagger registrations.\n","image":null,"permalink":"/golang/rpc/services/iswagger_service/","subtitle":null,"tags":null,"title":"ISwaggerService"},{"content":"Description The ISwaggerService interface is used to perform Swagger registrations.\nInstance methods RegisterOpenApiSpec Performs the required Swagger registration steps.\n void RegisterOpenApiSpec(string baseRoute, string swaggerRoute)\n  baseRoute: string - base route swaggerRoute: string - Swagger route  ","description":"Interface to perform Swagger registrations.\n","image":null,"permalink":"/net/rpc/services/iswagger_service/","subtitle":null,"tags":null,"title":"ISwaggerService"},{"content":"Description The ISwaggerService interface is used to perform Swagger registrations.\nInstance methods registerOpenApiSpec Performs the required Swagger registration steps.\n registerOpenApiSpec(base_route: string, swagger_route: string): void\n  baseRoute: string - base route swaggerRoute: string - Swagger route  ","description":"Interface to perform Swagger registrations.\n","image":null,"permalink":"/node/rpc/services/iswagger_service/","subtitle":null,"tags":null,"title":"ISwaggerService"},{"content":"Description The ISwaggerService interface is used to perform Swagger registrations.\nInstance methods register_open_api_spec Performs the required Swagger registration steps.\n register_open_api_spec(base_route: str, swagger_route: str)\n  base_route: str - base route swagger_route: str - Swagger route  ","description":"Interface to perform Swagger registrations.\n","image":null,"permalink":"/python/rpc/services/iswagger_service/","subtitle":null,"tags":null,"title":"ISwaggerService"},{"content":"Implements: ITokenizerState\nDescription The ISymbolState interface is used for tokenizer states that process delimiters.\nInstance methods add Add a multi-character symbol.\n add(value: string, tokenType: TokenType): void\n  value: string - symbol to add, such as \u0026quot;=:=\u0026quot;. tokenType: TokenType - token type.  ","description":"Defines an interface for tokenizer state that processes delimiters.\n","image":null,"permalink":"/node/expressions/tokenizers/isymbol_state/","subtitle":null,"tags":null,"title":"ISymbolState"},{"content":"Description The ITokenizer interface defines the main elements of a tokenizer.\nImportant points\n  A tokenizer divides a string into tokens. This class is highly customizable with regard to exactly how this division occurs, but it also has defaults that are suitable for many languages. This class assumes that the character values read from the string lie in the range 0-255. For example, the Unicode value of a capital A is 65, so String.fromCharCode(65) prints out a capital A.\n  The behavior of a tokenizer depends on its character state table. This table is an array of 256 TokenizerState states. The state table decides which state to enter upon reading a character from the input string.\n  For example, by default, upon reading an \u0026lsquo;A\u0026rsquo;, a tokenizer will enter a \u0026ldquo;word\u0026rdquo; state. This means the tokenizer will ask a WordState object to consume the \u0026lsquo;A\u0026rsquo;, along with the characters after the \u0026lsquo;A\u0026rsquo; that form a word. The state\u0026rsquo;s responsibility is to consume characters and return a complete token.\n  The default table sets a SymbolState for every character from 0 to 255, and then overrides this with:\n   From To State 0 ' ' whitespaceState 'a' 'z' wordState 'A' 'Z' wordState 160 255 wordState '0' '9' numberState '-' '-' numberState '.' '.' numberState '\"' '\"' quoteState '\\'' '\\'' quoteState '/' '/' slashState   In addition to allowing modification of the state table, this class makes each of the states above available. Some of these states are customizable. For example, wordState allows customization of what characters can be part of a word, after the first character.  Fields commentState A token state to process comments.\n commentState: ICommentState\n decodeStrings Decodes quoted strings.\n decodeStrings: boolean\n mergeWhitespaces Merges whitespaces.\n mergeWhitespaces: boolean\n numberState A token state to process numbers.\n numberState: INumberState\n quoteState A token state to process quoted strings.\n quoteState: IQuoteState\n scanner The stream scanner to tokenize.\n scanner: IScanner\n skipComments Skips comments.\n skipComments: boolean\n skipEof Skips End-Of-File token at the end of stream.\n skipEof: boolean\n skipUnknown Skip unknown characters.\n skipUnknown: boolean\n skipWhitespaces Skips whitespaces.\n skipWhitespaces: boolean\n symbolState A token state to process symbols (single like \u0026ldquo;=\u0026rdquo; or muti-character like \u0026ldquo;\u0026lt;\u0026gt;\u0026quot;)\n symbolState: ISymbolState\n unifyNumbers Unifies numbers: \u0026ldquo;Integers\u0026rdquo; and \u0026ldquo;Floats\u0026rdquo; makes just \u0026ldquo;Numbers\u0026rdquo;.\n unifyNumbers: boolean\n whitespaceState A token state to process white space delimiters.\n whitespaceState: IWhitespaceState\n wordState A token state to process words or indentificators.\n wordState: IWordState\n  Instance methods hasNextToken Checks if there i a next token.\n hasNextToken(): boolean\n  returns: boolean - true if scanner has the next token.  nextToken Gets the next token from the scanner.\n nextToken(): Token\n  returns: Token - next token of null if there are no more tokens left.  tokenizeBuffer Tokenizes a string buffer into a list of tokens structures.\n tokenizeBuffer(buffer: string): Token[]\n  buffer: string - string buffer to be tokenized. returns: Token[] - list of token structures.  tokenizeBufferToStrings Tokenizes a string buffer into a list of strings.\n tokenizeBufferToStrings(buffer: string): string[]\n  buffer: string - string buffer to be tokenized. returns: string[] - list of token strings.  tokenizeStream Tokenizes a textual stream into a list of token structures.\n tokenizeStream(scanner: IScanner): Token[]\n  scanner: IScanner - textual stream to be tokenized. returns: Token[] - list of token structures.  tokenizeStreamToStrings Tokenizes a textual stream into a list of strings.\n tokenizeStreamToStrings(scanner: IScanner): string[]\n  scanner: IScanner - textual stream to be tokenized. returns: string[] - list of token strings.  ","description":"Interface for tokenizers.\n","image":null,"permalink":"/node/expressions/tokenizers/itokenizer/","subtitle":null,"tags":null,"title":"ITokenizer"},{"content":"Description The ITokenizerState interface is used by TokenizerStates. A tokenizerState returns a token, given a scanner, an initial character read from the scanner, and a tokenizer that is conducting an overall tokenization of the scanner.\nImportant points\n  The tokenizer will typically have a character state table that decides which state to use, depending on an initial character. If a single character is insufficient, a state such as SlashState will read a second character, and may delegate to another state, such as SlashStarState.\n  This prospect of delegation is the reason that the nextToken() method has a tokenizer argument.\n  Instance methods nextToken Gets the next token from the stream started from the character linked to this state.\n nextToken(scanner: IScanner, tokenizer: ITokenizer): Token\n  scanner: IScanner - A textual string to be tokenized. tokenizer: ITokenizer - A tokenizer class that controls the process. returns: Token - The next token from the top of the stream.  ","description":"Interface for TokenizerStates.\n","image":null,"permalink":"/node/expressions/tokenizers/itokenizer_state/","subtitle":null,"tags":null,"title":"ITokenizerState"},{"content":"Description The ITracer interface is used to create tracer components that capture operation traces.\nMethods BeginTrace Begings recording an operation trace\n BeginTrace(correlationId string, component string, operation string) *TraceTiming\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. component: string - name of the called component operation: string - name of the executed operation. return: *TraceTiming - trace timing object.  Failure Records an operation failure with its name, duration and error.\n Failure(correlationId string, component string, operation string, err error, duration int64)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. component: string - name of called component operation: string - name of the executed operation. err: error - error object associated with this trace. duration: int64 - execution duration in milliseconds.  Trace Records an operation trace with its name and duration\n Trace(correlationId string, component string, operation string, duration int64)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. component: string - name of the called component operation: string - name of the executed operation. duration: int64 - execution duration in milliseconds.  ","description":"Interface for tracer components that capture operation traces.\n","image":null,"permalink":"/golang/components/trace/itracer/","subtitle":null,"tags":null,"title":"ITracer"},{"content":"Description The ITracer interface is used to create tracer component that capture operation traces.\nInstance methods BeginTrace Begings recording an operation trace\n TraceTiming BeginTrace(string correlationId, string component, string operation)\n  correlationId: string - (optional) transaction id to trace execution through a call chain. component: string - name of the called component operation: string - name of the executed operation. return: TraceTiming - a trace timing object.  Failure Records an operation failure with its name, duration and error.\n void Failure(string correlationId, string component, string operation, Exception error, long duration)\n  correlationId: string - (optional) transaction id to trace execution through call chain. component: string - a name of called component operation: string - a name of the executed operation. error: Exception - an error object associated with this trace. duration: long - execution duration in milliseconds.  Trace Records an operation trace with its name and duration\n void Trace(string correlationId, string component, string operation, long duration)\n  correlationId: string - (optional) transaction id to trace execution through a call chain. component: string - name of the called component operation: string - name of the executed operation. duration: long - execution duration in milliseconds.  ","description":"Interface for tracer components that capture operation traces.\n","image":null,"permalink":"/net/components/trace/itracer/","subtitle":null,"tags":null,"title":"ITracer"},{"content":"Description The ITracer interface is used to create tracer component that capture operation traces.\nInstance methods beginTrace Begings recording an operation trace\n beginTrace(correlationId: string, component: string, operation: string): TraceTiming\n  correlationId: string - (optional) transaction id to trace execution through a call chain. component: string - name of the called component operation: string - name of the executed operation. return: TraceTiming - a trace timing object.  failure Records an operation failure with its name, duration and error.\n failure(correlationId: string, component: string, operation: string, error: Error, duration: number): void\n  correlationId: string - (optional) transaction id to trace execution through call chain. component: string - a name of called component operation: string - a name of the executed operation. error: Error - an error object associated with this trace. duration: number - execution duration in milliseconds.  trace Records an operation trace with its name and duration\n trace(correlationId: string, component: string, operation: string, duration: number): void\n  correlationId: string - (optional) transaction id to trace execution through a call chain. component: string - name of the called component operation: string - name of the executed operation. duration: number - execution duration in milliseconds.  ","description":"Interface for tracer components that capture operation traces.\n","image":null,"permalink":"/node/components/trace/itracer/","subtitle":null,"tags":null,"title":"ITracer"},{"content":"Description The ITracer interface is used to create tracer component that capture operation traces.\nInstance methods begin_trace Begings recording an operation trace\n begin_trace(correlation_id: Optional[str], component: str, operation: str): TraceTiming\n  correlation_id: Optional[str] - (optional) transaction id to trace execution through a call chain. component: str - name of the called component operation: str - name of the executed operation. return: TraceTiming - a trace timing object.  failure Records an operation failure with its name, duration and error.\n failure(correlation_id: Optional[str], component: str, operation: str, error: Exception, duration: float)\n  correlation_id: Optional[str] - (optional) transaction id to trace execution through call chain. component: str - a name of called component operation: str - a name of the executed operation. error: Exception - an error object associated with this trace. duration: float - execution duration in milliseconds.  trace Records an operation trace with its name and duration\n trace(correlation_id: Optional[str], component: str, operation: str, duration: float)\n  correlation_id: Optional[str] - (optional) transaction id to trace execution through a call chain. component: str - name of the called component operation: str - name of the executed operation. duration: float - execution duration in milliseconds.  ","description":"Interface for tracer components that capture operation traces.\n","image":null,"permalink":"/python/components/trace/itracer/","subtitle":null,"tags":null,"title":"ITracer"},{"content":"Inherits: IChangeable\nDescription The ITrackagle interface allows you to define data objects that can track their changes, including logical deletion.\nProperties CreatedTime UTC time at which the object was created.\n DateTime CreatedTime { get; set; }\n LastChangeTime UTC time at which the object was last changed (created, updated, or deleted).\n DateTime LastChangeTime { get; set; }\n IsDeleted Logical deletion flag. True when object is deleted and null or false otherwise\n bool IsDeleted { get; set; }\n Examples public class MyData: IStringIdentifiable, ITrackable { string id {get; set;} string field1; int field2; ... DateTime change_time {get; set;} DateTime create_time {get; set;} bool deleted {get; set;} } See also   IChangeable   ","description":"Interface for data objects that can track their changes, including logical deletion.\n","image":null,"permalink":"/net/commons/data/itrackable/","subtitle":null,"tags":null,"title":"ITrackable"},{"content":"Extends: IChangeable\nDescription The ITrackagle interface allows you to define data objects that can track their changes, including logical deletion.\nFields create_time UTC time at which the object was created.\n create_time: Date\n change_time UTC time at which the object was last changed (created, updated, or deleted).\n change_time: Date\n deleted Logical deletion flag. True when object is deleted and null or false otherwise\n deleted: boolean\n  Examples export class MyData implements IStringIdentifiable, ITrackable { public id: string; public field1: string; public field2: number; ... public change_time: Date; public create_time: Date; public deleted: boolean; } See also   IChangeable   ","description":"Interface for data objects that can track their changes, including logical deletion.\n","image":null,"permalink":"/node/commons/data/itrackable/","subtitle":null,"tags":null,"title":"ITrackable"},{"content":"Implements: IChangeable\nDescription The ITrackagle interface allows you to define data objects that can track their changes, including logical deletion.\nFields create_time The UTC time at which the object was created.\n create_time: datetime\n change_time The UTC time at which the object was last changed (created, updated, or deleted).\n change_time: datetime\n deleted The logical deletion flag. True when object is deleted and None or false otherwise\n deleted: datetime\n  Examples class MyData(IStringIdentifiable, ITrackable): id = None ... change_time = None create_time = None deleted = None See also   IChangeable   ","description":"Interface for data objects that can track their changes, including logical deletion.\n","image":null,"permalink":"/python/commons/data/itrackable/","subtitle":null,"tags":null,"title":"ITrackable"},{"content":"Extends: IChangeable\nDescription The ITrackagle interface allows you to define data objects that can track their changes, including logical deletion.\nFields create_time The UTC time at which the object was created.\n CreateTime: time.Time\n change_time The UTC time at which the object was last changed (created, updated, or deleted).\n ChangeTime: time.Time\n deleted The logical deletion flag. True when object is deleted and null or false otherwise\n Deleted: bool\n  Examples type MyData struct { Id string `json:\u0026#34;id\u0026#34;` Field1 string `json:\u0026#34;field1\u0026#34;` Field2 int32 `json:\u0026#34;field2\u0026#34;` ... ChangeTime time.Time `json:\u0026#34;change_time\u0026#34;` CreateTime time.Time `json:\u0026#34;create_time\u0026#34;` Deleted bool `json:\u0026#34;delete\u0026#34;` } See also   IChangeable   ","description":"Interface for data objects that can track their changes, including logical deletion.\n","image":null,"permalink":"/golang/commons/data/itrackable/","subtitle":null,"tags":null,"title":"ITrackable!"},{"content":"Description The IUnreferenceable interface can be used for components that require the capacity to clear previously defined references to dependent components.\nMethods UnsetReferences Unsets (clears) previously set references to dependent components.\n UnsetReferences()\n Examples type MyController { _persistence IMyPersistence; } func (mc* MyController) SetReferences(references *IReferences) { mc._persistence = references.GetOneRequired( NewDescriptor(\u0026#34;mygroup\u0026#34;, \u0026#34;persistence\u0026#34;, \u0026#34;*\u0026#34;, \u0026#34;*\u0026#34;, \u0026#34;1.0\u0026#34;) ); } func (mc* MyController) UnsetReferences() { mc._persistence = nil; } See also   IReferences   IReferenceable   ","description":"Interface for components that require the capacity to clear previously defined references to dependent components.\n","image":null,"permalink":"/golang/commons/refer/iunreferenceable/","subtitle":null,"tags":null,"title":"IUnreferenceable"},{"content":"Description The IUnreferenceable interface can be used for components that require the capacity to clear previously defined references to dependent components.\nInstance methods UnsetReferences Unsets (clears) previously set references to dependent components.\n void UnsetReferences()\n Examples public class MyController: IReferenceable, IUnreferenceable { public IMyPersistence _persistence; ... public void SetReferences(IReferences references) { this._persistence = references.getOneRequired\u0026lt;IMyPersistence\u0026gt;( new Descriptor(\u0026#34;mygroup\u0026#34;, \u0026#34;persistence\u0026#34;, \u0026#34;*\u0026#34;, \u0026#34;*\u0026#34;, \u0026#34;1.0\u0026#34;) ); } public void UnsetReferences() { this._persistence = null; } ... } See also   IReferences   IReferenceable   ","description":"Interface for components that require the capacity to clear previously defined references to dependent components.\n","image":null,"permalink":"/net/commons/refer/iunreferenceable/","subtitle":null,"tags":null,"title":"IUnreferenceable"},{"content":"Description The IUnreferenceable interface can be used for components that require the capacity to clear previously defined references to dependent components.\nInstance methods unsetReferences Unsets (clears) previously set references to dependent components.\n unsetReferences(): void\n Examples export class MyController implements IReferenceable, IUnreferenceable { public _persistence: IMyPersistence; ... public setReferences(references: IReferences): void { this._persistence = references.getOneRequired\u0026lt;IMyPersistence\u0026gt;( new Descriptor(\u0026#34;mygroup\u0026#34;, \u0026#34;persistence\u0026#34;, \u0026#34;*\u0026#34;, \u0026#34;*\u0026#34;, \u0026#34;1.0\u0026#34;) ); } public unsetReferences(): void { this._persistence = null; } ... } See also   IReferences   IReferenceable   ","description":"Interface for components that require the capacity to clear previously defined references to dependent components.\n","image":null,"permalink":"/node/commons/refer/iunreferenceable/","subtitle":null,"tags":null,"title":"IUnreferenceable"},{"content":"Description The IUnreferenceable interface can be used for components that require the capacity to clear previously defined references to dependent components.\nInstance methods unset_references Unsets (clears) previously set references to dependent components.\n unset_references()\n Examples class MyController(IReferenceable): _persistence = None def set_references(self, references): self._persistence = references.getOneRequired(Descriptor(\u0026#34;mygroup\u0026#34;, \u0026#34;persistence\u0026#34;, \u0026#34;*\u0026#34;, \u0026#34;*\u0026#34;, \u0026#34;1.0\u0026#34;)) def unset_references(self): self._persistence = None See also   IReferences   IReferenceable   ","description":"Interface for components that require the capacity to clear previously defined references to dependent components.\n","image":null,"permalink":"/python/commons/refer/iunreferenceable/","subtitle":null,"tags":null,"title":"IUnreferenceable"},{"content":"Description The IValidationRule interface allows you to implement custom validation rules.\nMethods Validate Validates a given value against this rule.\n Validate(path string, schema ISchema, value interface{}) []*ValidationResult\n  path: string - dot notation path to the value. schema: ISchema - schema this rule is called from value: interface{} - value to be validated. results: []*ValidationResult - list with validation results to add new results.  ","description":"Interface used to implement custom validation rules.\n","image":null,"permalink":"/golang/commons/validate/ivalidation_rule/","subtitle":null,"tags":null,"title":"IValidationRule"},{"content":"Description The IValidationRule interface allows you to implement custom validation rules.\nInstance methods Validate Validates a given value against this rule.\n public void Validate(string path, Schema schema, object value, List\u0026lt;ValidationResult\u0026gt; results)\n  path: string - dot notation path to the value. schema: Schema - schema this rule is called from value: object - value to be validated. results: List\u0026lt;ValidationResult\u0026gt; - list with validation results.  ","description":"Interface used to implement custom validation rules.\n","image":null,"permalink":"/net/commons/validate/ivalidation_rule/","subtitle":null,"tags":null,"title":"IValidationRule"},{"content":"Description The IValidationRule interface allows you to implement custom validation rules.\nInstance methods validate Validates a given value against this rule.\n public validate(path: string, schema: Schema, value: any, results: ValidationResult[]): void\n  path: string - dot notation path to the value. schema: Schema - schema this rule is called from value: any - value to be validated. results: ValidationResult[] - list with validation results.  ","description":"Interface used to implement custom validation rules.\n","image":null,"permalink":"/node/commons/validate/ivalidation_rule/","subtitle":null,"tags":null,"title":"IValidationRule"},{"content":"Description The IValidationRule interface allows you to implement custom validation rules.\nInstance methods validate Validates a given value against this rule.\n validate(path: str, schema: Schema, value: Any, results: List[ValidationResult])\n  path: str - a dot notation path to the value. schema: Schema - a schema this rule is called from value: Any - a value to be validated. results: List[ValidationResult] - a list with validation results to add new results.  ","description":"Interface used to implement custom validation rules.\n","image":null,"permalink":"/python/commons/validate/ivalidation_rule/","subtitle":null,"tags":null,"title":"IValidationRule"},{"content":"Extends: GenericNumberState\nDescription The IVariable interface allows you to define a variable.\nFields name The variable name.\n name: string\n value The variable value.\n value: Variant\n  ","description":"Defines a variable interface.\n","image":null,"permalink":"/node/expressions/calculator/variables/ivariable/","subtitle":null,"tags":null,"title":"IVariable"},{"content":"Implements: IVariableCollection\nDescription The IVariableCollection interface defines a list of variables.\nProperties length Gets a number of variables stored in the collection.\n length(): number\n  returns: number - number of stored variables.  Instance methods add Adds a new variable to the collection.\n add(variable: IVariable): void\n  variable: IVariable - variable to be added.  clear Clears the collection.\n clear(): void\n clearValues Clears all stored variables (assigns null values).\n clearValues(): void\n findByName Clears all stored variables (assigns null values).\n findByName(name: string): IVariable\n findIndexByName \u0026lsquo;sFinds a variable index in the list by the variable\u0026rsquo;s name.\n findIndexByName(name: string): number\n  name: string - variable name to be found. returns: number - variable index in the list or -1 if variable was not found.  get Gets a variable by its index.\n get(index: number): IVariable\n  index: string - variable index. returns: IVariable - retrieved variable.  getAll Gets all the variables stored in the collection.\n getAll(): IVariable[]\n  returns: IVariable[] - list with stored variables.  locate Finds a variable in the list or creates a new one if the variable was not found.\n locate(name: string): IVariable\n  name: string - name of the variable to be found. returns: IVariable - found or created variable.  remove Removes a variable by its index.\n remove(index: number): void\n  index: number - index of the variable to be removed.  removeByName Removes a variable by it\u0026rsquo;s name.\n removeByName(name: string): void\n  name: string - name of the variable to be removed.  ","description":"Defines a list of variables.\n","image":null,"permalink":"/node/expressions/calculator/variables/ivariable_collection/","subtitle":null,"tags":null,"title":"IVariableCollection"},{"content":"Description The IVariantOperations class allows you to implement an abstract variant operations manager object.\nInstance methods add Performs the \u0026lsquo;+\u0026rsquo; operation for two variants.\n add(value1: Variant, value2: Variant): Variant\n  value1: Variant - first operand for this operation. value2: Variant - second operand for this operation. returns: Variant - result variant object.  and Performs the AND operation for two variants.\n and(value1: Variant, value2: Variant): Variant\n  value1: Variant - first operand for this operation. value2: Variant - second operand for this operation. returns: Variant - result variant object.  convert Converts the variant to a specified type.\n convert(value: Variant, newType: VariantType): Variant\n  value: Variant - variant value to be converted. newType: VariantType - type of object to be returned. returns: Variant - converted Variant value.  div Performs the \u0026lsquo;/\u0026rsquo; operation for two variants.\n div(value1: Variant, value2: Variant): Variant\n  value1: Variant - first operand for this operation. value2: Variant - second operand for this operation. returns: Variant - result variant object.  equal Performs the \u0026lsquo;=\u0026rsquo; operation for two variants.\n equal(value1: Variant, value2: Variant): Variant\n  value1: Variant - first operand for this operation. value2: Variant - second operand for this operation. returns: Variant - result variant object.  getElement Performs the [] operation for two variants.\n getElement(value1: Variant, value2: Variant): Variant\n  value1: Variant - first operand for this operation. value2: Variant - second operand for this operation. returns: Variant - result variant object.  in Performs the IN operation for two variants.\n in(value1: Variant, value2: Variant): Variant\n  value1: Variant - first operand for this operation. value2: Variant - second operand for this operation. returns: Variant - result variant object.  less Performs the \u0026lsquo;\u0026lt;\u0026rsquo; operation for two variants.\n less(value1: Variant, value2: Variant): Variant\n  value1: Variant - first operand for this operation. value2: Variant - second operand for this operation. returns: Variant - result variant object.  lessEqual Performs the \u0026lsquo;\u0026lt;=\u0026rsquo; operation for two variants.\n lessEqual(value1: Variant, value2: Variant): Variant\n  value1: Variant - first operand for this operation. value2: Variant - second operand for this operation. returns: Variant - result variant object.  lsh Performs the \u0026lsquo;\u0026laquo;\u0026rsquo; operation for two variants.\n lsh(value1: Variant, value2: Variant): Variant\n  value1: Variant - first operand for this operation. value2: Variant - second operand for this operation. returns: Variant - result variant object.  mod Performs the \u0026lsquo;%\u0026rsquo; operation for two variants.\n mod(value1: Variant, value2: Variant): Variant\n  value1: Variant - first operand for this operation. value2: Variant - second operand for this operation. returns: Variant - result variant object.  more Performs the \u0026lsquo;\u0026gt;\u0026rsquo; operation for two variants.\n more(value1: Variant, value2: Variant): Variant\n  value1: Variant - first operand for this operation. value2: Variant - second operand for this operation. returns: Variant - result variant object.  moreEqual Performs the \u0026lsquo;\u0026gt;=\u0026rsquo; operation for two variants.\n moreEqual(value1: Variant, value2: Variant): Variant\n  value1: Variant - first operand for this operation. value2: Variant - The second operand for this operation. returns: Variant - A result variant object.  mul Performs the \u0026lsquo;*\u0026rsquo; operation for two variants.\n mul(value1: Variant, value2: Variant): Variant\n  value1: Variant - first operand for this operation. value2: Variant - second operand for this operation. returns: Variant - result variant object.  negative Performs the unary \u0026lsquo;-\u0026rsquo; operation for a variant.\n negative(value: Variant): Variant\n  value: Variant - first operand for this operation. returns: Variant - result variant object.  not Performs the NOT operation for a variant.\n not(value: Variant): Variant\n  value: Variant - first operand for this operation. returns: Variant - result variant object.  notEqual Performs the \u0026lsquo;\u0026lt;\u0026gt;\u0026rsquo; operation for two variants.\n notEqual(value1: Variant, value2: Variant): Variant\n  value1: Variant - first operand for this operation. value2: Variant - second operand for this operation. returns: Variant - result variant object.  or Performs the OR operation for two variants.\n or(value1: Variant, value2: Variant): Variant\n  value1: Variant - first operand for this operation. value2: Variant - second operand for this operation. returns: Variant - result variant object.  pow Performs the \u0026lsquo;^\u0026rsquo; operation for two variants.\n pow(value1: Variant, value2: Variant): Variant\n  value1: Variant - first operand for this operation. value2: Variant - second operand for this operation. returns: Variant - result variant object.  rsh Performs the \u0026lsquo;\u0026raquo;\u0026rsquo; operation for two variants.\n rsh(value1: Variant, value2: Variant): Variant\n  value1: Variant - first operand for this operation. value2: Variant - second operand for this operation. returns: Variant - result variant object.  sub Performs the \u0026lsquo;-\u0026rsquo; operation for two variants.\n sub(value1: Variant, value2: Variant): Variant\n  value1: Variant - first operand for this operation. value2: Variant - second operand for this operation. returns: Variant - result variant object.  typeToString Converts a variant type to its string representation.\n protected typeToString(value: VariantType): string\n  value: VariantType - variant type to be converted. returns: string - string representation of the type.  xor Performs the XOR operation for two variants.\n xor(value1: Variant, value2: Variant): Variant\n  value1: Variant - first operand for this operation. value2: Variant - second operand for this operation. returns: Variant - result variant object.  ","description":"Implements an abstractd variant operations manager object.\n","image":null,"permalink":"/node/expressions/variants/ivariant_operations/","subtitle":null,"tags":null,"title":"IVariantOperations"},{"content":"Description The IVersioned interface allows you to define data objects that can be versioned.\nImportant points\n Versioning is often used as an optimistic concurrency mechanism. The version doesn\u0026rsquo;t have to be a number, but it is recommended to use sequential values to determine if one object has a newer or older version than another one. It is common to use the time of change as the object version.  Properties Version The object\u0026rsquo;s version.\n string Version { get; set; }\n Examples public class MyData: IStringIdentifiable, IVersioned { string id {get; set;} string field1; int field2; string version {get; set;} ... } public void updateData(string correlationId, MyData item) { ... if (item.Version \u0026lt; oldItem.Version) { throw new ConcurrencyException(null, \u0026#34;VERSION_CONFLICT\u0026#34;, \u0026#34;The change has older version stored value\u0026#34;); } ... } ","description":"Interface used to define data objects that can be versioned.\n","image":null,"permalink":"/net/commons/data/iversioned/","subtitle":null,"tags":null,"title":"IVersioned"},{"content":"Description The IVersioned interface allows you to define data objects that can be versioned.\nImportant points\n Versioning is often used as an optimistic concurrency mechanism. The version doesn\u0026rsquo;t have to be a number, but it is recommended to use sequential values to determine if one object has a newer or older version than another one. It is common to use the time of change as the object version.  Fields version Object\u0026rsquo;s version.\n version: string\n  Examples export class MyData implements IStringIdentifiable, IVersioned { public id: string; public field1: string; public field2: number; public version: string; ... } public updateData(correlationId: string, item: MyData): void { ... if (item.version \u0026lt; this.version) { throw new ConcurrencyException(null, \u0026#34;VERSION_CONFLICT\u0026#34;, \u0026#34;The change has older version stored value\u0026#34;); } ... } ","description":"Interface used to define data objects that can be versioned.\n","image":null,"permalink":"/node/commons/data/iversioned/","subtitle":null,"tags":null,"title":"IVersioned"},{"content":"Description The IVersioned interface allows you to define data objects that can be versioned.\nImportant points\n Versioning is often used as an optimistic concurrency mechanism. The version doesn\u0026rsquo;t have to be a number, but it is recommended to use sequential values to determine if one object has a newer or older version than another one. It is common to use the time of change as the object version.  Fields version The object\u0026rsquo;s version.\n version: str\n Examples class MyData(IStringIdentifiable, IVersioned): id = None version = None # do something def update_data(item): # do something if item.version \u0026lt; old_item.version: raise ConcurrencyException(None, \u0026#34;VERSION_CONFLICT\u0026#34;, \u0026#34;The change has older version stored args\u0026#34;) # do something  ","description":"Interface used to define data objects that can be versioned.\n","image":null,"permalink":"/python/commons/data/iversioned/","subtitle":null,"tags":null,"title":"IVersioned"},{"content":"Description The IVersioned interface allows you to define data objects that can be versioned.\nImportant points\n Versioning is often used as an optimistic concurrency mechanism. The version doesn\u0026rsquo;t have to be a number, but it is recommended to use sequential values to determine if one object has a newer or older version than another one. It is common to use the time of change as the object version.  Fields version The object\u0026rsquo;s version.\n version: string\n  Examples type MyData struct { Id string `json:\u0026#34;id\u0026#34;` Field1 string `json:\u0026#34;field1\u0026#34;` Field2 int32 `json:\u0026#34;field2\u0026#34;` Version string `json:\u0026#34;version\u0026#34;` ... } func (c* MyData) UpdateData(correlationId string, item MyData) error { ... if item.version \u0026lt; c.version { return NewConcurrencyErrorn(\u0026#34;\u0026#34;, \u0026#34;VERSION_CONFLICT\u0026#34;, \u0026#34;The change has older version stored value\u0026#34;); } return nil ... ","description":"Interface used to define data objects that can be versioned.\n","image":null,"permalink":"/golang/commons/data/iversioned/","subtitle":null,"tags":null,"title":"IVersioned!"},{"content":"Extends: ITokenizerState\nDescription The IWhitespaceState interface is used by TokenizerStates that process whitespaces (' \u0026lsquo;, \u0026lsquo;\\t\u0026rsquo;).\nInstance methods clearWhitespaceChars Clears definitions of whitespace characters.\n clearWhitespaceChars(): void\n setWhitespaceChars Establish the given characters as whitespace to ignore.\n setWhitespaceChars(fromSymbol: number, toSymbol: number, enable: boolean): void\n  fromSymbol: number - first character index of the interval. toSymbol: number - last character index of the interval. enable: boolean - true if this state should ignore characters in the given range.  ","description":"Defines an interface for tokenizer state that processes whitespaces (' ', '\\t').\n","image":null,"permalink":"/node/expressions/tokenizers/iwhitespace_state/","subtitle":null,"tags":null,"title":"IWhitespaceState"},{"content":"Extends: ITokenizerState\nDescription The IWordState interface is used by tokenizer states that process words, identificators or keywords.\nInstance methods clearWordChars Clears definitions of word chars.\n clearWordChars(): void\n setWordChars Establish characters in the given range as valid characters for part of a word after the first character. Note that the tokenizer must determine which characters are valid as the beginning character of a word.\n setWordChars(fromSymbol: number, toSymbol: number, enable: boolean): void\n  fromSymbol: number - first character index of the interval. toSymbol: number - last character index of the interval. enable: boolean - true if this state should use characters in the given range.  ","description":"Defines an interface for tokenizer state that processes words, identificators or keywords\n","image":null,"permalink":"/node/expressions/tokenizers/iword_state/","subtitle":null,"tags":null,"title":"IWordState"},{"content":"Description The IWriter interface is used by data processng components that can create, update and delete data items.\nMethods Create Creates a data item.\n Create(correlation_id string, item interface{}) (value interface{}, err error)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. item: interface{} - item to be created. returns: (value interface{}, err error) - created item  Update Updates a data item.\n Update(correlation_id string, item interface{}) (value interface{}, err error)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. item: interface{} - item to be updated. returns: (value interface{}, err error) - updated item  DeleteById Updates a data item.\n DeleteById(correlation_id string, id interface{}) (value interface{}, err error)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. id: interface{} - id of the item to be deleted returns: (value interface{}, err error) - deleted item.  ","description":"Interface for data processing components that can create, update and delete data items.\n","image":null,"permalink":"/golang/data/persistence/iwriter/","subtitle":null,"tags":null,"title":"IWriter"},{"content":"Description The IWriter interface is used by data processng components that can create, update and delete data items.\nInstance methods CreateAsync Creates a data item.\n Task\u0026lt;T\u0026gt; CreateAsync(string correlationId, T item)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. item: T - item to be created. returns: Task\u0026lt;T\u0026gt; - created item  UpdateAsync Updates a data item.\n Task\u0026lt;T\u0026gt; UpdateAsync(string correlationId, T item)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. item: T - item to be updated. returns: Task\u0026lt;T\u0026gt; - updated item  DeleteByIdAsync Updates a data item.\n Task\u0026lt;T\u0026gt; DeleteByIdAsync(string correlationId, K id)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. id: K - id of the item to be deleted returns: Task\u0026lt;T\u0026gt; - deleted item.  ","description":"Interface for data processing components that can create, update and delete data items.\n","image":null,"permalink":"/net/data/core/iwriter/","subtitle":null,"tags":null,"title":"IWriter\u003cT, in K\u003e"},{"content":"Description The IWriter interface is used by data processng components that can create, update and delete data items.\nInstance methods create Creates a data item.\n create(correlationId: string, item: T): Promise\u0026lt;T\u0026gt;\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. item: T - item to be created. returns: T - created item  update Updates a data item.\n update(correlationId: string, item: T): Promise\u0026lt;T\u0026gt;\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. item: T - item to be updated. returns: Promise\u0026lt;T\u0026gt; - updated item  deleteById Updates a data item.\n deleteById(correlationId: string, id: K): Promise\u0026lt;T\u0026gt;\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. id: K - id of the item to be deleted returns: Promise\u0026lt;T\u0026gt; - deleted item.  ","description":"Interface for data processing components that can create, update and delete data items.\n","image":null,"permalink":"/node/data/core/iwriter/","subtitle":null,"tags":null,"title":"IWriter\u003cT, K\u003e"},{"content":"Description The IWriter interface is used by data processng components that can create, update and delete data items.\nInstance methods create Creates a data item.\n create(correlation_id: Optional[str], item: T): T\n  correlation_id: Optional[str] - (optional) transaction id used to trace execution through the call chain. item: T - item to be created. returns: T - created item  update Updates a data item.\n update(correlation_id: Optional[str], item: T): T\n  correlation_id: Optional[str] - (optional) transaction id used to trace execution through the call chain. item: T - item to be updated. returns: T - updated item  delete_by_id Updates a data item.\n delete_by_id(correlation_id: Optional[str], id: Any): T\n  correlation_id: Optional[str] - (optional) transaction id used to trace execution through the call chain. id: Any - id of the item to be deleted returns: T - deleted item.  ","description":"Interface for data processing components that can create, update and delete data items.\n","image":null,"permalink":"/python/data/core/iwriter/","subtitle":null,"tags":null,"title":"IWriter"},{"content":"Keeps list of working jobs. The service allows you to manage tasks in those cases when the generation (statement) of the task is performed in a separate microservice, and direct execution is implemented in one way or another.\n Server implementations: NodeJS, Dart Communication protocols: Direct, Commandable HTTP, Commandable GRPC, GRPC Persistence: Memory, Flat Files, MongoDB, Couchbase Deployment options: Monolith, Process, Docker, AWS Lambda Client implementations: NodeJS, Dart  ","description":null,"image":null,"permalink":"/microservices/infrastructure/jobs/","subtitle":null,"tags":null,"title":"Jobs Microservice"},{"content":"Implements: FileConfigReader\nDescription The JsonConfigReader class allows you to create a config reader that reads a configuration from a JSON file.\nImportant points\n The reader supports parameterization using Handlebar template engine.  Configuration parameters  path: path to the configuration file parameters: this entire section is used as template parameters \u0026hellip;  Constructors NewJsonConfigReader Creates a new instance of the config reader.\n NewJsonConfigReader(path string) *JsonConfigReader\n  path: string - (optional) path to the configuration file.  NewEmptyJsonConfigReader Creates a new instance of the config reader.\n NewEmptyJsonConfigReader() *JsonConfigReader\n Methods ReadConfig Reads a configuration and parameterizes it with given values.\n (c *JsonConfigReader) ReadConfig(correlationId string, parameters *cconfig.ConfigParams) (result *cconfig.ConfigParams, err error)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. parameters: *cconfig.ConfigParams - values to parameters the configuration or nil to skip parameterization. returns: (result *cconfig.ConfigParams, err error) - ConfigParams configuration.  ReadObject Reads a configuration file, parameterizes its content and converts it into JSON object.\n (c *JsonConfigReader) ReadObject(correlationId string, parameters *cconfig.ConfigParams) (interface{}, error)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. parameters: *cconfig.ConfigParams - values of the configuration parameters. returns: (interface{}, error) - JSON object with configuration.  ReadConfig Reads a configuration from a file, parameterizes it with given values and returns a new ConfigParams object.\n (c *JsonConfigReader) ReadConfig(correlationId string, parameters *cconfig.ConfigParams) (result *cconfig.ConfigParams, err error)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. path: string - path to a configuration file. parameters: *cconfig.ConfigParams - values of the configuration parameters. returns: (result *cconfig.ConfigParams, err error) - ConfigParams configuration.  ReadJsonObject Reads a configuration file, parameterizes its content and converts it into a JSON object.\n ReadJsonObject(correlationId string, path string, parameters *cconfig.ConfigParams) (interface{}, error)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. path: string - path to configuration file. parameters: *cconfig.ConfigParams - values of the configuration parameters. returns: (interface{}, error) - JSON object with configuration.  Examples { \u0026#34;key1\u0026#34;: \u0026#34;{{KEY1_VALUE}}\u0026#34;, \u0026#34;key2\u0026#34;: \u0026#34;{{KEY2_VALUE}}\u0026#34; } configReader := NewJsonConfigReader(\u0026#34;config.json\u0026#34;) parameters := NewConfigParamsFromTuples(\u0026#34;KEY1_VALUE\u0026#34;, 123, \u0026#34;KEY2_VALUE\u0026#34;, \u0026#34;ABC\u0026#34;) res, err := configReader.ReadConfig(\u0026#34;123\u0026#34;, parameters) See also   IConfigReader   FileConfigReader   ","description":"Config reader that reads a configuration from a JSON file.\n","image":null,"permalink":"/golang/components/config/json_config_reader/","subtitle":null,"tags":null,"title":"JsonConfigReader"},{"content":"Inherits: FileConfigReader\nDescription The JsonConfigReader class allows you to create a config reader that reads a configuration from a JSON file.\nImportant points\n The reader supports parameterization using Handlebar template engine.  Configuration parameters  path: path to the configuration file parameters: this entire section is used as template parameters \u0026hellip;  Constructors Creates a new instance of the config reader.\n public JsonConfigReader(string path = null)\n  path: string - (optional) path to the configuration file.  Instance methods ReadConfig Reads a configuration and parameterizes it with given values.\n public override ReadConfig(string correlationId, ConfigParams ConfigParams parameters)\n  correlationId: string - (optional) transaction id to trace execution through call chain. parameters: ConfigParams - values to parameters the configuration or null to skip parameterization. returns: ConfigParams - ConfigParams configuration.  ReadObject Reads a configuration file, parameterizes its content and converts it into a JSON object.\n private object ReadObject(string correlationId, ConfigParams parameters)\n  correlationId: string - (optional) transaction id to trace execution through a call chain. parameters: ConfigParams - values of the configuration parameters. returns: object - a JSON object with configuration.  Static methods ReadConfig Reads a configuration from a file, parameterizes it with given values and returns a new ConfigParams object.\n public static ConfigParams ReadConfig(string correlationId, string path, ConfigParams parameters)\n  correlationId: string - (optional) transaction id used to trace execution through a call chain. path: string - a path to configuration file. parameters: ConfigParams - values of the configuration parameters. returns: ConfigParams - ConfigParams configuration.  ReadObject Reads a configuration file, parameterizes its content and converts it into a JSON object.\n public static object ReadObject(string correlationId, string path, ConfigParams parameters)\n  correlationId: string - (optional) transaction id to trace execution through a call chain. path: string - a path to configuration file. parameters: ConfigParams - values of the configuration parameters. returns: object - a JSON object with configuration.  Examples { \u0026#34;key1\u0026#34;: \u0026#34;{{KEY1_VALUE}}\u0026#34;, \u0026#34;key2\u0026#34;: \u0026#34;{{KEY2_VALUE}}\u0026#34; } var configReader = new JsonConfigReader(\u0026#34;config.json\u0026#34;); var parameters = ConfigParams.FromTuples(\u0026#34;KEY1_VALUE\u0026#34;, 123, \u0026#34;KEY2_VALUE\u0026#34;, \u0026#34;ABC\u0026#34;); configReader.ReadConfig(\u0026#34;123\u0026#34;, parameters); See also   IConfigReader   FileConfigReader   ","description":"Config reader that reads a configuration from a JSON file.\n","image":null,"permalink":"/net/components/config/json_config_reader/","subtitle":null,"tags":null,"title":"JsonConfigReader"},{"content":"Extends: FileConfigReader\nDescription The JsonConfigReader class allows you to create a config reader that reads a configuration from a JSON file.\nImportant points\n The reader supports parameterization using Handlebar template engine.  Configuration parameters  path: path to the configuration file parameters: this entire section is used as template parameters \u0026hellip;  Constructors Creates a new instance of the config reader.\n public constructor(path: string = null)\n  path: string - (optional) path to the configuration file.  Instance methods readConfig Reads a configuration and parameterizes it with given values.\n public readConfig(correlationId: string, parameters: ConfigParams): Promise\u0026lt;ConfigParams\u0026gt;\n  correlationId: string - (optional) transaction id to trace execution through call chain. parameters: ConfigParams - values to parameters the configuration or null to skip parameterization. returns: Promise\u0026lt;ConfigParams\u0026gt; - ConfigParams configuration.  readObject Reads a configuration file, parameterizes its content and converts it into a JSON object.\n public readObject(correlationId: string, parameters: ConfigParams): any\n  correlationId: string - (optional) transaction id to trace execution through a call chain. parameters: ConfigParams - values of the configuration parameters. returns: any - a JSON object with configuration.  Static methods readConfig Reads a configuration from a file, parameterizes it with given values and returns a new ConfigParams object.\n public static readConfig(correlationId: string, path: string, parameters: ConfigParams): ConfigParams\n  correlationId: string - (optional) transaction id used to trace execution through a call chain. path: string - a path to configuration file. parameters: ConfigParams - values of the configuration parameters. returns: ConfigParams - ConfigParams configuration.  readObject Reads a configuration file, parameterizes its content and converts it into a JSON object.\n public static readObject(correlationId: string, path: string, parameters: ConfigParams): any\n  correlationId: string - (optional) transaction id to trace execution through a call chain. path: string - a path to configuration file. parameters: ConfigParams - values of the configuration parameters. returns: any - a JSON object with configuration.  Examples { \u0026#34;key1\u0026#34;: \u0026#34;{{KEY1_VALUE}}\u0026#34;, \u0026#34;key2\u0026#34;: \u0026#34;{{KEY2_VALUE}}\u0026#34; } let configReader = new JsonConfigReader(\u0026#34;config.json\u0026#34;); let parameters = ConfigParams.fromTuples(\u0026#34;KEY1_VALUE\u0026#34;, 123, \u0026#34;KEY2_VALUE\u0026#34;, \u0026#34;ABC\u0026#34;); let config = await configReader.readConfig(\u0026#34;123\u0026#34;, parameters); // Result: key1=123;key2=ABC See also   IConfigReader   FileConfigReader   ","description":"Config reader that reads a configuration from a JSON file.\n","image":null,"permalink":"/node/components/config/json_config_reader/","subtitle":null,"tags":null,"title":"JsonConfigReader"},{"content":"Implements: FileConfigReader\nDescription The JsonConfigReader class allows you to create a config reader that reads a configuration from a JSON file.\nImportant points\n The reader supports parameterization using Handlebar template engine.  Configuration parameters  path: path to the configuration file parameters: this entire section is used as template parameters \u0026hellip;  Constructors Creates a new instance of the config reader.\n JsonConfigReader(path: str = None)\n  path: str - (optional) path to the configuration file.  Instanc methods _read_config Reads a configuration and parameterizes it with given values.\n _read_config(correlation_id: Optional[str], parameters: ConfigParams): ConfigParams\n  correlation_id: Optional[str] - (optional) transaction id to trace execution through call chain. parameters: ConfigParams - values to parameters the configuration or None to skip parameterization. returns: ConfigParams - ConfigParams configuration.  _read_object Reads a configuration file, parameterizes its content and converts it into a JSON object.\n _read_object(correlation_id: Optional[str], parameters: ConfigParams): Any\n  correlation_id: Optional[str] - (optional) transaction id to trace execution through a call chain. parameters: ConfigParams - values of the configuration parameters. returns: Any - a JSON object with configuration.  read_config Reads a configuration from a file, parameterizes it with given values and returns a new ConfigParams object.\n static read_config(correlation_id: Optional[str], path: str, parameters: ConfigParams): ConfigParams\n  correlation_id: Optional[str] - (optional) transaction id used to trace execution through a call chain. path: str - a path to configuration file. parameters: ConfigParams - values of the configuration parameters. returns: ConfigParams - ConfigParams configuration.  read_object Reads a configuration file, parameterizes its content and converts it into a JSON object.\n static read_config(correlation_id: Optional[str], path: str, parameters: ConfigParams): Any\n  correlation_id: Optional[str] - (optional) transaction id to trace execution through a call chain. path: str - a path to configuration file. parameters: ConfigParams - values of the configuration parameters. returns: Any - a JSON object with configuration.  Examples { \u0026#34;key1\u0026#34;: \u0026#34;{{KEY1_VALUE}}\u0026#34;, \u0026#34;key2\u0026#34;: \u0026#34;{{KEY2_VALUE}}\u0026#34; } configReader = JsonConfigReader(\u0026#34;config.json\u0026#34;) parameters = ConfigParams.from_tuples(\u0026#34;KEY1_VALUE\u0026#34;, 123, \u0026#34;KEY2_VALUE\u0026#34;, \u0026#34;ABC\u0026#34;) configReader._read_config(\u0026#34;123\u0026#34;, parameters) See also   IConfigReader   FileConfigReader   ","description":"Config reader that reads a configuration from a JSON file.\n","image":null,"permalink":"/python/components/config/json_config_reader/","subtitle":null,"tags":null,"title":"JsonConfigReader"},{"content":"Description The JsonConverter class allows you to convert arbitrary values (e.g. a JSON object) from and to JSON (JavaScript Object Notation) strings.\nMethods FromJson Converts value from JSON string\n FromJson(value string) (interface{}, error)\n  value: string - JSON string to convert. returns: (interface{}, error) - converted object value or nil when value is nil.  FromJsonAs Converts a JSON string into a value of type specified by a TypeCode.\n FromJsonAs(result interface{}, value string) (interface{}, error)\n  result: interface{} - TypeCode for the data type into which \u0026lsquo;value\u0026rsquo; is to be converted. value: string - JSON string to convert. returns: (interface{}, error) - converted object value or nil when value is nil.  ToJson Converts a value into a JSON string.\n ToJson(value interface{}) (string, error)\n  value: interface{} - value to convert. returns: (string, error) - JSON string or nil when value is nil.  ToMap Converts a JSON string into a map object or returns an empty map when conversion is not possible. See LongConverter.ToNullableLong\n ToMap(value string) map[string]interface{}\n  value: string - JSON string to convert. returns: map[string]interface{} - Map object value or empty object when conversion is not supported.  ToMapWithDefault Converts a JSON string into a map object or returns a default value when conversion is not possible.\n ToMapWithDefault(value string, defaultValue map[string]interface{}) map[string]interface{}\n  value: string - JSON string to convert. defaultValue: map[string]interface{} - default value. returns: map[string]interface{} - Map object value or default when conversion is not supported.  ToNullableMap Converts a JSON string into a map object or returns nil when conversion is not possible.\nSee MapConverter.ToNullableMap\n ToNullableMap(value string) *map[string]interface{}\n  value: string - JSON string to convert. returns: *map[string]interface{} - Map object value or nil when conversion is not supported.  Examples value1, _ := convert.FromJson(\u0026#34;{\\\u0026#34;key\\\u0026#34;:123}\u0026#34;) value2 := convert.JsonConverter.ToMap(\u0026#34;{\\\u0026#34;key\\\u0026#34;:123}\u0026#34;) value3, _ := convert.ToJson(map[string]int{\u0026#34;key\u0026#34;: 123}) fmt.Println(value1) // map[key:123] fmt.Println(value2) // map[key:123] fmt.Println(value3) // {\u0026#34;key\u0026#34;:123}  ","description":"The JsonConverter class allows you to convert arbitrary values (e.g. a JSON object) from and to JSON (JavaScript Object Notation) strings.\n","image":null,"permalink":"/golang/commons/convert/json_converter/","subtitle":null,"tags":null,"title":"JsonConverter"},{"content":"Description The JsonConverter class allows you to convert arbitrary values (e.g. a JSON object) from and to JSON (JavaScript Object Notation) strings.\nStatic methods FromJson Converts to value from a JSON string\n public static object FromJson(string value)\n  value: string - JSON string to convert. returns: T - converted object value or null when value is null.  FromJson Converts value from JSON string to T object\n public static T FromJson\u0026lt;T\u0026gt;(string value)\n  value: string - JSON string to convert. returns: T - converted object value or null when value is null.  ToJson Converts value to a JSON string.\n public static string ToJson(object value)\n  value: object - value to convert. returns: string - JSON string or null when value is null.  ToMap Converts JSON string into map object or returns empty map when the conversion is not possible. See LongConverter.ToNullableLong\n public static IDictionary\u0026lt;string, object\u0026gt; ToMap(string value)\n  value: string - JSON string to convert. returns: IDictionary\u0026lt;string, object\u0026gt; - Map object value or empty object when the conversion is not supported.  ToMapWithDefault Converts a JSON string into a map object or returns a given default value when the conversion is not possible.\n public static IDictionary\u0026lt;string, object\u0026gt; ToMapWithDefault(string value, IDictionary\u0026lt;string, object\u0026gt; defaultValue)\n  value: string - JSON string to convert. defaultValue: IDictionary\u0026lt;string, object\u0026gt; - default value. returns: IDictionary\u0026lt;string, object\u0026gt; - Map object value or default when the conversion is not supported.  ToNullableMap Converts a JSON string into a map object or returns null when the conversion is not possible.\nSee MapConverter.ToNullableMap\n public static IDictionary\u0026lt;string, object\u0026gt; ToNullableMap(string value)\n  value: string - JSON string to convert. returns: IDictionary\u0026lt;string, object\u0026gt; - Map object value or null when conversion is not supported.  Examples var value1 = JsonConverter.FromJson(\u0026#34;{\\\u0026#34;key\\\u0026#34;:123}\u0026#34;); // Result: { key: 123 } var value2 = JsonConverter.ToMap({ key: 123}); // Result: \u0026#34;{\\\u0026#34;key\\\u0026#34;:123}\u0026#34;  ","description":"The JsonConverter class allows you to convert arbitrary values (e.g. a JSON object) from and to JSON (JavaScript Object Notation) strings.\n","image":null,"permalink":"/net/commons/convert/json_converter/","subtitle":null,"tags":null,"title":"JsonConverter"},{"content":"Description The JsonConverter class allows you to convert arbitrary values (e.g. a JSON object) from and to JSON (JavaScript Object Notation) strings.\nStatic methods fromJson Converts a JSON string into a value of the type specified by a TypeCode.\n public static fromJson\u0026lt;T\u0026gt;(type: TypeCode, value: string): T\n  type: TypeCode - TypeCode for the data type into which \u0026lsquo;value\u0026rsquo; is to be converted. value: string - JSON string to convert. returns: T - converted object value or null when value is null.  toJson Converts value into a JSON string.\n public static toJson(value: any): string\n  value: any - value to convert. returns: string - JSON string or null when value is null.  toMap Converts JSON string into a map object or returns an empty map when the conversion is not possible. See LongConverter.toNullableLong\n public static toMap(value: string): any\n  value: string - JSON string to convert. returns: any - Map object value or empty object when the conversion is not supported.  toMapWithDefault Converts a JSON string into a map object or returns a default value when the conversion is not possible.\n public static toMapWithDefault(value: string, defaultValue: any): any\n  value: string - JSON string to convert. defaultValue: any - default value. returns: any - Map object or given default when the conversion is not supported.  toNullableMap Converts a JSON string into a map object or returns null when the conversion is not possible.\nSee MapConverter.toNullableMap\n public static toNullableMap(value: string): any\n  value: string - JSON string to convert. returns: any - Map object or null when the conversion is not supported.  Examples let value1 = JsonConverter.fromJson(\u0026#34;{\\\u0026#34;key\\\u0026#34;:123}\u0026#34;); // Result: { key: 123 } let value2 = JsonConverter.toMap({ key: 123}); // Result: \u0026#34;{\\\u0026#34;key\\\u0026#34;:123}\u0026#34;  ","description":"The JsonConverter class allows you to convert arbitrary values (e.g. a JSON object) from and to JSON (JavaScript Object Notation) strings.\n","image":null,"permalink":"/node/commons/convert/json_converter/","subtitle":null,"tags":null,"title":"JsonConverter"},{"content":"Description The JsonConverter class allows you to convert arbitrary values (e.g. a JSON object) from and to JSON (JavaScript Object Notation) strings.\nStatic methods from_json Converts JSON string into a value of type specified by a TypeCode.\n static from_json(type: TypeCode, value: str): Any\n  type: TypeCode - the TypeCode for the data type into which \u0026lsquo;value\u0026rsquo; is to be converted. value: str - the JSON string to convert. returns: Any - converted object value or None when value is None.  to_json Converts value into JSON string.\n static to_json(value: Any): Optional[str]\n  value: Any - the value to convert. returns: str - JSON string or None when value is None.  to_map Converts JSON string into map object or returns empty map when conversion is not possible. See LongConverter.to_nullable_long\n static to_map(value: str): Any\n  value: str - the JSON string to convert. returns: Any - Map object value or empty object when conversion is not supported.  to_map_with_default Converts JSON string into map object or returns default value when conversion is not possible.\n static to_map_with_default(value: str, default_value: Any): Any\n  value: str - the JSON string to convert. default_value: Any - the default value. returns: Any - Map object value or default when conversion is not supported.  to_nullable_map Converts JSON string into map object or returns None when conversion is not possible.\nSee MapConverter.to_nullable_map\n static to_nullable_map(value: str): Any\n  value: str - the JSON string to convert. returns: Any - Map object value or None when conversion is not supported.  Examples value1 = JsonConverter.to_json({\u0026#39;key\u0026#39;:123}) # Returns \u0026#39;{\u0026#34;key\u0026#34;: 123}\u0026#39; ","description":"The JsonConverter class allows you to convert arbitrary values (e.g. a JSON object) from and to JSON (JavaScript Object Notation) strings.\n","image":null,"permalink":"/python/commons/convert/json_converter/","subtitle":null,"tags":null,"title":"JsonConverter"},{"content":"Description The JsonFilePersister class allows you to create persistence components that load and save data from/to a flat file\nConfiguration parameters  path: path to the file where the data is stored  Constructors NewJsonFilePersister Creates a new instance of the JSON file persistence component.\n NewJsonFilePersister(prototype reflect.Type, path string) *JsonFilePersister\n  prototype: reflect.Type - data type path: string - (optional) path to the file where the data is stored.  Fields path Gets the file path where the data is stored.\n (c *JsonFilePersister) Path() string\n  returns: string - file path where the data is stored.  SetPath Sets the file path where data is stored.\n (c *JsonFilePersister) SetPath(value string)\n  value: string - file path where data is stored.  Methods Configure Configures the component by passing its configuration parameters.\n (c *JsonFilePersister) Configure(config *config.ConfigParams)\n  config: *config.ConfigParams - configuration parameters to be set.  Load Loads data items from an external JSON file.\n (c *JsonFilePersister) Load(correlation_id string) (data []interface{}, err error)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. returns: (data []interface{}, err error) - loaded items  Save Saves given data items to an external JSON file.\n (c *JsonFilePersister) Save(correlationId string, items []interface{}) error\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. items: []interface{} - list if data items to save returns: error - returns error if not saved  Examples persister := NewJsonFilePersister(reflect.TypeOf(MyData{}), \u0026#34;./data/data.json\u0026#34;); err_sav := persister.Save(\u0026#34;123\u0026#34;, [\u0026#34;A\u0026#34;, \u0026#34;B\u0026#34;, \u0026#34;C\u0026#34;]) if err_sav == nil { items, err_lod := persister.Load(\u0026#34;123\u0026#34;) if err_lod == nil { fmt.Println(items);// Result: [\u0026#34;A\u0026#34;, \u0026#34;B\u0026#34;, \u0026#34;C\u0026#34;] \t} } ","description":"Persistence component that loads and saves data from/to a flat file.\nIt is used by [FilePersistence](../file_persistence), but can be useful on its own.\n","image":null,"permalink":"/golang/data/persistence/json_file_persister/","subtitle":null,"tags":null,"title":"JsonFilePersister"},{"content":"Inherits: IConfigurable, ILoader, ISaver\nDescription The JsonFilePersister class allows you to create persistence components that load and save data from/to a flat file\nConfiguration parameters  path: path to the file where the data is stored  Constructors Creates a new instance of the JSON file persistence component.\n public JsonFilePersister(string path)\n  path: string - (optional) path to the file where the data is stored.  Creates a new instance of the persistence.\n public JsonFilePersister()\n Properties Path Gets and sets the file path where the data is stored.\n public Path [ get, private set ]\n Instance methods Configure Configures the component by passing its configuration parameters.\n public void Configure(ConfigParams config)\n  config: ConfigParams - configuration parameters to be set.  LoadAsync Loads data items from an external JSON file.\n public Task\u0026lt;List\u0026lt;T\u0026gt;\u0026gt; LoadAsync(string correlationId)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. returns: Task\u0026lt;List\u0026lt;T\u0026gt;\u0026gt; - loaded items  Save Saves given data items to an external JSON file.\n public Task SaveAsync(string correlationId, IEnumerable\u0026lt;T\u0026gt; entities)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. items: IEnumerable\u0026lt;T\u0026gt; - list if data items to save  Examples var persister = new JsonFilePersister(\u0026#34;./data/data.json\u0026#34;); var list = new List\u0026lt;string\u0026gt;() {{add(\u0026#34;A\u0026#34;); add(\u0026#34;B\u0026#34;); add(\u0026#34;C\u0026#34;); }}; persister.Save(\u0026#34;123\u0026#34;, list); ... persister.Load(\u0026#34;123\u0026#34;, items); Console.Out.WriteLine(items); // Result: [\u0026#34;A\u0026#34;, \u0026#34;B\u0026#34;, \u0026#34;C\u0026#34;]  ","description":"Persistence component that loads and saves data from/to a flat file.\nIt is used by [FilePersistence](../file_persistence), but can be useful on its own.\n","image":null,"permalink":"/net/data/persistence/json_file_persister/","subtitle":null,"tags":null,"title":"JsonFilePersister\u003cT\u003e"},{"content":"Implements: IConfigurable, ILoader, ISaver\nDescription The JsonFilePersister class allows you to create persistence components that load and save data from/to a flat file\nConfiguration parameters  path: path to the file where the data is stored  Constructors Creates a new instance of the JSON file persistence component.\n public constructor(path?: string)\n  path: string - (optional) path to the file where the data is stored.  Properties path Gets the file path where the data is stored.\n public path(): string\n  returns: string - file path where the data is stored.  Sets the file path where data is stored.\n public path(value: string)\n  value: string - file path where data is stored.  Instance methods configure Configures the component by passing its configuration parameters.\n public configure(config: ConfigParams): void\n  config: ConfigParams - configuration parameters to be set.  load Loads data items from an external JSON file.\n public load(correlationId: string): Promise\u0026lt;T[]\u0026gt;\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. returns: Promise\u0026lt;T[]\u0026gt; - loaded items  save Saves given data items to an external JSON file.\n public save(correlationId: string, items: T[]): Promise\u0026lt;void\u0026gt;\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. items: T[] - list if data items to save  Examples let persister = new JsonFilePersister(\u0026#34;./data/data.json\u0026#34;); await persister.save(\u0026#34;123\u0026#34;, [\u0026#34;A\u0026#34;, \u0026#34;B\u0026#34;, \u0026#34;C\u0026#34;]); ... let items = await persister.load(\u0026#34;123\u0026#34;); console.log(items); // Result: [\u0026#34;A\u0026#34;, \u0026#34;B\u0026#34;, \u0026#34;C\u0026#34;]  ","description":"Persistence component that loads and saves data from/to a flat file.\nIt is used by [FilePersistence](../file_persistence), but can be useful on its own.\n","image":null,"permalink":"/node/data/persistence/json_file_persister/","subtitle":null,"tags":null,"title":"JsonFilePersister\u003cT\u003e"},{"content":"Implements: IConfigurable, ILoader, ISaver\nDescription The JsonFilePersister class allows you to create persistence components that load and save data from/to a flat file\nConfiguration parameters  path: path to the file where the data is stored  Constructors Creates a new instance of the JSON file persistence component.\n JsonFilePersister(path: str = None)\n  path: str - (optional) path to the file where the data is stored.  Properties path Gets the file path where the data is stored.\n path(): str\n  returns: str - file path where the data is stored.  Sets the file path where data is stored.\n path(value: str)\n  value: str - file path where data is stored.  Instance methods configure Configures the component by passing its configuration parameters.\n configure(config: ConfigParams)\n  config: ConfigParams - configuration parameters to be set.  load Loads data items from an external JSON file.\n load(correlation_id: Optional[str]): List[T]\n  correlation_id: Optional[str] - (optional) transaction id used to trace execution through the call chain. returns: List[T] - loaded items  save Saves given data items to an external JSON file.\n save(correlation_id: Optional[str], items: List[T])\n  correlation_id: Optional[str] - (optional) transaction id used to trace execution through the call chain. items: List[T] - list if data items to save  Examples persister = JsonFilePersister(\u0026#34;./data/data.json\u0026#34;) persister.save(\u0026#34;123\u0026#34;, [\u0026#34;A\u0026#34;, \u0026#34;B\u0026#34;, \u0026#34;C\u0026#34;]) ... persister.load(\u0026#34;123\u0026#34;, items) print(items) ","description":"Persistence component that loads and saves data from/to a flat file.\nIt is used by [FilePersistence](../file_persistence), but can be useful on its own.\n","image":null,"permalink":"/python/data/persistence/json_file_persister/","subtitle":null,"tags":null,"title":"JsonFilePersister"},{"content":"Description The LambdaAction class is used to define actions to be executed as Lambda functions.\nFields cmd Command to call the action\n public cmd: string\n schema Schema to validate action parameters\n public schema: Schema\n action Action to be executed\n public action: (params: any) =\u0026gt; Promise\u0026lt;any\u0026gt;\n  ","description":"TODO: add description\n","image":null,"permalink":"/node/aws/services/lambda_action/","subtitle":null,"tags":null,"title":"LambdaAction"},{"content":"Implements: IOpenable, IConfigurable, IReferenceable\nDescription When making calls \u0026ldquo;cmd\u0026rdquo; parameter determines which what action shall be called, while other parameters are passed to the action itself.\nConfiguration parameters  connections:  discovery_key: (optional) a key to retrieve the connection from IDiscovery region: (optional) AWS region   credentials:  store_key: (optional) a key to retrieve the credentials from ICredentialStore access_id: AWS access/client id access_key: AWS access/client id   options:  connect_timeout: (optional) connection timeout in milliseconds (default: 10 sec)    References  *:logger:*:*:1.0: (optional) ILogger components to pass log messages. *:counters:*:*:1.0: (optional) ICounters components to pass collected measurements. *:discovery:*:*:1.0: (optional) IDiscovery services to resolve connection. *:credential-store:*:*:1.0: (optional) Credential stores to resolve credentials.  Constructors Creates a new instance of this client.\n public constructor(name: string)\n  name: string - a service name.  Fields _connection The AWS connection parameters\n protected _connection: AwsConnectionParams\n _connectionResolver The connection resolver.\n protected _connectionResolver: AwsConnectionResolver\n _counters The performance counters.\n protected _counters: CompositeCounters\n _dependencyResolver The dependencies resolver.\n protected _dependencyResolver: DependencyResolver\n _lambda The reference to AWS Lambda Function.\n protected _lambda: any\n _logger The logger.\n protected _logger: CompositeLogger\n _opened The opened flag.\n protected _opened: boolean\n _tracer The tracer.\n protected _tracer: CompositeTracer\n  Instance methods call Calls a AWS Lambda Function action.\n protected call(cmd: string, correlationId: string, params: any = {}): Promise\u0026lt;any\u0026gt;\n  cmd: string - an action name to be called. correlationId: string - (optional) transaction id to trace execution through call chain. params: any - (optional) action parameters. returns: Promise\u0026lt;any\u0026gt; - action result.  callOneWay Calls a AWS Lambda Function action asynchronously without waiting for response.\n protected callOneWay(cmd: string, correlationId: string, params: any = {}): Promise\u0026lt;any\u0026gt;\n  cmd: string - an action name to be called. correlationId: string - (optional) transaction id to trace execution through call chain. params: any - (optional) action parameters. returns: Promise\u0026lt;any\u0026gt; - action result.  close Closes component and frees used resources.\n public close(correlationId: string): Promise\u0026lt;void\u0026gt;\n  correlationId: string - (optional) transaction id to trace execution through call chain.  configure Configures component by passing configuration parameters.\n public configure(config: ConfigParams): void\n  config: ConfigParams - configuration parameters to be set.  instrument Adds instrumentation to log calls and measure call time. It returns a InstrumentTiming object that is used to end the time measurement.\n protected instrument(correlationId: string, name: string): InstrumentTiming\n  correlationId: string - (optional) transaction id to trace execution through call chain. name: string - a method name. returns: InstrumentTiming - object to end the time measurement.  invoke Performs AWS Lambda Function invocation.\n protected invoke(invocationType: string, cmd: string, correlationId: string, args: any): Promise\u0026lt;any\u0026gt;\n  invocationType: string - an invocation type: \u0026ldquo;RequestResponse\u0026rdquo; or \u0026ldquo;Event\u0026rdquo; cmd: string - an action name to be called. correlationId: string - (optional) transaction id to trace execution through call chain. args: any - action arguments returns: Promise\u0026lt;any\u0026gt; - action result.  isOpen Checks if the component is opened.\n public isOpen(): boolean\n  returns: boolean - true if the component has been opened and false otherwise.  open Opens the component.\n public open(correlationId: string): Promise\u0026lt;void\u0026gt;\n  correlationId: string - (optional) transaction id to trace execution through call chain.  setReferences Sets references to dependent components.\n public setReferences(references: IReferences): void\n  references: IReferences - references to locate the component dependencies.  Examples class MyLambdaClient extends LambdaClient implements IMyClient { ... public async getData(correlationId: string, id: string): Promise\u0026lt;MyData\u0026gt; { let timing = this.instrument(correlationId, \u0026#39;myclient.get_data\u0026#39;); const result = await this.call(\u0026#34;get_data\u0026#34; correlationId, { id: id }); timing.endTiming(); return result; } ... } let client = new MyLambdaClient(); client.configure(ConfigParams.fromTuples( \u0026#34;connection.region\u0026#34;, \u0026#34;us-east-1\u0026#34;, \u0026#34;connection.access_id\u0026#34;, \u0026#34;XXXXXXXXXXX\u0026#34;, \u0026#34;connection.access_key\u0026#34;, \u0026#34;XXXXXXXXXXX\u0026#34;, \u0026#34;connection.arn\u0026#34;, \u0026#34;YYYYYYYYYYYYY\u0026#34; )); * const result = await client.getData(\u0026#34;123\u0026#34;, \u0026#34;1\u0026#34;); See also   LambdaFunction   ","description":"Abstract client that calls AWS Lambda Functions.\n","image":null,"permalink":"/node/aws/clients/lambda_client/","subtitle":null,"tags":null,"title":"LambdaClient"},{"content":"Extends: Container\nDescription The LambdaFunction class allows you to create an abstract AWS Lambda function that acts as a container to instantiate and run components, and expose them via an external entry point.\nImportant points\n  When handling calls \u0026ldquo;cmd\u0026rdquo; parameter determines which what action shall be called, while other parameters are passed to the action itself.\n  Container configuration for this Lambda function is stored in \u0026quot;./config/config.yml\u0026quot; file. But this path can be overriden by CONFIG_PATH environment variable.\n  References  *:logger:*:*:1.0: (optional) ILogger components to pass log messages. *:counters:*:*:1.0: (optional) ICounters components to pass collected measurements. *:service:lambda:*:1.0: (optional) ILambdaService services to handle action requests *:service:commandable-lambda:*:1.0: (optional) ILambdaService services to handle action requests  Constructors Creates a new instance of this lambda function.\n public constructor(name: string, description?: string)\n  name: string - (optional) a container name (accessible via ContextInfo). description: string - (optional) a container description (accessible via ContextInfo).  Fields _actions Map containing registered actions.\n protected _actions: { [id: string]: any }\n _configPath Default path to config file.\n protected _configPath: string = \u0026lsquo;./config/config.yml\u0026rsquo;\n _counters Performanc counters.\n protected _counters = new CompositeCounters()\n _dependencyResolver Dependency resolver.\n protected _dependencyResolver = new DependencyResolver()\n _schemas Map of registred validation schemas.\n protected _schemas: { [id: string]: Schema }\n _tracer Tracer.\n protected _tracer: CompositeTracer = new CompositeTracer()\n  Instance methods act Calls registered action in this lambda function. \u0026ldquo;cmd\u0026rdquo; parameter in the action parameters determines what action shall be called.\n This method shall only be used in testing.   public act(params: any): Promise\u0026lt;any\u0026gt;\n  params: any - action parameters. returns: Promise\u0026lt;any\u0026gt; - result  execute Executes this AWS Lambda function and returns the result. This method can be overloaded in child classes if they need to change the default behavior\n protected execute(event: any): Promise\u0026lt;any\u0026gt;\n  event: any - event parameters (or function arguments) returns: Promise\u0026lt;any\u0026gt; - result of the function execution.  getHandler Gets an entry point into this lambda function.\n public getHandler(): (event: any) =\u0026gt; Promise\u0026lt;\\any\u0026gt;\n  returns: (event: any) =\u0026gt; Promise\u0026lt;\\any\u0026gt; - incoming event object with invocation parameters.  instrument Gets entry point into this lambda function.\n protected instrument(correlationId: string, name: string): InstrumentTiming\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. name: string - method name. returns: InstrumentTiming - object to end the time measurement.  open Opens the component.\n public open(correlationId: string): Promise\u0026lt;void\u0026gt;\n  correlationId: string - (optional) transaction id used to trace execution through the call chain.  register Registers all actions in this lambda function.\n Note: Overloading of this method has been deprecated. Use LambdaService instead.   protected register(): void\n registerAction Registers an action in this lambda function.\n Note: This method has been deprecated. Use LambdaService instead.   protected registerAction(cmd: string, schema: Schema, action: (params: any) =\u0026gt; Promise\u0026lt;any\u0026gt;): void\n  cmd: string - action/command name. schema: Schema - validation schema used to validate received parameters. action: (params: any) =\u0026gt; Promise\u0026lt;any\u0026gt; - action function that is called when action is invoked.  registerServices Registers all lambda services in the container.\n protected registerServices(): void\n run Runs this lambda function, loads container configuration, instantiate components and manage their lifecycle, makes this function ready to access action calls.\n public run(): Promise\u0026lt;void\u0026gt;\n setReferences Sets references to dependent components.\n public setReferences(references: IReferences): void\n  references: IReferences - references to locate the component\u0026rsquo;s dependencies.  Examples class MyLambdaFunction extends LambdaFunction { public constructor() { base(\u0026#34;mygroup\u0026#34;, \u0026#34;MyGroup lambda function\u0026#34;); } } let lambda = new MyLambdaFunction(); await service.run(); console.log(\u0026#34;MyLambdaFunction is started\u0026#34;); See also   LambdaClient   ","description":"Abstract AWS Lambda function that acts as a container to instantiate and run components,  and expose them via an external entry point. \n","image":null,"permalink":"/node/aws/containers/lambda_function/","subtitle":null,"tags":null,"title":"LambdaFunction"},{"content":"Implements: ILambdaService, IOpenable, IConfigurable, IReferenceable\nDescription The LambdaService class allows you to create abstract services that receive remove calls via AWS Lambda protocol.\nImportant points\nThis service is intended to work inside LambdaFunction container that exploses registered actions externally.\nConfiguration parameters  dependencies:  controller: override for Controller dependency    References  *:logger:*:*:1.0: (optional) ILogger components to pass log messages. *:counters:*:*:1.0: (optional) ICounters components to pass collected measurements.  Constructors Creates an instance of this service.\n public constructor(name?: string)\n  name: string - service name to generate action cmd.  Fields _counters Performance counters.\n protected _counters: CompositeCounters\n _dependencyResolver Dependency resolver.\n protected _dependencyResolver: DependencyResolver\n _logger Dependency resolver.\n protected _logger: CompositeLogger\n _tracer Tracer.\n protected _tracer: CompositeTracer\n  Constructors Creates an instance of this service.\n public constructor(name?: string)\n  name: string - service name to generate action cmd.  Instance methods act Calls registered action in this lambda function. \u0026ldquo;cmd\u0026rdquo; parameter in the action parameters determin what action shall be called.\n This method shall only be used in testing.   public act(params: any): Promise\u0026lt;any\u0026gt;\n  params: any - action parameters. returns: Promise\u0026lt;any\u0026gt; - results  applyInterceptors  protected applyInterceptors(action: (params: any) =\u0026gt; Promise\u0026lt;any\u0026gt;): (params: any) =\u0026gt; Promise\u0026lt;any\u0026gt;\n  action: (params: any) =\u0026gt; Promise\u0026lt;any\u0026gt; - parameters returns: (params: any) =\u0026gt; Promise\u0026lt;any\u0026gt; - results  applyValidation Applies a validation according to a given schema.\n protected applyValidation(schema: Schema, action: (params: any) =\u0026gt; Promise\u0026lt;any\u0026gt;): (params: any) =\u0026gt; Promise\u0026lt;any\u0026gt;\n  schema: Schema - validation schema action: (params: any) =\u0026gt; Promise\u0026lt;any\u0026gt; - action returns: (params: any) =\u0026gt; Promise\u0026lt;any\u0026gt; - results  close Closes a component and frees used resources.\n public close(correlationId: string): Promise\u0026lt;void\u0026gt;\n  correlationId: string - (optional) transaction id used to trace execution through the call chain.  configure Configures a component by passing configuration parameters.\n public configure(config: ConfigParams): void\n  config: ConfigParams - configuration parameters to be set.  generateActionCmd Adds .cmd to the name of the command.\n protected generateActionCmd(name: string): string\n  name: string - name of the command returns: string - T - generated command  getActions Gets all the actions supported by the service.\n public getActions(): LambdaAction[]\n  returns: LambdaAction[] - array with supported actions.  instrument Adds instrumentation to log calls and measure call time. It returns a Timing object that is used to end the time measurement.\n protected instrument(correlationId: string, name: string): InstrumentTiming\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. name: string - method name. returns: InstrumentTiming - InstrumentTiming object to end the time measurement.  isOpen Checks if the component is opened.\n public isOpen(): boolean\n  returns: boolean - true if the component has been opened and false otherwise.  open Opens the component.\n public open(correlationId: string): Promise\u0026lt;void\u0026gt;\n  correlationId: string - (optional) transaction id used to trace execution through the call chain.  registerAction Registers a action in AWS Lambda function.\n protected registerAction(name: string, schema: Schema, action: (params: any) =\u0026gt; Promise\u0026lt;any\u0026gt;): void\n  name: string - action name schema: Schema - a validation schema used to validate received parameters. action: (params: any) =\u0026gt; Promise\u0026lt;any\u0026gt; - action function that is called when operation is invoked.  registerActionWithAuth Registers an action with authorization.\n protected registerActionWithAuth(name: string, schema: Schema, authorize: (call: any, next: (call: any) =\u0026gt; Promise\u0026lt;any\u0026gt;) =\u0026gt; Promise\u0026lt;any\u0026gt;, action: (call: any) =\u0026gt; Promise\u0026lt;any\u0026gt;): void\n  name: string - action name schema: Schema - validation schema used to validate received parameters. authorize: (call: any, next: (call: any) =\u0026gt; Promise\u0026lt;any\u0026gt; - authorization interceptor action: (call: any) =\u0026gt; Promise\u0026lt;any\u0026gt; - action function that is called when operation is invoked.  registerInterceptor Registers a middleware for actions in AWS Lambda service.\n protected registerInterceptor(action: (params: any, next: (params: any) =\u0026gt; Promise\u0026lt;any\u0026gt;) =\u0026gt; Promise\u0026lt;any\u0026gt;): void\n  action: (params: any, next: (params: any) =\u0026gt; Promise\u0026lt;any\u0026gt;) =\u0026gt; Promise\u0026lt;any\u0026gt; - action function that is called when middleware is invoked.  setReferences Sets references to dependent components.\n public setReferences(references: IReferences): void\n  references: IReferences - references used to locate the component dependencies.  Abstract methods register Registers all service routes in HTTP endpoint.\nThis method is called by the service and must be overriden in child classes.\n protected abstract register(): void\n Examples class MyLambdaService extends LambdaService { private _controller: IMyController; ... public constructor() { base(\u0026#39;v1.myservice\u0026#39;); this._dependencyResolver.put( \u0026#34;controller\u0026#34;, new Descriptor(\u0026#34;mygroup\u0026#34;,\u0026#34;controller\u0026#34;,\u0026#34;*\u0026#34;,\u0026#34;*\u0026#34;,\u0026#34;1.0\u0026#34;) ); } public setReferences(references: IReferences): void { base.setReferences(references); this._controller = this._dependencyResolver.getRequired\u0026lt;IMyController\u0026gt;(\u0026#34;controller\u0026#34;); } public register(): void { registerAction(\u0026#34;get_mydata\u0026#34;, null, async (params) =\u0026gt; { let correlationId = params.correlation_id; let id = params.id; return await this._controller.getMyData(correlationId, id); }); ... } } let service = new MyLambdaService(); service.configure(ConfigParams.fromTuples( \u0026#34;connection.protocol\u0026#34;, \u0026#34;http\u0026#34;, \u0026#34;connection.host\u0026#34;, \u0026#34;localhost\u0026#34;, \u0026#34;connection.port\u0026#34;, 8080 )); service.setReferences(References.fromTuples( new Descriptor(\u0026#34;mygroup\u0026#34;,\u0026#34;controller\u0026#34;,\u0026#34;default\u0026#34;,\u0026#34;default\u0026#34;,\u0026#34;1.0\u0026#34;), controller )); service.open(\u0026#34;123\u0026#34;); console.log(\u0026#34;The GRPC service is running on port 8080\u0026#34;); See also   LambdaClient   ","description":"Abstract service that receives remove calls via AWS Lambda protocol.\n","image":null,"permalink":"/node/aws/services/lambda_service/","subtitle":null,"tags":null,"title":"LambdaService"},{"content":"Implements: ReferencesDecorator\nDescription The LinkReferencesDecorator class allows you to create a references decorator that automatically sets references to newly added components that implement the IReferenceable interface, and unsets references from removed components that implement the IUnreferenceable interface.\nConstructors NewLinkReferencesDecorator Creates a new instance of the decorator.\n NewLinkReferencesDecorator(nextReferences IReferences, topReferences IReferences) *LinkReferencesDecorator\n  nextReferences: IReferences - next references or decorator in the chain. topReferences: IReferences - decorator at the top of the chain.  Methods Close Closes the component and frees used resources.\n (c *LinkReferencesDecorator) Close(correlationId string) error\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. returns: error - returns error if not closed  IsOpen Checks if the component is open.\n (c *LinkReferencesDecorator) IsOpen() bool\n  returns: bool - True if the component is open and False otherwise.  Open Opens the component.\n (c *LinkReferencesDecorator) Open(correlationId string) error\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. returns: error - returns error if not opened  Put Puts a new reference into the reference map.\n (c *LinkReferencesDecorator) Put(locator interface{}, component interface{})\n  locator: interface{} - locator to find the reference by. component: interface{} - component\u0026rsquo;s reference to be added.  Remove Removes a previously added reference that matches the specified locator. If many references match the locator, it removes only the first one. When all references shall be removed, use RemoveAll method instead.\n (c *LinkReferencesDecorator) Remove(locator interface{}) interface{}\n  locator: interface{} - locator to remove reference returns: interface{} - removed component reference.  RemoveAll Removes all component references that match the specified locator.\n (c *LinkReferencesDecorator) RemoveAll(locator interface{}) []interface{}\n  locator: interface{} - the locator to remove references by. returns: []interface{} - list, containing all removed references.  ","description":"References decorator that automatically sets references to newly added components that implement [IReferenceable interface](../../../commons/refer/ireferenceable), and unsets references from removed components that implement [IUnreferenceable interface](../../../commons/refer/iunreferenceable).\n","image":null,"permalink":"/golang/container/refer/link_references_decorator/","subtitle":null,"tags":null,"title":"LinkReferencesDecorator"},{"content":"Inherits: ReferencesDecorator, IOpenable\nDescription The LinkReferencesDecorator class allows you to create a references decorator that automatically sets references to newly added components that implement the IReferenceable interface, and unsets references from removed components that implement the IUnreferenceable interface.\nConstructors Creates a new instance of the decorator.\n public LinkReferencesDecorator(IReferences baseReferences = null, IReferences parentReferences = null)\n  baseReferences: IReferences - next references or decorator in the chain. parentReferences: IReferences - decorator at the top of the chain.  Instance methods Close Closes the component and frees used resources.\n public Task CloseAsync(string correlationId)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain.  IsOpen Checks if the component is open.\n public bool IsOpen()\n  returns: bool - True if the component is open and False otherwise.  Open Opens the component.\n public Task OpenAsync(string correlationId)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain.  Put Puts a new reference into the reference map.\n public override void Put(object locator, object component)\n  locator: object - locator to find the reference by. component: object - component\u0026rsquo;s reference to be added.  Remove Removes a previously added reference that matches the specified locator. If many references match the locator, it removes only the first one. When all references shall be removed, use RemoveAll method instead.\n public override object Remove(object locator)\n  locator: object - locator to remove reference returns: object - removed component reference.  RemoveAll Removes all component references that match the specified locator.\n public override List\u0026lt;object\u0026gt; RemoveAll(object locator)\n  locator: object - the locator to remove references by. returns: List\u0026lt;object\u0026gt; - list, containing all removed references.  ","description":"References decorator that automatically sets references to newly added components that implement [IReferenceable interface](../../../commons/refer/ireferenceable), and unsets references from removed components that implement [IUnreferenceable interface](../../../commons/refer/iunreferenceable).\n","image":null,"permalink":"/net/container/refer/link_references_decorator/","subtitle":null,"tags":null,"title":"LinkReferencesDecorator"},{"content":"Extends: ReferencesDecorator\nImplements: IOpenable\nDescription The LinkReferencesDecorator class allows you to create a references decorator that automatically sets references to newly added components that implement the IReferenceable interface, and unsets references from removed components that implement the IUnreferenceable interface.\nConstructors Creates a new instance of the decorator.\n public constructor(nextReferences: IReferences, topReferences: IReferences)\n  nextReferences: IReferences - next references or decorator in the chain. topReferences: IReferences - decorator at the top of the chain.  Instance methods close Closes the component and frees used resources.\n public close(correlationId: string): Promise\u0026lt;void\u0026gt;\n  correlationId: string - (optional) transaction id used to trace execution through the call chain.  isOpen Checks if the component is open.\n public isOpen(): boolean\n  returns: boolean - True if the component is open and False otherwise.  open Opens the component.\n public open(correlationId: string): Promise\u0026lt;void\u0026gt;\n  correlationId: string - (optional) transaction id used to trace execution through the call chain.  put Puts a new reference into the reference map.\n public put(locator: any, component: any)\n  locator: any - locator to find the reference by. component: any - component\u0026rsquo;s reference to be added.  remove Removes a previously added reference that matches the specified locator. If many references match the locator, it removes only the first one. When all references shall be removed, use removeAll method instead.\n public remove(locator: any): any\n  locator: any - locator to remove reference returns: any - removed component reference.  removeAll Removes all component references that match the specified locator.\n public removeAll(locator: any): any[]\n  locator: any - the locator to remove references by. returns: any[] - list, containing all removed references.  ","description":"References decorator that automatically sets references to newly added components that implement [IReferenceable interface](../../../commons/refer/ireferenceable), and unsets references from removed components that implement [IUnreferenceable interface](../../../commons/refer/iunreferenceable).\n","image":null,"permalink":"/node/container/refer/link_references_decorator/","subtitle":null,"tags":null,"title":"LinkReferencesDecorator"},{"content":"Implements: ReferencesDecorator, IOpenable\nDescription The LinkReferencesDecorator class allows you to create a references decorator that automatically sets references to newly added components that implement the IReferenceable interface, and unsets references from removed components that implement the IUnreferenceable interface.\nConstructors Creates a new instance of the decorator.\n LinkReferencesDecorator(next_references: IReferences, top_references: IReferences)\n  next_references: IReferences - next references or decorator in the chain. top_references: IReferences - decorator at the top of the chain.  Instance methods close Closes the component and frees used resources.\n close(correlation_id: Optional[str])\n  correlation_id: Optional[str] - (optional) transaction id used to trace execution through the call chain.  is_open Checks if the component is open.\n is_open(): bool\n  returns: bool - True if the component is open and False otherwise.  open Opens the component.\n open(correlation_id: Optional[str])\n  correlation_id: Optional[str] - (optional) transaction id used to trace execution through the call chain.  put Puts a new reference into the reference map.\n put(locator: Any = None, component: Any = None)\n  locator: Any - locator to find the reference by. component: Any - component\u0026rsquo;s reference to be added.  remove Removes a previously added reference that matches the specified locator. If many references match the locator, it removes only the first one. When all references shall be removed, use remove_all method instead.\n remove(locator: Any): Any\n  locator: Any - locator to remove reference returns: Any - removed component reference.  remove_all Removes all component references that match the specified locator.\n remove_all(locator: Any): List[Any]\n  locator: Any - the locator to remove references by. returns: List[Any] - list, containing all removed references.  ","description":"References decorator that automatically sets references to newly added components that implement [IReferenceable interface](../../../commons/refer/ireferenceable), and unsets references from removed components that implement [IUnreferenceable interface](../../../commons/refer/iunreferenceable).\n","image":null,"permalink":"/python/container/refer/link_references_decorator/","subtitle":null,"tags":null,"title":"LinkReferencesDecorator"},{"content":"Implements: ILock\nDescription The Lock class represents an abstract lock that implements the defaul lock acquisition routine.\nConfiguration parameters options:\n retry_timeout: timeout (in milliseconds) to retry lock acquisition. (Default: 100)  Constructors InheritLock Inherits lock from ILock\n InheritLock(overrides ILockOverrides) *Lock\n  overrides: ILockOverrides - inherited lock  Methods AcquireLock Makes multiple attempts to acquire a lock by its key within a given time interval.\n (c *Lock) AcquireLock(correlationId string, key string, ttl int64, timeout int64) error\n  correlationId: string -(optional) transaction id used to trace execution through the call chain. key: string - unique lock key to acquire. ttl: int64 - lock timeout (time to live) in milliseconds. timeout: int64 - lock acquisition timeout. returns: error - returns error if not acquired  Configure Configures component by passing configuration parameters.\n (c *Lock) Configure(config *config.ConfigParams)\n  config: *config.ConfigParams - configuration parameters to be set.  See also   ILock   ","description":"Abstract lock that implements the default lock acquisition routine.\n","image":null,"permalink":"/golang/components/lock/lock/","subtitle":null,"tags":null,"title":"Lock"},{"content":"Inherits: ILock, IReconfigurable\nDescription The Lock class represents an abstract lock that implements the defaul lock acquisition routine.\nConfiguration parameters options:\n retry_timeout: timeout in milliseconds to retry lock acquisition. (Default: 100)  Instance methods AcquireLock Makes multiple attempts to acquire a lock by its key within a given time interval.\n public void AcquireLock(string correlationId, string key, long ttl, long timeout)\n  correlationId: string -(optional) transaction id to trace execution through a call chain. key: string - a unique lock key to acquire. ttl: long - a lock timeout (time to live) in milliseconds. timeout: long - a lock acquisition timeout.  Configure Configures component by passing configuration parameters.\n public virual void Configure(ConfigParams config)\n  config: ConfigParams - configuration parameters to be set.  Abstract methods ReleaseLock Releases a prevously acquired lock by its key.\n public abstract void ReleaseLock(string correlationId, string key)\n  correlationId: string - (optional) transaction id to trace execution through a call chain. key: string - a unique lock key to release.  TryAcquireLock Makes a single attempt to acquire a lock by its key. It returns immediately a positive or negative result.\n public abstract bool TryAcquireLock(string correlationId, string key, long ttl)\n  correlationId: string - (optional) transaction id to trace execution through call chain. key: string - a unique lock key to acquire. ttl: long - a lock timeout (time to live) in milliseconds. returns: bool - lock result  See also   ILock   ","description":"Abstract lock that implements the default lock acquisition routine.\n","image":null,"permalink":"/net/components/lock/lock/","subtitle":null,"tags":null,"title":"Lock"},{"content":"Implements: ILock, IReconfigurable\nDescription The Lock class represents an abstract lock that implements the defaul lock acquisition routine.\nConfiguration parameters options:\n retry_timeout: timeout in milliseconds to retry lock acquisition. (Default: 100)  Instance methods acquireLock Makes multiple attempts to acquire a lock by its key within a given time interval.\n public acquireLock(correlationId: string, key: string, ttl: number, timeout: number): Promise\u0026lt;void\u0026gt;\n  correlationId: string -(optional) transaction id to trace execution through a call chain. key: string - a unique lock key to acquire. ttl: number - a lock timeout (time to live) in milliseconds. timeout: number - a lock acquisition timeout.  configure Configures component by passing configuration parameters.\n public configure(config: ConfigParams): void\n  config: ConfigParams - configuration parameters to be set.  Abstract methods releaseLock Releases a prevously acquired lock by its key.\n public abstract releaseLock(correlationId: string, key: string): Promise\u0026lt;void\u0026gt;\n  correlationId: string - (optional) transaction id to trace execution through a call chain. key: string - a unique lock key to release.  tryAcquireLock Makes a single attempt to acquire a lock by its key. It returns immediately a positive or negative result.\n public abstract tryAcquireLock(correlationId: string, key: string, ttl: number): Promise\u0026lt;boolean\u0026gt;\n  correlationId: string - (optional) transaction id to trace execution through call chain. key: string - a unique lock key to acquire. ttl: number - a lock timeout (time to live) in milliseconds. returns: bool - lock result  See also   ILock   ","description":"Abstract lock that implements the default lock acquisition routine.\n","image":null,"permalink":"/node/components/lock/lock/","subtitle":null,"tags":null,"title":"Lock"},{"content":"Implements: ILock, IReconfigurable\nDescription The Lock class represents an abstract lock that implements the defaul lock acquisition routine.\nConfiguration parameters options:\n retry_timeout: timeout in milliseconds to retry lock acquisition. (Default: 100)  Instance methods acquire_lock Makes multiple attempts to acquire a lock by its key within a given time interval.\n acquire_lock(correlation_id: Optional[str], key: str, ttl: float, timeout: float)\n  correlation_id: Optional[str] -(optional) transaction id to trace execution through a call chain. key: str - a unique lock key to acquire. ttl: float - a lock timeout (time to live) in milliseconds. timeout: float - a lock acquisition timeout.  configure Configures component by passing configuration parameters.\n configure(config: ConfigParams)\n  config: ConfigParams - configuration parameters to be set.  Abstract methods release_lock Releases a prevously acquired lock by its key.\n abstractmethod release_lock(correlation_id: Optional[str], key: str)\n  correlation_id: Optional[str] - (optional) transaction id to trace execution through a call chain. key: str - a unique lock key to release.  try_acquire_lock Makes a single attempt to acquire a lock by its key. It returns immediately a positive or negative result.\n abstractmethod try_acquire_lock(correlation_id: Optional[str], key: str, ttl: float): bool\n  correlation_id: Optional[str] - (optional) transaction id to trace execution through call chain. key: str - a unique lock key to acquire. ttl: float - a lock timeout (time to live) in milliseconds. returns: bool - lock result  See also   ILock   ","description":"Abstract lock that implements the default lock acquisition routine.\n","image":null,"permalink":"/python/components/lock/lock/","subtitle":null,"tags":null,"title":"Lock"},{"content":"Description The LockedMessage class allows you to create data objects used to store and lock incoming messages in MemoryMessageQueue.\nFields ExpirationTime The expiration time for the message lock. If it is nil, then the message is not locked.\n ExpirationTime: time.Time\n Message The incoming message.\n Message: *MessageEnvelope\n Timeout The lock timeout in milliseconds.\n Timeout: time.Duration\n  See also   MemoryMessageQueue   ","description":"Data object used to store and lock incoming messages in [MemoryMessageQueue](../memory_message_queue).  \n","image":null,"permalink":"/golang/messaging/queues/locked_message/","subtitle":null,"tags":null,"title":"LockedMessage"},{"content":"Description The LockedMessage class allows you to create data objects used to store and lock incoming messages in MemoryMessageQueue.\nFields expirationTime The expiration time for the message lock. If it is null, then the message is not locked.\n public expirationTime: Date\n message The incoming message.\n public message: MessageEnvelope\n timeout The lock timeout in milliseconds.\n public timeout: number\n  See also   MemoryMessageQueue   ","description":"Data object used to store and lock incoming messages in [MemoryMessageQueue](../memory_message_queue).  \n","image":null,"permalink":"/node/messaging/queues/locked_message/","subtitle":null,"tags":null,"title":"LockedMessage"},{"content":"Description The LockedMessage class allows you to create data objects used to store and lock incoming messages in MemoryMessageQueue.\nFields expiration_time The expiration time for the message lock. If it is None, then the message is not locked.\n expiration_time: datetime.datetime\n message The incoming message.\n message: MessageEnvelope\n timeout The lock timeout in milliseconds.\n timeout: int\n  See also   MemoryMessageQueue   ","description":"Data object used to store and lock incoming messages in [MemoryMessageQueue](../memory_message_queue).  \n","image":null,"permalink":"/python/messaging/queues/locked_message/","subtitle":null,"tags":null,"title":"LockedMessage"},{"content":"","description":"TODO: this class is not implemented yet. \n","image":null,"permalink":"/net/messaging/queues/locked_message/","subtitle":null,"tags":null,"title":"LockedMessage!"},{"content":"Implements: CachedCounters\nDescription The LogCounters class allows you to create performance counters that periodically dump counters' measurements to a logger.\nConfiguration parameters options:\n interval: interval (in milliseconds) to save current counters measurements (default: 5 mins) reset_timeout: timeout (in milliseconds) to reset the counters. 0 disables the reset (default: 0)  References  *:logger:*:*:1.0 - ILogger components to dump the captured counters *:context-info:*:*:1.0 - (optional) ContextInfo to detect the context id and specify counters source  Constructors NewLogCounters Creates a new instance of the counters.\n NewLogCounters() *LogCounters\n Methods Save Saves the current counters measurements.\n (c *LogCounters) Save(counters []*Counter) error\n  counters: []*Counter - current counters measurements to be saved. returns: error - return erro if not saved.  SetReferences Sets references to dependent components.\n (c *LogCounters) SetReferences(references refer.IReferences)\n  references: refer.IReferences - references to locate the component dependencies.  Examples counters := NewLogCounters(); counters.SetReferences(NewReferencesFromTuples( NewDescriptor(\u0026#34;pip-services\u0026#34;, \u0026#34;logger\u0026#34;, \u0026#34;console\u0026#34;, \u0026#34;default\u0026#34;, \u0026#34;1.0\u0026#34;), NewConsoleLogger() )); counters.Increment(\u0026#34;mycomponent.mymethod.calls\u0026#34;); timing := counters.BeginTiming(\u0026#34;mycomponent.mymethod.exec_time\u0026#34;); defer timing.EndTiming(); // do something  counters.Dump(); See also   Counter   CachedCounters   CompositeLogger   ","description":"Performance counters that periodically dump counters' measurements to logger.\n","image":null,"permalink":"/golang/components/count/log_counters/","subtitle":null,"tags":null,"title":"LogCounters"},{"content":"Inherits: CachedCounters, IReferenceable\nDescription The LogCounters allows you to create performance counters that periodically dump counters' measurements to logger.\nConfiguration parameters options:\n interval: interval in milliseconds to save current counters measurements (default: 5 mins) reset_timeout: timeout in milliseconds to reset the counters. 0 disables the reset (default: 0)  References  *:logger:*:*:1.0 - ILogger components to dump the captured counters *:context-info:*:*:1.0 - (optional) ContextInfo to detect the context id and specify counters source  Instance methods Save Saves the current counters measurements.\n protected override void Save(IEnumerable\u0026lt;Counter\u0026gt; counters)\n  counters: IEnumerable\u0026lt;Counter\u0026gt; - current counters measurements to be saved.  SetReferences Sets references to dependent components.\n public virtual void SetReferences(IReferences references)\n  references: IReferences - references to locate the component dependencies.  Examples var counters = new LogCounters(); counters.SetReferences(References.FromTuples( new Descriptor(\u0026#34;pip-services3\u0026#34;, \u0026#34;logger\u0026#34;, \u0026#34;console\u0026#34;, \u0026#34;default\u0026#34;, \u0026#34;1.0\u0026#34;), new ConsoleLogger() )); counters.Increment(\u0026#34;mycomponent.mymethod.calls\u0026#34;); var timing = counters.BeginTiming(\u0026#34;mycomponent.mymethod.exec_time\u0026#34;); try { ... } finally { timing.EndTiming(); } counters.Dump(); See also   Counter   CachedCounters   CompositeLogger   ","description":"Performance counters that periodically dump counters' measurements to logger.\n","image":null,"permalink":"/net/components/count/log_counters/","subtitle":null,"tags":null,"title":"LogCounters"},{"content":"Implements: CachedCounters, IReferenceable\nDescription The LogCounters allows you to create performance counters that periodically dump counters' measurements to logger.\nConfiguration parameters options:\n interval: interval in milliseconds to save current counters measurements (default: 5 mins) reset_timeout: timeout in milliseconds to reset the counters. 0 disables the reset (default: 0)  References  *:logger:*:*:1.0 - ILogger components to dump the captured counters *:context-info:*:*:1.0 - (optional) ContextInfo to detect the context id and specify counters source  Instance methods save Saves the current counters measurements.\n protected save(counters: Counter[]): void\n  counters: Counter[] - current counters measurements to be saved.  setReferences Sets references to dependent components.\n public setReferences(references: IReferences): void\n  references: IReferences - references to locate the component dependencies.  Examples let counters = new LogCounters(); counters.setReferences(References.fromTuples( new Descriptor(\u0026#34;pip-services\u0026#34;, \u0026#34;logger\u0026#34;, \u0026#34;console\u0026#34;, \u0026#34;default\u0026#34;, \u0026#34;1.0\u0026#34;), new ConsoleLogger() )); counters.increment(\u0026#34;mycomponent.mymethod.calls\u0026#34;); let timing = counters.beginTiming(\u0026#34;mycomponent.mymethod.exec_time\u0026#34;); try { ... } finally { timing.endTiming(); } counters.dump(); See also   Counter   CachedCounters   CompositeLogger   ","description":"Performance counters that periodically dump counters' measurements to logger.\n","image":null,"permalink":"/node/components/count/log_counters/","subtitle":null,"tags":null,"title":"LogCounters"},{"content":"Implements: CachedCounters, IReferenceable\nDescription The LogCounters allows you to create performance counters that periodically dump counters' measurements to logger.\nConfiguration parameters options:\n interval: interval in milliseconds to save current counters measurements (default: 5 mins) reset_timeout: timeout in milliseconds to reset the counters. 0 disables the reset (default: 0)  References  *:logger:*:*:1.0 - ILogger components to dump the captured counters *:context-info:*:*:1.0 - (optional) ContextInfo to detect the context id and specify counters source  Instance methods _save Saves the current counters measurements.\n _save(counters: List[Counter])\n  counters: List[Counter] - current counters measurements to be saved.  set_references Sets references to dependent components.\n set_references(references: IReferences)\n  references: IReferences - references to locate the component dependencies.  Examples counters = LogCounters() counters.set_references(References.from_tuples( Descriptor(\u0026#34;pip-services\u0026#34;, \u0026#34;logger\u0026#34;, \u0026#34;console\u0026#34;, \u0026#34;default\u0026#34;, \u0026#34;1.0\u0026#34;), ConsoleLogger())) counters.increment(\u0026#34;mycomponent.mymethod.calls\u0026#34;) timing = counters.begin_timing(\u0026#34;mycomponent.mymethod.exec_time\u0026#34;) # do something timing.end_timing() See also   Counter   CachedCounters   CompositeLogger   ","description":"Performance counters that periodically dump counters' measurements to logger.\n","image":null,"permalink":"/python/components/count/log_counters/","subtitle":null,"tags":null,"title":"LogCounters"},{"content":"Inherits: Logger\nDescription TODO: add description\nFields Current TODO: add description\n public static Current: LogEventSource = new LogEventSource();\n  Instance methods Debug TODO: add description\n void Debug(string correlationId, string message)\n  correlationId: string - (optional) transaction id to trace execution through a call chain. message: string - a human-readable message to log.  Error TODO: add description\n void Error(string correlationId, string message)\n  correlationId: string - (optional) transaction id to trace execution through a call chain. message: string - a human-readable message to log.  Fatal TODO: add description\n void Fatal(string correlationId, string message)\n  correlationId: string - (optional) transaction id to trace execution through a call chain. message: string - a human-readable message to log.  Info TODO: add description\n void Info(string correlationId, string message)\n  correlationId: string - (optional) transaction id to trace execution through a call chain. message: string - a human-readable message to log.  Trace TODO: add description\n void Trace(string correlationId, string message)\n  correlationId: string - (optional) transaction id to trace execution through call chain. message: string - a human-readable message to log.  Warn TODO: add description\n void Warn(string correlationId, string message)\n  correlationId: string - (optional) transaction id to trace execution through call chain. message: string - a human-readable message to log.  See also   Logger   ","description":"TODO: add description\n","image":null,"permalink":"/net/components/log/log_event_source/","subtitle":null,"tags":null,"title":"LogEventSource  "},{"content":"Implements: ILogger, IReconfigurable, IReferenceable\nDescription The Logger class allows you to create a logger that captures and formats logs messages.\nImportant points\n Child classes take the captured messages and write them to their specific destinations.  Configuration parameters Parameters to pass to the configure method for component configuration:\n level: maximum log level to capture source: source (context) name  References  *:context-info:*:*:1.0 - (optional) ContextInfo to detect the context id and specify counters source  Constructors InheritLogger Creates a new instance of the logger and inherites from ILogerWriter.\n InheritLogger(overrides ILoggerOverrides) *Logger\n  overrides: ILoggerOverrides - inherited logger  Fields level Maximum log level to capture.\n level: int\n source source (context) name\n source: string\n  Methods ComposeError Composes an human-readable error description.\n (c *Logger) ComposeError(err error) string\n  err: error - error to format. returns: string - human-redable error description.  Configure Configures a component by passing its configuration parameters.\n (c *Logger) Configure(cfg *config.ConfigParams)\n  cfg: *config.ConfigParams - configuration parameters to be set.  Debug Logs high-level debug information for troubleshooting.\n (c *Logger) Debug(correlationId string, message string, args \u0026hellip;interface{})\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. message: string - human-readable message to log. args:\u0026hellip;interface{}- arguments to parameterize the message.  Error Logs recoverable application errors.\n (c *Logger) Error(correlationId string, err error, message string, args \u0026hellip;interface{})\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. err: error - error object associated with this message. message: string - human-readable message to log. args: \u0026hellip;interface{}- arguments to parameterize the message.  Fatal Logs fatal (unrecoverable) messages that caused the process to crash.\n (c *Logger) Fatal(correlationId string, err error, message string, args \u0026hellip;interface{})\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. error: Error - error object associated with this message. message: string - human-readable message to log. args: \u0026hellip;interface{} - arguments to parameterize the message.  FormatAndWrite Formats the log message and writes it to the logger destination.\n (c *Logger) FormatAndWrite(level int, correlationId string, err error, message string, args []interface{})\n  level: int - log level. correlationId: string - (optional) transaction id used to trace execution through the call chain. err: error - error object associated with this message. message: string - human-readable message to log. args: []interface{}- arguments to parameterize the message.  Level Gets the maximum log level. Messages with a higher log level are filtered out.\n (c *Logger) Level() int\n  returns: int - maximum log level.  Source Gets the source (context) name.\n (c *Logger) Source() string\n  returns: string - source (context) name.  Info Logs an important information message.\n (c *Logger) Info(correlationId string, message string, args \u0026hellip;interface{})\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. message: string - human-readable message to log. args: \u0026hellip;interface{} - arguments to parameterize the message.  Log Logs a message at a specified log level.\n (c *Logger) Log(level int, correlationId string, err error, message string, args \u0026hellip;interface{})\n  level: int - log level. correlationId: string - (optional) transaction id used to trace execution through the call chain. error: error - error object associated with this message. message: string - human-readable message to log. args: \u0026hellip;interface{} - arguments to parameterize the message.  SetLevel Sets the maximum log level.\n (c *Logger) SetLevel(value int)\n  value: int - new maximum log level.  Trace Logs a low-level debug information for troubleshooting.\n (c *Logger) Trace(correlationId string, message string, args \u0026hellip;interface{})\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. message: string - human-readable message to log. args: \u0026hellip;interface{}- arguments to parameterize the message.  Warn Logs a warning that may or may not have a negative impact.\n (c *Logger) Warn(correlationId string, message string, args \u0026hellip;interface{})\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. message: string - human-readable message to log. args: \u0026hellip;interface{} - arguments to parameterize the message.  See also   ILogger   ","description":"Logger that captures and formats log messages.\n","image":null,"permalink":"/golang/components/log/logger/","subtitle":null,"tags":null,"title":"Logger"},{"content":"Inherits: ILogger, IReconfigurable, IReferenceable\nDescription The Logger class allows you to create a logger that captures and formats logs messages.\nImportant points\n Child classes take the captured messages and write them to their specific destinations.  Configuration parameters Parameters to pass to the configure method for component configuration:\n level: maximum log level to capture source: source (context) name  References  *:context-info:*:*:1.0 - (optional) ContextInfo to detect the context id and specify counters source  Fields _level Maximum log level to capture\n protected _level: LogLevel = LogLevel.Info\n _source source (context) name\n protected _source: string = null\n  Instance methods ComposeError Composes an human-readable error description\n protected string ComposeError(Exception error)\n  error: Exception - an error to format. returns: string - a human-redable error description.  Configure Configures component by passing configuration parameters.\n public virtual void Configure(ConfigParams config)\n  config: ConfigParams - configuration parameters to be set.  Debug Logs high-level debug information for troubleshooting.\n public void Debug(string correlationId, string message, params object[] args)\n  correlationId: string - (optional) transaction id to trace execution through a call chain. message: string - a human-readable message to log. args: object[] - arguments to parameterize the message.  Debug Logs high-level debug information for troubleshooting.\n public void Debug(string correlationId, Exception error, string message = null, params object[] args)\n  correlationId: string - (optional) transaction id to trace execution through a call chain. error: Exception - an error object associated with this message. message: string - a human-readable message to log. args: object[] - arguments to parameterize the message.  Error Logs recoverable application error.\n public void Error(string correlationId, string message, params object[] args)\n  correlationId: string - (optional) transaction id to trace execution through a call chain. message: string - a human-readable message to log. args: object[] - arguments to parameterize the message.  Error Logs recoverable application error.\n public void Error(string correlationId, Exception error, string message = null, params object[] args)\n  correlationId: string - (optional) transaction id to trace execution through a call chain. error: Exception - an error object associated with this message. message: string - a human-readable message to log. args: object[] - arguments to parameterize the message.  Fatal Logs fatal (unrecoverable) message that caused the process to crash.\n public void Fatal(string correlationId, string message, params object[] args)\n  correlationId: string - (optional) transaction id to trace execution through a call chain. message: string - a human-readable message to log. args: object[] - arguments to parameterize the message.  Fatal Logs fatal (unrecoverable) message that caused the process to crash.\n public void Fatal(string correlationId, Exception error, string message = null, params object[] args)\n  correlationId: string - (optional) transaction id to trace execution through a call chain. error: Exception - an error object associated with this message. message: string - a human-readable message to log. args: object[] - arguments to parameterize the message.  FormatAndWrite Formats the log message and writes it to the logger destination.\n protected void FormatAndWrite(LogLevel level, string correlationId, Exception error, string message, object[] args)\n  level: LogLevel - a log level. correlationId: string - (optional) transaction id to trace execution through call chain. error: Exception - an error object associated with this message. message: string - a human-readable message to log. args: object[] - arguments to parameterize the message.  Info Logs an important information message\n public void Info(string correlationId, string message, params object[] args): void\n  correlationId: string - (optional) transaction id to trace execution through a call chain. message: string - a human-readable message to log. args: object[] - arguments to parameterize the message.  Info Logs an important information message\n public void Info(string correlationId, Exception error, string message = null, params object[] args): void\n  correlationId: string - (optional) transaction id to trace execution through a call chain. error: Exception - an error object associated with this message. message: string - a human-readable message to log. args: object[] - arguments to parameterize the message.  Log Logs a message at a specified log level.\n public void Log(LogLevel level, string correlationId, Exception error, string message, params object[] args)\n  level: LogLevel - a log level. correlationId: string - (optional) transaction id to trace execution through a call chain. error: Exception - an error object associated with this message. message: string - a human-readable message to log. args: object[] - arguments to parameterize the message.  SetReferences Sets references to dependent components.\n public override void SetReferences(IReferences references)\n  references: IReferences - references to locate the component dependencies.  Trace Logs low-level debug information for troubleshooting.\n public void Trace(string correlationId, string message, params object[] args)\n  correlationId: string - (optional) transaction id to trace execution through call chain. message: string - a human-readable message to log. args: object[] - arguments to parameterize the message.  Trace Logs low-level debug information for troubleshooting.\n public void Trace(string correlationId, Exception error, string message = null, params object[] args)\n  correlationId: string - (optional) transaction id to trace execution through call chain. error: Exception - an error object associated with this message. message: string - a human-readable message to log. args: object[] - arguments to parameterize the message.  Warn Logs a warning that may or may not have a negative impact.\n public void Warn(string correlationId, string message, params object[] args)\n  correlationId: string - (optional) transaction id to trace execution through call chain. message: string - a human-readable message to log. args: object[] - arguments to parameterize the message.  Warn Logs a warning that may or may not have a negative impact.\n public void Warn(string correlationId, Exception error, string message = null, params object[] args)\n  correlationId: string - (optional) transaction id to trace execution through call chain. error: Exception - an error object associated with this message message: string - a human-readable message to log. args: object[] - arguments to parameterize the message.  See also   ILogger   ","description":"Logger that captures and formats log messages.\n","image":null,"permalink":"/net/components/log/logger/","subtitle":null,"tags":null,"title":"Logger"},{"content":"Implements: ILogger, IReconfigurable, IReferenceable\nDescription The Logger class allows you to create a logger that captures and formats logs messages.\nImportant points\n Child classes take the captured messages and write them to their specific destinations.  Configuration parameters Parameters to pass to the configure method for component configuration:\n level: maximum log level to capture source: source (context) name  References  *:context-info:*:*:1.0 - (optional) ContextInfo to detect the context id and specify counters source  Fields _level Maximum log level to capture\n protected _level: LogLevel = LogLevel.Info\n _source source (context) name\n protected _source: string\n  Instance methods composeError Composes an human-readable error description\n protected composeError(error: Error): string\n  error: Error - an error to format. returns: string - a human-redable error description.  configure Configures component by passing configuration parameters.\n public configure(config: ConfigParams): void\n  config: ConfigParams - configuration parameters to be set.  debug Logs high-level debug information for troubleshooting.\n public debug(correlationId: string, message: string, \u0026hellip;args: any[]): void\n  correlationId: string - (optional) transaction id to trace execution through call chain. message: string - a human-readable message to log. args: any[]- arguments to parameterize the message.  error Logs recoverable application error.\n public error(correlationId: string, error: Error, message: string, \u0026hellip;args: any[]): void\n  correlationId: string - (optional) transaction id to trace execution through a call chain. error: Error - an error object associated with this message. message: string - a human-readable message to log. args: any[]- arguments to parameterize the message.  fatal Logs fatal (unrecoverable) messages that caused the process to crash.\n public fatal(correlationId: string, error: Error, message: string, \u0026hellip;args: any[]): void\n  correlationId: string - (optional) transaction id to trace execution through a call chain. error: Error - an error object associated with this message. message: string - a human-readable message to log. args: any[]- arguments to parameterize the message.  formatAndWrite Formats the log message and writes it to the logger destination.\n protected formatAndWrite(level: LogLevel, correlationId: string, error: Error, message: string, \u0026hellip;args: any[]): void\n  level: LogLevel - a log level. correlationId: string - (optional) transaction id to trace execution through call chain. error: Error - an error object associated with this message. message: string - a human-readable message to log. args: any[]- arguments to parameterize the message.  getLevel Gets the maximum log level. Messages with higher log level are filtered out.\n public getLevel(): LogLevel\n  returns: LogLevel - the maximum log level.  getSource Gets the source (context) name.\n public getSource(): string\n  returns: string - the source (context) name.  info Logs an important information message\n public info(correlationId: string, message: string, \u0026hellip;args: any[]): void\n  correlationId: string - (optional) transaction id to trace execution through call chain. message: string - a human-readable message to log. args: any[]- arguments to parameterize the message.  log Logs a message at a specified log level.\n public log(level: LogLevel, correlationId: string, error: Error, message: string, \u0026hellip;args: any[]): void\n  level: LogLevel - a log level. correlationId: string - (optional) transaction id to trace execution through a call chain. error: Error - an error object associated with this message. message: string - a human-readable message to log. args: any[]- arguments to parameterize the message.  setLevel Set the maximum log level.\n public setLevel(level: LogLevel): void\n  level: LogLevel - a new maximum log level.  trace Logs a low-level debug information for troubleshooting.\n public trace(correlationId: string, message: string, \u0026hellip;args: any[]): void\n  correlationId: string - (optional) transaction id to trace execution through call chain. message: string - a human-readable message to log. args: any[]- arguments to parameterize the message.  warn Logs a warning that may or may not have a negative impact.\n public warn(correlationId: string, message: Error, \u0026hellip;args: any[]): void\n  correlationId: string - (optional) transaction id to trace execution through a call chain. message: string - a human-readable message to log. args: any[]- arguments to parameterize the message.  See also   ILogger   ","description":"Logger that captures and formats log messages.\n","image":null,"permalink":"/node/components/log/logger/","subtitle":null,"tags":null,"title":"Logger"},{"content":"Implements: ILogger, IReconfigurable, IReferenceable\nDescription The Logger class allows you to create a logger that captures and formats logs messages.\nImportant points\n Child classes take the captured messages and write them to their specific destinations.  Configuration parameters Parameters to pass to the configure method for component configuration:\n level: maximum log level to capture source: source (context) name  References  *:context-info:*:*:1.0 - (optional) ContextInfo to detect the context id and specify counters source  Fields _level Maximum log level to capture\n _level: LogLevel = LogLevel.Info\n _source source (context) name\n _source: str\n  Instance methods _compose_error Composes an human-readable error description\n _compose_error(error: Exception): str\n  error: Exception - an error to format. returns: str - a human-redable error description.  configure Configures component by passing configuration parameters.\n configure(config: ConfigParams)\n  config: ConfigParams - configuration parameters to be set.  debug Logs high-level debug information for troubleshooting.\n debug(correlation_id: Optional[str], message: str, *args: Any, **kwargs: Any)\n  correlation_id: Optional[str] - (optional) transaction id to trace execution through call chain. message: str - a human-readable message to log. args: Any - arguments to parameterize the message. kwargs: Any - arguments to parameterize the message.  error Logs recoverable application error.\n error(correlation_id: Optional[str], error: Exception, message: str, *args: Any, **kwargs: Any)\n  correlation_id: Optional[str] - (optional) transaction id to trace execution through a call chain. error: Exception - an error object associated with this message. message: str - a human-readable message to log. args: Any - arguments to parameterize the message. kwargs: Any - arguments to parameterize the message.  fatal Logs fatal (unrecoverable) messages that caused the process to crash.\n fatal(correlation_id: Optional[str], error: Exception, message: str, *args: Any, **kwargs: Any)\n  correlation_id: Optional[str] - (optional) transaction id to trace execution through a call chain. error: Exception - an error object associated with this message. message: str - a human-readable message to log. args: Any - arguments to parameterize the message. kwargs: Any - arguments to parameterize the message.  _format_and_write Formats the log message and writes it to the logger destination.\n _format_and_write(level: LogLevel, correlation_id: Optional[str], error: Optional[Exception], message: Optional[str], *args: Any, **kwargs: Any)\n  level: LogLevel - a log level. correlation_id: Optional[str] - (optional) transaction id to trace execution through call chain. error: Optional[Exception] - an error object associated with this message. message: Optional[str] - a human-readable message to log. args: Any - arguments to parameterize the message. kwargs: Any - arguments to parameterize the message.  get_level Gets the maximum log level. Messages with higher log level are filtered out.\n get_level(): LogLevel\n  returns: LogLevel - the maximum log level.  get_source Gets the source (context) name.\n get_source(): str\n  returns: str - the source (context) name.  info Logs an important information message\n info(correlation_id: Optional[str], message: str, *args: Any, **kwargs: Any)\n  correlation_id: Optional[str] - (optional) transaction id to trace execution through call chain. message: str - a human-readable message to log. args: Any - arguments to parameterize the message. kwargs: Any - arguments to parameterize the message.  log Logs a message at a specified log level.\n log(level: LogLevel, correlation_id: Optional[str], error: Optional[Exception], message: Optional[str], *args: Any, **kwargs: Any)\n  level: LogLevel - a log level. correlation_id: Optional[str] - (optional) transaction id to trace execution through a call chain. error: Optional[Exception] - an error object associated with this message. message: Optional[str] - a human-readable message to log. args: Any - arguments to parameterize the message. kwargs: Any - arguments to parameterize the message.  set_level Set the maximum log level.\n set_level(level: LogLevel)\n  level: LogLevel - a new maximum log level.  trace Logs a low-level debug information for troubleshooting.\n trace(correlation_id: Optional[str], message: str, *args: Any, **kwargs: Any)\n  correlation_id: Optional[str] - (optional) transaction id to trace execution through call chain. message: str - a human-readable message to log. args: Any - arguments to parameterize the message. kwargs: Any - arguments to parameterize the message.  warn Logs a warning that may or may not have a negative impact.\n warn(correlation_id: Optional[str], message: str, *args: Any, **kwargs: Any)\n  correlation_id: Optional[str] - (optional) transaction id to trace execution through a call chain. message: str - a human-readable message to log. args: Any - arguments to parameterize the message. kwargs: Any - arguments to parameterize the message.  See also   ILogger   ","description":"Logger that captures and formats log messages.\n","image":null,"permalink":"/python/components/log/logger/","subtitle":null,"tags":null,"title":"Logger"},{"content":"Collects execution logs from distributed microservices, stores and provides a single entry point to read all of them.\n Server implementations: NodeJS, .NET, Dart, Python Communication protocols: Direct, Commandable HTTP, Commandable GRPC, GRPC Persistence: Memory, Flat Files, MongoDB, Couchbase Deployment options: Monolith, Process, Docker, AWS Lambda Client implementations: NodeJS, .NET, Dart, Python  ","description":null,"image":null,"permalink":"/microservices/infrastructure/logging/","subtitle":null,"tags":null,"title":"Logging Microservice"},{"content":"Description The LogLevel class provides an enumeration of standard log levels.\nImportant points\n Logs at debug and trace levels are usually captured only locally for troubleshooting and never sent to consolidated log services.  Enumeration members  Null = 0 - Nothing to be logged Fatal = 1 - Logs only fatal errors that cause microservice to fail Error = 2 - Logs all errors - fatal or recoverable Warn = 3 - Logs errors and warnings Info = 4 - Logs errors and important information messages Debug = 5 - Logs everything up to high-level debugging information Trace = 6 - Logs everything down to fine-granular debugging messages   ","description":"Standard log level enumeration.\n","image":null,"permalink":"/golang/components/log/log_level/","subtitle":null,"tags":null,"title":"LogLevel"},{"content":"Description The LogLevel class provides an enumeration of standard log levels.\nImportant points\n Logs at debug and trace levels are usually captured only locally for troubleshooting and never sent to consolidated log services.  Enumeration members  Null = 0 - Nothing to be logged Fatal = 1 - Logs only fatal errors that cause microservice to fail Error = 2 - Logs all errors - fatal or recoverable Warn = 3 - Logs errors and warnings Info = 4 - Logs errors and important information messages Debug = 5 - Logs everything up to high-level debugging information Trace = 6 - Logs everything down to fine-granular debugging messages   ","description":"Standard log level enumeration.\n","image":null,"permalink":"/net/components/log/log_level/","subtitle":null,"tags":null,"title":"LogLevel"},{"content":"Description The LogLevel class provides an enumeration of standard log levels.\nImportant points\n Logs at debug and trace levels are usually captured only locally for troubleshooting and never sent to consolidated log services.  Enumeration members  Null = 0 - Nothing to be logged Fatal = 1 - Logs only fatal errors that cause microservice to fail Error = 2 - Logs all errors - fatal or recoverable Warn = 3 - Logs errors and warnings Info = 4 - Logs errors and important information messages Debug = 5 - Logs everything up to high-level debugging information Trace = 6 - Logs everything down to fine-granular debugging messages   ","description":"Standard log level enumeration.\n","image":null,"permalink":"/node/components/log/log_level/","subtitle":null,"tags":null,"title":"LogLevel"},{"content":"Description The LogLevel class provides an enumeration of standard log levels.\nImportant points\n Logs at debug and trace levels are usually captured only locally for troubleshooting and never sent to consolidated log services.  Enumeration members  Nothing = 0 - Nothing to be logged Fatal = 1 - Logs only fatal errors that cause microservice to fail Error = 2 - Logs all errors - fatal or recoverable Warn = 3 - Logs errors and warnings Info = 4 - Logs errors and important information messages Debug = 5 - Logs everything up to high-level debugging information Trace = 6 - Logs everything down to fine-granular debugging messages   ","description":"Standard log level enumeration.\n","image":null,"permalink":"/python/components/log/log_level/","subtitle":null,"tags":null,"title":"LogLevel"},{"content":"Description The LogLevelConverter class is used to convert log level values.\nMethods LogLevelFromString Converts log level to a LogLevel.\n LogLevelFromString(value interface{}) int\n  value: interface{} - a log level string to convert. returns: int - log level value.  LogLevelToString Converts log level to a string.\n LogLevelToString(level int) string\n  level: int - log level to convert. returns: string - log level name string.  ToLogLevel Converts numbers and strings to standard log level values.\n (c *TLogLevelConverter) ToLogLevel(value interface{}) int\n  value: interface{} - value to be converted returns: int - converted log level  ToString Converts a log level to a string.\n (c *TLogLevelConverter) ToString(level int) string\n  level: int - log level to convert returns: string - log level name string.  See also   LogLevel   ","description":"Helper class used to convert log level values.\n","image":null,"permalink":"/golang/components/log/log_level_converter/","subtitle":null,"tags":null,"title":"LogLevelConverter"},{"content":"Description The LogLevelConverter class is used to convert log level values.\nStatic methods ToInteger Converts log level to a number.\n public static int ToInteger([LogLevel](../log_level level))\n  level: LogLevel - a log level to convert. returns: int - log level number value.  ToLogLevel Converts numbers and strings to standard log level values.\n public static LogLevel ToLogLevel(object value, LogLevel defaultValue = LogLevel.Info)\n  value: object - a value to be converted defaultValue: LogLevel - a default value if conversion is not possible returns: LogLevel - converted log level  ToString Converts log level to a string.\n public static string ToString(LogLevel level)\n  level: LogLevel - a log level to convert returns: string - log level name string.  See also   LogLevel   ","description":"Helper class used to convert log level values.\n","image":null,"permalink":"/net/components/log/log_level_converter/","subtitle":null,"tags":null,"title":"LogLevelConverter"},{"content":"Description The LogLevelConverter class is used to convert log level values.\nStatic methods toInteger Converts log level to a number.\n public static toInteger(level: LogLevel): number\n  level: LogLevel - a log level to convert. returns: number - log level number value.  toLogLevel Converts numbers and strings to standard log level values.\n public static toLogLevel(value: any, defaultValue: LogLevel = LogLevel.Info): LogLevel\n  value: any - a value to be converted defaultValue: LogLevel - a default value if conversion is not possible returns: LogLevel - converted log level  toString Converts log level to a string.\n public static toString(level: LogLevel): string\n  level: LogLevel - a log level to convert returns: string - log level name string.  See also   LogLevel   ","description":"Helper class used to convert log level values.\n","image":null,"permalink":"/node/components/log/log_level_converter/","subtitle":null,"tags":null,"title":"LogLevelConverter"},{"content":"Description The LogLevelConverter class is used to convert log level values.\nStatic methods to_integer Converts log level to a number.\n static to_integer(level: LogLevel): int\n  level: LogLevel - a log level to convert. returns: int - log level number value.  to_log_level Converts numbers and strings to standard log level values.\n static to_log_level(value: Any, default_value: LogLevel = LogLevel.Info): LogLevel\n  value: Any - a value to be converted default_value: LogLevel - a default value if conversion is not possible returns: LogLevel - converted log level  to_string Converts log level to a string.\n static to_string(level: LogLevel): str\n  level: LogLevel - a log level to convert returns: str - log level name string.  See also   LogLevel   ","description":"Helper class used to convert log level values.\n","image":null,"permalink":"/python/components/log/log_level_converter/","subtitle":null,"tags":null,"title":"LogLevelConverter"},{"content":"Description The LogMessage class allows you to create data objects used to store captured log messages.\nImportant points\n This object is used by CachedLogger.  Constructors   NewLogMessage(level int, source string, correlationId string, errors.ErrorDescription , message string) LogMessage\n  level: int - log level. source: string - source. correlationId: string - transaction id used to trace execution through the call chain. err: errors.ErrorDescription - error object associated with this message. message: string - human-readable message to log.  Fields Time Time the message was generated\n Time: time.Time\n Level Log level\n Level: int\n Source Source (context name)\n Source: string\n CorrelationId Transaction id used to trace execution through a call chain.\n CorrelationId: string\n Error Transaction id used to trace execution through a call chain.\nSee also ErrorDescription, ApplicationException\n Error: ErrorDescription\n Message Human-readable message\n Message: string\n  ","description":"Data object used to store captured log messages.\n","image":null,"permalink":"/golang/components/log/log_message/","subtitle":null,"tags":null,"title":"LogMessage"},{"content":"Description The LogMessage class allows you to create data objects used to store captured log messages.\nImportant points\n This object is used by CachedLogger.  Properties Time The time the message was generated\n public DateTime Time { get; set; }\n level This log level\n public string Level { get; set; }\n Source The source (context name)\n public string Source { get; set; }\n CorrelationId The transaction id to trace execution through a call chain.\n public string CorrelationId { get; set; }\n Error The transaction id to trace execution through a call chain.\nSee also ErrorDescription, ApplicationException\n public ErrorDescription Error { get; set; }\n Message The human-readable message\n public string Message { get; set; }\n ","description":"Data object used to store captured log messages.\n","image":null,"permalink":"/net/components/log/log_message/","subtitle":null,"tags":null,"title":"LogMessage"},{"content":"Description The LogMessage class allows you to create data objects used to store captured log messages.\nImportant points\n This object is used by CachedLogger.  Fields time The time the message was generated\n public time: Date\n level This log level\n public level: LogLevel\n source The source (context name)\n public source: string\n correlation_id The transaction id to trace execution through a call chain.\n public correlation_id: string\n error The transaction id to trace execution through a call chain.\nSee also ErrorDescription, ApplicationException\n public error: ErrorDescription\n message The human-readable message\n public message: string\n  ","description":"Data object used to store captured log messages.\n","image":null,"permalink":"/node/components/log/log_message/","subtitle":null,"tags":null,"title":"LogMessage"},{"content":"Description The LogMessage class allows you to create data objects used to store captured log messages.\nImportant points\n This object is used by CachedLogger.  Fields time The time the message was generated\n time: datetime\n level This log level\n level: LogLevel\n source The source (context name)\n source: str\n correlation_id The transaction id to trace execution through a call chain.\n correlation_id: Optional[str]\n error The transaction id to trace execution through a call chain.\nSee also ErrorDescription, ApplicationException\n error: ErrorDescription\n message The human-readable message\n message: str\n  ","description":"Data object used to store captured log messages.\n","image":null,"permalink":"/python/components/log/log_message/","subtitle":null,"tags":null,"title":"LogMessage"},{"content":"Description The LogTracer class allows you to create a tracer that dumps recorded traces to a logger.\nConfiguration parameters options:\n log_level: log level used to record traces (default: debug)  References  *:logger:*:*:1.0 - ILogger components to dump the captured counters *:context-info:*:*:1.0 - (optional) ContextInfo used to detect the context id and specify a counter\u0026rsquo;s source  Constructors NewLogTracer Creates a new instance of the tracer.\n NewLogTracer() *LogTracer\n Methods BeginTrace Begings recording an operation trace.\n (c *LogTracer) BeginTrace(correlationId string, component string, operation string) *TraceTiming\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. component: string - name of the called component operation: string - name of the executed operation. return: *TraceTiming - trace timing object.  Configure Configures component by passing configuration parameters.\n (c *LogTracer) Configure(config *cconf.ConfigParams\n  config: *cconf.ConfigParams - configuration parameters to be set.  Failure Records an operation failure with its name, duration and error\n (c *LogTracer) Failure(correlationId string, component string, operation string, err error, duration int64)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. component: string - name of the called component operation: string - name of the executed operation. err: error - error object associated with this trace. duration: int64 - execution duration in milliseconds.  SetReferences Sets references to dependent components.\n (c *LogTracer) SetReferences(references cref.IReferences)\n  references: cref.IReferences - references used to locate the component\u0026rsquo;s dependencies.  Trace Records an operation trace with its name and duration.\n (c *LogTracer) Trace(correlationId string, component string, operation string, duration int64)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. component: string - name of the called component operation: string - name of the executed operation. duration: int64 - execution duration in milliseconds.  Examples tracer = NewLogTracer(); tracer.SetReferences(NewReferencesFromTuples( NewDescriptor(\u0026#34;pip-services\u0026#34;, \u0026#34;logger\u0026#34;, \u0026#34;console\u0026#34;, \u0026#34;default\u0026#34;, \u0026#34;1.0\u0026#34;), NewConsoleLogger() )); timing := trcer.BeginTrace(\u0026#34;123\u0026#34;, \u0026#34;mycomponent\u0026#34;, \u0026#34;mymethod\u0026#34;); ... timing.EndTrace(); if err != nil { timing.EndFailure(err); } See also   Tracer   CachedCounters   CompositeLogger   ","description":"Tracer that dumps recorded traces to a logger.\n","image":null,"permalink":"/golang/components/trace/log_tracer/","subtitle":null,"tags":null,"title":"LogTracer"},{"content":"Inherits: IReconfigurable, IReferenceable\nDescription The LogTracer class allows you to create a tracer that dumps recorded traces to a logger.\nConfiguration parameters options:\n log_level: log level to record traces (default: debug)  References  *:logger:*:*:1.0 - ILogger components to dump the captured counters *:context-info:*:*:1.0 - (optional) ContextInfo to detect the context id and specify counters source  Instance methods BeginTrace Begings recording an operation trace.\n public TraceTiming BeginTrace(string correlationId, string component, string operation)\n  correlationId: string - (optional) transaction id to trace execution through a call chain. component: string - name of the called component operation: string - name of the executed operation. return: TraceTiming - a trace timing object.  Configure Configures component by passing configuration parameters.\n public void Configure(ConfigParams config)\n  config: ConfigParams - configuration parameters to be set.  Failure Records an operation failure with its name, duration and error\n public void Failure(string correlationId, string component, string operation, Exception error, long duration)\n  correlationId: string - (optional) transaction id to trace execution through call chain. component: string - name of the called component operation: string - name of the executed operation. error: Exception - an error object associated with this trace. duration: long - execution duration in milliseconds.  SetReferences Sets references to dependent components.\n public void SetReferences(IReferences references)\n  references: IReferences - references to locate the component dependencies.  Trace Records an operation trace with its name and duration.\n public void Trace(string correlationId, string component, string operation, long duration)\n  correlationId: string - (optional) transaction id to trace execution through a call chain. component: string - name of the called component operation: string - name of the executed operation. duration: long - execution duration in milliseconds.  Examples var tracer = new LogTracer(); tracer.SetReferences(References.FromTuples( new Descriptor(\u0026#34;pip-services\u0026#34;, \u0026#34;logger\u0026#34;, \u0026#34;console\u0026#34;, \u0026#34;default\u0026#34;, \u0026#34;1.0\u0026#34;), new ConsoleLogger() )); var timing = trcer.BeginTrace(\u0026#34;123\u0026#34;, \u0026#34;mycomponent\u0026#34;, \u0026#34;mymethod\u0026#34;); try { ... timing.EndTrace(); } catch { timing.EndFailure(err); } See also   Tracer   CachedCounters   CompositeLogger   ","description":"Tracer that dumps recorded traces to a logger.\n","image":null,"permalink":"/net/components/trace/log_tracer/","subtitle":null,"tags":null,"title":"LogTracer"},{"content":"Implements: IReconfigurable, IReferenceable\nDescription The LogTracer class allows you to create a tracer that dumps recorded traces to a logger.\nConfiguration parameters options:\n log_level: log level to record traces (default: debug)  References  *:logger:*:*:1.0 - ILogger components to dump the captured counters *:context-info:*:*:1.0 - (optional) ContextInfo to detect the context id and specify counters source  Instance methods beginTrace Begings recording an operation trace.\n public beginTrace(correlationId: string, component: string, operation: string): TraceTiming\n  correlationId: string - (optional) transaction id to trace execution through a call chain. component: string - name of the called component operation: string - name of the executed operation. return: TraceTiming - a trace timing object.  configure Configures component by passing configuration parameters.\n public configure(config: ConfigParams): void\n  config: ConfigParams - configuration parameters to be set.  failure Records an operation failure with its name, duration and error\n public failure(correlationId: string, component: string, operation: string, error: Error, duration: number): void\n  correlationId: string - (optional) transaction id to trace execution through call chain. component: string - name of the called component operation: string - name of the executed operation. error: Error - an error object associated with this trace. duration: number - execution duration in milliseconds.  setReferences Sets references to dependent components.\n public setReferences(references: IReferences): void\n  references: IReferences - references to locate the component dependencies.  trace Records an operation trace with its name and duration.\n public trace(correlationId: string, component: string, operation: string, duration: number): void\n  correlationId: string - (optional) transaction id to trace execution through a call chain. component: string - name of the called component operation: string - name of the executed operation. duration: number - execution duration in milliseconds.  Examples let tracer = new LogTracer(); tracer.setReferences(References.fromTuples( new Descriptor(\u0026#34;pip-services\u0026#34;, \u0026#34;logger\u0026#34;, \u0026#34;console\u0026#34;, \u0026#34;default\u0026#34;, \u0026#34;1.0\u0026#34;), new ConsoleLogger() )); let timing = trcer.beginTrace(\u0026#34;123\u0026#34;, \u0026#34;mycomponent\u0026#34;, \u0026#34;mymethod\u0026#34;); try { ... timing.endTrace(); } catch(err) { timing.endFailure(err); } See also   Tracer   CachedCounters   CompositeLogger   ","description":"Tracer that dumps recorded traces to a logger.\n","image":null,"permalink":"/node/components/trace/log_tracer/","subtitle":null,"tags":null,"title":"LogTracer"},{"content":"Implements: IReconfigurable, IReferenceable\nDescription The LogTracer class allows you to create a tracer that dumps recorded traces to a logger.\nConfiguration parameters options:\n log_level: log level to record traces (default: debug)  References  *:logger:*:*:1.0 - ILogger components to dump the captured counters *:context-info:*:*:1.0 - (optional) ContextInfo to detect the context id and specify counters source  Instance methods begin_trace Begings recording an operation trace.\n begin_trace(correlation_id: Optional[str], component: str, operation: str): TraceTiming\n  correlation_id: Optional[str] - (optional) transaction id to trace execution through a call chain. component: str - name of the called component operation: str - name of the executed operation. return: TraceTiming - a trace timing object.  configure Configures component by passing configuration parameters.\n configure(config: ConfigParams)\n  config: ConfigParams - configuration parameters to be set.  failure Records an operation failure with its name, duration and error\n failure(correlation_id: Optional[str], component: str, operation: str, error: Exception, duration: float)\n  correlation_id: Optional[str] - (optional) transaction id to trace execution through call chain. component: str - name of the called component operation: str - name of the executed operation. error: Exception - an error object associated with this trace. duration: float - execution duration in milliseconds.  set_references Sets references to dependent components.\n set_references(references: IReferences)\n  references: IReferences - references to locate the component dependencies.  trace Records an operation trace with its name and duration.\n trace(correlation_id: Optional[str], component: str, operation: str, duration: float)\n  correlation_id: Optional[str] - (optional) transaction id to trace execution through a call chain. component: str - name of the called component operation: str - name of the executed operation. duration: float - execution duration in milliseconds.  Examples tracer = LogTracer() tracer.set_references(References.from_tuples( Descriptor(\u0026#34;pip-services\u0026#34;, \u0026#34;logger\u0026#34;, \u0026#34;console\u0026#34;, \u0026#34;default\u0026#34;, \u0026#34;1.0\u0026#34;), ConsoleLogger() )) timing = tracer.begin_trace(\u0026#34;123\u0026#34;, \u0026#34;mycomponent\u0026#34;, \u0026#34;mymethod\u0026#34;) try: ... timing.end_trace() except Exception as err: timing.end_failure(err) See also   Tracer   CachedCounters   CompositeLogger   ","description":"Tracer that dumps recorded traces to a logger.\n","image":null,"permalink":"/python/components/trace/log_tracer/","subtitle":null,"tags":null,"title":"LogTracer"},{"content":"Description The LongConverter class allows you to convert arbitrary values into longs using the following extended conversion rules:\n Strings are converted to floats, then to longs DateTime: total number of milliseconds since unix epoсh Boolean: 1 for true and 0 for false  Methods ToLong Converts a value into long or returns 0 when conversion is not possible.\n ToLong(value interface{}) int64\n  value: interface{} - value to convert. returns: int64 - long value or 0 when conversion is not supported.  ToLongWithDefault Converts a value into integer or returns default when conversion is not possible.\n ToLongWithDefault(value interface{}, defaultValue int64) int64\n  value: interface{} - value to convert. defaultValue: int64 - default value. returns: int64 - long value or default when conversion is not supported  ToNullableLong Converts a value into long or returns nil when conversion is not possible.\n ToNullableLong(value interface{}) *int64\n  value: interface{} - value to convert. returns: *int64 - long value or nil when conversion is not supported.  ToULong Converts a value into unsigned long or returns 0 when conversion is not possible.\n ToULong(value interface{}) uint64\n  value: interface{} - value to convert. returns: uint64 - long value or 0 when conversion is not supported.  ToULongWithDefault Converts a value into unsigned long or returns default when conversion is not possible.\n ToULongWithDefault(value interface{}, defaultValue uint64) uint64\n  value: interface{} - value to convert. defaultValue: uint64 - default value. returns: uint64 - long value or default when conversion is not supported.  ToNullableULong Converts value into unsigned long or returns nil when conversion is not possible.\n ToNullableULong(value interface{}) *uint64\n  value: interface{} - value to convert. returns: *uint64 - long value or nil when conversion is not supported.  Examples value1 := convert.LongConverter.ToNullableLong(\u0026#34;ABC\u0026#34;) value2 := convert.LongConverter.ToNullableLong(\u0026#34;123.456\u0026#34;) value3 := convert.LongConverter.ToNullableLong(true) value4 := convert.LongConverter.ToNullableLong(time.Now()) fmt.Println(value1) // \u0026lt;nil\u0026gt; fmt.Println(*value2) // 123 fmt.Println(*value3) // 1 fmt.Println(*value4) // current milliseconds (e.g. 1566333527)  ","description":"The LongConverter class allows you to convert arbitrary values into longs using extended conversion rules.\n","image":null,"permalink":"/golang/commons/convert/long_converter/","subtitle":null,"tags":null,"title":"LongConverter"},{"content":"Description The LongConverter class allows you to convert arbitrary values into longs using the following extended conversion rules:\n Strings are converted to floats, then to longs DateTime: total number of milliseconds since unix epoсh Boolean: 1 for true and 0 for false  Static methods ToLong Converts value into long or returns 0 when the conversion is not possible.\n public static long ToLong(object value)\n  value: object - value to convert. returns: long - long value or 0 when conversion is not supported.  ToLongWithDefault Converts value into integer or returns a given default value when the conversion is not possible.\n public static long ToLongWithDefault(object value, long defaultValue)\n  value: object - value to convert. defaultValue: long - default value. returns: long - long value or given default value when the conversion is not supported  ToNullableLong Converts value into long or returns null when the conversion is not possible.\n public static long ToNullableLong(object value)\n  value: object - value to convert. returns: long - long value or null when the conversion is not supported.  Examples var value1 = LongConverter.ToNullableLong(\u0026#34;ABC\u0026#34;); // Result: null var value2 = LongConverter.ToNullableLong(\u0026#34;123.456\u0026#34;); // Result: 123 var value3 = LongConverter.ToNullableLong(true); // Result: 1 var value4 = LongConverter.ToNullableLong(new Date()); // Result: current milliseconds  ","description":"The LongConverter class allows you to convert arbitrary values into longs using extended conversion rules.\n","image":null,"permalink":"/net/commons/convert/long_converter/","subtitle":null,"tags":null,"title":"LongConverter"},{"content":"Description The LongConverter class allows you to convert arbitrary values into longs using the following extended conversion rules:\n Strings are converted to floats, then to longs DateTime: total number of milliseconds since unix epoсh Boolean: 1 for true and 0 for false  Static methods toLong Converts a value into a long or returns 0 when the conversion is not possible.\n public static toLong(value: any): number\n  value: any - value to convert. returns: number - long value or 0 when the conversion is not supported.  toLongWithDefault Converts a value into an integer or returns a given default when the conversion is not possible.\n public static toLongWithDefault(value: any, defaultValue: number): number\n  value: any - value to convert. defaultValue: number - default value. returns: number - long value or default when the conversion is not supported  toNullableLong Converts a value into a long or returns null when the conversion is not possible.\n public static toNullableLong(value: any): number\n  value: any - value to convert. returns: number - long value or null when the conversion is not supported.  Examples let value1 = LongConverter.toNullableLong(\u0026#34;ABC\u0026#34;); // Result: null let value2 = LongConverter.toNullableLong(\u0026#34;123.456\u0026#34;); // Result: 123 let value3 = LongConverter.toNullableLong(true); // Result: 1 let value4 = LongConverter.toNullableLong(new Date()); // Result: current milliseconds (E.g. 1619869474907)  ","description":"The LongConverter class allows you to convert arbitrary values into longs using extended conversion rules.\n","image":null,"permalink":"/node/commons/convert/long_converter/","subtitle":null,"tags":null,"title":"LongConverter"},{"content":"Description The LongConverter class allows you to convert arbitrary values into longs using the following extended conversion rules:\n Strings are converted to floats, then to longs DateTime: total number of milliseconds since unix epoсh Boolean: 1 for true and 0 for false  Static methods to_long Converts value into long or returns 0 when conversion is not possible.\n static to_long(value: Any): float\n  value: Any - the value to convert. returns: float - long value or 0 when conversion is not supported.  to_long_with_default Converts value into integer or returns default when conversion is not possible.\n static to_long_with_default(value: Any, defaultValue: float): float\n  value: Any - the value to convert. default_value: float - the default value. returns: float - long value or default when conversion is not supported  to_nullable_long Converts value into long or returns None when conversion is not possible.\n static to_nullable_long(value: Any): Optional[float]\n  value: Any - the value to convert. returns: float - long value or None when conversion is not supported.  Examples import datetime value1 = LongConverter.to_nullable_long(\u0026#34;ABC\u0026#34;); # Returns None value2 = LongConverter.to_nullable_long(\u0026#34;123.456\u0026#34;); # Returns 123 value3 = LongConverter.to_nullable_long(True); # Returns 1 value4 = LongConverter.to_nullable_long(datetime.datetime.now()); # Returns current milliseconds (E.g. 1619869474907) ","description":"The LongConverter class allows you to convert arbitrary values into longs using extended conversion rules.\n","image":null,"permalink":"/python/commons/convert/long_converter/","subtitle":null,"tags":null,"title":"LongConverter"},{"content":"Implements: ReferencesDecorator\nDescription The ManagedReferences class allows you to create managed references that in additon to keeping and locating references can also manage their lifecycle, such as:\n Auto-creation of missing components using available factories Auto-linking newly added components Auto-opening newly added components Auto-closing removed components  Constructors NewManagedReferences Creates a new instance of the decorator.\n NewManagedReferences(tuples []interface{}) *ManagedReferences\n  tuples: []interface{} - tuples where odd values are component locators (descriptors) and even values are component references  NewEmptyManagedReferences Creates a new instance of the references\n NewEmptyManagedReferences() *ManagedReferences\n NewEmptyManagedReferences Creates a new instance of the references\n NewEmptyManagedReferences() *ManagedReferences\n NewManagedReferencesFromTuples Removes all component references that match the specified locator.\n NewManagedReferencesFromTuples(tuples \u0026hellip;interface{}) *ManagedReferences\n  locator: \u0026hellip;interface{} - locator to remove references by. returns: ManagedReferences - list containing all removed references.  Methods Close Closes the component and frees used resources.\n (c *ManagedReferences) Close(correlationId string) error\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. retunrs: error - returns error if not closed  IsOpen Checks if the component is open.\n (c *ManagedReferences) IsOpen() bool\n  returns: bool - True if the component is open and False otherwise.  Open Opens the component.\n (c *ManagedReferences) Open(correlationId string) error\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. returns: error - return error if not opened  See also   RunReferencesDecorator   LinkReferencesDecorator   BuildReferencesDecorator   References   ","description":"Managed references that in addition to keeping and locating references can also  manage their lifecycle.\n","image":null,"permalink":"/golang/container/refer/managed_references/","subtitle":null,"tags":null,"title":"ManagedReferences"},{"content":"Inherits: ReferencesDecorator, IOpenable\nDescription The ManagedReferences class allows you to create managed references that in additon to keeping and locating references can also manage their lifecycle, such as:\n Auto-creation of missing components using available factories Auto-linking newly added components Auto-opening newly added components Auto-closing removed components  Constructors Creates a new instance of the decorator.\n public ManagedReferences(object[] tuples = null)\n  tuples: object[] - tuples where odd values are component locators (descriptors) and even values are component references  Fields _references TODO: add description\n protected _references: References\n _builder TODO: add description\n protected _builder: BuildReferencesDecorator\n _linker TODO: add description\n protected _linker: LinkReferencesDecorator\n _runner TODO: add description\n protected _runner: RunReferencesDecorator\n  Instance methods Close Closes the component and frees used resources.\n public Task CloseAsync(string correlationId)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain.  IsOpen Checks if the component is open.\n public bool IsOpen()\n  returns: bool - True if the component is open and False otherwise.  Open Opens the component.\n public Task OpenAsync(string correlationId)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain.  Static methods FromTuples Removes all component references that match the specified locator.\n public static ManagedReferences FromTyples(params object[] tuples)\n  locator: object[] - locator to remove references by. returns: ManagedReferences - list containing all removed references.  See also   RunReferencesDecorator   LinkReferencesDecorator   BuildReferencesDecorator   References   ","description":"Managed references that in addition to keeping and locating references can also  manage their lifecycle.\n","image":null,"permalink":"/net/container/refer/managed_references/","subtitle":null,"tags":null,"title":"ManagedReferences"},{"content":"Extends: ReferencesDecorator\nImplements: IOpenable\nDescription The ManagedReferences class allows you to create managed references that in additon to keeping and locating references can also manage their lifecycle, such as:\n Auto-creation of missing components using available factories Auto-linking newly added components Auto-opening newly added components Auto-closing removed components  Constructors Creates a new instance of the decorator.\n public constructor(tuples: any[] = null)\n  tuples: any[] - tuples where odd values are component locators (descriptors) and even values are component references  Fields _references TODO: add description\n protected _references: References\n _builder TODO: add description\n protected _builder: BuildReferencesDecorator\n _linker TODO: add description\n protected _linker: LinkReferencesDecorator\n _runner TODO: add description\n protected _runner: RunReferencesDecorator\n  Instance methods close Closes the component and frees used resources.\n public close(correlationId: string): Promise\u0026lt;void\u0026gt;\n  correlationId: string - (optional) transaction id used to trace execution through the call chain.  isOpen Checks if the component is open.\n public isOpen(): boolean\n  returns: boolean - True if the component is open and False otherwise.  open Opens the component.\n public open(correlationId: string): Promise\u0026lt;void\u0026gt;\n  correlationId: string - (optional) transaction id used to trace execution through the call chain.  Static methods fromTuples Removes all component references that match the specified locator.\n public static fromTuples(\u0026hellip;tuples: any[]): ManagedReferences\n  locator: any[] - locator to remove references by. returns: ManagedReferences - list containing all removed references.  See also   RunReferencesDecorator   LinkReferencesDecorator   BuildReferencesDecorator   References   ","description":"Managed references that in addition to keeping and locating references can also  manage their lifecycle.\n","image":null,"permalink":"/node/container/refer/managed_references/","subtitle":null,"tags":null,"title":"ManagedReferences"},{"content":"Implements: ReferencesDecorator, IOpenable\nDescription The ManagedReferences class allows you to create managed references that in additon to keeping and locating references can also manage their lifecycle, such as:\n Auto-creation of missing components using available factories Auto-linking newly added components Auto-opening newly added components Auto-closing removed components  Constructors Creates a new instance of the decorator.\n ManagedReferences(tuples: Sequence[Any] = None)\n  tuples: Sequence[Any] - tuples where odd values are component locators (descriptors) and even values are component references  Fields _references TODO: add description\n _references: References\n _builder TODO: add description\n _builder: BuildReferencesDecorator\n _linker TODO: add description\n _linker: LinkReferencesDecorator\n _runner TODO: add description\n _runner: RunReferencesDecorator\n  Instance methods close Closes the component and frees used resources.\n close(correlation_id: Optional[str])\n  correlation_id: Optional[str] - (optional) transaction id used to trace execution through the call chain.  is_open Checks if the component is open.\n is_open(): bool\n  returns: bool - True if the component is open and False otherwise.  open Opens the component.\n open(correlation_id: Optional[str])\n  correlation_id: Optional[str] - (optional) transaction id used to trace execution through the call chain.  Static methods from_tuples Removes all component references that match the specified locator.\n static from_tuples(*tuples: Any): ManagedReferences\n  locator: Any - locator to remove references by. returns: ManagedReferences - list containing all removed references.  See also   RunReferencesDecorator   LinkReferencesDecorator   BuildReferencesDecorator   References   ","description":"Managed references that in addition to keeping and locating references can also  manage their lifecycle.\n","image":null,"permalink":"/python/container/refer/managed_references/","subtitle":null,"tags":null,"title":"ManagedReferences"},{"content":"Description The MapConverter class allows you to convert arbitrary values into map objects using the following extended conversion rules:\n Objects: property names as keys, property values as values Arrays: element indexes as keys, elements as values  Methods ToMap Converts a value into a map object or returns an empty map when conversion is not possible\n ToMap(value interface{}) map[string]interface{}\n  value: interface{} - value to convert. returns: map[string]interface{} - map object or empty map when conversion is not supported.  ToMapWithDefault Converts a value into a map object or returns a default map when conversion is not possible\n ToMapWithDefault(value interface{}, defaultValue map[string]interface{}) map[string]interface{}\n  value: interface{} - value to convert. defaultValue: map[string]interface{} - default value. returns: map[string]interface{} - map object or empty map when conversion is not supported.  ToNullableMap Converts a value into a map object or returns nil when conversion is not possible.\n ToNullableMap(value interface{}) *map[string]interface{}\n  value: interface{} - value to convert. returns: *map[string]interface{} - map object or nil when conversion is not supported.  Examples value1 := convert.MapConverter.ToNullableMap(\u0026#34;ABC\u0026#34;) value2 := convert.MapConverter.ToNullableMap(map[string]int{\u0026#34;key\u0026#34;: 123}) value3 := convert.MapConverter.ToNullableMap([...]int{1, 2, 3}) fmt.Println(value1) // \u0026lt;nil\u0026gt; fmt.Println(*value2) // map[key:123] fmt.Println(*value3) // map[0:1 1:2 2:3]  ","description":"The MapConverter class allows you to convert arbitrary values into map objects using extended conversion rules.\n","image":null,"permalink":"/golang/commons/convert/map_converter/","subtitle":null,"tags":null,"title":"MapConverter"},{"content":"Description The MapConverter class allows you to convert arbitrary values into map objects using the following extended conversion rules:\n Objects: property names as keys, property values as values Arrays: element indexes as keys, elements as values  Static methods ToMap Converts value into a map object or returns an empty map when the conversion is not possible\n public static IDictionary\u0026lt;string, object\u0026gt; ToMap(object value)\n  value: object - value to convert. returns: IDictionary\u0026lt;string, object\u0026gt; - map object or empty map when the conversion is not supported.  ToMapWithDefault Converts value into a map object or returns a gvien default value when the conversion is not possible\n public static IDictionary\u0026lt;string, object\u0026gt; ToMapWithDefault(object value, IDictionary\u0026lt;string, object\u0026gt; defaultValue)\n  value: object - value to convert. defaultValue: IDictionary\u0026lt;string, object\u0026gt; - default value. returns: IDictionary\u0026lt;string, object\u0026gt; - map object or empty map when the conversion is not supported.  ToNullableMap Converts value into a map object or returns null when the conversion is not possible.\n public static IDictionary\u0026lt;string, object\u0026gt; ToNullableMap(object value)\n  value: object - value to convert. returns: IDictionary\u0026lt;string, object\u0026gt; - map object or null when the conversion is not supported.  Examples var value1 = MapConverted.ToNullableMap(\u0026#34;ABC\u0026#34;); // Result: null var value2 = MapConverted.ToNullableMap({ key: 123 }); // Result: { key: 123 } var value3 = MapConverted.ToNullableMap(new int[] { 1, 2, 3 }); // Result: { \u0026#34;0\u0026#34;: 1, \u0026#34;1\u0026#34;: 2, \u0026#34;2\u0026#34;: 3 }  ","description":"The MapConverter class allows you to convert arbitrary values into map objects using extended conversion rules.\n","image":null,"permalink":"/net/commons/convert/map_converter/","subtitle":null,"tags":null,"title":"MapConverter"},{"content":"Description The MapConverter class allows you to convert arbitrary values into map objects using the following extended conversion rules:\n Objects: property names as keys, property values as values Arrays: element indexes as keys, elements as values  Static methods toMap Converts a value into a map object or returns an empty map when the conversion is not possible.\n public static toMap(value: any): any\n  value: any - value to convert. returns: any - map object or empty map when the conversion is not supported.  toMapWithDefault Converts a value into a map object or returns a given default when the conversion is not possible.\n public static toMapWithDefault(value: any, defaultValue: any): any\n  value: any - value to convert. defaultValue: any - default value. returns: any - map object or empty map when the conversion is not supported.  toNullableMap Converts a value into a map object or returns null when the conversion is not possible.\n public static toNullableMap(value: any): any\n  value: any - value to convert. returns: any - map object or null when the conversion is not supported.  Examples let value1 = MapConverted.toNullableMap(\u0026#34;ABC\u0026#34;); // Result: null let value2 = MapConverted.toNullableMap({ key: 123 }); // Result: { key: 123 } let value3 = MapConverted.toNullableMap([1,2,3]); // Result: { \u0026#34;0\u0026#34;: 1, \u0026#34;1\u0026#34;: 2, \u0026#34;2\u0026#34;: 3 }  ","description":"The MapConverter class allows you to convert arbitrary values into map objects using extended conversion rules.\n","image":null,"permalink":"/node/commons/convert/map_converter/","subtitle":null,"tags":null,"title":"MapConverter"},{"content":"Description The MapConverter class allows you to convert arbitrary values into map objects using the following extended conversion rules:\n Objects: property names as keys, property values as values Arrays: element indexes as keys, elements as values  Static methods to_map Converts value into map object or returns empty map when conversion is not possible\n static to_map(value: Any): Any\n  value: Any - the value to convert. returns: Any - map object or empty map when conversion is not supported.  to_map_with_default Converts value into map object or returns default when conversion is not possible\n static toMapWithDefault(value: Any, default_value: Any): Any\n  value: Any - the value to convert. default_value: Any - the default value. returns: Any - map object or empty map when conversion is not supported.  to_nullable_map Converts value into map object or returns None when conversion is not possible.\n static to_nullable_map(value: Any): Any\n  value: Any - the value to convert. returns: Any - map object or None when conversion is not supported.  Examples value1 = MapConverter.to_nullable_map(\u0026#34;ABC\u0026#34;) # Returns None value2 = MapConverter.to_nullable_map({ key: 123 }) # Returns { key: 123 } value3 = MapConverter.to_nullable_map([1,2,3]) # Returns { \u0026#34;0\u0026#34;: 1, \u0026#34;1\u0026#34;: 2, \u0026#34;2\u0026#34;: 3 } ","description":"The MapConverter class allows you to convert arbitrary values into map objects using extended conversion rules.\n","image":null,"permalink":"/python/commons/convert/map_converter/","subtitle":null,"tags":null,"title":"MapConverter"},{"content":"Implements: Schema\nDescription The MapSchema class provides you with a schema to validate maps.\nConstructors NewMapSchemaWithRules Creates a new instance of a validation schema and sets its values. See IValidationRule, TypeCode\n NewMapSchemaWithRules(keyType interface{}, valueType interface{}, required bool, rules []IValidationRule) *MapSchema\n  keyType: interface{} - type of map keys. Null means that keys may have any type. valueType: interface{} - type of map values. Null means that values may have any type. required: bool - (optional) true to always require non-nil values. rules: []IValidationRule - (optional) list with validation rules.  NewMapSchema Creates a new instance of a validation schema and sets its values.\n NewMapSchema(keyType interface{}, valueType interface{}) *MapSchema\n  keyType: interface{} - type of map keys. Null means that keys may have any type. valueType: interface{} - type of map values. Null means that values may have any type.  Methods KeyType Gets the type of map keys. Null means that keys may have any type.\n (c *MapSchema) KeyType() interface{}\n  returns: interface{} - type of map keys.  ValueType Gets the type of map values. Null means that the values may have any type.\n (c *MapSchema) ValueType() interface{}\n  returns: interface{} - type of map values.  PerformValidation Validates a given value against the schema and configured validation rules.\n (c *MapSchema) PerformValidation(path string, value interface{}) []*ValidationResult\n  path: string - dot notation path to the value. value: interface{} - value to be validated. returns: []*ValidationResult - list with validation results to add new results.  SetKeyType Sets the type of map keys. Null means that keys may have any type.\n (c *MapSchema) SetKeyType(value interface{})\n  value: interface{} - type of map keys.  SetValueType Sets the type of map values. Null means that values may have any type.\n (c *MapSchema) SetValueType(value interface{})\n  value: interface{} - type of map values.  Examples var schema = NewMapSchema(TypeCode.String, TypeCode.Integer); schema.Validate({ \u0026#34;key1\u0026#34;: \u0026#34;A\u0026#34;, \u0026#34;key2\u0026#34;: \u0026#34;B\u0026#34; }); // Result: no errors schema.Validate({ \u0026#34;key1\u0026#34;: 1, \u0026#34;key2\u0026#34;: 2 }); // Result: element type mismatch schema.Validate([ 1, 2, 3 ]); // Result: type mismatch  ","description":"Schema to validate maps.\n","image":null,"permalink":"/golang/commons/validate/map_schema/","subtitle":null,"tags":null,"title":"MapSchema"},{"content":"Inherits: Schema\nDescription The MapSchema class provides you with a schema to validate maps.\nConstructors Creates a new instance of validation schema and sets its values. See IValidationRule, TypeCode\n public MapSchema(object keyType, object valueType)\n  keyType: object - type of map keys. Null means that keys may have any type. valueType: object - type of map values. Null means that values may have any type.  Creates a new instance of validation schema.\n public MapSchema()\n Properties KeyType Gets and sets the type of the map keys. Null means that keys may have any type.\n public object KeyType { get; set; }\n ValueType Gets and sets the type of map values. Null means that values may have any type.\n public object ValueType { get; set; }\n Instance methods PerformValidation Validates a given value against the schema and configured validation rules.\n protected internal override void PerformValidation(string path, object value, List\u0026lt;ValidationResult\u0026gt; results)\n  path: string - dot notation path to the value. value: object - value to be validated. results: List\u0026lt;ValidationResult\u0026gt; - list with validation results.  Examples var schema = new MapSchema(TypeCode.String, TypeCode.Integer); schema.Validate({ \u0026#34;key1\u0026#34;: \u0026#34;A\u0026#34;, \u0026#34;key2\u0026#34;: \u0026#34;B\u0026#34; }); // Result: no errors schema.Validate({ \u0026#34;key1\u0026#34;: 1, \u0026#34;key2\u0026#34;: 2 }); // Result: element type mismatch schema.Validate(new int[]{ 1, 2, 3 }); // Result: type mismatch ","description":"Schema to validate maps.\n","image":null,"permalink":"/net/commons/validate/map_schema/","subtitle":null,"tags":null,"title":"MapSchema"},{"content":"Extends: Schema\nDescription The MapSchema class provides you with a schema to validate maps\nConstructors Creates a new instance of validation schema and sets its values. See IValidationRule, TypeCode\n public constructor(keyType?: any, valueType?: any, required?: boolean, rules?: IValidationRule[])\n  keyType: any - type of map keys. Null means that keys may have any type. valueType: any - type of map values. Null means that values may have any type. required: boolean - (optional) true to always require non-null values. rules: IValidationRule[] - (optional) list with validation rules.  Instance methods getKeyType Gets the type of map keys. Null means that keys may have any type.\n public getKeyType(): any\n  returns: any - type of map keys.  getValueType Gets the type of map values. Null means that values may have any type.\n public getValueType(): any\n  returns: any - type of map values.  performValidation Validates a given value against the schema and configured validation rules.\n protected performValidation(path: string, value: any, results: ValidationResult[]): void\n  path: string - dot notation path to the value. value: any - value to be validated. results: ValidationResult[] - list with validation results to add new results.  setKeyType Sets the type of map keys. Null means that keys may have any type.\n public setKeyType(value: any): void\n  value: any - type of map keys.  setValueType Sets the type of map values. Null means that values may have any type.\n public setValueType(value: any): void\n  value: any - type of map values.  Examples let schema = new MapSchema(TypeCode.String, TypeCode.Integer); schema.validate({ \u0026#34;key1\u0026#34;: \u0026#34;A\u0026#34;, \u0026#34;key2\u0026#34;: \u0026#34;B\u0026#34; }); // Result: no errors schema.validate({ \u0026#34;key1\u0026#34;: 1, \u0026#34;key2\u0026#34;: 2 }); // Result: element type mismatch schema.validate([ 1, 2, 3 ]); // Result: type mismatch  ","description":"Schema to validate maps.\n","image":null,"permalink":"/node/commons/validate/map_schema/","subtitle":null,"tags":null,"title":"MapSchema"},{"content":"Implements: Schema\nDescription The MapSchema class provides you with a schema to validate maps\nConstructors Creates a new instance of validation schema and sets its values. See IValidationRule, TypeCode\n MapSchema(key_type: Any = None, value_type: Any = None, required: bool = None, rules: List[IValidationRule] = None)\n  key_type: Any - a type of map keys. Null means that keys may have any type. value_type: Any - a type of map values. Null means that values may have any type. required: boolean - (optional) true to always require non-None values. rules: List[IValidationRule] - (optional) a list with validation rules.  Instance methods get_key_type Gets the type of map keys. Null means that keys may have any type.\n get_key_type(): Any\n  returns: Any - the type of map keys.  get_value_type Gets the type of map values. Null means that values may have any type.\n get_value_type(): Any\n  returns: Any - the type of map values.  perform_validation Validates a given value against the schema and configured validation rules.\n _perform_validation(path: str, value: Any, results: List[ValidationResult])\n  path: str - a dot notation path to the value. value: Any - a value to be validated. results: List[ValidationResult] - a list with validation results to add new results.  set_key_type Sets the type of map keys. Null means that keys may have any type.\n set_key_type(value: Any)\n  value: Any - a type of map keys.  set_value_type Sets the type of map values. Null means that values may have any type.\n set_value_type(value: Any)\n  value: Any - a type of map values.  Examples schema = MapSchema(TypeCode.String, TypeCode.Integer) schema.validate({ \u0026#34;key1\u0026#34;: \u0026#34;A\u0026#34;, \u0026#34;key2\u0026#34;: \u0026#34;B\u0026#34; }) # Result: no errors schema.validate({ \u0026#34;key1\u0026#34;: 1, \u0026#34;key2\u0026#34;: 2 }) # Result: element type mismatch schema.validate([ 1, 2, 3 ]) # Result: type mismatch ","description":"Schema to validate maps.\n","image":null,"permalink":"/python/commons/validate/map_schema/","subtitle":null,"tags":null,"title":"MapSchema"},{"content":"Description The MemoryCache class allows you to create a cache that stores values in the process memory.\nImportant points\n This implementation is not suitable for synchronization of distributed processes.  Configuration parameters options:\n timeout: default caching timeout in milliseconds (default: 1 minute) max_size: maximum number of values stored in this cache (default: 1000)  Constructors NewMemoryCache Creates a new instance of the cache.\n NewMemoryCache() *MemoryCache\n NewMemoryCacheFromConfig Creates a new instance of the cache.\n NewMemoryCacheFromConfig(cfg *config.ConfigParams) [*MemoryCache])()\n  cfg: *config.ConfigParams - configuration parameters to be set.  Methods Configure Configures a component by passing its configuration parameters.\n (c *MemoryCache) Configure(cfg *config.ConfigParams)\n  config: *config.ConfigParams - configuration parameters to be set.  Clear Clears a value from the cache.\n (c *MemoryCache) Clear(correlationId string) error\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. returns: error - return error if not cleared.  Remove Removes a value from the cache by its key.\n (c *MemoryCache) Remove(correlationId string, key string) error\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. key: string - unique value key. returns: error - returns error if not removed.  Retrieve Retrieves cached value from the cache using its key. If value is missing in the cache or expired it returns nil.\n (c *MemoryCache) Retrieve(correlationId string, key string) (interface{}, error)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. key: string - unique value key. returns: (interface{}, error) - cached value or nil if value wasn\u0026rsquo;t found or timeout expired.  RetrieveAs Retrieves a cached value from the cache using its key and restores it into a reference object. If the value is missing in the cache or expired, it returns false.\n (c *MemoryCache) RetrieveAs(correlationId string, key string, result interface{}) (interface{}, error)\n  correlationId: string - transaction id used to trace execution through the call chain. key: string - unique value key. result: (interface{}, error) - pointer to object for restore  Store Stores a value in the cache with expiration time.\n (c *MemoryCache) Store(correlationId string, key string, value interface{}, timeout int64) (interface{}, error)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. key: string - unique value key. value: interface{} - value to store. timeout: int64 - expiration timeout in milliseconds. returns: (interface{}, error) - cached value stored in the cache.  Examples cache := NewMemoryCache(); res, err := cache.Store(\u0026#34;123\u0026#34;, \u0026#34;key1\u0026#34;, \u0026#34;ABC\u0026#34;, 10000); See also   ICache   ","description":"Cache that stores values in the process memory.\n","image":null,"permalink":"/golang/components/cache/memory_cache/","subtitle":null,"tags":null,"title":"MemoryCache"},{"content":"Inherits: ICache, IReconfigurable\nDescription The MemoryCache class allows you to create a cache that stores values in the process memory.\nImportant points\n This implementation is not suitable for synchronization of distributed processes.  Configuration parameters options:\n timeout: default caching timeout in milliseconds (default: 1 minute) max_size: maximum number of values stored in this cache (default: 1000)  Constructors Creates instance of local in-memory cache component\n public MemoryCache(ConfigParams config)\n  config: ConfigParams - configuration parameters.  Creates instance of local in-memory cache component\n public MemoryCache()\n Instance methods ClearAsync Clears component state.\n Task ClearAsync(string correlationId)\n  correlationId: string - (optional) transaction id to trace execution through call chain.  Configure Configures component by passing configuration parameters.\n public override void Configure(ConfigParams config)\n  config: ConfigParams - configuration parameters to be set.  RemoveAsync Removes a value from the cache by its key.\n public override Task RemoveAsync(string correlationId, string key)\n  correlationId: string - (optional) transaction id to trace execution through call chain. key: string - a unique value key.  RetrieveAsync Retrieves cached value from the cache using its key. If value is missing in the cache or expired it returns null.\n public Task\u0026lt;T\u0026gt; RetrieveAsync\u0026lt;T\u0026gt;(string correlationId, string key)\n  correlationId: string - (optional) transaction id to trace execution through call chain. key: string - a unique value key. returns: Task\u0026lt;T\u0026gt; - a cached value or null if value wasn\u0026rsquo;t found or timeout expired.  StoreAsync Stores value in the cache with expiration time.\n public Task\u0026lt;T\u0026gt; StoreAsync\u0026lt;T\u0026gt;(string correlationId, string key, T value, long timeout)\n  correlationId: string - (optional) transaction id to trace execution through call chain. key: string - a unique value key. value: T - a value to store. timeout: long - expiration timeout in milliseconds. returns: Task\u0026lt;T\u0026gt; - a cached value stored in the cache.  Examples var cache = new MemoryCache(); ... cache.StoreAsync(\u0026#34;123\u0026#34;, \u0026#34;key1\u0026#34;, \u0026#34;ABC\u0026#34;, 0); ... See also   ICache   ","description":"Cache that stores values in the process memory.\n","image":null,"permalink":"/net/components/cache/memory_cache/","subtitle":null,"tags":null,"title":"MemoryCache"},{"content":"Implements: ICache, IReconfigurable\nDescription The MemoryCache class allows you to create a cache that stores values in the process memory.\nImportant points\n This implementation is not suitable for synchronization of distributed processes.  Configuration parameters options:\n timeout: default caching timeout in milliseconds (default: 1 minute) max_size: maximum number of values stored in this cache (default: 1000)  Instance methods configure Configures component by passing configuration parameters.\n public configure(config: ConfigParams): void\n  config: ConfigParams - configuration parameters to be set.  remove Removes a value from the cache by its key.\n public remove(correlationId: string, key: string): Promise\u0026lt;void\u0026gt;\n  correlationId: string - (optional) transaction id to trace execution through call chain. key: string - a unique value key.  retrieve Retrieves cached value from the cache using its key. If value is missing in the cache or expired it returns null.\n public retrieve(correlationId: string, key: string): Promise\u0026lt;any\u0026gt;\n  correlationId: string - (optional) transaction id to trace execution through call chain. key: string - a unique value key. returns: any - a cached value or null if value wasn\u0026rsquo;t found or timeout expired.  store Stores value in the cache with expiration time.\n public store(correlationId: string, key: string, value: any, timeout: number): Promise\u0026lt;any\u0026gt;\n  correlationId: string - (optional) transaction id to trace execution through call chain. key: string - a unique value key. value: any - a value to store. timeout: number - expiration timeout in milliseconds. returns: Promise\u0026lt;any\u0026gt; - a cached value stored in the cache.  Examples let cache = new MemoryCache(); await cache.store(\u0026#34;123\u0026#34;, \u0026#34;key1\u0026#34;, \u0026#34;ABC\u0026#34;); ... let value = await cache.retrieve(\u0026#34;123\u0026#34;, \u0026#34;key1\u0026#34;); // Result: \u0026#34;ABC\u0026#34; See also   ICache   ","description":"Cache that stores values in the process memory.\n","image":null,"permalink":"/node/components/cache/memory_cache/","subtitle":null,"tags":null,"title":"MemoryCache"},{"content":"Implements: ICache, IReconfigurable\nDescription The MemoryCache class allows you to create a cache that stores values in the process memory.\nImportant points\n This implementation is not suitable for synchronization of distributed processes.  Configuration parameters options:\n timeout: default caching timeout in milliseconds (default: 1 minute) max_size: maximum number of values stored in this cache (default: 1000)  Instance methods configure Configures component by passing configuration parameters.\n configure(config: ConfigParams)\n  config: ConfigParams - configuration parameters to be set.  remove Removes a value from the cache by its key.\n remove(correlation_id: Optional[str], key: str)\n  correlation_id: Optional[str] - (optional) transaction id to trace execution through call chain. key: str - a unique value key.  retrieve Retrieves cached value from the cache using its key. If value is missing in the cache or expired it returns None.\n retrieve(correlation_id: Optional[str], key: str): Any\n  correlation_id: Optional[str] - (optional) transaction id to trace execution through call chain. key: str - a unique value key. returns: Any - a cached value or None if value wasn\u0026rsquo;t found or timeout expired.  store Stores value in the cache with expiration time.\n store(correlation_id: Optional[str], key: str, value: Any, timeout: int): Any\n  correlation_id: Optional[str] - (optional) transaction id to trace execution through call chain. key: str - a unique value key. value: Any - a value to store. timeout: int - expiration timeout in milliseconds. returns: Any - a cached value stored in the cache.  Examples cache = MemoryCache() cache.store(\u0026#34;123\u0026#34;, \u0026#34;key1\u0026#34;, \u0026#34;ABC\u0026#34;, 0) See also   ICache   ","description":"Cache that stores values in the process memory.\n","image":null,"permalink":"/python/components/cache/memory_cache/","subtitle":null,"tags":null,"title":"MemoryCache"},{"content":"Description The MemoryConfigReader class allows you to create a config reader that stores a configuration in memory.\nConfiguration parameters The configuration parameters are the configuration template\n path: path to the configuration file parameters: this entire section is used as template parameters \u0026hellip;  Constructors NewMemoryConfigReader Creates a new instance of a config reader.\n NewMemoryConfigReader(config *cconfig.ConfigParams) *MemoryConfigReader\n  cconfig: *cconfig.ConfigParams - (optional) component configuration parameters  NewEmptyMemoryConfigReader Creates a new instance of config reader.\n NewEmptyMemoryConfigReader() *MemoryConfigReader\n Methods Configure Configures a component by passing its configuration parameters.\n (c *MemoryConfigReader) Configure(config *cconfig.ConfigParams)\n  cconfig: *cconfig.ConfigParams - configuration parameters to be set.  ReadConfig Reads a configuration and parameterizes it with given values.\n (c *MemoryConfigReader) ReadConfig(correlationId string, parameters *cconfig.ConfigParams) (*cconfig.ConfigParams, error)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. parameters: *cconfig.ConfigParams - values to parameters the configuration or nil to skip parameterization. returns: *cconfig.ConfigParams - ConfigParams configuration.  Examples config := NewConfigParamsFromTuples( \u0026#34;connection.host\u0026#34;, \u0026#34;localhost\u0026#34;, \u0026#34;connection.port\u0026#34;, \u0026#34;8080\u0026#34; ); configReader := NewMemoryConfigReader(); configReader.Configure(config); parameters := NewConfigParamsFromValue(process.env); res, err := configReader.ReadConfig(\u0026#34;123\u0026#34;, parameters); // Possible result: connection.host=10.1.1.100;connection.port=8080 ","description":"Config reader that stores a configuration in memory.\n","image":null,"permalink":"/golang/components/config/memory_config_reader/","subtitle":null,"tags":null,"title":"MemoryConfigReader"},{"content":"Inherits: IConfigReader, IReconfigurable\nDescription The MemoryConfigReader class allows you to create a config reader that stores a configuration in memory.\nConfiguration parameters The configuration parameters are the configuration template\n path: path to the configuration file parameters: this entire section is used as template parameters \u0026hellip;  Constructors Creates a new instance of a config reader.\n public MemoryConfigReader(ConfigParams config = null)\n  config: ConfigParams - (optional) component configuration parameters  Fields _config  protected _config: ConfigParams = new ConfigParams()\n  Instance methods Configure Configures a component by passing its configuration parameters.\n public void Configure(ConfigParams config)\n  config: ConfigParams - configuration parameters to be set.  ReadConfig Reads a configuration and parameterizes it with given values.\n public virtual ConfigParams ReadConfig(string correlationId, ConfigParams parameters)\n  correlationId: string - (optional) transaction id to trace execution through a call chain. parameters: ConfigParams - values to parameters the configuration or null to skip parameterization. returns: ConfigParams - ConfigParams configuration.  Examples var config = ConfigParams.FromTuples( \u0026#34;connection.host\u0026#34;, \u0026#34;{{SERVICE_HOST}}\u0026#34;, \u0026#34;connection.port\u0026#34;, \u0026#34;{{SERVICE_PORT}}{{^SERVICE_PORT}}8080{{/SERVICE_PORT}}\u0026#34; ); var configReader = new MemoryConfigReader(); configReader.Configure(config); var parameters = ConfigParams.fromValue(process.env); configReader.ReadConfig(\u0026#34;123\u0026#34;, parameters); ","description":"Config reader that stores a configuration in memory.\n","image":null,"permalink":"/net/components/config/memory_config_reader/","subtitle":null,"tags":null,"title":"MemoryConfigReader"},{"content":"Implements: IConfigReader, IReconfigurable\nDescription The MemoryConfigReader class allows you to create a config reader that stores a configuration in memory.\nConfiguration parameters The configuration parameters are the configuration template\n path: path to the configuration file parameters: this entire section is used as template parameters \u0026hellip;  Constructors Creates a new instance of a config reader.\n public constructor(config: ConfigParams = null)\n  config: ConfigParams - (optional) component configuration parameters  Instance methods configure Configures a component by passing its configuration parameters.\n public configure(config: ConfigParams): void\n  config: ConfigParams - configuration parameters to be set.  readConfig Reads a configuration and parameterizes it with given values.\n public readConfig(correlationId: string, parameters: ConfigParams): ConfigParams\n  correlationId: string - (optional) transaction id to trace execution through a call chain. parameters: ConfigParams - values to parameters the configuration or null to skip parameterization. returns: ConfigParams - ConfigParams configuration.  Examples let config = ConfigParams.fromTuples( \u0026#34;connection.host\u0026#34;, \u0026#34;{{SERVICE_HOST}}\u0026#34;, \u0026#34;connection.port\u0026#34;, \u0026#34;{{SERVICE_PORT}}{{^SERVICE_PORT}}8080{{/SERVICE_PORT}}\u0026#34; ); let configReader = new MemoryConfigReader(); configReader.configure(config); let parameters = ConfigParams.fromValue(process.env); let config = await configReader.readConfig(\u0026#34;123\u0026#34;, parameters); // Possible result: connection.host=10.1.1.100;connection.port=8080 ","description":"Config reader that stores a configuration in memory.\n","image":null,"permalink":"/node/components/config/memory_config_reader/","subtitle":null,"tags":null,"title":"MemoryConfigReader"},{"content":"Implements: IConfigReader, IReconfigurable\nDescription The MemoryConfigReader class allows you to create a config reader that stores a configuration in memory.\nConfiguration parameters The configuration parameters are the configuration template\n path: path to the configuration file parameters: this entire section is used as template parameters \u0026hellip;  Constructors Creates a new instance of a config reader.\n MemoryConfigReader(config: ConfigParams = None)\n  config: ConfigParams - (optional) component configuration parameters  Instance methods configure Configures a component by passing its configuration parameters.\n configure(config: ConfigParams)\n  config: ConfigParams - configuration parameters to be set.  _read_config Reads a configuration and parameterizes it with given values.\n _read_config(correlation_id: Optional[str], parameters: ConfigParams): ConfigParams\n  correlation_id: Optional[str] - (optional) transaction id to trace execution through a call chain. parameters: ConfigParams - values to parameters the configuration or None to skip parameterization. returns: ConfigParams - ConfigParams configuration.  Examples config = ConfigParams.from_tuples( \u0026#34;connection.host\u0026#34;, \u0026#34;localhost\u0026#34;, \u0026#34;connection.port\u0026#34;, \u0026#34;8080\u0026#34; ) config_reader = MemoryConfigReader() config_reader.configure(config) parameters = ConfigParams.from_value(sys.argv) config_reader.read_config(\u0026#34;123\u0026#34;, parameters) # Result: connection.host=localhost;connection.port=8080 ","description":"Config reader that stores a configuration in memory.\n","image":null,"permalink":"/python/components/config/memory_config_reader/","subtitle":null,"tags":null,"title":"MemoryConfigReader"},{"content":"Description The MemoryCredentialStore class is used to create credential stores that keep their contained credentials in memory.\nConfiguration parameters  [credential key 1]: \u0026hellip; : credential parameters for key 1 [credential key 2]: \u0026hellip; : credential parameters for key N \u0026hellip; :  References  *:credential-store:*:*:1.0 - (optional) credential stores to resolve credentials  Constructors NewMemoryCredentialStore Creates a new instance of the credential store.\n NewMemoryCredentialStore(config *config.ConfigParams) *MemoryCredentialStore\n  config: *config.ConfigParams - (optional) configuration with credential parameters.  NewEmptyMemoryCredentialStore Creates a new instance of the credential store.\n NewEmptyMemoryCredentialStore() *MemoryCredentialStore\n Methods Configure Configures component by passing configuration parameters.\n (c *MemoryCredentialStore) Configure(config *config.ConfigParams)\n  config: *config.ConfigParams - configuration parameters to be set.  Lookup Looks up credential parameters by its key.\n (c *MemoryCredentialStore) Lookup(correlationId string, key string) (result *CredentialParams, err error)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. key: string - key used to uniquely identify the credential. returns: (result *CredentialParams, err error) - found credential parameters or nil if nothing was found  ReadCredentials Reads credentials from configuration parameters. Each section represents an individual CredentialParams.\n (c *MemoryCredentialStore) ReadCredentials(config *config.ConfigParams)\n  config: *config.ConfigParams - configuration parameters to be read  Store Stores credential parameters into the store.\n (c *MemoryCredentialStore) Store(correlationId string, key string, credential *CredentialParams) error\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. key: string - key to uniquely identify the credential parameters. credential: *CredentialParams - credential parameters to be stored. returns: error - return error if not stored.  Examples config := NewConfigParamsFromTuples( \u0026#34;key1.user\u0026#34;, \u0026#34;jdoe\u0026#34;, \u0026#34;key1.pass\u0026#34;, \u0026#34;pass123\u0026#34;, \u0026#34;key2.user\u0026#34;, \u0026#34;bsmith\u0026#34;, \u0026#34;key2.pass\u0026#34;, \u0026#34;mypass\u0026#34; ); credentialStore := NewEmptyMemoryCredentialStore(); credentialStore.ReadCredentials(config); res, err := credentialStore.Lookup(\u0026#34;123\u0026#34;, \u0026#34;key1\u0026#34;); See also   CredentialParams   ICredentialStore   ","description":"Credential store that keeps credentials in memory.\n","image":null,"permalink":"/golang/components/auth/memory_credential_store/","subtitle":null,"tags":null,"title":"MemoryCredentialStore"},{"content":"Inherits: ICredentialStore, IReconfigurable\nDescription The MemoryCredentialStore class is used to create credential stores that keep their contained credentials in memory.\nConfiguration parameters  [credential key 1]: \u0026hellip; : credential parameters for key 1 [credential key 2]: \u0026hellip; : credential parameters for key N \u0026hellip; :  References  *:credential-store:*:*:1.0 - (optional) Credential stores to resolve credentials  Constructors Creates a new instance of the credential store.\n public MemoryCredentialStore(ConfigParams config)\n  config: ConfigParams - (optional) configuration with credential parameters.  Creates a new instance of the credential store.\n public MemoryCredentialStore()\n Instance methods Configure Configures component by passing configuration parameters.\n public virtual void Configure(ConfigParams config)\n  config: ConfigParams - configuration parameters to be set.  LookupAsync Lookups credential parameters by its key.\n public Task\u0026lt;CredentialParams\u0026gt; LookupAsync(string correlationId, string key)\n  correlationId: string - (optional) transaction id to trace execution through call chain. key: string - a key to uniquely identify the credential. returns: Task\u0026lt;CredentialParams\u0026gt; - found credential parameters or null if nothing was found  ReadCredentials Reads credentials from configuration parameters. Each section represents an individual CredentialParams.\n public void ReadCredentials(ConfigParams config)\n  config: ConfigParams - configuration parameters to be read  StoreAsync Stores credential parameters into the store.\n public Task StoreAsync(string correlationId, string key, CredentialParams credential)\n  correlationId: string - (optional) transaction id to trace execution through call chain. key: string - a key to uniquely identify the credential parameters. credential: CredentialParams - a credential parameters to be stored.  Examples var config = ConfigParams.FromTuples( \u0026#34;key1.user\u0026#34;, \u0026#34;jdoe\u0026#34;, \u0026#34;key1.pass\u0026#34;, \u0026#34;pass123\u0026#34;, \u0026#34;key2.user\u0026#34;, \u0026#34;bsmith\u0026#34;, \u0026#34;key2.pass\u0026#34;, \u0026#34;mypass\u0026#34; ); var credentialStore = new MemoryCredentialStore(); credentialStore.ReadCredentials(config); credentialStore.LookupAsync(\u0026#34;123\u0026#34;, \u0026#34;key1\u0026#34;); See also   CredentialParams   ICredentialStore   ","description":"Credential store that keeps credentials in memory.\n","image":null,"permalink":"/net/components/auth/memory_credential_store/","subtitle":null,"tags":null,"title":"MemoryCredentialStore"},{"content":"Implements: ICredentialStore, IReconfigurable\nDescription The MemoryCredentialStore class is used to create credential stores that keep their contained credentials in memory.\nConfiguration parameters  [credential key 1]: \u0026hellip; : credential parameters for key 1 [credential key 2]: \u0026hellip; : credential parameters for key N \u0026hellip; :  References  *:credential-store:*:*:1.0 - (optional) Credential stores to resolve credentials  Constructors Creates a new instance of the credential store.\n public constructor(config: ConfigParams = null)\n  config: ConfigParams - (optional) configuration with credential parameters.  Instance methods configure Configures component by passing configuration parameters.\n public configure(config: ConfigParams): void\n  config: ConfigParams - configuration parameters to be set.  lookup Lookups credential parameters by its key.\n public lookup(correlationId: string, key: string): Promise\u0026lt;CredentialParams\u0026gt;\n  correlationId: string - (optional) transaction id to trace execution through call chain. key: string - a key to uniquely identify the credential. returns: Promise\u0026lt;CredentialParams\u0026gt; - found credential parameters or null if nothing was found  readCredentials Reads credentials from configuration parameters. Each section represents an individual CredentialParams.\n public readCredentials(config: ConfigParams): void\n  config: ConfigParams - configuration parameters to be read  store Stores credential parameters into the store.\n public store(correlationId: string, key: string, credential: CredentialParams): Promise\u0026lt;void\u0026gt;\n  correlationId: string - (optional) transaction id to trace execution through call chain. key: string - a key to uniquely identify the credential parameters. credential: CredentialParams - a credential parameters to be stored.  Examples let config = ConfigParams.fromTuples( \u0026#34;key1.user\u0026#34;, \u0026#34;jdoe\u0026#34;, \u0026#34;key1.pass\u0026#34;, \u0026#34;pass123\u0026#34;, \u0026#34;key2.user\u0026#34;, \u0026#34;bsmith\u0026#34;, \u0026#34;key2.pass\u0026#34;, \u0026#34;mypass\u0026#34; ); let credentialStore = new MemoryCredentialStore(); credentialStore.readCredentials(config); let credential = await credentialStore.lookup(\u0026#34;123\u0026#34;, \u0026#34;key1\u0026#34;); // Result: user=jdoe;pass=pass123 See also   CredentialParams   ICredentialStore   ","description":"Credential store that keeps credentials in memory.\n","image":null,"permalink":"/node/components/auth/memory_credential_store/","subtitle":null,"tags":null,"title":"MemoryCredentialStore"},{"content":"Implements: ICredentialStore, IReconfigurable\nDescription The MemoryCredentialStore class is used to create credential stores that keep their contained credentials in memory.\nConfiguration parameters  [credential key 1]: \u0026hellip; : credential parameters for key 1 [credential key 2]: \u0026hellip; : credential parameters for key N \u0026hellip; :  References  *:credential-store:*:*:1.0 - (optional) Credential stores to resolve credentials  Constructors Creates a new instance of the credential store.\n MemoryCredentialStore(config: ConfigParams = None)\n  config: ConfigParams - (optional) configuration with credential parameters.  Instance methods configure Configures component by passing configuration parameters.\n configure(config: ConfigParams)\n  config: ConfigParams - configuration parameters to be set.  lookup Lookups credential parameters by its key.\n lookup(correlation_id: Optional[str], key: str): CredentialParams\n  correlation_id: Optional[str] - (optional) transaction id to trace execution through call chain. key: str - a key to uniquely identify the credential. returns: CredentialParams - found credential parameters or None if nothing was found  read_credentials Reads credentials from configuration parameters. Each section represents an individual CredentialParams.\n read_credentials(config: ConfigParams)\n  config: ConfigParams - configuration parameters to be read  store Stores credential parameters into the store.\n store(correlation_id: Optional[str], key: str, credential: CredentialParams)\n  correlation_id: Optional[str] - (optional) transaction id to trace execution through call chain. key: str - a key to uniquely identify the credential parameters. credential: CredentialParams - a credential parameters to be stored.  Examples config = ConfigParams.from_tuples(\u0026#34;key1.user\u0026#34;, \u0026#34;jdoe\u0026#34;, \u0026#34;key1.pass\u0026#34;, \u0026#34;pass123\u0026#34;, \u0026#34;key2.user\u0026#34;, \u0026#34;bsmith\u0026#34;, \u0026#34;key2.pass\u0026#34;, \u0026#34;mypass\u0026#34; ) credentialStore = MemoryCredentialStore() credentialStore.read_credentials(config) credentialStore.lookup(\u0026#34;123\u0026#34;, \u0026#34;key1\u0026#34;) See also   CredentialParams   ICredentialStore   ","description":"Credential store that keeps credentials in memory.\n","image":null,"permalink":"/python/components/auth/memory_credential_store/","subtitle":null,"tags":null,"title":"MemoryCredentialStore"},{"content":"Implements: IDiscovery, IReconfigurable\nDescription The MemoryDiscovery class allows you to create discovery services that keep connections in memory.\nConfiguration parameters  [connection key 1]: \u0026hellip; : connection parameters for key 1 [connection key 2]: \u0026hellip; : connection parameters for key N  Constructors NewMemoryDiscovery Creates a new instance of discovery service.\n NewMemoryDiscovery(config *config.ConfigParam) *MemoryDiscovery\n  config: *config.ConfigParam - (optional) configuration with connection parameters.  Methods Configure Configures component by passing configuration parameters.\n (c *MemoryDiscovery) Configure(config *config.ConfigParams)\n  config: *config.ConfigParams - configuration parameters to be set.  ReadConnections Reads connections from configuration parameters. Each section represents an individual Connection params.\n (c *MemoryDiscovery) ReadConnections(config *config.ConfigParams)\n  connections: *config.ConfigParams - configuration parameters to be read  Register Registers connection parameters into the discovery service.\n (c *MemoryDiscovery) Register(correlationId string, key string, connection *ConnectionParams) (result *ConnectionParams, err error)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. key: string - key to uniquely identify the connection parameters. connection: *ConnectionParams - connection to be registered. returns: (result *ConnectionParams, err error) - the registered connection parameters.  ResolveAll Resolves all connection parameters by their key.\n (c *MemoryDiscovery) ResolveAll(correlationId string, key string) (result []*ConnectionParams, err error)\n  correlationId: string - (optional) transaction id to trace execution through a call chain. key: string - key to uniquely identify the connections. returns: (result []*ConnectionParams, err error) - list with resolved connections.  ResolveOne Resolves a single connection parameters by its key.\n (c *MemoryDiscovery) ResolveOne(correlationId string, key string) (result *ConnectionParams, err error)\n  correlationId: string - (optional) transaction id used to trace execution through a call chain. key: string - key used to uniquely identify the connection. returns: (result *ConnectionParams, err error) - resolved connection.  Examples config := NewConfigParamsFromTuples( \u0026#34;key1.host\u0026#34;, \u0026#34;10.1.1.100\u0026#34;, \u0026#34;key1.port\u0026#34;, \u0026#34;8080\u0026#34;, \u0026#34;key2.host\u0026#34;, \u0026#34;10.1.1.100\u0026#34;, \u0026#34;key2.port\u0026#34;, \u0026#34;8082\u0026#34; ); discovery := NewMemoryDiscovery(); discovery.ReadConnections(config); discovery.Resolve(\u0026#34;123\u0026#34;, \u0026#34;key1\u0026#34;, (err, connection) =\u0026gt; { // Result: host=10.1.1.100;port=8080 }); See also   IDiscovery   ConnectionParams   ","description":"Discovery service that keeps connections in memory.\n","image":null,"permalink":"/golang/components/connect/memory_discovery/","subtitle":null,"tags":null,"title":"MemoryDiscovery"},{"content":"Inherits: IDiscovery, IReconfigurable\nDescription The MemoryDiscovery class allows you to create discovery services that keep connections in memory.\nConfiguration parameters  [connection key 1]: \u0026hellip; : connection parameters for key 1 [connection key 2]: \u0026hellip; : connection parameters for key N  Constructors Creates a new instance of discovery service.\n public MemoryDiscovery(ConfigParams config = null)\n  config: ConfigParams - (optional) configuration with connection parameters.  Creates a new instance of discovery service.\n public MemoryDiscovery()\n Instance methods Configure Configures component by passing configuration parameters.\n public virtual void Configure(ConfigParams config)\n  config: ConfigParams - configuration parameters to be set.  ReadConnections! TODO: this method is not realized yet for this language\nReads connections from configuration parameters. Each section represents an individual Connection params\n public void ReadConnections(ConfigParams connections)\n  connections: ConfigParams - configuration parameters to be read  RegisterAsync Registers connection parameters into the discovery service.\n public Task\u0026lt;void\u0026gt; RegisterAsync(string correlationId, string key, ConnectionParams connection)\n  correlationId: string - (optional) transaction id to trace execution through call chain. key: string - a key to uniquely identify the connection parameters. connection: ConnectionParams - a connection to be registered.  ResolveAllAsync Resolves all connection parameters by their key.\n public Task\u0026lt;List\u0026lt;ConnectionParams\u0026gt;\u0026gt; ResolveAllAsync(string correlationId, string key)\n  correlationId: string - (optional) transaction id to trace execution through a call chain. key: string - a key to uniquely identify the connections. returns: Task\u0026lt;List\u0026lt;ConnectionParams\u0026gt;\u0026gt; - a list with resolved connections.  ResolveOneAsync Resolves a single connection parameters by its key.\n public Task\u0026lt;ConnectionParams\u0026gt; ResolveOneAsync(string correlationId, string key)\n  correlationId: string - (optional) transaction id to trace execution through a call chain. key: string - a key to uniquely identify the connection. returns: Task\u0026lt;ConnectionParams\u0026gt; - a resolved connection.  Examples ConfigParams config = ConfigParams.FromTuples( \u0026#34;key1.host\u0026#34;, \u0026#34;10.1.1.100\u0026#34;, \u0026#34;key1.port\u0026#34;, \u0026#34;8080\u0026#34;, \u0026#34;key2.host\u0026#34;, \u0026#34;10.1.1.100\u0026#34;, \u0026#34;key2.port\u0026#34;, \u0026#34;8082\u0026#34; ); MemoryDiscovery discovery = new MemoryDiscovery(); discovery.ReadConnections(config); discovery.Resolve(\u0026#34;123\u0026#34;, \u0026#34;key1\u0026#34;); See also   IDiscovery   ConnectionParams   ","description":"Discovery service that keeps connections in memory.\n","image":null,"permalink":"/net/components/connect/memory_discovery/","subtitle":null,"tags":null,"title":"MemoryDiscovery"},{"content":"Implements: IDiscovery, IReconfigurable\nDescription The MemoryDiscovery class allows you to create discovery services that keep connections in memory.\nConfiguration parameters  [connection key 1]: \u0026hellip; : connection parameters for key 1 [connection key 2]: \u0026hellip; : connection parameters for key N  Constructors Creates a new instance of discovery service.\n public constructor(config: ConfigParams = null)\n  config: ConfigParams - (optional) configuration with connection parameters.  Instance methods configure Configures component by passing configuration parameters.\n public configure(config: ConfigParams): void\n  config: ConfigParams - configuration parameters to be set.  readConnections Reads connections from configuration parameters. Each section represents an individual Connection params\n public readConnections(connections: ConfigParams): void\n  connections: ConfigParams - configuration parameters to be read  register Registers connection parameters into the discovery service.\n public register(correlationId: string, key: string, connection: ConnectionParams): Promise\u0026lt;ConnectionParams\u0026gt;\n  correlationId: string - (optional) transaction id to trace execution through call chain. key: string - a key to uniquely identify the connection parameters. connection: ConnectionParams - a connection to be registered. returns: Promise\u0026lt;ConnectionParams\u0026gt; - the registered connection parameters.  resolveAll Resolves all connection parameters by their key.\n public resolveAll(correlationId: string, key: string): Promise\u0026lt;ConnectionParams[]\u0026gt;\n  correlationId: string - (optional) transaction id to trace execution through a call chain. key: string - a key to uniquely identify the connections. returns: Promise\u0026lt;ConnectionParams[]\u0026gt; - a list with resolved connections.  resolveOne Resolves a single connection parameters by its key.\n public resolveOne(correlationId: string, key: string): Promise\u0026lt;ConnectionParams\u0026gt;\n  correlationId: string - (optional) transaction id to trace execution through a call chain. key: string - a key to uniquely identify the connection. returns: Promise\u0026lt;ConnectionParams\u0026gt; - a resolved connection.  Examples let config = ConfigParams.fromTuples( \u0026#34;key1.host\u0026#34;, \u0026#34;10.1.1.100\u0026#34;, \u0026#34;key1.port\u0026#34;, \u0026#34;8080\u0026#34;, \u0026#34;key2.host\u0026#34;, \u0026#34;10.1.1.100\u0026#34;, \u0026#34;key2.port\u0026#34;, \u0026#34;8082\u0026#34; ); let discovery = new MemoryDiscovery(); discovery.readConnections(config); let connection = await discovery.resolve(\u0026#34;123\u0026#34;, \u0026#34;key1\u0026#34;); // Result: host=10.1.1.100;port=8080 See also   IDiscovery   ConnectionParams   ","description":"Discovery service that keeps connections in memory.\n","image":null,"permalink":"/node/components/connect/memory_discovery/","subtitle":null,"tags":null,"title":"MemoryDiscovery"},{"content":"Implements: IDiscovery, IReconfigurable\nDescription The MemoryDiscovery class allows you to create discovery services that keep connections in memory.\nConfiguration parameters  [connection key 1]: \u0026hellip; : connection parameters for key 1 [connection key 2]: \u0026hellip; : connection parameters for key N  Constructors Creates a new instance of discovery service.\n MemoryDiscovery(config: ConfigParams = None)\n  config: ConfigParams - (optional) configuration with connection parameters.  Instance methods configure Configures component by passing configuration parameters.\n configure(config: ConfigParams)\n  config: ConfigParams - configuration parameters to be set.  read_connections Reads connections from configuration parameters. Each section represents an individual Connection params\n read_connections(connections: ConfigParams)\n  connections: ConfigParams - configuration parameters to be read  register Registers connection parameters into the discovery service.\n register(correlation_id: Optional[str], key: str, connection: ConnectionParams): ConnectionParams\n  correlation_id: Optional[str] - (optional) transaction id to trace execution through call chain. key: str - a key to uniquely identify the connection parameters. connection: ConnectionParams - a connection to be registered. returns: ConnectionParams - the registered connection parameters.  resolve_all Resolves all connection parameters by their key.\n resolve_all(correlation_id: Optional[str], key: str): List[ConnectionParams]\n  correlation_id: Optional[str] - (optional) transaction id to trace execution through a call chain. key: str - a key to uniquely identify the connections. returns: List[ConnectionParams] - a list with resolved connections.  resolve_one Resolves a single connection parameters by its key.\n resolve_one(correlation_id: Optional[str], key: str): ConnectionParams\n  correlation_id: Optional[str] - (optional) transaction id to trace execution through a call chain. key: str - a key to uniquely identify the connection. returns: ConnectionParams - a resolved connection.  Examples config = ConfigParams.from_tuples( \u0026#34;key1.host\u0026#34;, \u0026#34;10.1.1.100\u0026#34;, \u0026#34;key1.port\u0026#34;, \u0026#34;8080\u0026#34;, \u0026#34;key2.host\u0026#34;, \u0026#34;10.1.1.100\u0026#34;, \u0026#34;key2.port\u0026#34;, \u0026#34;8082\u0026#34;) discovery = MemoryDiscovery() discovery.read_connections(config) discovery.resolve(\u0026#34;123\u0026#34;, \u0026#34;key1\u0026#34;) See also   IDiscovery   ConnectionParams   ","description":"Discovery service that keeps connections in memory.\n","image":null,"permalink":"/python/components/connect/memory_discovery/","subtitle":null,"tags":null,"title":"MemoryDiscovery"},{"content":"Implements: Lock\nDescription The MemoryLock class is used to synchronize the execution of a process using shared memory.\nImportant points\n This implementation is not suitable for synchronization of distributed processes.  Configuration parameters options:\n retry_timeout: timeout (in milliseconds) to retry lock acquisition. (Default: 100)  Constructors NewMemoryLock Creates new memory lock\n NewMemoryLock() *MemoryLock\n Methods ReleaseLock Releases a prevously acquired lock by its key.\n (c *MemoryLock) ReleaseLock(correlationId string, key string) error\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. key: string - unique lock key to release. returns: error - returns error if not released  TryAcquireLock Makes a single attempt to acquire a lock by its key. It returns immediately a positive or negative result.\n (c *MemoryLock) TryAcquireLock(correlationId string, key string, ttl int64) (bool, error)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. key: string - unique lock key to acquire. ttl: int64 - lock timeout (time to live) in milliseconds. returns: (bool, error) - lock result  Examples lock := NewMemoryLock() err = lock.Acquire(\u0026#34;123\u0026#34;, \u0026#34;key1\u0026#34;) if err == nil { defer _ = lock.ReleaseLock(\u0026#34;123\u0026#34;, \u0026#34;key1\u0026#34;) // Processing... } See also   ILock   Lock   ","description":"Lock used to synchronize the execution of a process using shared memory.\n","image":null,"permalink":"/golang/components/lock/memory_lock/","subtitle":null,"tags":null,"title":"MemoryLock"},{"content":"Inherits: Lock\nDescription The MemoryLock class is used to synchronize the execution of a process using shared memory.\nImportant points\n This implementation is not suitable for synchronization of distributed processes.  Configuration parameters options:\n retry_timeout: timeout in milliseconds to retry lock acquisition. (Default: 100)  Instance methods ReleaseLock Releases prevously acquired lock by its key.\n public override void ReleaseLock(string correlationId, string key)\n  correlationId: string - (optional) transaction id to trace execution through call chain. key: string - a unique lock key to release.  TryAcquireLock Makes a single attempt to acquire a lock by its key. It returns immediately a positive or negative result.\n public bool TryAcquireLock(string correlationId, string key, long ttl)\n  correlationId: string - (optional) transaction id to trace execution through call chain. key: string - a unique lock key to acquire. ttl: long - a lock timeout (time to live) in milliseconds. returns: bool - lock result  Examples var lock = new MemoryLock(); lock.TryAcquireLock(\u0026#34;123\u0026#34;, \u0026#34;key1\u0026#34;, 0); try { // Processing... } finally { lock.ReleaseLock(\u0026#34;123\u0026#34;, \u0026#34;key1\u0026#34;); // Continue... }); See also   ILock   Lock   ","description":"Lock used to synchronize the execution of a process using shared memory.\n","image":null,"permalink":"/net/components/lock/memory_lock/","subtitle":null,"tags":null,"title":"MemoryLock"},{"content":"Extends: Lock\nDescription The MemoryLock class is used to synchronize the execution of a process using shared memory.\nImportant points\n This implementation is not suitable for synchronization of distributed processes.  Configuration parameters options:\n retry_timeout: timeout in milliseconds to retry lock acquisition. (Default: 100)  Instance methods releaseLock Releases prevously acquired lock by its key.\n public releaseLock(correlationId: string, key: string)\n  correlationId: string - (optional) transaction id to trace execution through call chain. key: string - a unique lock key to release.  tryAcquireLock Makes a single attempt to acquire a lock by its key. It returns immediately a positive or negative result.\n public tryAcquireLock(correlationId: string, key: string, ttl: number): bool\n  correlationId: string - (optional) transaction id to trace execution through call chain. key: string - a unique lock key to acquire. ttl: number - a lock timeout (time to live) in milliseconds. returns: bool - lock result  Examples let lock = new MemoryLock(); await lock.acquire(\u0026#34;123\u0026#34;, \u0026#34;key1\u0026#34;); try { // Processing... } finally { await lock.releaseLock(\u0026#34;123\u0026#34;, \u0026#34;key1\u0026#34;); } // Continue...  See also   ILock   Lock   ","description":"Lock used to synchronize the execution of a process using shared memory.\n","image":null,"permalink":"/node/components/lock/memory_lock/","subtitle":null,"tags":null,"title":"MemoryLock"},{"content":"Implements: Lock\nDescription The MemoryLock class is used to synchronize the execution of a process using shared memory.\nImportant points\n This implementation is not suitable for synchronization of distributed processes.  Configuration parameters options:\n retry_timeout: timeout in milliseconds to retry lock acquisition. (Default: 100)  Instance methods release_lock Releases prevously acquired lock by its key.\n release_lock(correlation_id: Optional[str], key: str)\n  correlation_id: Optional[str] - (optional) transaction id to trace execution through call chain. key: str - a unique lock key to release.  try_acquire_lock Makes a single attempt to acquire a lock by its key. It returns immediately a positive or negative result.\n try_acquire_lock(correlation_id: Optional[str], key: str, ttl: float): bool\n  correlation_id: Optional[str] - (optional) transaction id to trace execution through call chain. key: str - a unique lock key to acquire. ttl: float - a lock timeout (time to live) in milliseconds. returns: bool - lock result  Examples lock = MemoryLock() lock.acquire_lock(\u0026#34;123\u0026#34;, \u0026#34;key1\u0026#34;, None, None) # processing lock.release_lock(\u0026#34;123\u0026#34;, \u0026#34;key1\u0026#34;) See also   ILock   Lock   ","description":"Lock used to synchronize the execution of a process using shared memory.\n","image":null,"permalink":"/python/components/lock/memory_lock/","subtitle":null,"tags":null,"title":"MemoryLock"},{"content":"Implements: MessageQueue\nDescription The MemoryMessageQueue class is used to create message queues that send and receive messages within the same process by using shared memory.\nImportant points\n This queue is typically used for testing to mock real queues.  Configuration parameters  name: name of the message queue  References  *:logger:*:*:1.0 - (optional) ILogger components to pass log messages *:counters:*:*:1.0 - (optional) ICounters components to pass collected measurements  Constructors NewMemoryMessageQueue Creates a new instance of the message queue.\nSee also MessagingCapabilities\n NewMemoryMessageQueue(name string) *MemoryMessageQueue\n  name: string - (optional) a queue name.  Methods Abandon Returns a message into the queue and makes it available for all subscribers to receive it again. This method is usually used to return a message that could not be processed at the moment to repeat the attempt. Messages that cause unrecoverable errors shall be removed permanently or/and sent to dead letter queue.\n (c *MemoryMessageQueue) Abandon(message *MessageEnvelope) (err error)\n  message: *MessageEnvelope - message to return. returns: (err error) - error or nil no errors occured.  Clear Clears the component\u0026rsquo;s state.\n (c *MemoryMessageQueue) Clear(correlationId string) (err error)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. returns: (err error) - error or nil no errors occured.  Close Closes the component and frees used resources.\n (c *MemoryMessageQueue) Close(correlationId string) (err error)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. returns: (err error) - error or nil no errors occured.  Complete Permanently removes a message from the queue. This method is usually used to remove the message after successful processing.\n (c *MemoryMessageQueue) Complete(message *MessageEnvelope) (err error)\n  message: *MessageEnvelope - message to remove. returns: (err error) - error or nil no errors occured.  EndListen Ends listening for incoming messages. When this method is called, listen unblocks the thread and execution continues.\n (c *MemoryMessageQueue) EndListen(correlationId string)\n  correlationId: string - (optional) transaction id to trace execution through a call chain.  IsOpen Checks if the component is opened.\n (c *MemoryMessageQueue) IsOpen() bool\n  returns: bool - True if the component is open and False otherwise.  Listen Listens for incoming messages and blocks the current thread until the queue is closed.\nSee also IMessageReceiver, receive\n (c *MemoryMessageQueue) Listen(correlationId string, receiver IMessageReceiver) error\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. receiver: IMessageReceiver - receiver used to receive incoming messages. returns: error - error or nil no errors occured.  Open Opens the component with given connection and credential parameters.\n (c *MemoryMessageQueue) Open(correlationId string) (err error)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. returns: (err error) - error or nil no errors occured.  Peek Peeks a single incoming message from the queue without removing it. If there are no messages available in the queue, it returns nil.\n (c *MemoryMessageQueue) Peek(correlationId string) (result *MessageEnvelope, err error)\n  correlationId: string - transaction id used to trace execution through the call chain. returns: (result *MessageEnvelope, err error) - peeked message or nil.  PeekBatch Peeks multiple incoming messages from the queue without removing them. If there are no messages available in the queue, it returns an empty list.\n (c *MemoryMessageQueue) PeekBatch(correlationId string, messageCount int64) (result []*MessageEnvelope, err error)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. messageCount: int64 - maximum number of messages to peek. returns: (result []*MessageEnvelope, err error) - list with peeked messages.  ReadMessageCount Reads the current number of messages in the queue to be delivered.\n (c *MemoryMessageQueue) ReadMessageCount() (count int64, err error)\n  returns: (count int64, err error) - number of messages in the queue.  Receive Receives an incoming message and removes it from the queue.\n (c *MemoryMessageQueue) Receive(correlationId string, waitTimeout time.Duration) (*MessageEnvelope, error)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. waitTimeout: time.Duration - timeout in milliseconds to wait for a message to come. returns: (*MessageEnvelope, error) - received message or nil.  RenewLock Renews a lock on a message that makes it invisible from other receivers in the queue. This method is usually used to extend the message processing time.\n (c *MemoryMessageQueue) RenewLock(message *MessageEnvelope, lockTimeout time.Duration) (err error)\n  message: *MessageEnvelope - message to extend its lock. lockTimeout: time.Duration - locking timeout in milliseconds. returns: error - error or nil no errors occured.  Send Sends a message into the queue.\n (c *MemoryMessageQueue) Send(correlationId string, envelope *MessageEnvelope) (err error)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. envelope: *MessageEnvelope - message envelop to be sent. returns: (err error) - error or nil no errors occured.  Examples queue := NewMessageQueue(\u0026#34;myqueue\u0026#34;); queue.Send(\u0026#34;123\u0026#34;, NewMessageEnvelop(\u0026#34;\u0026#34;, \u0026#34;mymessage\u0026#34;, \u0026#34;ABC\u0026#34;)); message, err := queue.Receive(\u0026#34;123\u0026#34;) if (message != nil) { ... queue.Complete(\u0026#34;123\u0026#34;, message); } See also   MessagingCapabilities   MessageQueue   ","description":"Message queue that sends and receives messages within the same process by using shared memory.  \n","image":null,"permalink":"/golang/messaging/queues/memory_message_queue/","subtitle":null,"tags":null,"title":"MemoryMessageQueue"},{"content":"Inherits: MessageQueue\nDescription The MemoryMessageQueue class is used to create message queues that send and receive messages within the same process by using shared memory.\nImportant points\n This queue is typically used for testing to mock real queues.  Configuration parameters  name: name of the message queue  References  *:logger:*:*:1.0 - (optional) ILogger components to pass log messages *:counters:*:*:1.0 - (optional) ICounters components to pass collected measurements  Constructors Creates a new instance of the message queue.\nSee also MessagingCapabilities\n public MemoryMessageQueue(string name = null)\n  name: string - (optional) a queue name.  Instance methods Abandon Returns a message into the queue and makes it available for all subscribers to receive it again. This method is usually used to return a message that could not be processed at the moment to repeat the attempt. Messages that cause unrecoverable errors shall be removed permanently or/and sent to dead letter queue.\n public override Task AbandonAsync(MessageEnvelope message)\n  message: MessageEnvelope - message to return.  ClearAsync Clears the component\u0026rsquo;s state.\n public override Task ClearAsync(string correlationId)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain.  CloseAsync Closes the component and frees used resources.\n public override Task CloseAsync(string correlationId)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain.  CompleteAsync Permanently removes a message from the queue. This method is usually used to remove the message after successful processing.\n public override Task CompleteAsync(MessageEnvelope message)\n  message: MessageEnvelope - message to remove.  EndListen Ends listening for incoming messages. When this method is called, ListenAsync unblocks the thread and execution continues.\n public override void EndListen(string correlationId)\n  correlationId: string - (optional) transaction id to trace execution through a call chain.  IsOpen Checks if the component is opened.\n public override bool IsOpen()\n  returns: bool - True if the component is open and False otherwise.  ListenAsync Listens for incoming messages and blocks the current thread until the queue is closed.\nSee also IMessageReceiver, ReceiveAsync\n public override Task ListenAsync(string correlationId, IMessageReceiver receiver)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. receiver: IMessageReceiver - receiver used to receive incoming messages.  Peek Peeks a single incoming message from the queue without removing it. If there are no messages available in the queue, it returns null.\n public override Task\u0026lt;MessageEnvelope\u0026gt; PeekAsync(string correlationId)\n  correlationId: string - transaction id used to trace execution through the call chain. returns: Task\u0026lt;MessageEnvelope\u0026gt; - peeked message or null.  PeekBatch Peeks multiple incoming messages from the queue without removing them. If there are no messages available in the queue, it returns an empty list.\n public override Task\u0026lt;List\u0026lt;MessageEnvelope\u0026gt;\u0026gt; PeekBatchAsync(string correlationId, int messageCount)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. messageCount: int - maximum number of messages to peek. returns: Task\u0026lt;List\u0026lt;MessageEnvelope\u0026gt;\u0026gt; - list with peeked messages.  ReadMessageCount Reads the current number of messages in the queue to be delivered.\n public override Task\u0026lt;long\u0026gt; ReadMessageCountAsync()\n  returns: Task\u0026lt;long\u0026gt; - number of messages in the queue.  ReceiveAsync Receives an incoming message and removes it from the queue.\n public override Task\u0026lt;MessageEnvelope\u0026gt; ReceiveAsync(string correlationId, long waitTimeout)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. waitTimeout: long - timeout in milliseconds to wait for a message to come. returns: Task\u0026lt;MessageEnvelope\u0026gt; - received message or null.  RenewLock Renews a lock on a message that makes it invisible from other receivers in the queue. This method is usually used to extend the message processing time.\n public override Task RenewLockAsync(MessageEnvelope message, long lockTimeout)\n  message: MessageEnvelope - message to extend its lock. lockTimeout: long - locking timeout in milliseconds.  SendAsync Sends a message into the queue.\n public override Task SendAsync(string correlationId, MessageEnvelope message)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. envelope: MessageEnvelope - message envelop to be sent.  Examples var queue = new MessageQueue(\u0026#34;myqueue\u0026#34;); queue.SendAsync(\u0026#34;123\u0026#34;, new MessageEnvelop(null, \u0026#34;mymessage\u0026#34;, \u0026#34;ABC\u0026#34;)); queue.ReceiveAsync(\u0026#34;123\u0026#34;, 0); See also   MessagingCapabilities   MessageQueue   ","description":"Message queue that sends and receives messages within the same process by using shared memory.  \n","image":null,"permalink":"/net/messaging/queues/memory_message_queue/","subtitle":null,"tags":null,"title":"MemoryMessageQueue"},{"content":"Extends: MessageQueue\nDescription The MemoryMessageQueue class is used to create message queues that send and receive messages within the same process by using shared memory.\nImportant points\n This queue is typically used for testing to mock real queues.  Configuration parameters  name: name of the message queue  References  *:logger:*:*:1.0 - (optional) ILogger components to pass log messages *:counters:*:*:1.0 - (optional) ICounters components to pass collected measurements  Constructors Creates a new instance of the message queue.\nSee also MessagingCapabilities\n public constructor(name?: string)\n  name: string - (optional) a queue name.  Instance methods abandon Returns a message into the queue and makes it available for all subscribers to receive it again. This method is usually used to return a message that could not be processed at the moment to repeat the attempt. Messages that cause unrecoverable errors shall be removed permanently or/and sent to dead letter queue.\n public abandon(message: MessageEnvelope): Promise\u0026lt;void\u0026gt;\n  message: MessageEnvelope - message to return.  clear Clears the component\u0026rsquo;s state.\n public clear(correlationId: string): Promise\u0026lt;void\u0026gt;\n  correlationId: string - (optional) transaction id used to trace execution through the call chain.  close Closes the component and frees used resources.\n public close(correlationId: string): Promise\u0026lt;void\u0026gt;\n  correlationId: string - (optional) transaction id used to trace execution through the call chain.  complete Permanently removes a message from the queue. This method is usually used to remove the message after successful processing.\n public complete(message: MessageEnvelope): Promise\u0026lt;void\u0026gt;\n  message: MessageEnvelope - message to remove.  configure Configures the component by passing its configuration parameters.\n public configure(config: ConfigParams): void\n  config: ConfigParams - configuration parameters to be set.  endListen Ends listening for incoming messages. When this method is called, listen unblocks the thread and execution continues.\n endListen(correlationId: string): void\n  correlationId: string - (optional) transaction id to trace execution through a call chain.  isOpen Checks if the component is opened.\n public isOpen(): boolean\n  returns: boolean - True if the component is open and False otherwise.  listen Listens for incoming messages and blocks the current thread until the queue is closed.\nSee also IMessageReceiver, receive\n public listen(correlationId: string, receiver: IMessageReceiver): void\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. receiver: IMessageReceiver - receiver used to receive incoming messages.  peek Peeks a single incoming message from the queue without removing it. If there are no messages available in the queue, it returns null.\n public peek(correlationId: string): Promise\u0026lt;MessageEnvelope\u0026gt;\n  correlationId: string - transaction id used to trace execution through the call chain. returns: Promise\u0026lt;MessageEnvelope\u0026gt; - peeked message or null.  peekBatch Peeks multiple incoming messages from the queue without removing them. If there are no messages available in the queue, it returns an empty list.\n public peekBatch(correlationId: string, messageCount: number): Promise\u0026lt;MessageEnvelope[]\u0026gt;\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. messageCount: number - maximum number of messages to peek. returns: Promise\u0026lt;MessageEnvelope[]\u0026gt; - list with peeked messages.  readMessageCount Reads the current number of messages in the queue to be delivered.\n public readMessageCount(): Promise\u0026lt;number\u0026gt;\n  returns: number - number of messages in the queue.  receive Receives an incoming message and removes it from the queue.\n public receive(correlationId: string, waitTimeout: number): Promise\u0026lt;MessageEnvelope\u0026gt;\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. waitTimeout: number - timeout in milliseconds to wait for a message to come. returns: Promise\u0026lt;MessageEnvelope\u0026gt; - received message or null.  renewLock Renews a lock on a message that makes it invisible from other receivers in the queue. This method is usually used to extend the message processing time.\n public renewLock(message: MessageEnvelope, lockTimeout: number): Promise\u0026lt;void\u0026gt;\n  message: MessageEnvelope - message to extend its lock. lockTimeout: number - locking timeout in milliseconds.  send Sends a message into the queue.\n public send(correlationId: string, envelope: MessageEnvelope): Promise\u0026lt;void\u0026gt;\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. envelope: MessageEnvelope - message envelop to be sent.  openWithParams Opens the component with given connection and credential parameters.\n protected openWithParams(correlationId: string, connections: ConnectionParams[], credentials: CredentialParams): Promise\u0026lt;void\u0026gt;\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. connections: ConnectionParams[] - connection parameters credential: CredentialParams - credential parameters  Examples let queue = new MessageQueue(\u0026#34;myqueue\u0026#34;); await queue.send(\u0026#34;123\u0026#34;, new MessageEnvelop(null, \u0026#34;mymessage\u0026#34;, \u0026#34;ABC\u0026#34;)); let message = await queue.receive(\u0026#34;123\u0026#34;); if (message != null) { ... await queue.complete(\u0026#34;123\u0026#34;, message); } See also   MessagingCapabilities   MessageQueue   ","description":"Message queue that sends and receives messages within the same process by using shared memory.  \n","image":null,"permalink":"/node/messaging/queues/memory_message_queue/","subtitle":null,"tags":null,"title":"MemoryMessageQueue"},{"content":"Implements: MessageQueue\nDescription The MemoryMessageQueue class is used to create message queues that send and receive messages within the same process by using shared memory.\nImportant points\n This queue is typically used for testing to mock real queues.  Configuration parameters  name: name of the message queue  References  *:logger:*:*:1.0 - (optional) ILogger components to pass log messages *:counters:*:*:1.0 - (optional) ICounters components to pass collected measurements  Constructors Creates a new instance of the message queue.\nSee also MessagingCapabilities\n MemoryMessageQueue(name: str = None)\n  name: str - (optional) a queue name.  Fields _lock Threading lock.\n _lock: threading.Lock\n _event Threading event.\n _event: threading.Event\n  Instance methods abandon Returns a message into the queue and makes it available for all subscribers to receive it again. This method is usually used to return a message that could not be processed at the moment to repeat the attempt. Messages that cause unrecoverable errors shall be removed permanently or/and sent to dead letter queue.\n abandon(message: MessageEnvelope)\n  message: MessageEnvelope - message to return.  clear Clears the component\u0026rsquo;s state.\n clear(correlation_id: Optional[str])\n  correlation_id: Optional[str] - (optional) transaction id used to trace execution through the call chain.  close Closes the component and frees used resources.\n close(correlation_id: Optional[str])\n  correlation_id: Optional[str] - (optional) transaction id used to trace execution through the call chain.  complete Permanently removes a message from the queue. This method is usually used to remove the message after successful processing.\n complete(message: MessageEnvelope)\n  message: MessageEnvelope - message to remove.  configure Configures the component by passing its configuration parameters.\n configure(config: ConfigParams)\n  config: ConfigParams - configuration parameters to be set.  end_listen Ends listening for incoming messages. When this method is called, listen unblocks the thread and execution continues.\n end_listen(correlation_id: Optional[str])\n  correlation_id: Optional[str] - (optional) transaction id to trace execution through a call chain.  is_open Checks if the component is opened.\n is_open(): bool\n  returns: bool - True if the component is open and False otherwise.  listen Listens for incoming messages and blocks the current thread until the queue is closed.\nSee also IMessageReceiver, receive\n listen(correlation_id: Optional[str], receiver: IMessageReceiver)\n  correlation_id: Optional[str] - (optional) transaction id used to trace execution through the call chain. receiver: IMessageReceiver - receiver used to receive incoming messages.  peek Peeks a single incoming message from the queue without removing it. If there are no messages available in the queue, it returns None.\n peek(correlation_id: Optional[str]): MessageEnvelope\n  correlation_id: Optional[str] - transaction id used to trace execution through the call chain. returns: MessageEnvelope - peeked message or None.  peek_batch Peeks multiple incoming messages from the queue without removing them. If there are no messages available in the queue, it returns an empty list.\n peek_batch(correlation_id: Optional[str], message_count: int): List[MessageEnvelope]\n  correlation_id: Optional[str] - (optional) transaction id used to trace execution through the call chain. message_count: int - maximum number of messages to peek. returns: List[MessageEnvelope] - list with peeked messages.  read_message_count Reads the current number of messages in the queue to be delivered.\n read_message_count(): int\n  returns: int - number of messages in the queue.  receive Receives an incoming message and removes it from the queue.\n receive(correlation_id: Optional[str], wait_timeout: int): MessageEnvelope\n  correlation_id: Optional[str] - (optional) transaction id used to trace execution through the call chain. wait_timeout: int - timeout in milliseconds to wait for a message to come. returns: MessageEnvelope - received message or None.  renew_lock Renews a lock on a message that makes it invisible from other receivers in the queue. This method is usually used to extend the message processing time.\n renew_lock(message: MessageEnvelope, lock_timeout: int)\n  message: MessageEnvelope - message to extend its lock. lock_timeout: int - locking timeout in milliseconds.  send Sends a message into the queue.\n send(correlation_id: Optional[str], envelope: MessageEnvelope)\n  correlation_id: Optional[str] - (optional) transaction id used to trace execution through the call chain. envelope: MessageEnvelope - message envelop to be sent.  _open_with_params Opens the component with given connection and credential parameters.\n _open_with_params(correlation_id: Optional[str], connections: List[ConnectionParams], credentials: CredentialParams)\n  correlation_id: Optional[str] - (optional) transaction id used to trace execution through the call chain. connections: List[ConnectionParams] - connection parameters credential: CredentialParams - credential parameters  Examples queue = MessageQueue(\u0026#34;myqueue\u0026#34;) queue.send(\u0026#34;123\u0026#34;, MessageEnvelope(None, \u0026#34;mymessage\u0026#34;, \u0026#34;ABC\u0026#34;)) message = queue.receive(\u0026#34;123\u0026#34;, 0) if message != None: # ... queue.complete(\u0026#34;123\u0026#34;, message) See also   MessagingCapabilities   MessageQueue   ","description":"Message queue that sends and receives messages within the same process by using shared memory.  \n","image":null,"permalink":"/python/messaging/queues/memory_message_queue/","subtitle":null,"tags":null,"title":"MemoryMessageQueue"},{"content":"Implements: MessageQueueFactory\nDescription The MemoryMessageQueueFactory class allows you to create MemoryMessageQueue components based on their descriptors.\nImportant points\n The name of the created message queue is taken from its descriptor.  Constructors NewMemoryMessageQueueFactory Creates a new instance of the factory.\n NewMemoryMessageQueueFactory() *MemoryMessageQueueFactory\n Methods CreateQueue Creates a message queue component and assigns its name.\n (c *MemoryMessageQueueFactory) CreateQueue(name string) queues.IMessageQueue\n  name: string - name of the created message queue. returns: queues.IMessageQueue - message queue.  See also   Factory   MemoryMessageQueue   ","description":"Creates [MemoryMessageQueue](../../queues/memory_message_queue) components based on their descriptors.\n","image":null,"permalink":"/golang/messaging/build/memory_message_queue_factory/","subtitle":null,"tags":null,"title":"MemoryMessageQueueFactory"},{"content":"Inherits: MessageQueueFactory\nDescription The MemoryMessageQueueFactory class allows you to create MemoryMessageQueue components based on their descriptors.\nImportant points\n The name of the created message queue is taken from its descriptor.  Constructors Creates a new instance of the factory.\n public MemoryMessageQueueFactory()\n Instance methods CreateQueue Creates a message queue component and assigns its name.\n public override IMessageQueue CreateQueue(string name)\n  name: string - name of the created message queue. returns: IMessageQueue - message queue.  See also   Factory   MemoryMessageQueue   ","description":"Creates [MemoryMessageQueue](../../queues/memory_message_queue) components based on their descriptors.\n","image":null,"permalink":"/net/messaging/build/memory_message_queue_factory/","subtitle":null,"tags":null,"title":"MemoryMessageQueueFactory"},{"content":"Extends: MessageQueueFactory\nDescription The MemoryMessageQueueFactory class allows you to create MemoryMessageQueue components based on their descriptors.\nImportant points\n The name of the created message queue is taken from its descriptor.  Constructors Creates a new instance of the factory.\n public constructor()\n Instance methods createQueue Creates a message queue component and assigns its name.\n public createQueue(name: string): IMessageQueue\n  name: string - name of the created message queue. returns: IMessageQueue - message queue.  See also   Factory   MemoryMessageQueue   ","description":"Creates [MemoryMessageQueue](../../queues/memory_message_queue) components based on their descriptors.\n","image":null,"permalink":"/node/messaging/build/memory_message_queue_factory/","subtitle":null,"tags":null,"title":"MemoryMessageQueueFactory"},{"content":"Implements: MessageQueueFactory\nDescription The MemoryMessageQueueFactory class allows you to create MemoryMessageQueue components based on their descriptors.\nImportant points\n The name of the created message queue is taken from its descriptor.  Constructors Creates a new instance of the factory.\n MemoryMessageQueueFactory()\n Instance methods create_queue Creates a message queue component and assigns its name.\n create_queue(name: str): IMessageQueue\n  name: str - name of the created message queue. returns: IMessageQueue - message queue.  See also   Factory   MemoryMessageQueue   ","description":"Creates [MemoryMessageQueue](../../queues/memory_message_queue) components based on their descriptors.\n","image":null,"permalink":"/python/messaging/build/memory_message_queue_factory/","subtitle":null,"tags":null,"title":"MemoryMessageQueueFactory"},{"content":"Description The MemoryPersistence class allows you to create persistence components that store data in memory.\nImportant points\n This is the most basic persistence component that is only able to store data items of any type. Specific CRUD operations over the data items must be implemented in child classes by accessing the Items property and calling the Save method. The component supports loading and saving items from another data source. This allows to use it as a base class for file and other types of persistence components that cache all data in memory.  Configuration parameters options:\n max_page_size: maximum number of items returned in a single page (default: 100)  References  *:logger:*:*:1.0 - (optional) (../../../components/log/ilogger) components to pass log messages  Constructors NewMemoryPersistence Creates a new instance of the memory persistence component.\n NewMemoryPersistence(prototype reflect.Type) *MemoryPersistence\n  prototype: reflect.Type - type of contained data  Fields Logger Logger.\n Logger: CompositeLogger\n Items Items to load/save.\n Items: []interface{}\n Loader Loader.\n Loader: ILoader\n Saver Saver.\n Saver: ISaver\n opened Boolean that indicates whether the compent is open or not.\n opened: bool = false\n MaxPageSize Maximum amount of items per page.\n MaxPageSize: int\n  Methods Clear Clears the component\u0026rsquo;s state.\n (c *MemoryPersistence) Clear(correlationId string) error\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. returns: error - returns error if not cleaned  Create Creates a data item.\n (c *MemoryPersistence) Create(correlationId string, item interface{}) (result interface{}, err error)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. item: interface{} - item to be created. returns: (result interface{}, err error) - created item  DeleteByFilter Deletes data items that match to a given filter. This method shall be called by a public DeleteByFilter method from a child class that receives FilterParams and converts them into a filter function.\n (c *MemoryPersistence) DeleteByFilter(correlationId string, filterFunc func(interface{}) bool) (err error)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. filterFunc: func(interface{}) bool - (optional) filter function used to filter items. returns: error - returns error if not deleted  GetCountByFilter Gets the number of items retrieved by a given filter.\nThis method shall be called by a public GetCountByFilter method from a child class that receives FilterParams and converts them into a filter function.\n (c *MemoryPersistence) GetCountByFilter(correlationId string, filterFunc func(interface{}) bool) (count int64, err error)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. filterFunc: func(interface{}) bool - id of the item to be deleted returns: (count int64, err error) - number of data items that satisfy the filter.  GetListByFilter Gets a list of data items retrieved by a given filter and sorted according to sorting parameters.\nThis method shall be called by a public GetListByFilter method from a child class that receives FilterParams and converts them into a filter function.\n (c *MemoryPersistence) GetListByFilter(correlationId string, filterFunc func(interface{}) bool, sortFunc func(a, b interface{}) bool, selectFunc func(in interface{}) (out interface{})) (results []interface{}, err error)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. filterFunc: func(interface{}) bool - (optional) filter function used to filter items sortFunc: func(a, b interface{}) bool - (optional) sorting parameters selectFunc: func(in interface{}) (out interface{}) - (optional) projection parameters (not used yet) returns: (results []interface{}, err error) - data list of filtered results.  GetOneRandom Gets a random item from items that match to a given filter.\nThis method shall be called by a public GetOneRandom method from a child class that receives FilterParams and converts them into a filter function.\n (c *MemoryPersistence) GetOneRandom(correlationId string, filterFunc func(interface{}) bool) (result interface{}, err error)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. filterFunc: func(interface{}) bool - (optional) a filter function to filter items. returns: (result interface{}, err error) - random item.  GetPageByFilter Gets a page of data items retrieved by a given filter and sorted according to sorting parameters.\nThis method shall be called by a public GetPageByFilter method from a child class that receives FilterParams and converts them into a filter function.\n (c *MemoryPersistence) GetPageByFilter(correlationId string, filterFunc func(interface{}) bool, paging *cdata.PagingParams, sortFunc func(a, b interface{}) bool, selectFunc func(in interface{}) (out interface{})) (page *cdata.DataPage, err error)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. filterFunc: func(interface{}) bool - filter function used to filter items paging: *cdata.PagingParams - (optional) paging parameters sortFunc: func(a, b interface{}) bool - (optional) sorting parameters selectFunc: func(in interface{}) (out interface{}) - (optional) projection parameters (not used yet) returns: (page *cdata.DataPage, err error) - data page with filterd results.  IsOpen Checks if the component is open.\n (c *MemoryPersistence) IsOpen() bool\n  returns: bool - True if the component is open and False otherwise.  Load Loads items.\n (c *MemoryPersistence) load(correlationId string) error\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. returns: error - returns error if not loaded  Open Opens the component.\n (c *MemoryPersistence) Open(correlationId string) error\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. returns: error - returns error if not opened  Save Saves items to an external data source using a configured saver component.\n (c *MemoryPersistence) Save(correlationId string) error\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. returns: error - returns error if not saved  SetReferences Sets the component\u0026rsquo;s references. References must match configured dependencies.\n (c *MemoryPersistence) SetReferences(references refer.IReferences)\n  references: refer.IReferences - references to set.  Examples type MyMemoryPersistence struct { MemoryPersistence } func (c * MyMemoryPersistence) GetByName(correlationId string, name string)(item interface{}, err error) { for _, v := range c.Items { if v.name == name { item = v break } } return item, nil }); func (c * MyMemoryPersistence) Set(correlatonId: string, item: MyData, callback: (err) =\u0026gt; void): void { c.Items = append(c.Items, item); c.Save(correlationId); } persistence := NewMyMemoryPersistence(); err := persistence.Set(\u0026#34;123\u0026#34;, MyData{ name: \u0026#34;ABC\u0026#34; }) item, err := persistence.GetByName(\u0026#34;123\u0026#34;, \u0026#34;ABC\u0026#34;) fmt.Println(item) // Result: { name: \u0026#34;ABC\u0026#34; }  See also   MemoryPersistence   ","description":"Persistence component that stores data in memory.\n","image":null,"permalink":"/golang/data/persistence/memory_persistence/","subtitle":null,"tags":null,"title":"MemoryPersistence"},{"content":"Inherits: IConfigurable, IReferenceable, IOpenable, ICleanable\nDescription The MemoryPersistence class allows you to create persistence components that store data in memory.\nImportant points\n This is the most basic persistence component that is only able to store data items of any type. Specific CRUD operations over the data items must be implemented in child classes by accessing the this._items property and calling the Save method. The component supports loading and saving items from another data source. This allows to use it as a base class for file and other types of persistence components that cache all data in memory.  Configuration parameters options:\n max_page_size: maximum number of items returned in a single page (default: 100)  References  *:logger:*:*:1.0 - (optional) (../../../components/log/ilogger) components to pass log messages  Constructors Creates a new instance of the memory persistence component.\n protected MemoryPersistence(ILoader loader, ISaver saver)\n  loader: ILoader - (optional) loader used to load items from an external datasource. saver: ISaver - (optional) saver used to save items to an external datasource.  Creates a new instance of the persistence.\n public MemoryPersistence()\n Fields _logger Logger.\n protected _logger: CompositeLogger\n _items Items to load/save.\n protected _items: List\u0026lt;T\u0026gt;\n _loader Loader.\n protected _loader: ILoader\n _saver Saver.\n protected _saver: ISaver\n _opened Boolean that indicates whether the compent is open or not.\n protected _opened: bool = false\n _maxPageSize Maximum amount of items per page.\n protected _maxPageSize: int = 100\n  Instance methods Clear Clears the component\u0026rsquo;s state.\n public Task ClearAsync(string correlationId)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain.  Configure Configures the component by passing its configuration parameters.\n public virtual void Configure(ConfigParams config)\n  config: ConfigParams - configuration parameters to be set.  Create Creates a data item.\n public virtual Task\u0026lt;T\u0026gt; CreateAsync(string correlationId, T item)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. item: T - item to be created. returns: Task\u0026lt;T\u0026gt; - created item  DeleteByFilter Deletes data items that match to a given filter. This method shall be called by a public DeleteByFilter method from a child class that receives FilterParams and converts them into a filter function.\n public Task DeleteByFilterAsync(string correlationId, IList\u0026lt;Func\u0026lt;T, bool\u0026gt;\u0026gt; matchFunctions)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. matchFunctions: IList\u0026lt;Func\u0026lt;T, bool\u0026gt;\u0026gt; - (optional) filter function used to filter items.  GetCountByFilter TODO: this method is not implemented yet\nGets the number of items retrieved by a given filter.\nThis method shall be called by a public GetCountByFilter method from a child class that receives FilterParams and converts them into a filter function.\n protected GetCountByFilter(correlationId: string, filter: object): Task\u0026lt;int\u0026gt;\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. filter: object - id of the item to be deleted returns: Task\u0026lt;int\u0026gt; - number of data items that satisfy the filter.  GetListByFilterAsync Gets a list of data items retrieved by a given filter and sorted according to sorting parameters.\nThis method shall be called by a public GetListByFilterAsync method from a child class that receives FilterParams and converts them into a filter function.\n public Task\u0026lt;List\u0026lt;T\u0026gt;\u0026gt; GetListByFilterAsync(string correlationId, IList\u0026lt;Func\u0026lt;T, bool\u0026gt;\u0026gt; matchFunctions)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. matchFunctions: IList\u0026lt;Func\u0026lt;T, bool\u0026gt;\u0026gt; - (optional) filter function used to filter items returns: Task\u0026lt;List\u0026lt;T\u0026gt;\u0026gt; - data list of filtered results.  GetOneRandomAsync Gets a random item from items that match to a given filter.\nThis method shall be called by a public GetOneRandomAsync method from a child class that receives FilterParams and converts them into a filter function.\n public Task\u0026lt;T\u0026gt; GetOneRandomAsync(string correlationId, IList\u0026lt;Func\u0026lt;T, bool\u0026gt;\u0026gt; matchFunctions)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. matchFunctions: IList\u0026lt;Func\u0026lt;T, bool\u0026gt;\u0026gt; - (optional) a filter function to filter items. returns: Task\u0026lt;T\u0026gt; - a random item.  GetPageByFilter Gets a page of data items retrieved by a given filter and sorted according to sorting parameters.\nThis method shall be called by a public getPageByFilter method from a child class that receives FilterParams and converts them into a filter function.\n public async Task\u0026lt;DataPage\u0026gt; GetPageByFilterAsync(string correlationId, IList\u0026lt;Func\u0026lt;T, bool\u0026gt;\u0026gt; matchFunctions, PagingParams paging)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. matchFunctions: IList\u0026lt;Func\u0026lt;T, bool\u0026gt;\u0026gt; - filter function used to filter items paging: PagingParams - (optional) paging parameters returns: Task\u0026lt;DataPage\u0026gt; - data page with filterd results.  IsOpen Checks if the component is open.\n public bool IsOpen()\n  returns: bool - True if the component is open and False otherwise.  LoadAsync Loads items.\n private Task LoadAsync(string correlationId)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain.  OpenAsync Opens the component.\n public Task OpenAsync(string correlationId)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain.  SaveAsync Saves items to an external data source using a configured saver component.\n public Task SaveAsync(string correlationId)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain.  SetReferences Sets the component\u0026rsquo;s references. References must match configured dependencies.\n public void SetReferences(IReferences references)\n  references: IReferences - references to set.  Examples class MyMemoryPersistence extends MemoryPersistence\u0026lt;MyData\u0026gt; { public MyData GetByName(String correlationId, String name) { MyData item = _items.Find((mydata) =\u0026gt; { return mydata.Name == name; }); ... return item; } public MyData Set(String correlatonId, MyData item) { this._items = _items.Filter((mydata) =\u0026gt; { return mydata.Name != name; }); ... this._items.add(item); this.save(correlationId); } var persistence = new MyMemoryPersistence(); persistence.Set(\u0026#34;123\u0026#34;, new MyData(\u0026#34;ABC\u0026#34;)); Console.Out.WriteLine(persistence.getByName(\u0026#34;123\u0026#34;, \u0026#34;ABC\u0026#34;)).toString(); // Result: { name: \u0026#34;ABC\u0026#34; }  See also   MemoryPersistence   ","description":"Persistence component that stores data in memory.\n","image":null,"permalink":"/net/data/persistence/memory_persistence/","subtitle":null,"tags":null,"title":"MemoryPersistence\u003cT\u003e"},{"content":"Implements: IConfigurable, IReferenceable, IOpenable, ICleanable\nDescription The MemoryPersistence class allows you to create persistence components that store data in memory.\nImportant points\n This is the most basic persistence component that is only able to store data items of any type. Specific CRUD operations over the data items must be implemented in child classes by accessing the this._items property and calling the save method. The component supports loading and saving items from another data source. This allows to use it as a base class for file and other types of persistence components that cache all data in memory.  Configuration parameters options:\n max_page_size: maximum number of items returned in a single page (default: 100)  References  *:logger:*:*:1.0 - (optional) (../../../components/log/ilogger) components to pass log messages  Constructors Creates a new instance of the memory persistence component.\n public constructor(loader: ILoader, saver: ISaver)\n  loader: ILoader - (optional) loader used to load items from an external datasource. saver: ISaver - (optional) saver used to save items to an external datasource.  Fields _logger Logger.\n protected _logger: CompositeLogger\n _items Items to load/save.\n protected _items: T[]\n _loader Loader.\n protected _loader: ILoader\n _saver Saver.\n protected _saver: ISaver\n _opened Boolean that indicates whether the compent is open or not.\n protected _opened: boolean = false\n _maxPageSize Maximum amount of items per page.\n protected _maxPageSize: number = 100\n  Instance methods clear Clears the component\u0026rsquo;s state.\n public clear(correlationId: string): Promise\u0026lt;void\u0026gt;\n  correlationId: string - (optional) transaction id used to trace execution through the call chain.  configure Configures the component by passing its configuration parameters.\n public configure(config: ConfigParams): void\n  config: ConfigParams - configuration parameters to be set.  create Creates a data item.\n public create(correlationId: string, item: T): Promise\u0026lt;T\u0026gt;\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. item: T - item to be created. returns: Promise\u0026lt;T\u0026gt; - created item  deleteByFilter Deletes data items that match to a given filter. This method shall be called by a public deleteByFilter method from a child class that receives FilterParams and converts them into a filter function.\n protected deleteByFilter(correlationId: string, filter: any): Promise\u0026lt;void\u0026gt;\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. filter: any - (optional) filter function used to filter items.  getCountByFilter Gets the number of items retrieved by a given filter.\nThis method shall be called by a public getCountByFilter method from a child class that receives FilterParams and converts them into a filter function.\n protected getCountByFilter(correlationId: string, filter: any): Promise\u0026lt;number\u0026gt;\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. filter: any - id of the item to be deleted returns: Promise\u0026lt;number\u0026gt; - number of data items that satisfy the filter.  getListByFilter Gets a list of data items retrieved by a given filter and sorted according to sorting parameters.\nThis method shall be called by a public getListByFilter method from a child class that receives FilterParams and converts them into a filter function.\n protected getListByFilter(correlationId: string, filter: any, sort: any, select: any): Promise\u0026lt;T[]\u0026gt;\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. filter: any - (optional) filter function used to filter items sort: any - (optional) sorting parameters select: any - (optional) projection parameters (not used yet) returns: Promise\u0026lt;T[]\u0026gt; - data list of filtered results.  getOneRandom Gets a random item from items that match to a given filter.\nThis method shall be called by a public getOneRandom method from a child class that receives FilterParams and converts them into a filter function.\n protected getOneRandom(correlationId: string, filter: any): Promise\u0026lt;T\u0026gt;\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. filter: any - (optional) a filter function to filter items. returns: Promise\u0026lt;T\u0026gt; - random item.  getPageByFilter Gets a page of data items retrieved by a given filter and sorted according to sorting parameters.\nThis method shall be called by a public getPageByFilter method from a child class that receives FilterParams and converts them into a filter function.\n protected getPageByFilter(correlationId: string, filter: any, paging: PagingParams, sort: any, select: any): Promise\u0026lt;DataPage\u0026gt;\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. filter: any - filter function used to filter items paging: PagingParams - (optional) paging parameters sort: any - (optional) sorting parameters select: any - (optional) projection parameters (not used yet) returns: Promise\u0026lt;DataPage\u0026gt; - data page with filterd results.  isOpen Checks if the component is open.\n public isOpen(): boolean\n  returns: boolean - True if the component is open and False otherwise.  load Loads items.\n protected load(correlationId: string): Promise\u0026lt;void\u0026gt;\n  correlationId: string - (optional) transaction id used to trace execution through the call chain.  open Opens the component.\n public open(correlationId: string): Promise\u0026lt;void\u0026gt;\n  correlationId: string - (optional) transaction id used to trace execution through the call chain.  save Saves items to an external data source using a configured saver component.\n public save(correlationId: string): Promise\u0026lt;void\u0026gt;\n  correlationId: string - (optional) transaction id used to trace execution through the call chain.  setReferences Sets the component\u0026rsquo;s references. References must match configured dependencies.\n public setReferences(references: IReferences): void\n  references: IReferences - references to set.  Examples class MyMemoryPersistence extends MemoryPersistence\u0026lt;MyData\u0026gt; { public async getByName(correlationId: string, name: string): Promise\u0026lt;MyData\u0026gt; { let item = this._items.find((d) =\u0026gt; d.name == name); return item; }); public set(correlatonId: string, item: MyData): Promise\u0026lt;MyData\u0026gt; { this._items = this._items.find((d) =\u0026gt; d.name != name); this._items.push(item); await this.save(correlationId); return item; } } let persistence = new MyMemoryPersistence(); let item = await persistence.set(\u0026#34;123\u0026#34;, { name: \u0026#34;ABC\u0026#34; }); item = await persistence.getByName(\u0026#34;123\u0026#34;, \u0026#34;ABC\u0026#34;); console.log(item); // Result: { name: \u0026#34;ABC\u0026#34; }  See also   MemoryPersistence   ","description":"Persistence component that stores data in memory.\n","image":null,"permalink":"/node/data/persistence/memory_persistence/","subtitle":null,"tags":null,"title":"MemoryPersistence\u003cT\u003e"},{"content":"Implements: IConfigurable, IReferenceable, IOpenable, ICleanable\nDescription The MemoryPersistence class allows you to create persistence components that store data in memory.\nImportant points\n This is the most basic persistence component that is only able to store data items of any type. Specific CRUD operations over the data items must be implemented in child classes by accessing the this._items property and calling the save method. The component supports loading and saving items from another data source. This allows to use it as a base class for file and other types of persistence components that cache all data in memory.  Configuration parameters options:\n max_page_size: maximum number of items returned in a single page (default: 100)  References  *:logger:*:*:1.0 - (optional) (../../../components/log/ilogger) components to pass log messages  Constructors Creates a new instance of the memory persistence component.\n MemoryPersistence(loader: ILoader = None, saver: ISaver = None)\n  loader: ILoader - (optional) loader used to load items from an external datasource. saver: ISaver - (optional) saver used to save items to an external datasource.  Fields _lock Threading lock.\n _lock: threading.Lock\n _logger Logger.\n _logger: CompositeLogger\n _items Items to load/save.\n _items: List[Any]\n _loader Loader.\n _loader: ILoader\n _saver Saver.\n _saver: ISaver\n _opened Boolean that indicates whether the compent is open or not.\n _opened: bool\n _max_page_size Maximum amount of items per page.\n _max_page_size = 100\n  Instance methods clear Clears the component\u0026rsquo;s state.\n clear(correlation_id: Optional[str])\n  correlation_id: Optional[str] - (optional) transaction id used to trace execution through the call chain.  configure Configures the component by passing its configuration parameters.\n configure(config: ConfigParams)\n  config: ConfigParams - configuration parameters to be set.  create Creates a data item.\n create(correlation_id: Optional[str], item: T): T\n  correlation_id: Optional[str] - (optional) transaction id used to trace execution through the call chain. item: T - item to be created. returns: T - created item  delete_by_filter Deletes data items that match to a given filter. This method shall be called by a public delete_by_filter method from a child class that receives FilterParams and converts them into a filter function.\n delete_by_filter(correlation_id: Optional[str], filter: Any)\n  correlation_id: Optional[str] - (optional) transaction id used to trace execution through the call chain. filter: Any - (optional) filter function used to filter items.  get_count_by_filter Gets the number of items retrieved by a given filter.\nThis method shall be called by a public get_count_by_filter method from a child class that receives FilterParams and converts them into a filter function.\n get_count_by_filter(correlation_id: Optional[str], filter: Any): int\n  correlation_id: Optional[str] - (optional) transaction id used to trace execution through the call chain. filter: Any - id of the item to be deleted returns: int - number of data items that satisfy the filter.  get_list_by_filter Gets a list of data items retrieved by a given filter and sorted according to sorting parameters.\nThis method shall be called by a public get_list_by_filter method from a child class that receives FilterParams and converts them into a filter function.\n get_list_by_filter(correlation_id: Optional[str], filter: Any, sort: Any = None, select: Any = None): List[T]\n  correlation_id: Optional[str] - (optional) transaction id used to trace execution through the call chain. filter: Any - (optional) filter function used to filter items sort: Any - (optional) sorting parameters select: Any - (optional) projection parameters (not used yet) returns: List[T] - data list of filtered results.  get_one_random Gets a random item from items that match to a given filter.\nThis method shall be called by a public get_one_random method from a child class that receives FilterParams and converts them into a filter function.\n get_one_random(correlation_id: Optional[str], filter: Any = None): T\n  correlation_id: Optional[str] - (optional) transaction id used to trace execution through the call chain. filter: Any - (optional) a filter function to filter items. returns: T - random item.  get_page_by_filter Gets a page of data items retrieved by a given filter and sorted according to sorting parameters.\nThis method shall be called by a public get_page_by_filter method from a child class that receives FilterParams and converts them into a filter function.\n get_page_by_filter(correlation_id: Optional[str], filter: Any, paging: PagingParams, sort: Any = None, select: Any = None): DataPage\n  correlation_id: Optional[str] - (optional) transaction id used to trace execution through the call chain. filter: Any - filter function used to filter items paging: PagingParams - (optional) paging parameters sort: Any - (optional) sorting parameters select: Any - (optional) projection parameters (not used yet) returns: DataPage - data page with filterd results.  is_open Checks if the component is open.\n is_open(): bool\n  returns: bool - True if the component is open and False otherwise.  load Loads items.\n load(correlation_id: Optional[str])\n  correlation_id: Optional[str] - (optional) transaction id used to trace execution through the call chain.  open Opens the component.\n open(correlation_id: Optional[str])\n  correlation_id: Optional[str] - (optional) transaction id used to trace execution through the call chain.  save Saves items to an external data source using a configured saver component.\n save(correlation_id: Optional[str])\n  correlation_id: Optional[str] - (optional) transaction id used to trace execution through the call chain.  set_references Sets the component\u0026rsquo;s references. References must match configured dependencies.\n set_references(references: IReferences)\n  references: IReferences - references to set.  Examples class MyMemoryPersistence(MemoryPersistence): def get_by_name(self, correlationId, name): item = self.find(name) ... return item persistence = MyMemoryPersistence() persistence.set(\u0026#34;123\u0026#34;, MyData(\u0026#34;ABC\u0026#34;)) print str(persistence.get_by_name(\u0026#34;123\u0026#34;, \u0026#34;ABC\u0026#34;))) See also   MemoryPersistence   ","description":"Persistence component that stores data in memory.\n","image":null,"permalink":"/python/data/persistence/memory_persistence/","subtitle":null,"tags":null,"title":"MemoryPersistence"},{"content":"Distributes messages to one or many recipients using their configured delivery methods: email or sms.\n Server implementations: NodeJS, Dart Communication protocols: Direct, Commandable HTTP, Commandable GRPC, GRPC Persistence: Memory, Flat Files, MongoDB, Couchbase Deployment options: Monolith, Process, Docker, AWS Lambda Client implementations: NodeJS, Golang, Dart  This microservice has optional dependencies on the following microservices:\n Email Settings - recipient email settings SMS Settings - recipient sms settings Email - email sending SMS Delivery - sms sending Message Templates - message templates  ","description":null,"image":null,"permalink":"/microservices/users/message_distribution/","subtitle":null,"tags":null,"title":"Message Distribution Microservice"},{"content":"Description The MessageEnvelope class allows you to add additional information to messages.\nImportant points\n A correlation id, message id, and a message type are added to the data being sent/received. Additionally, a MessageEnvelope can reference a lock token. A MessageEnvelope\u0026rsquo;s message is stored as a buffer, so strings are converted using utf8 conversions.  Constructors NewMessageEnvelope Creates a new MessageEnvelope, which adds a correlation id, message id, and a type to the data being sent/received.\n NewMessageEnvelope(correlationId string, messageType string, message []byte) *MessageEnvelope\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. messageType: string - a string value that defines the message\u0026rsquo;s type. message: []byte - the data being sent/received.  NewEmptyMessageEnvelope NewMessageEnvelope method are creates an empty MessageEnvelope\n NewEmptyMessageEnvelope() *MessageEnvelope\n Fields CorrelationId The unique business transaction id that is used to trace calls across components.\n CorrelationId: string\n Message The stored message.\n Message: []byte\n MessageId The message\u0026rsquo;s auto-generated ID.\n MessageId: string\n MessageType String value that defines the stored message\u0026rsquo;s type.\n MessageType: string\n SentTime The time at which the message was sent.\n SentTime: time.Time\n  Methods MarshalJSON TODO: add description\n (c *MessageEnvelope) MarshalJSON() ([]byte, error)\n  returns: ([]byte, error) - TODO: add description  UnmarshalJSON TODO: add description\n (c *MessageEnvelope) UnmarshalJSON(data []byte) error\n  data: []byte - TODO: add description  GetMessageAs Returns any the value that was stored in this message as a JSON string.\nSee also SetMessageAsObject\n (c *MessageEnvelope) GetMessageAs(value interface{}) interface{}\n  value: interface{} - TODO: add description. returns: interface{} - value that was stored in this message as a JSON string.  GetMessageAsString Returns the information stored in this message as a UTF-8 encoded string.\n (c *MessageEnvelope) GetMessageAsString() string\n  returns: string - information stored in this message as a UTF-8 encoded string.  GetMessageAsJson GetMessageAsJson method are returns the value that was stored in this message as a JSON string.\n (c *MessageEnvelope) GetMessageAsJson() interface{}\n  returns: interface{} - value as a JSON string.  GetReference Returns the lock token that this MessageEnvelope references.\n (c *MessageEnvelope) GetReference() interface{}\n  returns: interface{} - lock token that this MessageEnvelope references.  SetMessageAsObject Stores the given value as an object. See also GetMessageAs\n (c *MessageEnvelope) SetMessageAsObject(value interface{})\n  value: interface{} - value to convert to JSON and store in this message.  SetMessageAsJson SetMessageAsJson method are stores the given value as a JSON string.\n (c *MessageEnvelope) SetMessageAsJson(value interface{})\n  value: interface{} - the value to convert to JSON and store in this message.  SetMessageAsString Stores the given string.\n (c *MessageEnvelope) SetMessageAsString(value string)\n  value: string - string to set. It will be converted to a buffer using UTF-8 encoding.  SetReference Sets a lock token reference for this MessageEnvelope.\n (c *MessageEnvelope) SetReference(value interface{})\n  value: interface{} - lock token to reference the message envelope.  String Converts this MessageEnvelope to a string, using the following format:\n\u0026quot;[,\u0026lt;message_type\u0026gt;,\u0026lt;message.toString\u0026gt;]\u0026quot;.\nIf any of the values are nil, they will be replaced with ---.\n (c *MessageEnvelope) String() string\n  returns: string - generated string.  ","description":"Allows adding additional information to messages. \n","image":null,"permalink":"/golang/messaging/queues/message_envelope/","subtitle":null,"tags":null,"title":"MessageEnvelope"},{"content":"Description The MessageEnvelope class allows you to add additional information to messages.\nImportant points\n A correlation id, message id, and a message type are added to the data being sent/received. Additionally, a MessageEnvelope can reference a lock token. A MessageEnvelope\u0026rsquo;s message is stored as a buffer, so strings are converted using utf8 conversions.  Constructors Creates a new MessageEnvelope.\n public MessageEnvelope()\n Creates a new MessageEnvelope, which adds a correlation id, message id, and a type to the data being sent/received.\n public MessageEnvelope(string correlationId, string messageType, byte[] message)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. messageType: string - a string value that defines the message\u0026rsquo;s type. message: byte[] - the data being sent/received.  Creates a new MessageEnvelop, which adds a correlation id, message id, and a type to the data being sent/received.\n public MessageEnvelope(string correlationId, string messageType, string message)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. messageType: string - a string value that defines the message\u0026rsquo;s type. message: string - the data being sent/received.  Creates a new MessageEnvelop, which adds a correlation id, message id, and a type to the data being sent/received.\n public MessageEnvelope(string correlationId, string messageType, object message)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. messageType: string - a string value that defines the message\u0026rsquo;s type. message: object - the data being sent/received.  Properties CorrelationId The unique business transaction id that is used to trace calls across components.\n public string CorrelationId { get; set; }\n Message The stored message.\n public byte[] Message { get; set; }\n MessageId The message\u0026rsquo;s auto-generated ID.\n public string MessageId { get; set; }\n MessageType String value that defines the stored message\u0026rsquo;s type.\n public string MessageType { get; set; }\n SentTime The time at which the message was sent.\n public DateTime SentTime { get; set; }\n MessageBase64 Used for serialization { get; set; }\n public string MessageBase64\n  Instance methods GetMessageAs Returns any the value that was stored in this message as a JSON string.\nSee also SetMessageAsObject\n public T GetMessageAs\u0026lt;T\u0026gt;()\n  returns: T - value that was stored in this message as a JSON string.  GetMessageAsString Returns the information stored in this message as a UTF-8 encoded string.\n public string GetMessageAsString()\n  returns: string - information stored in this message as a UTF-8 encoded string.  SetMessageAsObject Stores the given value as an object. See also GetMessageAs\n public void SetMessageAsObject(object message)\n  message: object - value to convert to JSON and store in this message.  SetMessageAsString Stores the given string.\n public void SetMessageAsString(string message)\n  message: string - string to set. It will be converted to a buffer using UTF-8 encoding.  ToString Converts this MessageEnvelope to a string, using the following format:\n\u0026quot;[,\u0026lt;message_type\u0026gt;,\u0026lt;message.toString\u0026gt;]\u0026quot;.\nIf any of the values are null, they will be replaced with ---.\n public override string ToString()\n  returns: string - generated string.  ","description":"Allows adding additional information to messages. \n","image":null,"permalink":"/net/messaging/queues/message_envelope/","subtitle":null,"tags":null,"title":"MessageEnvelope"},{"content":"Description The MessageEnvelope class allows you to add additional information to messages.\nImportant points\n A correlation id, message id, and a message type are added to the data being sent/received. Additionally, a MessageEnvelope can reference a lock token. A MessageEnvelope\u0026rsquo;s message is stored as a buffer, so strings are converted using utf8 conversions.  Constructors Creates a new MessageEnvelope, which adds a correlation id, message id, and a type to the data being sent/received.\n public constructor(correlationId: string, messageType: string, message: any)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. messageType: string - a string value that defines the message\u0026rsquo;s type. message: any - the data being sent/received.  Fields correlationId The unique business transaction id that is used to trace calls across components.\n public correlationId: string\n message The stored message.\n public message: Buffer\n message_id The message\u0026rsquo;s auto-generated ID.\n public message_id: string\n message_type String value that defines the stored message\u0026rsquo;s type.\n public message_type: string\n sent_time The time at which the message was sent.\n public sent_time: Date\n  Instance methods getMessageAs Returns any the value that was stored in this message as a JSON string.\nSee also setMessageAsObject\n public getMessageAs\u0026lt;T\u0026gt;(): T\n  returns: T - value that was stored in this message as a JSON string.  getMessageAsString Returns the information stored in this message as a UTF-8 encoded string.\n public getMessageAsString(): string\n  returns: string - information stored in this message as a UTF-8 encoded string.  getReference Returns the lock token that this MessageEnvelope references.\n public getReference(): any\n  returns: any - lock token that this MessageEnvelope references.  setMessageAsObject Stores the given value as an object. See also getMessageAs\n public setMessageAsObject(value: any): void\n  value: any - value to convert to JSON and store in this message.  setMessageAsString Stores the given string.\n setMessageAsString(value: string): void\n  value: string - string to set. It will be converted to a buffer using UTF-8 encoding.  setReference Sets a lock token reference for this MessageEnvelope.\n public setReference(value: any): void\n  value: any - lock token to reference the message envelope.  toJSON Converts this MessageEnvelope to a JSON string. The message payload is passed as base64 string\n public toJSON(): any\n  returns: any - JSON encoded representation of the object.  toString Converts this MessageEnvelope to a string, using the following format:\n\u0026quot;[,\u0026lt;message_type\u0026gt;,\u0026lt;message.toString\u0026gt;]\u0026quot;.\nIf any of the values are null, they will be replaced with ---.\n public toString(): string\n  returns: string - generated string.  Static methods fromJSON Converts a JSON string into a MessageEnvelope The message payload is passed as a base64 string\n static fromJSON(value: string): MessageEnvelope\n  value: string - JSON encoded string returns: MessageEnvelope - decoded Message Envelope.  ","description":"Allows adding additional information to messages. \n","image":null,"permalink":"/node/messaging/queues/message_envelope/","subtitle":null,"tags":null,"title":"MessageEnvelope"},{"content":"Description The MessageEnvelope class allows you to add additional information to messages.\nImportant points\n A correlation id, message id, and a message type are added to the data being sent/received. Additionally, a MessageEnvelope can reference a lock token. A MessageEnvelope\u0026rsquo;s message is stored as a buffer, so strings are converted using utf8 conversions.  Constructors Creates a new MessageEnvelope, which adds a correlation id, message id, and a type to the data being sent/received.\n MessageEnvelope(correlation_id: Optional[str], message_type: Optional[str], message: Optional[Any])\n  correlation_id: Optional[str] - (optional) transaction id used to trace execution through the call chain. message_type: Optional[str] - a string value that defines the message\u0026rsquo;s type. message: Optional[Any] - the data being sent/received.  Fields correlation_id The unique business transaction id that is used to trace calls across components.\n correlation_id: str\n message The stored message.\n message: bytes\n message_id The message\u0026rsquo;s auto-generated ID.\n message_id: str\n message_type String value that defines the stored message\u0026rsquo;s type.\n message_type: str\n sent_time The time at which the message was sent.\n sent_time: datetime.datetime\n  Instance methods get_message_as Returns any the value that was stored in this message as a JSON string.\nSee also set_message_as_object\n get_message_as(): Any\n  returns: Any - value that was stored in this message as a JSON string.  get_message_as_string Returns the information stored in this message as a UTF-8 encoded string.\n get_message_as_string(): Optional[str]\n  returns: Optional[str] - information stored in this message as a UTF-8 encoded string.  get_reference Returns the lock token that this MessageEnvelope references.\n get_reference(): Any\n  returns: Any - lock token that this MessageEnvelope references.  set_message_as_object Stores the given value as an object. See also get_message_as\n set_message_as_object(value: Any)\n  value: Any - value to convert to JSON and store in this message.  set_message_as_string Stores the given string.\n set_message_as_string(value: str)\n  value: str - string to set. It will be converted to a buffer using UTF-8 encoding.  set_reference Sets a lock token reference for this MessageEnvelope.\n set_reference(value: Any)\n  value: Any - lock token to reference the message envelope.  to_json Converts this MessageEnvelope to a JSON string. The message payload is passed as base64 string\n to_json(): dict\n  returns: dict - JSON encoded representation of the object.  to_string Converts this MessageEnvelope to a string, using the following format:\n\u0026quot;[\u0026lt;correlation_id\u0026gt;,\u0026lt;message_type\u0026gt;,\u0026lt;message.toString\u0026gt;]\u0026quot;.\nIf any of the values are None, they will be replaced with ---.\n to_string(): str\n  returns: str - generated string.  from_json Converts a JSON string into a MessageEnvelope The message payload is passed as a base64 string\n static from_json(value: str): MessageEnvelope\n  value: str - JSON encoded string returns: MessageEnvelope - decoded Message Envelope.  ","description":"Allows adding additional information to messages. \n","image":null,"permalink":"/python/messaging/queues/message_envelope/","subtitle":null,"tags":null,"title":"MessageEnvelope"},{"content":"Implements: IMessageQueue\nDescription The MessageQueue class allows you to create a message queue that is used as a basis for specific message queue implementions.\nConfiguration parameters  name: name of the message queue  connection(s):\n discovery_key: key to retrieve parameters from discovery service protocol: connection protocol like http, https, tcp, udp host: host name or IP address port: port number uri: resource URI or connection string with all parameters in it  credential(s):\n store_key: key to retrieve parameters from credential store username: username password: user\u0026rsquo;s password access_id: application access id access_key: application secret key  References  *:logger:*:*:1.0 - (optional) ILogger components to pass log messages *:counters:*:*:1.0 - (optional) ICounters components to pass collected measurements *:discovery:*:*:1.0 - (optional) IDiscovery components to discover connection(s) *:credential-store:*:*:1.0 - (optional) ICredentialStore componetns to lookup credential(s)  Constructors Creates a new instance of the message queue.\n InheritMessageQueue(overrides IMessageQueueOverrides, name string, capabilities *MessagingCapabilities) *MessageQueue\n  overrides: IMessageQueueOverrides - overrides IMessageQueue. name: string - (optional) queue name capabilities: *MessagingCapabilities - (optional) capabilities of this message queue  Fields Logger Component used to pass log messages.\n Logger: *CompositeLogger\n Counters Component to pass collected measurements.\n Counters: *CompositeCounters\n ConnectionResolver Component used to resolve connections.\n ConnectionResolver: *ConnectionResolver\n CredentialResolver Component used to resolve credentials.\n CredentialResolver: *CredentialResolver\n name Name of the message queue.\n name: string\n capabilities Component used to store the message queue.\n capabilities: *MessagingCapabilities\n  Methods BeginListen Listens for incoming messages without blocking the current thread.\nSee also Listen, IMessageReceiver\n (c *MessageQueue) BeginListen(correlationId string, receiver IMessageReceiver)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. receiver: IMessageReceiver - receiver used to receive incoming messages.  CheckOpen Checks if the queue has been opened. Raise an exception if queue wasn\u0026rsquo;t opened or nil otherwise\n (c *MessageQueue) CheckOpen(correlationId string) error\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. returns: error - error or nil no errors occured.  Configure Configures the component by passing its configuration parameters.\n (c *MessageQueue) Configure(config *cconf.ConfigParams)\n  config: *cconf.ConfigParams - configuration parameters to be set.  Capabilities Gets the queue capabilities\n (c *MessageQueue) Capabilities() *MessagingCapabilities\n  returns: *MessagingCapabilities - queue\u0026rsquo;s capabilities object.  Listen Listens for incoming messages and blocks the current thread until the queue is closed.\nSee also IMessageReceiver, receive\n public abstract listen(correlationId: string, receiver: IMessageReceiver): void\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. receiver: IMessageReceiver - receiver used to receive incoming messages.  Name Gets the queue name\n (c *MessageQueue) Name() string\n  returns: string - queue name.  Open Opens the component.\n (c *MessageQueue) Open(correlationId string) error\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. returns: error - error or nil no errors occured.  SendAsObject Sends an object into the queue. Before sending the object is converted into JSON string and wrapped in a MessageEnvelope.\n (c *MessageQueue) SendAsObject(correlationId string, messageType string, message interface{}) (err error)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. messageType: string - a message type. message: interface{} - an object value to be sent. returns: (err error) - error or nil no errors occured.  SetReferences Sets references to dependent components.\n (c *MessageQueue) SetReferences(references cref.IReferences)\n  references: cref.IReferences - references to locate the component dependencies.  String Gets a string representation of the object.\n (c *MessageQueue) String() string\n  returns: string - string representation of the object.  OpenWithParams Opens the component with the given connection and credential parameters.\n OpenWithParams(correlationId string, connections []*cconn.ConnectionParams, credential *cauth.CredentialParams) error\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. connections: []*cconn.ConnectionParams - connection parameters. credentials: *cauth.CredentialParams - credential parameters. returns: error - error or nil no errors occured.  ","description":"Abstract message queue that is used as a basis for specific message queue implementations.\n","image":null,"permalink":"/golang/messaging/queues/message_queue/","subtitle":null,"tags":null,"title":"MessageQueue"},{"content":"Inherits: IMessageQueue, IConfigurable, IReferenceable\nDescription The MessageQueue class allows you to create a message queue that is used as a basis for specific message queue implementions.\nConfiguration parameters  name: name of the message queue  connection(s):\n discovery_key: key to retrieve parameters from discovery service protocol: connection protocol like http, https, tcp, udp host: host name or IP address port: port number uri: resource URI or connection string with all parameters in it  credential(s):\n store_key: key to retrieve parameters from credential store username: username password: user\u0026rsquo;s password access_id: application access id access_key: application secret key  References  *:logger:*:*:1.0 - (optional) ILogger components to pass log messages *:counters:*:*:1.0 - (optional) ICounters components to pass collected measurements *:discovery:*:*:1.0 - (optional) IDiscovery components to discover connection(s) *:credential-store:*:*:1.0 - (optional) ICredentialStore componetns to lookup credential(s)  Constructors Creates a new instance of the message queue.\n public MessageQueue(string name = null, MessagingCapabilities capabilities = null)\n  name: string - (optional) queue name capabilities: MessagingCapabilities - (optional) capabilities of this message queue  Fields _logger Component used to pass log messages.\n protected _logger: CompositeLogger\n _counters Component to pass collected measurements.\n protected _counters: CompositeCounters\n _connectionResolver Component used to resolve connections.\n protected _connectionResolver: ConnectionResolver\n _credentialResolver Component used to resolve credentials.\n protected _credentialResolver: CredentialResolver\n  Properties Name of the message queue.\n public string Name [ get, protected set ]\n Capabilities  public MessagingCapabilities Capabilities [ get, protected set ]\n Abstract methods AbandonAsync Returns a message into the queue and makes it available for all subscribers to receive it again. This method is usually used to return a message which could not be processed at the moment to repeat the attempt. Messages that cause unrecoverable errors shall be removed permanently or/and sent to dead letter queue.\n public abstract Task AbandonAsync(MessageEnvelope message);\n  message: MessageEnvelope - message to return.  ClearAsync Clears a component\u0026rsquo;s state.\n public abstract Task ClearAsync(string correlationId)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain.  CloseAsync Closes a component and frees the used resources.\n public abstract Task CloseAsync(string correlationId)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain.  Complete Permanently removes a message from the queue. This method is usually used to remove the message after successful processing.\n public abstract Task CompleteAsync(MessageEnvelope message)\n  message: MessageEnvelope - message to remove.  EndListen Ends listening for incoming messages. When this method is called, listen unblocks the thread and execution continues.\n public abstract void EndListen(string correlationId)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain.  IsOpen Checks if the component is opened.\n public abstract bool IsOpen()\n  returns: bool - True if the component has been opened and False otherwise.  ListenAsync Listens for incoming messages and blocks the current thread until the queue is closed.\nSee also IMessageReceiver, ReceiveAsync\n public abstract Task ListenAsync(string correlationId, IMessageReceiver receiver)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. receiver: IMessageReceiver - receiver used to receive incoming messages.  MoveToDeadLetter Permanently removes a message from the queue and sends it to dead letter queue.\n public abstract Task MoveToDeadLetterAsync(MessageEnvelope message)\n  message: MessageEnvelope - message to be removed.  PeekAsync Peeks a single incoming message from the queue without removing it. If there are no messages available in the queue, it returns null.\n public abstract Task\u0026lt;[MessageEnvelope](../message_envelope)\u0026gt; PeekAsync(string correlationId)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. returns: Task\u0026lt;[MessageEnvelope](../message_envelope)\u0026gt; - peeked message or null.  PeekBatch Peeks multiple incoming messages from the queue without removing them. If there are no messages available in the queue, it returns an empty list.\n public abstract Task\u0026lt;List\u0026lt;MessageEnvelope\u0026gt;\u0026gt; PeekBatchAsync(string correlationId, int messageCount)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. messageCount: int - maximum number of messages to peek. returns: Task\u0026lt;List\u0026lt;MessageEnvelope\u0026gt;\u0026gt; - list of peeked messages  ReadMessageCountAsync Reads the current number of messages in the queue to be delivered.\n public abstract Task\u0026lt;long\u0026gt; ReadMessageCountAsync()\n  returns: Task\u0026lt;long\u0026gt; - number of messages in the queue.  Receive Receives an incoming message and removes it from the queue.\n public abstract Task\u0026lt;MessageEnvelope\u0026gt; ReceiveAsync(string correlationId, long waitTimeout)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. waitTimeout: long - timeout in milliseconds to wait for a message to come. returns: Task\u0026lt;MessageEnvelope\u0026gt; - received message or null.  RenewLockAsync Renews a lock on a message that makes it invisible from other receivers in the queue. This method is usually used to extend the message processing time.\n public abstract Task RenewLockAsync(MessageEnvelope message, long lockTimeout)\n  message: MessageEnvelope - message to extend its lock. lockTimeout: long - locking timeout in milliseconds.  Instance methods BeginListen Listens for incoming messages without blocking the current thread.\nSee also ListenAsync, IMessageReceiver\n public void BeginListen(string correlationId, IMessageReceiver receiver)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. receiver: IMessageReceiver - receiver used to receive incoming messages.  Configure Configures the component by passing its configuration parameters.\n public virtual void Configure(ConfigParams config)\n  config: ConfigParams - configuration parameters to be set.  OpenAsync Opens the component with the given connection and credential parameters.\n public virtual Task OpenAsync(string correlationId, List\u0026lt;ConnectionParams\u0026gt; connections, CredentialParams credential)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. connections: ConnectionParams[] - connection parameters credentials: CredentialParams - credential parameters  SendAsObjectAsync Sends an object into the queue. Before sending the object is converted into JSON string and wrapped in a MessageEnvelope.\n public Task SendAsObjectAsync(string correlationId, string messageType, object message)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. messageType: string - a message type message: object - an object value to be sent  SetReferences Sets references to dependent components.\n public virtual void SetReferences(IReferences references)\n  references: IReferences - references to locate the component dependencies.  ToString Gets a string representation of the object.\n public override string ToString()\n  returns: string - string representation of the object.  CheckOpen Checks if the queue has been opened. Raise an exception if queue wasn\u0026rsquo;t opened or null otherwise\n protected void CheckOpen(string correlationId)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain.  ","description":"Abstract message queue that is used as a basis for specific message queue implementations.\n","image":null,"permalink":"/net/messaging/queues/message_queue/","subtitle":null,"tags":null,"title":"MessageQueue"},{"content":"Implements: IMessageQueue, IConfigurable, IReferenceable\nDescription The MessageQueue class allows you to create a message queue that is used as a basis for specific message queue implementions.\nConfiguration parameters  name: name of the message queue  connection(s):\n discovery_key: key to retrieve parameters from discovery service protocol: connection protocol like http, https, tcp, udp host: host name or IP address port: port number uri: resource URI or connection string with all parameters in it  credential(s):\n store_key: key to retrieve parameters from credential store username: username password: user\u0026rsquo;s password access_id: application access id access_key: application secret key  References  *:logger:*:*:1.0 - (optional) ILogger components to pass log messages *:counters:*:*:1.0 - (optional) ICounters components to pass collected measurements *:discovery:*:*:1.0 - (optional) IDiscovery components to discover connection(s) *:credential-store:*:*:1.0 - (optional) ICredentialStore componetns to lookup credential(s)  Constructors Creates a new instance of the message queue.\n public constructor(name?: string, capabilities?: MessagingCapabilities)\n  name: string - (optional) queue name capabilities: MessagingCapabilities - (optional) capabilities of this message queue  Fields _logger Component used to pass log messages.\n protected _logger: CompositeLogger\n _counters Component to pass collected measurements.\n protected _counters: CompositeCounters\n _connectionResolver Component used to resolve connections.\n protected _connectionResolver: ConnectionResolver\n _credentialResolver Component used to resolve credentials.\n protected _credentialResolver: CredentialResolver\n _name Name of the message queue.\n protected _name: string\n _capabilities Component used to store the message queue.\n protected _capabilities: MessagingCapabilities\n  Abstract methods abandon Returns a message into the queue and makes it available for all subscribers to receive it again. This method is usually used to return a message which could not be processed at the moment to repeat the attempt. Messages that cause unrecoverable errors shall be removed permanently or/and sent to dead letter queue.\n public abstract abandon(message: MessageEnvelope): Promise\u0026lt;void\u0026gt;\n  message: MessageEnvelope - message to return.  clear Clears a component\u0026rsquo;s state.\n public abstract clear(correlationId: string): Promise\u0026lt;void\u0026gt;\n  correlationId: string - (optional) transaction id used to trace execution through the call chain.  close Closes a component and frees the used resources.\n public abstract close(correlationId: string): Promise\u0026lt;void\u0026gt;\n  correlationId: string - (optional) transaction id used to trace execution through the call chain.  complete Permanently removes a message from the queue. This method is usually used to remove the message after successful processing.\n public abstract complete(message: MessageEnvelope): Promise\u0026lt;void\u0026gt;\n  message: MessageEnvelope - message to remove.  endListen Ends listening for incoming messages. When this method is called, listen unblocks the thread and execution continues.\n public abstract endListen(correlationId: string): void\n  correlationId: string - (optional) transaction id used to trace execution through the call chain.  isOpen Checks if the component is opened.\n public abstract isOpen(): boolean\n  returns: boolean - True if the component has been opened and False otherwise.  listen Listens for incoming messages and blocks the current thread until the queue is closed.\nSee also IMessageReceiver, receive\n public abstract listen(correlationId: string, receiver: IMessageReceiver): void\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. receiver: IMessageReceiver - receiver used to receive incoming messages.  moveToDeadLetter Permanently removes a message from the queue and sends it to dead letter queue.\n public abstract moveToDeadLetter(message: MessageEnvelope): Promise\u0026lt;void\u0026gt;\n  message: MessageEnvelope - message to be removed.  peek Peeks a single incoming message from the queue without removing it. If there are no messages available in the queue, it returns null.\n public abstract peek(correlationId: string): Promise\u0026lt;MessageEnvelope\u0026gt;\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. returns: Promise\u0026lt;MessageEnvelope\u0026gt; - peeked message or null.  peekBatch Peeks multiple incoming messages from the queue without removing them. If there are no messages available in the queue, it returns an empty list.\n public abstract peekBatch(correlationId: string, messageCount: number): Promise\u0026lt;MessageEnvelope[]\u0026gt;\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. messageCount: number - maximum number of messages to peek. returns: Promise\u0026lt;MessageEnvelope[]\u0026gt; - list of peeked messages  readMessageCount Reads the current number of messages in the queue to be delivered.\n public abstract readMessageCount(): Promise\u0026lt;number\u0026gt;\n  returns: Promise\u0026lt;number\u0026gt; - number of messages in the queue.  receive Receives an incoming message and removes it from the queue.\n public abstract receive(correlationId: string, waitTimeout: number): Promise\u0026lt;MessageEnvelope\u0026gt;\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. waitTimeout: number - timeout in milliseconds to wait for a message to come. returns: Promise\u0026lt;MessageEnvelope\u0026gt; - received message or null.  renewLock Renews a lock on a message that makes it invisible from other receivers in the queue. This method is usually used to extend the message processing time.\n public abstract renew_lock(message: MessageEnvelope, lockTimeout: number): Promise\u0026lt;void\u0026gt;\n  message: MessageEnvelope - message to extend its lock. lockTimeout: number - locking timeout in milliseconds.  Instance methods beginListen Listens for incoming messages without blocking the current thread.\nSee also listen, IMessageReceiver\n public beginListen(correlationId: string, receiver: IMessageReceiver): void\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. receiver: IMessageReceiver - receiver used to receive incoming messages.  configure Configures the component by passing its configuration parameters.\n public configure(config: ConfigParams): void\n  config: ConfigParams - configuration parameters to be set.  getCapabilities Gets the queue capabilities\n getCapabilities(): MessagingCapabilities\n  returns: MessagingCapabilities - queue\u0026rsquo;s capabilities object.  getName Gets the queue name\n public getName(): string\n  returns: string - queue name.  open Opens the component.\n public open(correlationId: string): Promise\u0026lt;void\u0026gt;\n  correlationId: string - (optional) transaction id used to trace execution through the call chain.  sendAsObject Sends an object into the queue. Before sending the object is converted into JSON string and wrapped in a MessageEnvelope.\n public sendAsObject(correlationId: string, message_type: string, message: any): Promise\u0026lt;void\u0026gt;\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. messageType: string - a message type message: any - an object value to be sent  setReferences Sets references to dependent components.\n public setReferences(references: IReferences): void\n  references: IReferences - references to locate the component dependencies.  toString Gets a string representation of the object.\n public toString(): string\n  returns: string - string representation of the object.  openWithParams Opens the component with the given connection and credential parameters.\n protected openWithParams(correlationId: string, connections: ConnectionParams[], credentials: CredentialParams): Promise\u0026lt;void\u0026gt;\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. connections: ConnectionParams[] - connection parameters credentials: CredentialParams - credential parameters  checkOpen Checks if the queue has been opened. Raise an exception if queue wasn\u0026rsquo;t opened or null otherwise\n protected checkOpen(correlationId: string): void\n  correlationId: string - (optional) transaction id used to trace execution through the call chain.  ","description":"Abstract message queue that is used as a basis for specific message queue implementations.\n","image":null,"permalink":"/node/messaging/queues/message_queue/","subtitle":null,"tags":null,"title":"MessageQueue"},{"content":"Implements: IMessageQueue, IConfigurable, IReferenceable\nDescription The MessageQueue class allows you to create a message queue that is used as a basis for specific message queue implementions.\nConfiguration parameters  name: name of the message queue  connection(s):\n discovery_key: key to retrieve parameters from discovery service protocol: connection protocol like http, https, tcp, udp host: host name or IP address port: port number uri: resource URI or connection string with all parameters in it  credential(s):\n store_key: key to retrieve parameters from credential store username: username password: user\u0026rsquo;s password access_id: application access id access_key: application secret key  References  *:logger:*:*:1.0 - (optional) ILogger components to pass log messages *:counters:*:*:1.0 - (optional) ICounters components to pass collected measurements *:discovery:*:*:1.0 - (optional) IDiscovery components to discover connection(s) *:credential-store:*:*:1.0 - (optional) ICredentialStore componetns to lookup credential(s)  Constructors Creates a new instance of the message queue.\n MessageQueue(name: str = None, capabilities: MessagingCapabilities = None)\n  name: str - (optional) queue name capabilities: MessagingCapabilities - (optional) capabilities of this message queue  Fields _lock Threading lock.\n _lock: threading.Lock\n _event Threading event.\n _event = threading.Event\n _logger Component used to pass log messages.\n _logger: CompositeLogger\n _counters Component to pass collected measurements.\n _counters: CompositeCounters\n _connectionResolver Component used to resolve connections.\n _connectionResolver: ConnectionResolver\n _credentialResolver Component used to resolve credentials.\n _credentialResolver: CredentialResolver\n _name Name of the message queue.\n _name: str\n _capabilities Component used to store the message queue.\n _capabilities: MessagingCapabilities\n  Abstract methods abandon Returns a message into the queue and makes it available for all subscribers to receive it again. This method is usually used to return a message which could not be processed at the moment to repeat the attempt. Messages that cause unrecoverable errors shall be removed permanently or/and sent to dead letter queue.\n abstractmethod abandon(message: MessageEnvelope)\n  message: MessageEnvelope - message to return.  clear Clears a component\u0026rsquo;s state.\n abstractmethod clear(correlation_id: Optional[str])\n  correlation_id: Optional[str] - (optional) transaction id used to trace execution through the call chain.  close Closes a component and frees the used resources.\n abstractmethod close(correlation_id: Optional[str])\n  correlation_id: Optional[str] - (optional) transaction id used to trace execution through the call chain.  complete Permanently removes a message from the queue. This method is usually used to remove the message after successful processing.\n abstractmethod complete(message: MessageEnvelope)\n  message: MessageEnvelope - message to remove.  end_listen Ends listening for incoming messages. When this method is called, listen unblocks the thread and execution continues.\n abstractmethod end_listen(correlation_id: Optional[str])\n  correlation_id: Optional[str] - (optional) transaction id used to trace execution through the call chain.  is_open Checks if the component is opened.\n abstractmethod is_open(): bool\n  returns: bool - True if the component has been opened and False otherwise.  listen Listens for incoming messages and blocks the current thread until the queue is closed.\nSee also IMessageReceiver, receive\n abstractmethod listen(correlation_id: Optional[str], receiver: IMessageReceiver)\n  correlation_id: Optional[str] - (optional) transaction id used to trace execution through the call chain. receiver: IMessageReceiver - receiver used to receive incoming messages.  move_to_dead_letter Permanently removes a message from the queue and sends it to dead letter queue.\n abstractmethod move_to_dead_letter(message: MessageEnvelope)\n  message: MessageEnvelope - message to be removed.  peek Peeks a single incoming message from the queue without removing it. If there are no messages available in the queue, it returns None.\n abstractmethod peek(correlation_id: Optional[str]): MessageEnvelope\n  correlation_id: Optional[str] - (optional) transaction id used to trace execution through the call chain. returns: MessageEnvelope - peeked message or None.  peek_batch Peeks multiple incoming messages from the queue without removing them. If there are no messages available in the queue, it returns an empty list.\n abstractmethod peek_batch(correlation_id: Optional[str], message_count: int): List[MessageEnvelope]\n  correlation_id: Optional[str] - (optional) transaction id used to trace execution through the call chain. message_count: int - maximum number of messages to peek. returns: List[MessageEnvelope] - list of peeked messages  read_message_count Reads the current number of messages in the queue to be delivered.\n abstractmethod read_message_count(): int\n  returns: int - number of messages in the queue.  receive Receives an incoming message and removes it from the queue.\n abstractmethod receive(correlation_id: Optional[str], wait_timeout: int): MessageEnvelope\n  correlation_id: Optional[str] - (optional) transaction id used to trace execution through the call chain. wait_timeout: int - timeout in milliseconds to wait for a message to come. returns: MessageEnvelope - received message or None.  renew_lock Renews a lock on a message that makes it invisible from other receivers in the queue. This method is usually used to extend the message processing time.\n abstractmethod renew_lock(message: MessageEnvelope, lock_timeout: int)\n  message: MessageEnvelope - message to extend its lock. lock_timeout: int - locking timeout in milliseconds.  send Sends a message into the queue.\n abstractmethod send(correlation_id: Optional[str], envelope: MessageEnvelope)\n  correlation_id: Optional[str] - (optional) transaction id used to trace execution through the call chain. envelope: MessageEnvelope - message envelop to be sent.  send_as_object Sends an object into the queue. Before sending the object is converted into JSON string and wrapped in a MessageEnvelope.\n abstractmethod send_as_object(correlation_id: Optional[str], message_type: str, message: Any)\n  correlation_id: Optional[str] - (optional) transaction id used to trace execution through the call chain. message_type: str - a message type message: Any - an object value to be sent  Instance methods begin_listen Listens for incoming messages without blocking the current thread.\nSee also listen, IMessageReceiver\n begin_listen(correlation_id: Optional[str], receiver: IMessageReceiver)\n  correlation_id: Optional[str] - (optional) transaction id used to trace execution through the call chain. receiver: IMessageReceiver - receiver used to receive incoming messages.  configure Configures the component by passing its configuration parameters.\n configure(config: ConfigParams)\n  config: ConfigParams - configuration parameters to be set.  get_capabilities Gets the queue capabilities\n get_capabilities(): MessagingCapabilities\n  returns: MessagingCapabilities - queue\u0026rsquo;s capabilities object.  get_name Gets the queue name\n get_name(): str\n  returns: str - queue name.  open Opens the component.\n open(correlation_id: Optional[str])\n  correlation_id: Optional[str] - (optional) transaction id used to trace execution through the call chain.  send_as_object Sends an object into the queue. Before sending it, the object is converted into a JSON string and wrapped in a MessageEnvelope.\n send_as_object(correlation_id: Optional[str], message_type: str, message: Any)\n  correlation_id: Optional[str] - (optional) transaction id used to trace execution through the call chain. message_type: str - message type message: Any - object value to be sent  set_references Sets references to dependent components.\n set_references(references: IReferences)\n  references: IReferences - references to locate the component dependencies.  to_string Gets a string representation of the object.\n to_string(): str\n  returns: str - string representation of the object.  _open_with_params Opens the component with the given connection and credential parameters.\n _open_with_params(correlation_id: Optional[str], connections: List[ConnectionParams], credentials: CredentialParams)\n  correlation_id: Optional[str] - (optional) transaction id used to trace execution through the call chain. connections: List[ConnectionParams] - connection parameters credentials: CredentialParams - credential parameters  _check_open Checks if the queue has been opened.\n _check_open(correlation_id: Optional[str])\n  correlation_id: Optional[str] - (optional) transaction id used to trace execution through the call chain. returns: Exception - an exception if queue wasn\u0026rsquo;t opened or None otherwise  ","description":"Abstract message queue that is used as a basis for specific message queue implementations.\n","image":null,"permalink":"/python/messaging/queues/message_queue/","subtitle":null,"tags":null,"title":"MessageQueue"},{"content":"Implements: Factory\nDescription The MessageQueueFactory class allows you to create IMessageQueue components based on their descriptors.\nConstructors InheritMessageQueueFactory NewMessageQueueFactory method creates a new instance of the factory.\n InheritMessageQueueFactory() *MessageQueueFactory\n Fields Config Configuration paramters\n Config: ConfigParams\n References References used to locate the component dependencies\n References: IReferences\n  Methods Configure Configures the component by passing its configuration parameters.\n (c *MessageQueueFactory) Configure(config *cconf.ConfigParams)\n  config: *cconf.ConfigParams - configuration parameters to be set.  SetReferences Sets references to dependent components.\n (c *MessageQueueFactory) SetReferences(references cref.IReferences)\n  references: cref.IReferences - references to locate the component dependencies.  See also   Factory   MemoryMessageQueue   ","description":"Creates [IMessageQueue](../../queues/imessage_queue) components based on their descriptors.\n","image":null,"permalink":"/golang/messaging/build/message_queue_factory/","subtitle":null,"tags":null,"title":"MessageQueueFactory"},{"content":"Inherits: Factory, IMessageQueueFactory, IConfigurable, IReferenceable\nDescription The MessageQueueFactory class allows you to create IMessageQueue components based on their descriptors.\nFields _config Configuration paramters\n protected _config: ConfigParams\n _references References used to locate the component dependencies\n protected _references: IReferences\n  Abstract methods CreateQueue Creates a message queue component and assigns its name.\n public abstract IMessageQueue CreateQueue(string name)\n  name: string - name of the created message queue. returns: IMessageQueue - message queue  Instance methods Configure Configures the component by passing its configuration parameters.\n public virtual void Configure(ConfigParams config)\n  config: ConfigParams - configuration parameters to be set.  SetReferences Sets references to dependent components.\n public virtual void SetReferences(IReferences references)\n  references: IReferences - references to locate the component dependencies.  See also   Factory   MemoryMessageQueue   ","description":"Creates [IMessageQueue](../../queues/imessage_queue) components based on their descriptors.\n","image":null,"permalink":"/net/messaging/build/message_queue_factory/","subtitle":null,"tags":null,"title":"MessageQueueFactory"},{"content":"Extends: Factory\nDescription The MessageQueueFactory class allows you to create IMessageQueue components based on their descriptors.\nFields _config Configuration paramters\n protected _config: ConfigParams\n _references References used to locate the component dependencies\n protected _references: IReferences\n  Abstract methods createQueue Creates a message queue component and assigns its name.\n public abstract createQueue(name: string): IMessageQueue\n  name: string - name of the created message queue. returns: IMessageQueue - message queue  Instance methods configure Configures the component by passing its configuration parameters.\n public configure(config: ConfigParams)\n  config: ConfigParams - configuration parameters to be set.  setReferences Sets references to dependent components.\n public setReferences(references: IReferences)\n  references: IReferences - references to locate the component dependencies.  See also   Factory   MemoryMessageQueue   ","description":"Creates [IMessageQueue](../../queues/imessage_queue) components based on their descriptors.\n","image":null,"permalink":"/node/messaging/build/message_queue_factory/","subtitle":null,"tags":null,"title":"MessageQueueFactory"},{"content":"Implements: Factory, IMessageQueueFactory, IConfigurable, IReferenceable\nDescription The MessageQueueFactory class allows you to create IMessageQueue components based on their descriptors.\nFields _config Configuration paramters\n _config: ConfigParams\n _references References used to locate the component dependencies\n _references: IReferences\n  Abstract methods create_queue Creates a message queue component and assigns its name.\n abstractmethod create_queue(name: str): IMessageQueue\n  name: str - name of the created message queue. returns: IMessageQueue - message queue  Instance methods configure Configures the component by passing its configuration parameters.\n configure(config: ConfigParams)\n  config: ConfigParams - configuration parameters to be set.  set_references Sets references to dependent components.\n set_references(references: IReferences)\n  references: IReferences - references to locate the component dependencies.  See also   Factory   MemoryMessageQueue   ","description":"Creates [IMessageQueue](../../queues/imessage_queue) components based on their descriptors.\n","image":null,"permalink":"/python/messaging/build/message_queue_factory/","subtitle":null,"tags":null,"title":"MessageQueueFactory"},{"content":"Shows to users inspirational msgtemplates on various topics.\n Server implementations: NodeJS, Dart Communication protocols: Direct, Commandable HTTP, Commandable GRPC, GRPC Persistence: Memory, Flat Files, MongoDB, Couchbase Deployment options: Monolith, Process, Docker, AWS Lambda Client implementations: NodeJS, Golang, Dart  ","description":null,"image":null,"permalink":"/microservices/content/messagetemplates/","subtitle":null,"tags":null,"title":"MessageTemplates Microservice"},{"content":"Description The MessagingCapabilities class allows you to create data objects that contain supported capabilities of message queues.\nImportant points\n If certain capability is not supported a queue will throw a NotImplemented exception.  Constructors NewMessagingCapabilities Creates a new instance of the capabilities object.\n NewMessagingCapabilities(canMessageCount bool, canSend bool, canReceive bool, canPeek bool, canPeekBatch bool, canRenewLock bool, canAbandon bool, canDeadLetter bool, canClear bool) *MessagingCapabilities\n  canMessageCount: bool - True if the queue supports reading message count. canSend: bool - True if the queue is able to send messages. canReceive: bool - True if the queue is able to receive messages. canPeek: bool - True if the queue is able to peek messages. canPeekBatch: bool - True if the queue is able to peek multiple messages in one batch. canRenewLock: bool - True if the queue is able to renew message lock. canAbandon: bool - True if the queue is able to abandon messages. canDeadLetter: bool - True if the queue is able to send messages to dead letter queue. canClear: bool - True if the queue can be cleared.  Properties CanAbandon Informs if the queue is able to abandon messages.\n (c *MessagingCapabilities) CanAbandon() bool\n  returns: bool - True if the queue is able to abandon messages.  CanClear Informs if the queue can be cleared.\n (c *MessagingCapabilities) CanClear() bool\n  returns: bool - True if the queue can be cleared.  CanDeadLetter Informs if the queue is able to send messages to dead letter queue.\n (c *MessagingCapabilities) CanDeadLetter() bool\n  returns: bool - True if the queue is able to send messages to dead letter queue.  CanMessageCount Informs if the queue is able to read the number of messages.\n (c *MessagingCapabilities) CanMessageCount() bool\n  returns: bool - True if the queue supports reading message count.  CanPeek Informs if the queue is able to peek messages.\n (c *MessagingCapabilities) CanPeek() bool\n  returns: bool - True if the queue is able to peek messages.  CanPeekBatch Informs if the queue is able to peek multiple messages in one batch.\n (c *MessagingCapabilities) CanPeekBatch() bool\n  returns: bool - True if the queue is able to peek multiple messages in one batch.  CanReceive Informs if the queue is able to receive messages.\n (c *MessagingCapabilities) CanReceive() bool\n  returns: bool - True if the queue is able to receive messages.  CanRenewLock Informs if the queue is able to renew message lock.\n (c *MessagingCapabilities) CanRenewLock() bool\n  returns: bool - True if the queue is able to renew message lock.  CanSend Informs if the queue is able to send messages.\n (c *MessagingCapabilities) CanSend() bool\n  returns: bool - True if the queue is able to send messages.  ","description":"Data object that contains supported capabilities of a message queue. \n","image":null,"permalink":"/golang/messaging/queues/messaging_capabilities/","subtitle":null,"tags":null,"title":"MessagingCapabilities"},{"content":"Description The MessagingCapabilities class allows you to create data objects that contain supported capabilities of message queues.\nImportant points\n If certain capability is not supported a queue will throw a NotImplemented exception.  Constructors Creates a new instance of the capabilities object.\n public MessagingCapabilities(bool canMessageCount, bool canSend, bool canReceive, bool canPeek, bool canPeekBatch, bool canRenewLock, bool canAbandon, bool canDeadLetter, bool canClear)\n  canMessageCount: bool - True if the queue supports reading message count. canSend: bool - True if the queue is able to send messages. canReceive: bool - True if the queue is able to receive messages. canPeek: bool - True if the queue is able to peek messages. canPeekBatch: bool - True if the queue is able to peek multiple messages in one batch. canRenewLock: bool - True if the queue is able to renew message lock. canAbandon: bool - True if the queue is able to abandon messages. canDeadLetter: bool - True if the queue is able to send messages to dead letter queue. canClear: bool - True if the queue can be cleared.  Properties CanAbandon Informs if the queue is able to abandon messages.\n public bool CanAbandon [ get, private set ]\n CanClear Informs if the queue can be cleared.\n public bool CanClear [ get, private set ]\n CanDeadLetter Informs if the queue is able to send messages to dead letter queue.\n public bool CanDeadLetter [ get, private set ]\n CanMessageCount Informs if the queue is able to read the number of messages.\n public get canMessageCount(): bool\n CanMessageCount Informs if the queue is able to peek messages.\n public bool CanMessageCount [ get, private set ]\n CanPeekBatch Informs if the queue is able to peek multiple messages in one batch.\n public bool CanPeekBatch [ get, private set ]\n CanReceive Informs if the queue is able to receive messages.\n public bool CanReceive [ get, private set ]\n CanRenewLock Informs if the queue is able to renew message lock.\n public bool CanRenewLock [ get, private set ]\n CanSend Informs if the queue is able to send messages.\n public bool CanSend [ get, private set ]\n ","description":"Data object that contains supported capabilities of a message queue. \n","image":null,"permalink":"/net/messaging/queues/messaging_capabilities/","subtitle":null,"tags":null,"title":"MessagingCapabilities"},{"content":"Description The MessagingCapabilities class allows you to create data objects that contain supported capabilities of message queues.\nImportant points\n If certain capability is not supported a queue will throw a NotImplemented exception.  Constructors Creates a new instance of the capabilities object.\n public constructor(canMessageCount: boolean, canSend: boolean, canReceive: boolean, canPeek: boolean, canPeekBatch: boolean, canRenewLock: boolean, canAbandon: boolean, canDeadLetter: boolean, canClear: boolean)\n  canMessageCount: boolean - True if the queue supports reading message count. canSend: boolean - True if the queue is able to send messages. canReceive: boolean - True if the queue is able to receive messages. canPeek: boolean - True if the queue is able to peek messages. canPeekBatch: boolean - True if the queue is able to peek multiple messages in one batch. canRenewLock: boolean - True if the queue is able to renew message lock. canAbandon: boolean - True if the queue is able to abandon messages. canDeadLetter: boolean - True if the queue is able to send messages to dead letter queue. canClear: boolean - True if the queue can be cleared.  Properties canAbandon Informs if the queue is able to abandon messages.\n public canAbandon(): boolean\n  returns: boolean - True if the queue is able to abandon messages.  canClear Informs if the queue can be cleared.\n public canClear(): boolean\n  returns: boolean - True if the queue can be cleared.  canDeadLetter Informs if the queue is able to send messages to dead letter queue.\n public get canDeadLetter(): boolean\n  returns: boolean - True if the queue is able to send messages to dead letter queue.  canMessageCount Informs if the queue is able to read the number of messages.\n public get canMessageCount(): boolean\n  returns: boolean - True if the queue supports reading message count.  canPeek Informs if the queue is able to peek messages.\n public get canPeek(): boolean\n  returns: boolean - True if the queue is able to peek messages.  canPeekBatch Informs if the queue is able to peek multiple messages in one batch.\n public get canPeekBatch(): boolean\n  returns: boolean - True if the queue is able to peek multiple messages in one batch.  canReceive Informs if the queue is able to receive messages.\n public get canReceive(): boolean\n  returns: boolean - True if the queue is able to receive messages.  canRenewLock Informs if the queue is able to renew message lock.\n public get canRenewLock(): boolean\n  returns: boolean - True if the queue is able to renew message lock.  canSend Informs if the queue is able to send messages.\n public get canSend(): boolean\n  returns: boolean - True if the queue is able to send messages.  ","description":"Data object that contains supported capabilities of a message queue. \n","image":null,"permalink":"/node/messaging/queues/messaging_capabilities/","subtitle":null,"tags":null,"title":"MessagingCapabilities"},{"content":"Description The MessagingCapabilities class allows you to create data objects that contain supported capabilities of message queues.\nImportant points\n If certain capability is not supported a queue will throw a NotImplemented exception.  Constructors Creates a new instance of the capabilities object.\n MessagingCapabilities(can_message_count: bool, can_send: bool, can_receive: bool, can_peek: bool, can_peek_batch: bool, can_renew_lock: bool, can_abandon: bool, can_dead_letter: bool, can_clear: bool)\n  can_message_count: bool - True if the queue supports reading message count. can_send: bool - True if the queue is able to send messages. can_receive: bool - True if the queue is able to receive messages. can_peek: bool - True if the queue is able to peek messages. can_peek_batch: bool - True if the queue is able to peek multiple messages in one batch. can_renew_lock: bool - True if the queue is able to renew message lock. can_abandon: bool - True if the queue is able to abandon messages. can_dead_letter: bool - True if the queue is able to send messages to dead letter queue. can_clear: bool - True if the queue can be cleared.  Properties can_abandon Informs if the queue is able to abandon messages.\n can_abandon(): bool\n  returns: bool - True if the queue is able to abandon messages.  can_clear Informs if the queue can be cleared.\n can_clear(): bool\n  returns: bool - True if the queue can be cleared.  can_dead_letter Informs if the queue is able to send messages to dead letter queue.\n can_dead_letter(): bool\n  returns: bool - True if the queue is able to send messages to dead letter queue.  can_message_count Informs if the queue is able to read the number of messages.\n can_message_count(): bool\n  returns: bool - True if the queue supports reading message count.  can_peek Informs if the queue is able to peek messages.\n can_peek(): bool\n  returns: bool - True if the queue is able to peek messages.  can_peek_batch Informs if the queue is able to peek multiple messages in one batch.\n can_peek_batch(): bool\n  returns: bool - True if the queue is able to peek multiple messages in one batch.  can_receive Informs if the queue is able to receive messages.\n can_receive(): bool\n  returns: bool - True if the queue is able to receive messages.  can_renew_lock Informs if the queue is able to renew message lock.\n can_renew_lock(): bool\n  returns: bool - True if the queue is able to renew message lock.  can_send Informs if the queue is able to send messages.\n can_send(): bool\n  returns: bool - True if the queue is able to send messages.  ","description":"Data object that contains supported capabilities of a message queue. \n","image":null,"permalink":"/python/messaging/queues/messaging_capabilities/","subtitle":null,"tags":null,"title":"MessagingCapabilities"},{"content":"Description The MethodReflector class allows you to examine an object\u0026rsquo;s methods (method instrospection) and to invoke them dynamically.\nImportant points\n This class has symmetric implementation across all languages supported by the Pip.Services toolkit and it is used to support dynamic data processing. Moreover, because all languages have different casing and case sensitivity rules, this class treats all method names as case insensitive.  Methods GetMethodNames Gets the names of all methods implemented in specified object.\n (c *TMethodReflector) GetMethodNames(obj interface{}) []string\n  obj: interface{} - objec to introspect. returns: []string - list with method names.  HasMethod Checks if an object has a method with a specified name..\n (c *TMethodReflector) HasMethod(obj interface{}, name string) bool\n  obj: interface{} - object to introspect. name: string - name of the method to check. returns: bool - true if the object has the method and false if it doesn\u0026rsquo;t.  InvokeMethod Invokes an object method by its name with specified parameters.\n (c *TMethodReflector) InvokeMethod(obj interface{}, name string, args \u0026hellip;interface{}) interface{}\n  obj: interface{} - object to invoke. name: string - name of the method to invoke. args: \u0026hellip;interface{} - list of method arguments. returns: interface{} - result of the method invocation or nil if the method returns void.  Examples myObj = MyObject(); methods = MethodReflector.GetMethodNames(); MethodReflector.HasMethod(myObj, \u0026#34;myMethod\u0026#34;); MethodReflector.InvokeMethod(myObj, \u0026#34;myMethod\u0026#34;, 123); ","description":"Helper class allows you to examine an object's methods (method instrospection) and to invoke them dynamically.\n","image":null,"permalink":"/golang/commons/reflect/method_reflector/","subtitle":null,"tags":null,"title":"MethodReflector"},{"content":"Description The MethodReflector class allows you to examine an object\u0026rsquo;s methods (method instrospection) and to invoke them dynamically.\nImportant points\n This class has symmetric implementation across all languages supported by the Pip.Services toolkit and it is used to support dynamic data processing. Moreover, because all languages have different casing and case sensitivity rules, this class treats all method names as case insensitive.  Static methods GetMethodNames Gets names of all methods implemented in a specified object.\n public static IEnumerable\u0026lt;string\u0026gt; GetMethodNames(object obj)\n  obj: object - objec to introspect. returns: IEnumerable\u0026lt;string\u0026gt; - list with method names.  HasMethod Checks if object has a method with specified name.\n public static bool HasMethod(object obj, string name)\n  obj: object - object to introspect. name: string - name of the method to check. returns: bool - true if the object has the method and false if it doesn\u0026rsquo;t.  InvokeMethod Invokes an object method by its name with specified parameters.\n public static object InvokeMethod(object obj, string name, params object[] args)\n  obj: object - object to invoke. name: string - name of the method to invoke. args: object[] - list of the method\u0026rsquo;s arguments. returns: object - result of the method invocation or null if the method returns void.  Examples var myObj = new MyObject(); var methods = MethodReflector.GetMethodNames(); MethodReflector.HasMethod(myObj, \u0026#34;myMethod\u0026#34;); MethodReflector.InvokeMethod(myObj, \u0026#34;myMethod\u0026#34;, 123); ","description":"Helper class that allows you to examine an object's methods (method instrospection) and to invoke them dynamically.\n","image":null,"permalink":"/net/commons/reflect/method_reflector/","subtitle":null,"tags":null,"title":"MethodReflector"},{"content":"Description The MethodReflector class allows you to examine an object\u0026rsquo;s methods (method instrospection) and to invoke them dynamically.\nImportant points\n This class has symmetric implementation across all languages supported by the Pip.Services toolkit and it is used to support dynamic data processing. Moreover, because all languages have different casing and case sensitivity rules, this class treats all method names as case insensitive.  Static methods getMethodNames Gets the names of all methods implemented in specified object.\n public static getMethodNames(obj: any): string[]\n  obj: any - objec to introspect. returns: string[] - list with method names.  hasMethod Checks if an object has a method with a specified name..\n public static hasMethod(obj: any, name: string): boolean\n  obj: any - object to introspect. name: string - name of the method to check. returns: boolean - true if the object has the method and false if it doesn\u0026rsquo;t.  invokeMethod Invokes an object method by its name with specified parameters.\n public static invokeMethod(obj: any, name: string, \u0026hellip;args: any[]): any\n  obj: any - object to invoke. name: string - name of the method to invoke. args: any[] - list of method arguments. returns: any - result of the method invocation or null if the method returns void.  Examples let myObj = new MyObject(); let methods = MethodReflector.getMethodNames(); MethodReflector.hasMethod(myObj, \u0026#34;myMethod\u0026#34;); MethodReflector.invokeMethod(myObj, \u0026#34;myMethod\u0026#34;, 123); ","description":"Helper class allows you to examine an object's methods (method instrospection) and to invoke them dynamically.\n","image":null,"permalink":"/node/commons/reflect/method_reflector/","subtitle":null,"tags":null,"title":"MethodReflector"},{"content":"Description The MethodReflector class allows you to examine an object\u0026rsquo;s methods (method instrospection) and to invoke them dynamically.\nImportant points\n This class has symmetric implementation across all languages supported by the Pip.Services toolkit and it is used to support dynamic data processing. Moreover, because all languages have different casing and case sensitivity rules, this class treats all method names as case insensitive.  Static methods get_method_names Gets names of all methods implemented in specified object.\n static get_method_names(obj: Any): List[str]\n  obj: Any - an objec to introspect. returns: List[str] - a list with method names.  has_method Checks if object has a method with specified name..\n static has_method(obj: Any, name: str): bool\n  obj: Any - an object to introspect. name: str - a name of the method to check. returns: bool - true if the object has the method and false if it doesn\u0026rsquo;t.  invoke_method Invokes an object method by its name with specified parameters.\n static invoke_method(obj: Any, name: str, args: Any): Any\n  obj: Any - an object to invoke. name: str -a name of the method to invoke. args: Any - a list of method arguments. returns: Any - the result of the method invocation or None if method returns None.  Examples myObj = new MyObject() methods = MethodReflector.get_method_names() MethodReflector.has_method(myObj, \u0026#34;myMethod\u0026#34;) MethodReflector.invoke_method(myObj, \u0026#34;myMethod\u0026#34;, 123) ","description":"Helper class allows you to examine an object's methods (method instrospection) and to invoke them dynamically.\n","image":null,"permalink":"/python/commons/reflect/method_reflector/","subtitle":null,"tags":null,"title":"MethodReflector"},{"content":"Keeps list of metrics. This microservice is designed to manage various metrics characterizing the operation of a process. Each metric has the following characteristics:\n metric name up to 3 types of measurements (in string format) date and time is a numerical value characterizing the metric  When adding or updating a metric, statistics on the metric are automatically calculated for different time horizons (you can specify the depth of the horizon) with the calculation of the average, maximum, minimum and accumulated values ​​within each of them. Data access is provided through a set of API functions.\n Server implementations: NodeJS, Dart Communication protocols: Direct, Commandable HTTP, Commandable GRPC, GRPC Persistence: Memory, Flat Files, MongoDB, Couchbase Deployment options: Monolith, Process, Docker, AWS Lambda Client implementations: NodeJS, Dart  ","description":null,"image":null,"permalink":"/microservices/infrastructure/metrics/","subtitle":null,"tags":null,"title":"Metrics Microservice"},{"content":"Description The MongoDbConnection class allows you to create a MongoDB connection using the official driver.\nImportant points\n By defining a connection and sharing it through multiple persistence components you can reduce the number of used database connections.  Configuration parameters connection(s):\n discovery_key: (optional) key to retrieve the connection from IDiscovery host: host name or IP address port: port number (default: 27017) uri: resource URI or connection string with all parameters in it  credential(s):\n store_key: (optional) key to retrieve the credentials from ICredentialStore username: (optional) username password: (optional) user\u0026rsquo;s password  options:\n max_pool_size: (optional) maximum connection pool size (default: 2) keep_alive: (optional) enable connection keep alive (default: true) connect_timeout: (optional) connection timeout in milliseconds (default: 5000) socket_timeout: (optional) socket timeout in milliseconds (default: 360000) auto_reconnect: (optional) enable auto reconnection (default: true) reconnect_interval: (optional) reconnection interval in milliseconds (default: 1000) max_page_size: (optional) maximum page size (default: 100) replica_set: (optional) name of replica set ssl: (optional) enable SSL connection (default: false) auth_source: (optional) authentication source debug: (optional) enable debug output (default: false).  References  *:logger:*:*:1.0 - (optional) ILogger components to pass log messages *:discovery:*:*:1.0 - (optional) IDiscovery services *:credential-store:*:*:1.0 - (optional) credential stores to resolve credentials  Constructors NewMongoDbConnection Creates a new instance of the connection component.\n NewMongoDbConnection() *MongoDbConnection\n Fields Logger The logger.\n Logger: *CompositeLogger\n ConnectionResolver The connection resolver.\n ConnectionResolver: *MongoDbConnectionResolver\n Options The configuration options.\n Options: *ConfigParams\n Connection The MongoDB connection object.\n Connection: *mongodrv.Client\n DatabaseName The MongoDB database name.\n DatabaseName: string\n Db The MongoDB database object.\n Db: *mongodrv.Database \n Methods Close Closes a component and frees used resources.\n (c *MongoDbConnection) Close(correlationId string) error\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. returns: error - error or nil no errors occured.  Configure Configures a component by passing its configuration parameters.\n (c *MongoDbConnection) Configure(config *cconf.ConfigParams)\n  config: *cconf.ConfigParams - configuration parameters to be set.  GetConnection Gets the connection.\n (c *MongoDbConnection) GetConnection() *mongodrv.Client\n  return: *mongodrv.Client - connection to a MongoDB database  GetDatabase Gets the MongoDB database.\n (c *MongoDbConnection) GetDatabase() *mongodrv.Database\n  return: *mongodrv.Database - MongoDB database  IsOpen Checks if the component is opened.\n (c *MongoDbConnection) IsOpen() bool\n  return: bool - True if the component has been opened and False otherwise.  Open Opens the component.\n (c *MongoDbConnection) Open(correlationId string) error\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. returns: error - error or nil no errors occured.  SetReferences Sets the references to the dependent components.\n (c *MongoDbConnection) SetReferences(references crefer.IReferences)\n  references: crefer.IReferences - references to locate the component dependencies.  ","description":"MongoDB connection using the official driver.\n","image":null,"permalink":"/golang/mongodb/connect/mongodb_connection/","subtitle":null,"tags":null,"title":"MongoDbConnection"},{"content":"Inherits: IReferenceable, IConfigurable, IOpenable\nDescription The MongoDbConnection class allows you to create a MongoDB connection using the official driver.\nImportant points\n By defining a connection and sharing it through multiple persistence components you can reduce the number of used database connections.  Configuration parameters connection(s):\n discovery_key: (optional) key to retrieve the connection from IDiscovery host: host name or IP address port: port number (default: 27017) uri: resource URI or connection string with all parameters in it  credential(s):\n store_key: (optional) key to retrieve the credentials from ICredentialStore username: (optional) username password: (optional) user\u0026rsquo;s password  options:\n max_pool_size: (optional) maximum connection pool size (default: 2) keep_alive: (optional) enable connection keep alive (default: true) connect_timeout: (optional) connection timeout in milliseconds (default: 5000) socket_timeout: (optional) socket timeout in milliseconds (default: 360000) auto_reconnect: (optional) enable auto reconnection (default: true) reconnect_interval: (optional) reconnection interval in milliseconds (default: 1000) max_page_size: (optional) maximum page size (default: 100) replica_set: (optional) name of replica set ssl: (optional) enable SSL connection (default: false) auth_source: (optional) authentication source debug: (optional) enable debug output (default: false).  References  *:logger:*:*:1.0 - (optional) ILogger components to pass log messages *:discovery:*:*:1.0 - (optional) IDiscovery services *:credential-store:*:*:1.0 - (optional) credential stores to resolve credentials  Constructors Creates a new instance of the connection component.\n public MongoDbConnection()\n Fields _areSessionsSupported Determines if the database supports sessions or not\n private _areSessionsSupported: bool\n _logger The logger.\n protected _logger: CompositeLogger\n _connectionResolver The connection resolver.\n protected _connectionResolver: MongoDbConnectionResolver\n _options The configuration options.\n protected _options: ConfigParams\n _connection The MongoDB connection object.\n protected _connection: MongoClient\n _databaseName The MongoDB database name.\n protected _databaseName: string\n _database The MongoDB database object.\n protected _database: IMongoDatabase \n Instance methods CloseAsync Closes a component and frees used resources.\n public virtual Task CloseAsync(string correlationId)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain.  Configure Configures a component by passing its configuration parameters.\n public virtual void Configure(ConfigParams config)\n  config: ConfigParams - configuration parameters to be set.  GetConnection Gets the connection.\n public MongoClient GetConnection()\n  return: MongoClient - connection to a MongoDB database  GetDatabase Gets the MongoDB database.\n public IMongoDatabase GetDatabase()\n  return: IMongoDatabase - MongoDB database  IsOpen Checks if the component is opened.\n public virtual bool IsOpen()\n  return: bool - True if the component has been opened and False otherwise.  Open Opens the component.\n public virtual Task OpenAsync(string correlationId)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain.  SetReferences Sets the references to the dependent components.\n public void SetReferences(IReferences references)\n  references: IReferences - references to locate the component dependencies.  ","description":"MongoDB connection using the official driver.\n","image":null,"permalink":"/net/mongodb/connect/mongodb_connection/","subtitle":null,"tags":null,"title":"MongoDbConnection"},{"content":"Implements: IReferenceable, IConfigurable, IOpenable\nDescription The MongoDbConnection class allows you to create a MongoDB connection using the official driver.\nImportant points\n By defining a connection and sharing it through multiple persistence components you can reduce the number of used database connections.  Configuration parameters connection(s):\n discovery_key: (optional) key to retrieve the connection from IDiscovery host: host name or IP address port: port number (default: 27017) uri: resource URI or connection string with all parameters in it  credential(s):\n store_key: (optional) key to retrieve the credentials from ICredentialStore username: (optional) username password: (optional) user\u0026rsquo;s password  options:\n max_pool_size: (optional) maximum connection pool size (default: 2) keep_alive: (optional) enable connection keep alive (default: true) connect_timeout: (optional) connection timeout in milliseconds (default: 5000) socket_timeout: (optional) socket timeout in milliseconds (default: 360000) auto_reconnect: (optional) enable auto reconnection (default: true) reconnect_interval: (optional) reconnection interval in milliseconds (default: 1000) max_page_size: (optional) maximum page size (default: 100) replica_set: (optional) name of replica set ssl: (optional) enable SSL connection (default: false) auth_source: (optional) authentication source debug: (optional) enable debug output (default: false).  References  *:logger:*:*:1.0 - (optional) ILogger components to pass log messages *:discovery:*:*:1.0 - (optional) IDiscovery services *:credential-store:*:*:1.0 - (optional) credential stores to resolve credentials  Constructors Creates a new instance of the connection component.\n public constructor()\n Fields _logger The logger.\n protected _logger: CompositeLogger\n _connectionResolver The connection resolver.\n protected _connectionResolver: MongoDbConnectionResolver\n _options The configuration options.\n protected _options: ConfigParams\n _connection The MongoDB connection object.\n protected _connection: any\n _databaseName The MongoDB database name.\n protected _databaseName: string\n _db The MongoDB database object.\n protected _db: any \n Instance methods close Closes a component and frees used resources.\n public close(correlationId: string): Promise\u0026lt;void\u0026gt;\n  correlationId: string - (optional) transaction id used to trace execution through the call chain.  configure Configures a component by passing its configuration parameters.\n public configure(config: ConfigParams): void\n  config: ConfigParams - configuration parameters to be set.  getConnection Gets the connection.\n public getConnection(): any\n  return: any - connection to a MongoDB database  getDatabase Gets the MongoDB database.\n public getDatabase(): any\n  return: any - MongoDB database  isOpen Checks if the component is opened.\n public isOpen(): boolean\n  return: boolean - True if the component has been opened and False otherwise.  open Opens the component.\n public async open(correlationId: string): Promise\u0026lt;void\u0026gt;\n  correlationId: string - (optional) transaction id used to trace execution through the call chain.  setReferences Sets the references to the dependent components.\n public setReferences(references: IReferences): void\n  references: IReferences - references to locate the component dependencies.  ","description":"MongoDB connection using the official driver.\n","image":null,"permalink":"/node/mongodb/connect/mongodb_connection/","subtitle":null,"tags":null,"title":"MongoDbConnection"},{"content":"Implements: IReferenceable, IConfigurable, IOpenable\nDescription The MongoDbConnection class allows you to create a MongoDB connection using the official driver.\nImportant points\n By defining a connection and sharing it through multiple persistence components you can reduce the number of used database connections.  Configuration parameters connection(s):\n discovery_key: (optional) key to retrieve the connection from IDiscovery host: host name or IP address port: port number (default: 27017) uri: resource URI or connection string with all parameters in it  credential(s):\n store_key: (optional) key to retrieve the credentials from ICredentialStore username: (optional) username password: (optional) user\u0026rsquo;s password  options:\n max_pool_size: (optional) maximum connection pool size (default: 2) keep_alive: (optional) enable connection keep alive (default: true) connect_timeout: (optional) connection timeout in milliseconds (default: 5000) socket_timeout: (optional) socket timeout in milliseconds (default: 360000) auto_reconnect: (optional) enable auto reconnection (default: true) reconnect_interval: (optional) reconnection interval in milliseconds (default: 1000) max_page_size: (optional) maximum page size (default: 100) replica_set: (optional) name of replica set ssl: (optional) enable SSL connection (default: false) auth_source: (optional) authentication source debug: (optional) enable debug output (default: false).  References  *:logger:*:*:1.0 - (optional) ILogger components to pass log messages *:discovery:*:*:1.0 - (optional) IDiscovery services *:credential-store:*:*:1.0 - (optional) credential stores to resolve credentials  Constructors Creates a new instance of the connection component.\n MongoDbConnection()\n Fields _logger The logger.\n _logger: CompositeLogger\n _connection_resolver The connection resolver.\n _connection_resolver: MongoDbConnectionResolver\n _options The configuration options.\n _options: ConfigParams\n _connection The MongoDB connection object.\n _connection: Any\n _database_name The MongoDB database name.\n _database_name: str\n _db The MongoDB database object.\n _db: Any \n Instance methods close Closes a component and frees used resources.\n close(correlation_id: Optional[str])\n  correlation_id: Optional[str] - (optional) transaction id used to trace execution through the call chain.  configure Configures a component by passing its configuration parameters.\n configure(config: ConfigParams)\n  config: ConfigParams - configuration parameters to be set.  get_connection Gets the connection.\n get_connection(): Any\n  return: Any - connection to a MongoDB database  get_database Gets the MongoDB database.\n get_database(): Any\n  return: Any - MongoDB database  is_open Checks if the component is opened.\n is_open(): bool\n  return: bool - True if the component has been opened and False otherwise.  open Opens the component.\n open(correlation_id: Optional[str])\n  correlation_id: Optional[str] - (optional) transaction id used to trace execution through the call chain.  set_references Sets the references to the dependent components.\n set_references(references: IReferences)\n  references: IReferences - references to locate the component dependencies.  ","description":"MongoDB connection using the official driver.\n","image":null,"permalink":"/python/mongodb/connect/mongodb_connection/","subtitle":null,"tags":null,"title":"MongoDbConnection"},{"content":"Description The MongoDbConnectionResolver class allows you to create a MongoDB connection resolver that resolves MongoDB connection and credential parameters, validates them, and generates a connection URI.\nImportant points\n It is able to process multiple connections to MongoDB cluster nodes.  Configuration parameters connection(s):\n discovery_key: (optional) key to retrieve the connection from IDiscovery host: host name or IP address port: port number (default: 27017) database: database name uri: resource URI or connection string with all parameters in it  credential(s):\n store_key: (optional) key to retrieve the credentials from ICredentialStore username: username password: user\u0026rsquo;s password  References  *:discovery:*:*:1.0 - (optional) IDiscovery services *:credential-store:*:*:1.0 - (optional) credential stores to resolve credentials  Constructors NewMongoDbConnectionResolver NewMongoDbConnectionResolver creates new connection resolver\n NewMongoDbConnectionResolver() *MongoDbConnectionResolver\n Fields ConnectionResolver MongoDB connection resolver.\n ConnectionResolver: ConnectionResolver\n _credential_resolver MongoDB credential resolver.\n CredentialResolver: CredentialResolver\n  Methods Configure Configures the component by passing its configuration parameters.\n (c *MongoDbConnectionResolver) Configure(config *cconf.ConfigParams)\n  config: *cconf.ConfigParams - configuration parameters to be set.  Resolve Resolves a MongoDB connection URI from connection and credential parameters.\n (c *MongoDbConnectionResolver) Resolve(correlationId string) (uri string, err error)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. returns: (uri string, err error) - resolved URI  SetReferences Sets references to dependent components.\n (c *MongoDbConnectionResolver) SetReferences(references crefer.IReferences)\n  references: crefer.IReferences - references to locate the component dependencies.  ","description":"MongoDbConnectionResolver implementation. Helper class that resolves MongoDB connection and credential parameters, validates them and generates a connection URI.\n","image":null,"permalink":"/golang/mongodb/connect/mongodb_connection_resolver/","subtitle":null,"tags":null,"title":"MongoDbConnectionResolver"},{"content":"Inherits: IReferenceable, IConfigurable\nDescription The MongoDbConnectionResolver class allows you to create a MongoDB connection resolver that resolves MongoDB connection and credential parameters, validates them, and generates a connection URI.\nImportant points\n It is able to process multiple connections to MongoDB cluster nodes.  Configuration parameters connection(s):\n discovery_key: (optional) key to retrieve the connection from IDiscovery host: host name or IP address port: port number (default: 27017) database: database name uri: resource URI or connection string with all parameters in it  credential(s):\n store_key: (optional) key to retrieve the credentials from ICredentialStore username: username password: user\u0026rsquo;s password  References  *:discovery:*:*:1.0 - (optional) IDiscovery services *:credential-store:*:*:1.0 - (optional) credential stores to resolve credentials  Fields _connectionResolver MongoDB connection resolver.\n protected _connectionResolver: ConnectionResolver\n _credentialResolver MongoDB credential resolver.\n protected _credentialResolver: CredentialResolver\n  Instance methods Configure Configures the component by passing its configuration parameters.\n public void Configure(ConfigParams config)\n  config: ConfigParams - configuration parameters to be set.  ResolveAsync Resolves a MongoDB connection URI from connection and credential parameters.\n public Task\u0026lt;string\u0026gt; ResolveAsync(string correlationId)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. returns: string - resolved URI  SetReferences Sets references to dependent components.\n public void SetReferences(IReferences references)\n  references: IReferences - references to locate the component dependencies.  ","description":"MongoDbConnectionResolver implementation. Helper class that resolves MongoDB connection and credential parameters, validates them and generates a connection URI.\n","image":null,"permalink":"/net/mongodb/connect/mongodb_connection_resolver/","subtitle":null,"tags":null,"title":"MongoDbConnectionResolver"},{"content":"Implements: IReferenceable, IConfigurable\nDescription The MongoDbConnectionResolver class allows you to create a MongoDB connection resolver that resolves MongoDB connection and credential parameters, validates them, and generates a connection URI.\nImportant points\n It is able to process multiple connections to MongoDB cluster nodes.  Configuration parameters connection(s):\n discovery_key: (optional) key to retrieve the connection from IDiscovery host: host name or IP address port: port number (default: 27017) database: database name uri: resource URI or connection string with all parameters in it  credential(s):\n store_key: (optional) key to retrieve the credentials from ICredentialStore username: username password: user\u0026rsquo;s password  References  *:discovery:*:*:1.0 - (optional) IDiscovery services *:credential-store:*:*:1.0 - (optional) credential stores to resolve credentials  Fields _connectionResolver MongoDB connection resolver.\n protected _connectionResolver: ConnectionResolver\n _credentialResolver MongoDB credential resolver.\n protected _credentialResolver: CredentialResolver\n  Instance methods configure Configures the component by passing its configuration parameters.\n public configure(config: ConfigParams): void\n  config: ConfigParams - configuration parameters to be set.  resolve Resolves a MongoDB connection URI from connection and credential parameters.\n public resolve(correlationId: string): Promise\u0026lt;string\u0026gt;\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. returns: string - resolved URI  setReferences Sets references to dependent components.\n public setReferences(references: IReferences): void\n  references: IReferences - references to locate the component dependencies.  ","description":"MongoDbConnectionResolver implementation. Helper class that resolves MongoDB connection and credential parameters, validates them and generates a connection URI.\n","image":null,"permalink":"/node/mongodb/connect/mongodb_connection_resolver/","subtitle":null,"tags":null,"title":"MongoDbConnectionResolver"},{"content":"Implements: IReferenceable, IConfigurable\nDescription The MongoDbConnectionResolver class allows you to create a MongoDB connection resolver that resolves MongoDB connection and credential parameters, validates them, and generates a connection URI.\nImportant points\n It is able to process multiple connections to MongoDB cluster nodes.  Configuration parameters connection(s):\n discovery_key: (optional) key to retrieve the connection from IDiscovery host: host name or IP address port: port number (default: 27017) database: database name uri: resource URI or connection string with all parameters in it  credential(s):\n store_key: (optional) key to retrieve the credentials from ICredentialStore username: username password: user\u0026rsquo;s password  References  *:discovery:*:*:1.0 - (optional) IDiscovery services *:credential-store:*:*:1.0 - (optional) credential stores to resolve credentials  Fields _connection_resolver MongoDB connection resolver.\n _connection_resolver: ConnectionResolver\n _credential_resolver MongoDB credential resolver.\n _credential_resolver: CredentialResolver\n  Instance methods configure Configures the component by passing its configuration parameters.\n configure(config: ConfigParams)\n  config: ConfigParams - configuration parameters to be set.  resolve Resolves a MongoDB connection URI from connection and credential parameters.\n resolve(correlation_id: Optional[str]): str\n  correlation_id: Optional[str] - (optional) transaction id used to trace execution through the call chain. returns: str - resolved URI  set_references Sets references to dependent components.\n set_references(references: IReferences)\n  references: IReferences - references to locate the component dependencies.  ","description":"MongoDbConnectionResolver implementation. Helper class that resolves MongoDB connection and credential parameters, validates them and generates a connection URI.\n","image":null,"permalink":"/python/mongodb/connect/mongodb_connection_resolver/","subtitle":null,"tags":null,"title":"MongoDbConnectionResolver"},{"content":"Description The MongoDbIndex class allows you to create an index for MongoDB.\nFields options Index keys (fields)\n public keys: any\n options Index options\n public options: any\n  ","description":"Index definition for MongoDB.\n","image":null,"permalink":"/node/mongodb/persistence/mongodb_index/","subtitle":null,"tags":null,"title":"MongoDbIndex"},{"content":"Description The MongoDbIndex class allows you to create an index for MongoDB.\nConstructors Creates a new instance of the index.\n MongoDbIndex(keys: Any, options: Any = None)\n Fields options Index keys (fields)\n keys: Any\n options Index options\n options: Any\n  ","description":"Index definition for MongoDB.\n","image":null,"permalink":"/python/mongodb/persistence/mongodb_index/","subtitle":null,"tags":null,"title":"MongoDbIndex"},{"content":"Description The MongoDbPersistence class allows you to create persistence components that store data in MongoDBs using the official MongoDB driver.\nImportant points\n This is the most basic persistence component that is only able to store data items of any type. Specific CRUD operations over the data items must be implemented in child classes by accessing c.Db or c.Collection properties.  Configuration parameters  collection: (optional) MongoDB collection name  connection(s):\n discovery_key: (optional) key to retrieve the connection from IDiscovery host: host name or IP address port: port number (default: 27017) uri: resource URI or connection string with all parameters in it  credential(s):\n store_key: (optional) key to retrieve the credentials from ICredentialStore username: (optional) username password: (optional) user\u0026rsquo;s password  options:\n max_pool_size: (optional) maximum connection pool size (default: 2) keep_alive: (optional) enable connection keep alive (default: true) connect_timeout: (optional) connection timeout in milliseconds (default: 5000) socket_timeout: (optional) socket timeout in milliseconds (default: 360000) auto_reconnect: (optional) enable auto reconnection (default: true) reconnect_interval: (optional) reconnection interval in milliseconds (default: 1000) max_page_size: (optional) maximum page size (default: 100) replica_set: (optional) name of replica set ssl: (optional) enable SSL connection (default: false) auth_source: (optional) authentication source debug: (optional) enable debug output (default: false).  References  *:logger:*:*:1.0 - (optional) ILogger components to pass log messages *:discovery:*:*:1.0 - (optional) IDiscovery services *:credential-store:*:*:1.0 - (optional) credential stores to resolve credentials  Constructors InheritMongoDbPersistence Creates a new instance of the persistence component.\n InheritMongoDbPersistence(overrides IMongoDbPersistenceOverrides, proto reflect.Type, collection string) *MongoDbPersistence\n  overrides: IMongoDbPersistenceOverrides - TODO: add description proto: reflect.Type - TODO: add description collection: string - (optional) collection name.  Fields DependencyResolver The dependency resolver.\n DependencyResolver: DependencyResolver\n Logger The logger.\n Logger: CompositeLogger\n Connection The MongoDB connection component.\n Connection: *MongoDBConnection\n CollectionName The MongoDB colleciton name.\n CollectionName: string;\n Collection The MongoDb collection object.\n Collection: *mongodrv.Collection\n Client The MongoDB connection pool object.\n Client: *mongodrv.Client\n DatabaseName The MongoDB database name.\n DatabaseName: string\n Db The MongoDb database object.\n Db *mongodrv.Database\n maxPageSize The maximum number of records to return from the database per request.\n maxPageSize: number = 100\n \u0026lt;/span\nMethods Clear Clears a component\u0026rsquo;s state.\n (c *MongoDbPersistence) Clear(correlationId string) error\n  correlationId: string - object to convert from the public partial format. returns: error - error or nil no errors occured.  Close Closes the component and frees used resources.\n (c *MongoDbPersistence) Close(correlationId string) error\n  correlationId: string - object to convert from the public partial format. returns: error - error or nil no errors occured.  Configure Closes the component and frees used resources.\n (c *MongoDbPersistence) Configure(config *cconf.ConfigParams)\n  config: *cconf.ConfigParams - configuration parameters to be set.  ConvertFromPublic Converts an object value from public to internal format.\n (c *MongoDbPersistence) ConvertFromPublic(item interface{}) interface{}\n  value: interface{} - object in public format to convert. returns: interface{} - converted object in internal format.  ConvertToPublic Converts and object value from internal to public format.\n (c *MongoDbPersistence) ConvertToPublic(value interface{}) interface{}\n  value: interface{} - object in internal format to convert. returns: interface{} - converted object in public format.  Create Creates a data item.\n (c *MongoDbPersistence) Create(correlationId string, item interface{}) (result interface{}, err error)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. item: interface{} - item to be created. returns: (result interface{}, err error) - created item  DefineSchema Defines the database schema\n (c *MongoDbPersistence) DefineSchema()\n DeleteByFilter This method shall be called by a public DeleteByFilter method from the child class that receives FilterParams and converts them into a filter function.\n (c *MongoDbPersistence) DeleteByFilter(correlationId string, filter interface{}) error\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. filter: interface{} - (optional) filter function used to filter items. returns: error - error or nil no errors occured.  EnsureIndex Adds index definition to create it on opening.\n (c *MongoDbPersistence) EnsureIndex(keys interface{}, options *mongoopt.IndexOptions)\n  keys: interface{} - index keys (fields) options: *mongoopt.IndexOptions - index options  GetCountByFilter Gets a number of data items retrieved by a given filter.\nThis method shall be called by a public GetCountByFilter method from the child class that receives FilterParams and converts them into a filter function.\n (c *MongoDbPersistence) GetCountByFilter(correlationId string, filter interface{}) (count int64, err error)\n  correlationId: string - (optional) transaction id usedto trace execution through the call chain. filter: interface{} - (optional) filter JSON object returns: (count int64, err error) - number of filtered items.  GetListByFilter Gets a list of data items retrieved by a given filter and sorted according to sort parameters.\nThis method shall be called by a public GetListByFilter method from the child class that receives FilterParams and converts them into a filter function.\n (c *MongoDbPersistence) GetListByFilter(correlationId string, filter interface{}, sort interface{}, sel interface{}) (items []interface{}, err error)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. filter: interface{} - (optional) filter function used to filter items sort: interface{} - (optional) sorting parameters select: interface{} - (optional) projection parameters (not used yet) returns: (items []interface{}, err error) - data list of results by filter.  GetOneRandom Gets a random item from items that match to a given filter.\nThis method shall be called by a public GetOneRandom method from the child class that receives FilterParams and converts them into a filter function.\n (c *MongoDbPersistence) GetOneRandom(correlationId string, filter interface{}) (item interface{}, err error)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. filter: interface{} - fileter JSON object. returns: (item interface{}, err error) - random item.  GetPageByFilter Gets a page of data items retrieved by a given filter and sorted according to sort parameters.\nThis method shall be called by a public GetPageByFilter method from the child class that receives FilterParams and converts them into a filter function.\n (c *MongoDbPersistence) GetPageByFilter(correlationId string, filter interface{}, paging *cdata.PagingParams, sort interface{}, sel interface{}) (page *cdata.DataPage, err error)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. filter: interface{} - (optional) filter JSON object paging: *cdata.PagingParams - (optional) paging parameters sort: interface{} - (optional) sorting JSON object sel: interface{} - (optional) projection JSON object returns: (page *cdata.DataPage, err error) - data page obtained by filtering  Examples type MyMongoDbPersistence struct { MongoDbPersistence } func NewMyMongoDbPersistence(proto reflect.Type, collection string) *MyMongoDbPersistence { mc:= MyMongoDbPersistence{} mc.MongoDbPersistence = NewMongoDbPersistence(proto, collection) return \u0026amp;mc } func (c * MyMongoDbPersistence) GetByName(correlationId string, name string) (item interface{}, err error) { filter := bson.M{\u0026#34;name\u0026#34;: name} docPointer := NewObjectByPrototype(c.Prototype) foRes := c.Collection.FindOne(context.TODO(), filter) ferr := foRes.Decode(docPointer.Interface()) if ferr != nil { if ferr == mongo.ErrNoDocuments { return nil, nil } return nil, ferr } item = docPointer.Elem().Interface() c.Overrides.ConvertToPublic(\u0026amp;item) return item, nil } func (c * MyMongoDbPersistence) Set(correlatonId string, item MyData) (result interface{}, err error) { newItem = cmpersist.CloneObject(item, c.Prototype) // Assign unique id if not exist  cmpersist.GenerateObjectId(\u0026amp;newItem) id := cmpersist.GetObjectId(newItem) c.Overrides.ConvertFromPublic(\u0026amp;newItem) filter := bson.M{\u0026#34;_id\u0026#34;: id} var options mngoptions.FindOneAndReplaceOptions retDoc := mngoptions.After options.ReturnDocument = \u0026amp;retDoc upsert := true options.Upsert = \u0026amp;upsert frRes := c.Collection.FindOneAndReplace(context.TODO(), filter, newItem, \u0026amp;options) if frRes.Err() != nil { return nil, frRes.Err() } docPointer := NewObjectByPrototype(c.Prototype) err = frRes.Decode(docPointer.Interface()) if err != nil { if err == mongo.ErrNoDocuments { return nil, nil } return nil, err } item = docPointer.Elem().Interface() c.Overrides.ConvertToPublic(\u0026amp;item) return item, nil } persistence := NewMyMongoDbPersistence(reflect.TypeOf(MyData{}), \u0026#34;mycollection\u0026#34;) persistence.Configure(NewConfigParamsFromTuples( \u0026#34;host\u0026#34;, \u0026#34;localhost\u0026#34;, \u0026#34;port\u0026#34;, \u0026#34;27017\u0026#34;, \u0026#34;database\u0026#34;, \u0026#34;test\u0026#34;, )) opnErr := persitence.Open(\u0026#34;123\u0026#34;) if opnErr != nil { ... } resItem, setErr := persistence.Set(\u0026#34;123\u0026#34;, MyData{ name: \u0026#34;ABC\u0026#34; }) if setErr != nil { ... } item, getErr := persistence.GetByName(\u0026#34;123\u0026#34;, \u0026#34;ABC\u0026#34;) if getErr != nil { ... } fmt.Println(item) // Result: { name: \u0026#34;ABC\u0026#34; } (\u0026#34;123\u0026#34;, \u0026#34;ABC\u0026#34;) ","description":"Abstract persistence component that stores data in MongoDB using the official MongoDB driver.\n","image":null,"permalink":"/golang/mongodb/persistence/mongodb_persistence/","subtitle":null,"tags":null,"title":"MongoDbPersistence"},{"content":"Inherits: IReferenceable, IUnreferenceable, IConfigurable, IOpenable, ICleanable\nDescription The MongoDbPersistence class allows you to create persistence components that store data in MongoDBs using the official MongoDB driver.\nImportant points\n This is the most basic persistence component that is only able to store data items of any type. Specific CRUD operations over the data items must be implemented in child classes by accessing this._collection or this.__model properties.  Configuration parameters  collection: (optional) MongoDB collection name  connection(s):\n discovery_key: (optional) key to retrieve the connection from IDiscovery host: host name or IP address port: port number (default: 27017) uri: resource URI or connection string with all parameters in it  credential(s):\n store_key: (optional) key to retrieve the credentials from ICredentialStore username: (optional) username password: (optional) user\u0026rsquo;s password  options:\n max_pool_size: (optional) maximum connection pool size (default: 2) keep_alive: (optional) enable connection keep alive (default: true) connect_timeout: (optional) connection timeout in milliseconds (default: 5 sec) auto_reconnect: (optional) enable auto reconnection (default: true) max_page_size: (optional) maximum page size (default: 100) debug: (optional) enable debug output (default: false).  References  *:logger:*:*:1.0 - (optional) ILogger components to pass log messages *:discovery:*:*:1.0 - (optional) IDiscovery services *:credential-store:*:*:1.0 - (optional) credential stores to resolve credentials  Constructors Creates a new instance of the persistence component.\n public MongoDbPersistence(string collectionName)\n  collectionName: string - (optional) collection name.  Fields _dependencyResolver The dependency resolver.\n protected _dependencyResolver: DependencyResolver\n _logger The logger.\n protected _logger: CompositeLogger\n _connection The MongoDB connection component.\n protected _connection: MongoDBConnection\n _collectionName The MongoDB colleciton name.\n protected _collectionName: string;\n _collection The MongoDb collection object.\n protected _collection: IMongoCollection\u0026lt;T\u0026gt;\n _client The MongoDB connection pool object.\n protected _client: MongoClient\n _database The MongoDb database object.\n protected _database: IMongoDatabase\n _maxPageSize The maximum number of records to return from the database per request.\n protected _maxPageSize: int = 100\n \u0026lt;/span\nInstance methods ClearAsync Clears a component\u0026rsquo;s state.\n public virtual Task ClearAsync(string correlationId)\n  correlationId: string - object to convert from the public partial format.  CloseAsync Closes the component and frees used resources.\n public virtual Task CloseAsync(string correlationId)\n  correlationId: string - object to convert from the public partial format.  Configure Closes the component and frees used resources.\n public virtual void Configure(ConfigParams config)\n  config: ConfigParams - configuration parameters to be set.  CreateAsync Creates a data item.\n public virtual async Task\u0026lt;T\u0026gt; CreateAsync(string correlationId, T item)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. item: T - item to be created. returns: Task\u0026lt;T\u0026gt; - created item  DeleteByFilterAsync This method shall be called by a public DeleteByFilterAsync method from the child class that receives FilterParams and converts them into a filter function.\n public virtual Task DeleteByFilterAsync(string correlationId, FilterDefinition\u0026lt;T\u0026gt; filterDefinition)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. filterDefinition: FilterDefinition\u0026lt;T\u0026gt; - (optional) filter function used to filter items.  GetListByFilterAsync Gets a list of data items retrieved by a given filter and sorted according to sort parameters.\nThis method shall be called by a public GetListByFilterAsync method from the child class that receives FilterParams and converts them into a filter function.\n public virtual Task\u0026lt;List\u0026lt;T\u0026gt;\u0026gt; GetListByFilterAsync(string correlationId, FilterDefinition\u0026lt;T\u0026gt; filterDefinition, SortDefinition\u0026lt;T\u0026gt; sortDefinition = null)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. filterDefinition: FilterDefinition\u0026lt;T\u0026gt; - (optional) filter function used to filter items sortDefinition: SortDefinition\u0026lt;T\u0026gt; - (optional) sorting parameters returns: Task\u0026lt;List\u0026lt;T\u0026gt;\u0026gt; - data list of results by filter.  GetOneRandomAsync Gets a random item from items that match to a given filter.\nThis method shall be called by a public GetOneRandomAsync method from the child class that receives FilterParams and converts them into a filter function.\n public virtual async Task\u0026lt;T\u0026gt; GetOneRandomAsync(string correlationId, FilterDefinition\u0026lt;T\u0026gt; filterDefinition)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. filterDefinition: FilterDefinition\u0026lt;T\u0026gt; - fileter JSON object. returns: Task\u0026lt;T\u0026gt; - random item.  GetPageByFilter Gets a page of data items retrieved by a given filter and sorted according to sort parameters.\nThis method shall be called by a public GetPageByFilter method from the child class that receives FilterParams and converts them into a filter function.\n public virtual Task\u0026lt;DataPage\u0026lt;T\u0026gt;\u0026gt; GetPageByFilterAsync(string correlationId, FilterDefinition\u0026lt;T\u0026gt; filterDefinition, PagingParams paging = null, SortDefinition\u0026lt;T\u0026gt; sortDefinition = null)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. filterDefinition: FilterDefinition\u0026lt;T\u0026gt; - (optional) filter JSON object paging: PagingParams - (optional) paging parameters sortDefinition: SortDefinition\u0026lt;T\u0026gt; - (optional) sorting JSON object returns: Task\u0026lt;DataPage\u0026lt;T\u0026gt;\u0026gt; - data page obtained by filtering  UnsetReferences Unsets (clears) previously set references to dependent components.\n public virtual void UnsetReferences()\n SetReferences Sets references to dependent components.\n public virtual void SetReferences(IReferences references)\n  references: IReferences - references to locate the component dependencies.  Examples class MyMongoDbPersistence: MongoDbPersistence\u0026lt;MyData\u0026gt; { public MyMongoDbPersistence() { base(\u0026#34;mydata\u0026#34;); } public MyData getByName(string correlationId, string name) { var builder = Builders\u0026lt;BeaconV1\u0026gt;.Filter; var filter = builder.Eq(x =\u0026gt; x.Name, name); var result = await _collection.Find(filter).FirstOrDefaultAsync(); return result; } public MyData set(String correlatonId, MyData item) { var filter = Builders\u0026lt;T\u0026gt;.Filter.Eq(x =\u0026gt; x.Id, item.Id); var options = new FindOneAndReplaceOptions\u0026lt;T\u0026gt; { ReturnDocument = ReturnDocument.After, IsUpsert = true }; var result = await _collection.FindOneAndReplaceAsync(filter, item, options); return result; } } var persistence = new MyMongoDbPersistence(); persistence.Configure(ConfigParams.FromTuples( \u0026#34;host\u0026#34;, \u0026#34;localhost\u0026#34;, \u0026#34;port\u0026#34;, 27017 )); persitence.Open(\u0026#34;123\u0026#34;); var mydata = new MyData(\u0026#34;ABC\u0026#34;); persistence.Set(\u0026#34;123\u0026#34;, mydata); persistence.GetByName(\u0026#34;123\u0026#34;, \u0026#34;ABC\u0026#34;); Console.Out.WriteLine(item); // Result: { name: \u0026#34;ABC\u0026#34; } ","description":"Abstract persistence component that stores data in MongoDB using the official MongoDB driver.\n","image":null,"permalink":"/net/mongodb/persistence/mongodb_persistence/","subtitle":null,"tags":null,"title":"MongoDbPersistence\u003cT\u003e"},{"content":"Implements: IReferenceable, IUnreferenceable, IConfigurable, IOpenable, ICleanable\nDescription The MongoDbPersistence class allows you to create persistence components that store data in MongoDBs using the official MongoDB driver.\nImportant points\n This is the most basic persistence component that is only able to store data items of any type. Specific CRUD operations over the data items must be implemented in child classes by accessing this.__collection or this.__model properties.  Configuration parameters  collection: (optional) MongoDB collection name  connection(s):\n discovery_key: (optional) key to retrieve the connection from IDiscovery host: host name or IP address port: port number (default: 27017) uri: resource URI or connection string with all parameters in it  credential(s):\n store_key: (optional) key to retrieve the credentials from ICredentialStore username: (optional) username password: (optional) user\u0026rsquo;s password  options:\n max_pool_size: (optional) maximum connection pool size (default: 2) keep_alive: (optional) enable connection keep alive (default: true) connect_timeout: (optional) connection timeout in milliseconds (default: 5000) socket_timeout: (optional) socket timeout in milliseconds (default: 360000) auto_reconnect: (optional) enable auto reconnection (default: true) reconnect_interval: (optional) reconnection interval in milliseconds (default: 1000) max_page_size: (optional) maximum page size (default: 100) replica_set: (optional) name of replica set ssl: (optional) enable SSL connection (default: false) auth_source: (optional) authentication source debug: (optional) enable debug output (default: false).  References  *:logger:*:*:1.0 - (optional) ILogger components to pass log messages *:discovery:*:*:1.0 - (optional) IDiscovery services *:credential-store:*:*:1.0 - (optional) credential stores to resolve credentials  Constructors Creates a new instance of the persistence component.\n public constructor(collection?: string)\n  collection: string - (optional) collection name.  Fields _dependencyResolver The dependency resolver.\n protected _dependencyResolver: DependencyResolver\n _logger The logger.\n protected _logger: CompositeLogger\n _connection The MongoDB connection component.\n protected _connection: MongoDBConnection\n _collectionName The MongoDB colleciton name.\n protected _collectionName: string;\n _collection The MongoDb collection object.\n protected _collection: any\n _client The MongoDB connection pool object.\n protected _client: any\n _databaseName The MongoDB database name.\n protected _databaseName: string\n _tableName The MongoDB table object.\n protected _tableName: string\n _db The MongoDb database object.\n protected _db: any\n _maxPageSize The maximum number of records to return from the database per request.\n protected _maxPageSize: number = 100\n \u0026lt;/span\nInstance methods clear Clears a component\u0026rsquo;s state.\n public clear(correlationId: string): Promise\u0026lt;void\u0026gt;\n  correlationId: string - object to convert from the public partial format.  clearSchema Clears all auto-created objects\n protected clearSchema(): void\n close Closes the component and frees used resources.\n public close(correlationId: string): Promise\u0026lt;void\u0026gt;\n  correlationId: string - object to convert from the public partial format.  configure Closes the component and frees used resources.\n public configure(config: ConfigParams): void\n  config: ConfigParams - configuration parameters to be set.  convertFromPublic Converts an object value from public to internal format.\n protected convertFromPublic(value: any): any\n  value: any - object in public format to convert. returns: any - converted object in internal format.  convertToPublic Converts and object value from internal to public format.\n protected convertToPublic(value: any): any\n  value: any - object in internal format to convert. returns: any - converted object in public format.  create Creates a data item.\n public create(correlationId: string, item: T): Promise\u0026lt;T\u0026gt;\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. item: T - item to be created. returns: Promise\u0026lt;T\u0026gt; - created item  defineSchema Defines the database schema\n protected defineSchema(): void\n deleteByFilter This method shall be called by a public deleteByFilter method from the child class that receives FilterParams and converts them into a filter function.\n public deleteByFilter(correlationId: string, filter: any): Promise\u0026lt;void\u0026gt;\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. filter: any - (optional) filter function used to filter items.  ensureIndex Adds index definition to create it on opening.\n protected ensureIndex(keys: any, options?: any): void\n  keys: any - index keys (fields) options: any - index options  getCountByFilter Gets a number of data items retrieved by a given filter.\nThis method shall be called by a public getCountByFilter method from the child class that receives FilterParams and converts them into a filter function.\n protected getCountByFilter(correlationId: string, filter: any): Promise\u0026lt;number\u0026gt;\n  correlationId: string - (optional) transaction id usedto trace execution through the call chain. filter: any - (optional) filter JSON object returns: Promise\u0026lt;number\u0026gt; - number of filtered items.  getListByFilter Gets a list of data items retrieved by a given filter and sorted according to sort parameters.\nThis method shall be called by a public getListByFilter method from the child class that receives FilterParams and converts them into a filter function.\n protected getListByFilter(correlationId: string, filter: any, sort: any, select: any): Promise\u0026lt;T[]\u0026gt;\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. filter: any - (optional) filter function used to filter items sort: any - (optional) sorting parameters select: any - (optional) projection parameters (not used yet) returns: Promise\u0026lt;T[]\u0026gt; - data list of results by filter.  getOneRandom Gets a random item from items that match to a given filter.\nThis method shall be called by a public getOneRandom method from the child class that receives FilterParams and converts them into a filter function.\n protected getOneRandom(correlationId: string, filter: any): Promise\u0026lt;T\u0026gt;\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. filter: any - fileter JSON object. returns: Promise\u0026lt;T\u0026gt; - random item.  getPageByFilter Gets a page of data items retrieved by a given filter and sorted according to sort parameters.\nThis method shall be called by a public getPageByFilter method from the child class that receives FilterParams and converts them into a filter function.\n protected getPageByFilter(correlationId: string, filter: any, paging: PagingParams, sort: any, select: any): Promise\u0026lt;DataPage\u0026lt;T\u0026gt;\u0026gt;\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. filter: any - (optional) filter JSON object paging: PagingParams - (optional) paging parameters sort: any - (optional) sorting JSON object select: any - (optional) projection JSON object returns: Promise\u0026lt;DataPage\u0026lt;T\u0026gt;\u0026gt; - data page obtained by filtering  Examples class MyMongoDbPersistence extends MongoDbPersistence\u0026lt;MyData\u0026gt; { public constructor() { base(\u0026#34;mydata\u0026#34;); } public async getByName(correlationId: string, name: string) { let criteria = { name: name }; return await new Promise((resolve, reject) =\u0026gt; { this._model.findOne(criteria, (err, item) =\u0026gt; { if (err == null) resolve(item); else reject(err); }); }); } public async set(correlatonId: string, item: MyData) { let criteria = { name: item.name }; let options = { upsert: true, new: true }; return await new Promise((resolve, reject) =\u0026gt; { this._model.findOneAndUpdate(criteria, item, options, (err, item) =\u0026gt; { if (err == null) resolve(item); else reject(err); }); }); } } let persistence = new MyMongoDbPersistence(); persistence.configure(ConfigParams.fromTuples( \u0026#34;host\u0026#34;, \u0026#34;localhost\u0026#34;, \u0026#34;port\u0026#34;, 27017 )); await persitence.open(\u0026#34;123\u0026#34;); await persistence.set(\u0026#34;123\u0026#34;, { name: \u0026#34;ABC\u0026#34; }); let item = await persistence.getByName(\u0026#34;123\u0026#34;, \u0026#34;ABC\u0026#34;); console.log(item); // Result: { name: \u0026#34;ABC\u0026#34; } ","description":"Abstract persistence component that stores data in MongoDB using the official MongoDB driver.\n","image":null,"permalink":"/node/mongodb/persistence/mongodb_persistence/","subtitle":null,"tags":null,"title":"MongoDbPersistence"},{"content":"Implements: IReferenceable, IUnreferenceable, IConfigurable, IOpenable, ICleanable\nDescription The MongoDbPersistence class allows you to create persistence components that store data in MongoDBs using the official MongoDB driver.\nImportant points\n This is the most basic persistence component that is only able to store data items of any type. Specific CRUD operations over the data items must be implemented in child classes by accessing self.__collection or self.__model properties.  Configuration parameters  collection: (optional) MongoDB collection name  connection(s):\n discovery_key: (optional) key to retrieve the connection from IDiscovery host: host name or IP address port: port number (default: 27017) uri: resource URI or connection string with all parameters in it  credential(s):\n store_key: (optional) key to retrieve the credentials from ICredentialStore username: (optional) username password: (optional) user\u0026rsquo;s password  options:\n max_pool_size: (optional) maximum connection pool size (default: 2) keep_alive: (optional) enable connection keep alive (default: true) connect_timeout: (optional) connection timeout in milliseconds (default: 5000) socket_timeout: (optional) socket timeout in milliseconds (default: 360000) auto_reconnect: (optional) enable auto reconnection (default: true) reconnect_interval: (optional) reconnection interval in milliseconds (default: 1000) max_page_size: (optional) maximum page size (default: 100) replica_set: (optional) name of replica set ssl: (optional) enable SSL connection (default: false) auth_source: (optional) authentication source debug: (optional) enable debug output (default: false).  References  *:logger:*:*:1.0 - (optional) ILogger components to pass log messages *:discovery:*:*:1.0 - (optional) IDiscovery services *:credential-store:*:*:1.0 - (optional) credential stores to resolve credentials  Constructors Creates a new instance of the persistence component.\n MongoDbPersistence(collection: str = None)\n  collection: str - (optional) collection name.  Instance methods clear Clears a component\u0026rsquo;s state.\n clear(correlation_id: Optional[str])\n  correlation_id: Optional[str]- object to convert from the public partial format.  _clear_schema Clears all auto-created objects\n _clear_schema()\n close Closes the component and frees used resources.\n close(correlation_id: Optional[str])\n  correlation_id: Optional[str]- object to convert from the public partial format.  configure Closes the component and frees used resources.\n configure(config: ConfigParams)\n  config: ConfigParams - configuration parameters to be set.  _convert_from_public Converts an object value from public to internal format.\n _convert_from_public(value: Any): Any\n  value: Any - object in public format to convert. returns: Any - converted object in internal format.  _convert_to_public Converts and object value from internal to public format.\n _convert_to_public(value: Any): Any\n  value: Any - object in internal format to convert. returns: Any - converted object in public format.  create Creates a data item.\n create(correlation_id: Optional[str], item: T): Optional[T]\n  correlation_id: Optional[str] - (optional) transaction id used to trace execution through the call chain. item: T - item to be created. returns: Optional[T] - created item  _define_schema Defines the database schema\n _define_schema()\n delete_by_filter This method shall be called by a public delete_by_filter method from the child class that receives FilterParams and converts them into a filter function.\n delete_by_filter(correlation_id: Optional[str], filter: Any)\n  correlation_id: Optional[str] - (optional) transaction id used to trace execution through the call chain. filter: Any - (optional) filter function used to filter items.  _ensure_index Adds index definition to create it on opening.\n _ensure_index(keys: Any, options: Any = None)\n  keys: Any - index keys (fields) options: Any - index options  get_count_by_filter Gets a number of data items retrieved by a given filter.\nThis method shall be called by a public get_count_by_filter method from the child class that receives FilterParams and converts them into a filter function.\n get_count_by_filter(correlation_id: Optional[str], filter: Any): int\n  correlation_id: Optional[str] - (optional) transaction id usedto trace execution through the call chain. filter: Any - (optional) filter JSON object returns: int - number of filtered items.  get_list_by_filter Gets a list of data items retrieved by a given filter and sorted according to sort parameters.\nThis method shall be called by a public get_list_by_filter method from the child class that receives FilterParams and converts them into a filter function.\n get_list_by_filter(correlation_id: Optional[str], filter: Any, sort: Any = None, select: Any = None): List[T]\n  correlation_id: Optional[str] - (optional) transaction id used to trace execution through the call chain. filter: Any - (optional) filter function used to filter items sort: Any - (optional) sorting parameters select: Any - (optional) projection parameters (not used yet) returns: List[dict] - data list of results by filter.  get_one_random Gets a random item from items that match to a given filter.\nThis method shall be called by a public get_one_random method from the child class that receives FilterParams and converts them into a filter function.\n get_one_random(correlation_id: Optional[str], filter: Any): Optional[T]\n  correlation_id: Optional[str] - (optional) transaction id used to trace execution through the call chain. filter: Any - fileter JSON object. returns: Optional[T] - random item.  get_page_by_filter Gets a page of data items retrieved by a given filter and sorted according to sort parameters.\nThis method shall be called by a public get_page_by_filter method from the child class that receives FilterParams and converts them into a filter function.\n get_page_by_filter(correlation_id: Optional[str], filter: Any, paging: PagingParams, sort: Any = None, select: Any = None): DataPage\n  correlation_id: Optional[str] - (optional) transaction id used to trace execution through the call chain. filter: Any - (optional) filter JSON object paging: PagingParams - (optional) paging parameters sort: Any - (optional) sorting JSON object select: Any - (optional) projection JSON object returns: DataPage - data page obtained by filtering  Examples class MyMongoDbPersistence(MongoDbPersistence): def __init__(self): super(MyMongoDbPersistence, self).__init__(\u0026#34;mydata\u0026#34;, MyData) def get_by_name(self, correlationId, name): item = self._collection.find_one({ \u0026#39;name\u0026#39;: name }) return item def set(self, correlationId, item): item = self._collection.find_one_and_update( { \u0026#39;_id\u0026#39;: item.id }, { \u0026#39;$set\u0026#39;: item }, return_document = pymongo.ReturnDocument.AFTER, upsert = True ) persistence = MyMongoDbPersistence() persistence.configure(ConfigParams.from_tuples(\u0026#34;host\u0026#34;, \u0026#34;localhost\u0026#34;, \u0026#34;port\u0026#34;, 27017)) persitence.open(\u0026#34;123\u0026#34;) persistence.set(\u0026#34;123\u0026#34;, { name: \u0026#34;ABC\u0026#34; }) item = persistence.get_by_name(\u0026#34;123\u0026#34;, \u0026#34;ABC\u0026#34;) print(item) ","description":"Abstract persistence component that stores data in MongoDB using the official MongoDB driver.\n","image":null,"permalink":"/python/mongodb/persistence/mongodb_persistence/","subtitle":null,"tags":null,"title":"MongoDbPersistence"},{"content":"Description The MultiString class allows you to create objects that contain string translations for multiple languages.\nImportant points\n Language keys use two-letter codes like: \u0026lsquo;en\u0026rsquo;, \u0026lsquo;sp\u0026rsquo;, \u0026lsquo;de\u0026rsquo;, \u0026lsquo;ru\u0026rsquo;, \u0026lsquo;fr\u0026rsquo;, \u0026lsquo;pr\u0026rsquo;. When a translation for a specific language does not exists, it defaults to English (\u0026lsquo;en\u0026rsquo;). When English does not exists, it falls back to the first defined language  Examples values := MultiString.FromTuples( \u0026#34;en\u0026#34;, \u0026#34;Hello World!\u0026#34;, \u0026#34;ru\u0026#34;, \u0026#34;Привет мир!\u0026#34; ); value1 := values.Get(\u0026#34;ru\u0026#34;); // Result: \u0026#34;Привет мир!\u0026#34; value2 := values.Get(\u0026#34;pt\u0026#34;); // Result: \u0026#34;Hello World!\u0026#34;  ","description":"Class used to create objects that contain string translations for multiple languages.\n","image":null,"permalink":"/golang/commons/data/multi_string/","subtitle":null,"tags":null,"title":"MultiString"},{"content":"Description The MultiString class allows you to create objects that contain string translations for multiple languages.\nImportant points\n Language keys use two-letter codes like: \u0026lsquo;en\u0026rsquo;, \u0026lsquo;sp\u0026rsquo;, \u0026lsquo;de\u0026rsquo;, \u0026lsquo;ru\u0026rsquo;, \u0026lsquo;fr\u0026rsquo;, \u0026lsquo;pr\u0026rsquo;. When a translation for a specific language does not exists, it defaults to English (\u0026lsquo;en\u0026rsquo;). When English does not exists, it falls back to the first defined language  Constructors Creates a new MultiString object and initializes it with values.\n public constructor(map: any = null)\n  map: any - a map with language-text pairs.  Instance methods append Appends a map with language-translation pairs.\n public append(map: any): void\n  map: any - map with language-translation pairs.  clear Clears all translations from this MultiString object.\n public clear(): void\n get Gets a string translation by specified language. When the language is not found, it defaults to English (\u0026lsquo;en\u0026rsquo;). When English is not found, it takes the first value.\n public get(language: string): string\n  language: string - language\u0026rsquo;s two-symbol code. returns: string - translation for the specified language or default translation.  getLanguages Gets all languages stored in this MultiString object.\n public getLanguages(): string[]\n  returns: string[] - list with language codes.  length Returns the number of translations stored in this MultiString object.\n public length(): number\n  returns: number - number of translations.  put Puts a new translation for the specified language.\n public put(language: string, value: any): void\n  language: string - language\u0026rsquo;s two-symbol code. value: any - new translation for the specified language.  remove Removes a translation for the specified language.\n public remove(language: string): void\n  language: string - language\u0026rsquo;s two-symbol code.  Static methods fromTuples Creates a new MultiString object from language-translation pairs (tuples).\n public static fromTuples(\u0026hellip;tuples: any[]): MultiString\n  tuples: any[] - array that contains language-translation tuples. returns: MultiString - MultiString Object.  fromTuplesArray Creates a new MultiString object from language-translation pairs (tuples) specified as array.\n public static fromTuplesArray(tuples: any[]): MultiString\n  tuples: any[] - array that contains language-translation tuples. returns: MultiString - MultiString Object.  fromValue Creates a new MultiString object from a value that contains language-translation pairs.\nSee StringValueMap\n public static fromValue(value: any): MultiString\n  value: any - value used to initialize a MultiString object. returns: MultiString - MultiString object.  Examples let values = MultiString.fromTuples( \u0026#34;en\u0026#34;, \u0026#34;Hello World!\u0026#34;, \u0026#34;ru\u0026#34;, \u0026#34;Привет мир!\u0026#34; ); let value1 = values.get(\u0026#39;ru\u0026#39;); // Result: \u0026#34;Привет мир!\u0026#34; let value2 = values.get(\u0026#39;pt\u0026#39;); // Result: \u0026#34;Hello World!\u0026#34;  ","description":"Class used to create objects that contain string translations for multiple languages.\n","image":null,"permalink":"/node/commons/data/multi_string/","subtitle":null,"tags":null,"title":"MultiString"},{"content":"Implements: dict\nDescription The MultiString class allows you to create objects that contain string translations for multiple languages.\nImportant points\n Language keys use two-letter codes like: \u0026lsquo;en\u0026rsquo;, \u0026lsquo;sp\u0026rsquo;, \u0026lsquo;de\u0026rsquo;, \u0026lsquo;ru\u0026rsquo;, \u0026lsquo;fr\u0026rsquo;, \u0026lsquo;pr\u0026rsquo;. When a translation for a specific language does not exists, it defaults to English (\u0026lsquo;en\u0026rsquo;). When English does not exists, it falls back to the first defined language  Constructors Creates a new MultiString object and initializes it with values.\n MultiString(map: Any = None)\n  map: Any - a map with language-text pairs.  Instance methods append Appends a map with language-translation pairs.\n append(map: Any)\n  map: Any - the map with language-translation pairs.  clear Clears all translations from this MultiString object.\n clear()\n get Gets a string translation by specified language. When language is not found it defaults to English (\u0026lsquo;en\u0026rsquo;). When English is not found it takes the first value.\n get(language: str): str\n  language: str - a language two-symbol code. returns: str - a translation for the specified language or default translation.  get_languages Gets all languages stored in this MultiString object.\n get_languages(): List[str]\n  returns: List[str] - a list with language codes.  length Returns the number of translations stored in this MultiString object.\n length(): int\n  returns: int - the number of translations.  put Puts a new translation for the specified language.\n put(language: str, value: Any): Any\n  language: str - a language two-symbol code. value: Any - a new translation for the specified language.  remove Removes translation for the specified language.\n remove(language: str)\n  language: str - a language two-symbol code.  Static methods from_tuples Creates a new MultiString object from language-translation pairs (tuples).\n static from_tuples(*tuples: Any): MultiString\n  tuples: Any - an array that contains language-translation tuples. returns: MultiString - a MultiString Object.  from_tuples_array Creates a new MultiString object from language-translation pairs (tuples) specified as array.\n static from_tuples_array(tuples: Sequence[Any]): MultiString\n  tuples: Sequence[Any] - an array that contains language-translation tuples. returns: MultiString - a MultiString Object.  from_value Creates a new MultiString object from a value that contains language-translation pairs.\nSee StringValueMap\n static from_value(value: Any): MultiString\n  value: Any - the value to initialize MultiString. returns: MultiString - a MultiString object.  Examples values = MultiString.from_tuples( \u0026#34;en\u0026#34;, \u0026#34;Hello World!\u0026#34;, \u0026#34;ru\u0026#34;, \u0026#34;Привет мир!\u0026#34; ); value1 = values.get(\u0026#39;ru\u0026#39;) # Result: \u0026#34;Привет мир!\u0026#34; value2 = values.get(\u0026#39;pt\u0026#39;) # Result: \u0026#34;Hello World!\u0026#34; ","description":"Class used to create objects that contain string translations for multiple languages.\n","image":null,"permalink":"/python/commons/data/multi_string/","subtitle":null,"tags":null,"title":"MultiString"},{"content":"","description":"Class used to create objects that contain string translations for multiple languages.\n\n**Note: this class is not available for this language**\n","image":null,"permalink":"/net/commons/data/multi_string/","subtitle":null,"tags":null,"title":"MultiString!"},{"content":"Description The MustacheErrorCode class provides definitions for general syntax errors.\nFields ErrorAt Error at\n public static ErrorAt: string = \u0026ldquo;ERROR_AT\u0026rdquo;\n ErrorNear Error near\n public static ErrorNear: string = \u0026ldquo;ERROR_NEAR\u0026rdquo;;\n Internal Internal error\n public static Internal: string = \u0026ldquo;INTERNAL\u0026rdquo;\n MismatchedBrackets Mismatched brackets\n public static MismatchedBrackets: string = \u0026ldquo;MISTMATCHED_BRACKETS\u0026rdquo;\n MissingVariable Missing variable\n public static MissingVariable: string = \u0026ldquo;MISSING_VARIABLE\u0026rdquo;\n NotClosedSection Not closed section\n public static NotClosedSection: string = \u0026ldquo;NOT_CLOSED_SECTION\u0026rdquo;\n UnexpectedEnd Unexpected end\n public static UnexpectedEnd: string = \u0026ldquo;UNEXPECTED_END\u0026rdquo;\n UnexpectedSectionEnd Unexpected section end\n public static UnexpectedSectionEnd: string = \u0026ldquo;UNEXPECTED_SECTION_END\u0026rdquo;\n UnexpectedSymbol Unexpected symbol\n public static UnexpectedSymbol: string = \u0026ldquo;UNEXPECTED_SYMBOL\u0026rdquo;\n Unknown Unknown symbol\n public static Unknown: string = \u0026ldquo;UNKNOWN\u0026rdquo;\n  ","description":"General syntax errors.\n","image":null,"permalink":"/node/expressions/mustache/parsers/mustache_error_code/","subtitle":null,"tags":null,"title":"MustacheErrorCode"},{"content":"Extends: BadRequestException\nDescription The MustacheException class defines an exception that can e thrown by a Mustache template.\nConstructors Creates a new instance of the MustacheException class.\n public constructor(correlationId: string, code: string, message: string, line: number, column: number)\n  correlationId: string - transaction id used to trace execution through the call chain. code: string - code message: string - human-readable message line: number - line number column: number - column number  ","description":"Exception that can be thrown by a Mustache template.\n","image":null,"permalink":"/node/expressions/mustache/mustache_exception/","subtitle":null,"tags":null,"title":"MustacheException"},{"content":"Description The MustacheLexicalState enum defines different states in Mustache lexical analysis.\nEnumeration members The codes are as follows:\n Value = 0 Operator1 = 1 Operator2 = 2 Variable = 3 Comment = 4 Closure = 5  ","description":"Defines states in Mustache lexical analysis.\n","image":null,"permalink":"/node/expressions/mustache/parsers/mustache_lexical_state/","subtitle":null,"tags":null,"title":"MustacheLexicalState"},{"content":"Description The MustacheParser class allows you to implement a Mustache parser.\nProperties initialTokens List of original Mustache tokens.\n public initialTokens(): MustacheToken[]\n  returns: MustacheToken[] - original mustache tokens.  originalTokens List of original Mustache tokens.\n public originalTokens(): Token[]\n  returns: Token[] - original Mustache tokens.   public originalTokens(value: Token[])\n  value: Token[] - original Mustache tokens.  resultTokens List of parsed Mustache tokens.\n public resultTokens(): MustacheToken[]\n  returns: MustacheToken[] - parsed Mustache tokens.  template Mustache template.\n public template(): string\n  returns: string - Mustache template.   public template(value: string)\n  value: string - Mustache template.  variableNames List of found variable names.\n public variableNames(): string[]\n  returns: string[] - found variable names.  Instance methods clear Clears parsing results.\n public clear(): void\n parseString Sets a new Mustache string and parses it into internal byte code.\n public parseString(mustache: string): void\n  mustache: string - new Mustache string.  parseTokens  public parseTokens(tokens: Token[]): void\n ","description":"Implements an mustache parser class.\n","image":null,"permalink":"/node/expressions/mustache/parsers/mustache_parser/","subtitle":null,"tags":null,"title":"MustacheParser"},{"content":"Extends: ITokenizerState\nDescription The MustacheSpecialState class allows you to implement a quote string state object for Mustache templates.\nInstance methods nextToken Gets the next token from the stream started from the character linked to this state.\n public nextToken(scanner: IScanner, tokenizer: ITokenizer): Token\n  scanner: IScanner - textual string to be tokenized. tokenizer: ITokenizer - tokenizer class that controls the process. returns: Token - next token from the top of the stream.  ","description":"Implements a quote string state object for Mustache templates.\n","image":null,"permalink":"/node/expressions/mustache/tokenizers/mustache_special_state/","subtitle":null,"tags":null,"title":"MustacheSpecialState"},{"content":"Description The MustacheTemplate class allows you to implement a Mustache template class.\nConstructors Constructs this class and assigns a mustache template.\n public constructor(template?: string)\n  template: string - mustache template.  Properties autoVariables Gets the flag to turn on auto-creation of variables for the Mustache template.\n public autoVariables(): boolean\n  returns: boolean - the flag to turn on auto creation of variables.  Sets the flag to turn on auto creation of variables for the Mustache template.\n public autoVariables(value: boolean)\n  value: boolean - flag to turn on auto-creation of variables.  defaultVariables The list with default variables.\n public defaultVariables(): any\n  returns: any - default variables.  initialTokens List of original mustache tokens.\n public initialTokens(): MustacheToken[]\n  returns: MustacheToken[] - Mustache tokens  originalTokens Lists the original tokens\n public originalTokens(): Token[]\n  returns: Token[] - original tokens   public originalTokens(value: Token[])\n  value: Token[] - original tokens  resultTokens The list of processed Mustache tokens.\n public resultTokens(): MustacheToken[]\n  returns: MustacheToken[] - processed Mustache tokens.  Instance methods clear Cleans up this calculator.\n public clear(): void\n createVariables Populates the specified variables list with variables obtained from a parsed Mustache template.\n public createVariables(variables: any): void\n  variables: any - The list of variables to be populated.  evaluate Evaluates this Mustache template using default variables.\n public evaluate(): string\n  returns: string - evaluated template.  evaluateWithVariables Evaluates this Mustache using specified variables.\n public evaluateWithVariables(variables: any): string\n  variables: any - collection of variables. returns: string - evaluated template  getVariable Gets a variable value from the collection of variables.\n public getVariable(variables: any, name: string): any\n  variables: any - collection of variables. name: string - variable name to get. returns: any - variable value or undefined.  ","description":"Implements a Mustache template class.\n","image":null,"permalink":"/node/expressions/mustache/mustache_template/","subtitle":null,"tags":null,"title":"MustacheTemplate"},{"content":"Description The MustacheToken defines a Mustache token holder.\nConstructors Creates an instance of a Mustache token.\n public constructor(type: MustacheTokenType, value: string, line: number, column: number)\n  type: MustacheTokenType - token type. value: string - token value. line: number - line number where the token is. column: number - column number where the token is.  Properties column Column number where the token is.\n public column(): number\n  returns: number - original Mustache tokens.  line Line number where the token is.\n public line(): number\n  returns: number - line number.  tokens Gets a list of subtokens in this token a section.\n public tokens(): MustacheToken[]\n  returns: MustacheToken[] - list of subtokens.  type Gets the token type.\n public type(): MustacheTokenType\n  returns: MustacheTokenType - token type.  value Gets the token value or variable name.\n public value(): string\n  returns: string - token value or variable name.  ","description":"Defines a Mustache token holder.\n","image":null,"permalink":"/node/expressions/mustache/parsers/mustache_token/","subtitle":null,"tags":null,"title":"MustacheToken"},{"content":"Extends: AbstractTokenizer\nDescription The MustacheTokenizer class allows you to create Mustache tokenizers.\nConstructors Constructs this object with default parameters.\n public constructor()\n Instance methods readNextToken Reads the next token\n protected readNextToken(): Token\n  returns: Token - next token  ","description":"Creates a Mustache tokenizer.\n","image":null,"permalink":"/node/expressions/mustache/tokenizers/mustache_tokenizer/","subtitle":null,"tags":null,"title":"MustacheTokenizer"},{"content":"Description The MustacheTokenType enum defines different types of Mustache tokens.\nEnumeration members The codes are as follows:\n Unknown = 0 Value = 1 Variable = 2 EscapedVariable = 3 Section = 4 InvertedSection = 5 SectionEnd = 6 Partial = 7 Comment = 8  ","description":"Defines types of Mustache tokens.\n","image":null,"permalink":"/node/expressions/mustache/parsers/mustache_token_type/","subtitle":null,"tags":null,"title":"MustacheTokenType"},{"content":"Inherits: IReferenceable, IConfigurable, IOpenable\nDescription The MySqlConnection class allows you to create a connection to a MySQL database using a plain driver.\nConfiguration parameters connection(s):\n discovery_key: (optional) key to retrieve the connection from IDiscovery host: host name or IP address port: port number (default: 27017) uri: resource URI or connection string with all parameters in it  credential(s):\n store_key: (optional) key to retrieve the credentials from ICredentialStore username: username password: user\u0026rsquo;s password  options:\n max_pool_size: (optional) maximum connection pool size (default keep_alive: (optional) enable connection keep alive (default connect_timeout: (optional) connection timeout in milliseconds (d auto_reconnect: (optional) enable auto reconnection (default: tr max_page_size: (optional) maximum page size (default: 100) debug: (optional) enable debug output (default: false).  References  *:logger:*:*:1.0 - (optional) ILogger components to pass log messages *:discovery:*:*:1.0 - (optional) IDiscovery services *:credential-store:*:*:1.0 (optional) credential stores to resolve credentials  Fields _connection The SQLServer connection pool object.\n private _connection: MySqlData.MySqlClient.MySqlConnection\n _connectionResolver The connection resolver.\n private _connectionResolver: MySqlConnectionResolver\n _databaseName The SQLServer database name.\n private _databaseName: string\n _databaseServer The database server name.\n private _databaseServer: string\n _logger The logger.\n private _logger: CompositeLogger\n _options The configuration options.\n private _options: ConfigParams\n _sshConfigs The SSH configuration object.\n private _sshConfigs: ConfigParams\n _sshEnabled The flag enabled ssh.\n private _sshEnabled: bool\n  Instance methods CloseAsync Closes the component and frees used resources.\n public Task CloseAsync(string correlationId)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain.  Configure Configures the component by passing configuration parameters.\n public void Configure(ConfigParams config)\n  config: ConfigParams - configuration parameters to be set.  GetConnection Gets the connection.\n public MySqlData.MySqlClient.MySqlConnection GetConnection()\n  returns: MySqlData.MySqlClient.MySqlConnection - connection to a MySQL database  GetDatabaseName Gets the database name\n public string GetDatabaseName()\n  returns: string - database name  IsOpen Checks if the component is opened.\n public bool IsOpen()\n  returns: bool - True if the component has been opened and False otherwise.  OpenAsync Opens the component.\n public Task OpenAsync(string correlationId)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain.  SetReferences Sets references to dependent components.\n public void SetReferences(IReferences references)\n  references: IReferences - references to locate the component dependencies.  ","description":"MySQL connection using the official driver.\n","image":null,"permalink":"/net/mysql/connect/mysql_connection/","subtitle":null,"tags":null,"title":"MySqlConnection"},{"content":"Implements: IReferenceable, IConfigurable, IOpenable\nDescription The MySqlConnection class allows you to create a connection to a MySQL database using a plain driver.\nConfiguration parameters connection(s):\n discovery_key: (optional) key to retrieve the connection from IDiscovery host: host name or IP address port: port number (default: 27017) uri: resource URI or connection string with all parameters in it  credential(s):\n store_key: (optional) key to retrieve the credentials from ICredentialStore username: username password: user\u0026rsquo;s password  options:\n connect_timeout: (optional) number of milliseconds to wait before timing out when connecting a new client (default: 0) idle_timeout: (optional) number of milliseconds a client must sit idle in the pool and not be checked out (default: 10000) max_pool_size: (optional) maximum number of clients the pool should contain (default: 10)  References  *:logger:*:*:1.0 - (optional) ILogger components to pass log messages *:discovery:*:*:1.0 - (optional) IDiscovery services *:credential-store:*:*:1.0 (optional) credential stores to resolve credentials  Fields _connection The SQLServer connection pool object.\n protected _connection: any\n _connectionResolver The connection resolver.\n protected _connectionResolver: MySqlConnectionResolver\n _databaseName The SQLServer database name.\n protected _databaseName: string\n _logger The logger.\n protected _logger: CompositeLogger\n _options The configuration options.\n protected _options: ConfigParams\n  Instance methods close Closes the component and frees used resources.\n public close(correlationId: string): Promise\u0026lt;void\u0026gt;\n  correlationId: string - (optional) transaction id used to trace execution through the call chain.  configure Configures the component by passing configuration parameters.\n public configure(config: ConfigParams): void\n  config: ConfigParams - configuration parameters to be set.  getConnection Gets the connection.\n public getConnection(): any\n  returns: any - connection to a MySQL database  getDatabaseName Gets the database name\n public getDatabaseName(): string\n  returns: string - database name  isOpen Checks if the component is opened.\n public isOpen(): boolean\n  returns: boolean - True if the component has been opened and False otherwise.  open Opens the component.\n public open(correlationId: string): Promise\u0026lt;void\u0026gt;\n  correlationId: string - (optional) transaction id used to trace execution through the call chain.  setReferences Sets references to dependent components.\n public setReferences(references: IReferences): void\n  references: IReferences - references to locate the component dependencies.  ","description":"MySQL connection using the official driver.\n","image":null,"permalink":"/node/mysql/connect/mysql_connection/","subtitle":null,"tags":null,"title":"MySqlConnection"},{"content":"Implements: IReferenceable, IConfigurable, IOpenable\nDescription The MySqlConnection class allows you to create a connection to a MySQL database using a plain driver.\nConfiguration parameters connection(s):\n discovery_key: (optional) key to retrieve the connection from IDiscovery host: host name or IP address port: port number (default: 27017) uri: resource URI or connection string with all parameters in it  credential(s):\n store_key: (optional) key to retrieve the credentials from ICredentialStore username: username password: user\u0026rsquo;s password  options:\n connect_timeout: (optional) number of milliseconds to wait before timing out when connecting a new client (default: 0) idle_timeout: (optional) number of milliseconds a client must sit idle in the pool and not be checked out (default: 10000) max_pool_size: (optional) maximum number of clients the pool should contain (default: 10)  References  *:logger:*:*:1.0 - (optional) ILogger components to pass log messages *:discovery:*:*:1.0 - (optional) IDiscovery services *:credential-store:*:*:1.0 (optional) credential stores to resolve credentials  Fields _connection The SQLServer connection pool object.\n _connection: Any\n _connection_resolver The connection resolver.\n _connection_resolver: MySqlConnectionResolver\n _database_name The SQLServer database name.\n _database_name: str\n _logger The logger.\n _logger: CompositeLogger\n _options The configuration options.\n _options: ConfigParams\n  Instance methods close Closes the component and frees used resources.\n close(correlation_id: Optional[str])\n  correlation_id: Optional[str] - (optional) transaction id used to trace execution through the call chain.  configure Configures the component by passing configuration parameters.\n configure(config: ConfigParams)\n  config: ConfigParams - configuration parameters to be set.  get_connection Gets the connection.\n get_connection(): Any\n  returns: Any - connection to a MySQL database  get_database_name Gets the database name\n get_database_name(): str\n  returns: str - database name  is_open Checks if the component is opened.\n is_open(): bool\n  returns: bool - True if the component has been opened and False otherwise.  open Opens the component.\n open(correlation_id: Optional[str])\n  correlation_id: Optional[str] - (optional) transaction id used to trace execution through the call chain.  set_references Sets references to dependent components.\n set_references(references: IReferences)\n  references: IReferences - references to locate the component dependencies.  ","description":"MySQL connection using the official driver.\n","image":null,"permalink":"/python/mysql/connect/mysql_connection/","subtitle":null,"tags":null,"title":"MySqlConnection"},{"content":"Inherits: IReferenceable, IConfigurable\nDescription The MySqlConnectionResolver class allows you to create a MySQL connection and credential parameters resolver that validates the parameters and generates a connection URI.\nImportant points\n It is able to process multiple connections to MySQL cluster nodes.  Configuration parameters connection(s):\n discovery_key: (optional) key to retrieve the connection from IDiscovery host: host name or IP address port: port number (default: 27017) database: database name uri: resource URI or connection string with all parameters in it  credential(s):\n store_key: (optional) key to retrieve the credentials from ICredentialStore username: username password: user\u0026rsquo;s password  References  *:discovery:*:*:1.0 - (optional) IDiscovery services *:credential-store:*:*:1.0 - (optional) ICredentialStore stores to resolve credentials  Fields _connectionResolver The connection resolver\n protected _connectionResolver: ConnectionResolver\n _connectionResolver The credential resolver\n protected _credentialResolver: CredentialResolver\n  Instance methods Configure Configures components by passing configuration parameters.\n public void Configure(ConfigParams config)\n  config: ConfigParams - configuration parameters to be set.  Resolve Resolves a MySQL configuration from connection and credential parameters.\n public Task\u0026lt;string\u0026gt; ResolveAsync(string correlationId)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. returns: Task\u0026lt;string\u0026gt; - resolved connection config or raise error  SetReferences Sets references to dependent components.\n public void SetReferences(IReferences references)\n  references: IReferences - references to locate the component dependencies.  ","description":"Helper class that resolves MySQL connection and credential parameters, validates them and generates a connection URI.\n","image":null,"permalink":"/net/mysql/connect/mysql_connection_resolver/","subtitle":null,"tags":null,"title":"MySqlConnectionResolver"},{"content":"Implements: IReferenceable, IConfigurable\nDescription The MySqlConnectionResolver class allows you to create a MySQL connection and credential parameters resolver that validates the parameters and generates a connection URI.\nImportant points\n It is able to process multiple connections to MySQL cluster nodes.  Configuration parameters connection(s):\n discovery_key: (optional) key to retrieve the connection from IDiscovery host: host name or IP address port: port number (default: 27017) database: database name uri: resource URI or connection string with all parameters in it  credential(s):\n store_key: (optional) key to retrieve the credentials from ICredentialStore username: username password: user\u0026rsquo;s password  References  *:discovery:*:*:1.0 - (optional) IDiscovery services *:credential-store:*:*:1.0 - (optional) ICredentialStore stores to resolve credentials  Fields _connectionResolver The connection resolver\n protected _connectionResolver: ConnectionResolver\n _credentialResolver The credential resolver\n protected _credentialResolver: CredentialResolver\n  Instance methods configure Configures components by passing configuration parameters.\n public configure(config: ConfigParams): void\n  config: ConfigParams - configuration parameters to be set.  resolve Resolves a MySQL configuration from connection and credential parameters.\n public resolve(correlationId: string): Promise\u0026lt;string\u0026gt;\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. returns: Promise\u0026lt;string\u0026gt; - resolved connection config or raise error  setReferences Sets references to dependent components.\n public setReferences(references: IReferences): void\n  references: IReferences - references to locate the component dependencies.  ","description":"Helper class that resolves MySQL connection and credential parameters, validates them and generates a connection URI.\n","image":null,"permalink":"/node/mysql/connect/mysql_connection_resolver/","subtitle":null,"tags":null,"title":"MySqlConnectionResolver"},{"content":"Implements: IReferenceable, IConfigurable\nDescription The MySqlConnectionResolver class allows you to create a MySQL connection and credential parameters resolver that validates the parameters and generates a connection URI.\nImportant points\n It is able to process multiple connections to MySQL cluster nodes.  Configuration parameters connection(s):\n discovery_key: (optional) key to retrieve the connection from IDiscovery host: host name or IP address port: port number (default: 27017) database: database name uri: resource URI or connection string with all parameters in it  credential(s):\n store_key: (optional) key to retrieve the credentials from ICredentialStore username: username password: user\u0026rsquo;s password  References  *:discovery:*:*:1.0 - (optional) IDiscovery services *:credential-store:*:*:1.0 - (optional) ICredentialStore stores to resolve credentials  Constructors Creates a new instance of the connection component.\n MySqlConnectionResolver()\n Fields _connection_resolver The connection resolver\n _connection_resolver: ConnectionResolver\n _credential_resolver The credential resolver\n _credential_resolver: CredentialResolver\n  Instance methods configure Configures components by passing configuration parameters.\n configure(config: ConfigParams)\n  config: ConfigParams - configuration parameters to be set.  resolve Resolves a MySQL configuration from connection and credential parameters.\n resolve(correlation_id: Optional[str]): str\n  correlation_id: Optional[str] - (optional) transaction id used to trace execution through the call chain. returns: str - resolved connection config or raise error  set_references Sets references to dependent components.\n set_references(references: IReferences)\n  references: IReferences - references to locate the component dependencies.  ","description":"Helper class that resolves MySQL connection and credential parameters, validates them and generates a connection URI.\n","image":null,"permalink":"/python/mysql/connect/mysql_connection_resolver/","subtitle":null,"tags":null,"title":"MySqlConnectionResolver"},{"content":"Inherits: IReferenceable, IUnreferenceable, IConfigurable, IOpenable, ICleanable\nDescription The MySqlPersistence class allows you to create persistence components that store data in MySQL databases using the official driver.\nImportant points\n This is the most basic persistence component that is only able to store data items of any type. Specific CRUD operations over the data items must be implemented in child classes by accessing this._db or this._collection properties.  Configuration parameters  collection: (optional) MySQL collection name connection(s): discovery_key: (optional) key to retrieve the connection from IDiscovery host: host name or IP address port: port number (default: 27017) uri: resource URI or connection string with all parameters in it  credential(s):\n store_key: (optional) key to retrieve the credentials from ICredentialStore username: (optional) username password: (optional) user\u0026rsquo;s password  options:\n max_pool_size: (optional) maximum connection pool size (default: 2) keep_alive: (optional) enable connection keep alive (default: true) connect_timeout: (optional) connection timeout in milliseconds (default: 5 sec) max_page_size: (optional) maximum page size (default: 100) debug: (optional) enable debug output (default: false).  References  *:logger:*:*:1.0 - (optional) ILogger components to pass log messages *:discovery:*:*:1.0 - (optional) IDiscovery services *:credential-store:*:*:1.0 - (optional) ICredentialStore to resolve credentials  Constructors Creates a new instance of the persistence component.\n public MySqlPersistence(string tableName)\n  tableName: string - (optional) table name.  Fields _databaseName The MySql table object.\n protected _databaseName: string\n _dependencyResolver The dependency resolver.\n protected _dependencyResolver: DependencyResolver\n _logger The logger.\n protected _logger: CompositeLogger\n _connection The MySql connection component.\n protected _connection: MySqlConnection\n _client The MySql connection component.\n protected _client: MySqlData.MySqlClient.MySqlConnection\n _databaseName The MySql database name.\n protected _databaseName: string\n _tableName The MySQL table object.\n protected _tableName: string\n _maxPageSize The maximum number of records to return from the database per request.\n protected _maxPageSize: number = 100\n  Instance methods AutoCreateObject Adds a statement to schema definition. This is a deprecated method. Use ensureSchema instead.\n This is a deprecated method. Use EnsureSchema instead.   protected void AutoCreateObject(string schemaStatement)\n  schemaStatement: string - statement to be added to the schema  ClearAsync Clears a component\u0026rsquo;s state.\n public virtual Task ClearAsync(string correlationId)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain.  ClearSchema Clears all auto-created objects\n protected void ClearSchema()\n CloseAsync Closes a component and frees the used resources.\n public virtual Task CloseAsync(string correlationId)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain.  Configure Configures component by passing configuration parameters.\n public virtual void Configure(ConfigParams config)\n  config:: ConfigParams - configuration parameters to be set.  ConvertFromPublic Converts object value from public to internal format.\n protected virtual AnyValueMap ConvertFromPublic(T value)\n  value: T - object in public format to convert. returns: AnyValueMap - converted object in internal format.  ConvertToPublic Converts object value from internal to public format.\n protected virtual T ConvertToPublic(AnyValueMap map)\n  value: AnyValueMap - object in internal format to convert. returns: T - converted object in public format.  CreateAsync Creates a data item.\n public virtual Task\u0026lt;T\u0026gt; CreateAsync(string correlationId, T item)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. item: T - item to be created. returns: Task\u0026lt;T\u0026gt; - created item  CreateSchemaAsync Checks if a table exists and if not, it creates the necessary database objects.\n protected Task CreateSchemaAsync(string correlationId)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain.  DefineSchema Defines database schema via auto create objects or convenience methods.\n protected virtual void DefineSchema()\n DeleteByFilterAsync Deletes data items that match to a given filter. This method shall be called by a public DeleteByFilterAsync method from child class that receives FilterParams and converts them into a filter function.\n public virtual Task DeleteByFilterAsync(string correlationId, string filter)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. filter: string - (optional) filter function to filter items.  EnsureIndex Adds index definition to create it on opening.\n protected void EnsureIndex(string name, Dictionary\u0026lt;string, bool\u0026gt; keys, IndexOptions options)\n  name: string - the index name. keys: Dictionary\u0026lt;string, bool\u0026gt; - index keys (fields). options: IndexOptions - index options.  EnsureSchema Adds a statement to schema definition.\n protected void EnsureSchema(string schemaStatement)\n  schemaStatement: string - statement to be added to the schema  GenerateColumns Generates a list of column names to use in SQL statements like: \u0026ldquo;column1,column2,column3\u0026rdquo;.\n protected string GenerateColumns(AnyValueMap map)\n  values: AnyValueMap - array with column values or a key-value map. returns: string - generated list of column names.  Generates a list of column names to use in SQL statements like: \u0026ldquo;column1,column2,column3\u0026rdquo;\n protected string GenerateColumns(IEnumerable\u0026lt;string\u0026gt; values)\n  values: AnyValueMap - aan array with column values returns: string - generated list of column names.  GenerateParameters Generates a list of value parameters to use in SQL statements like: \u0026quot;@Param1,@Param2,@Param3\u0026quot;.\n protected string GenerateParameters(AnyValueMap map)\n  values: AnyValueMap - array with values or a key-value map returns: string - generated list of value parameters   protected string GenerateParameters\u0026lt;K\u0026gt;(IEnumerable\u0026lt;K\u0026gt; values)\n  values: IEnumerable\u0026lt;K\u0026gt; - an array with column values returns: string - generated list of value parameters  GenerateSetParameters Generates a list of column sets to use in UPDATE statements like: \u0026quot;@Param1,@Param2,@Param3\u0026quot;\n protected string GenerateSetParameters(AnyValueMap map)\n  values: AnyValueMap - key-value map with columns and values returns: string - generated list of column sets  Generates a list of column sets to use in UPDATE statements like: column1=@Param1,column2=@Param2\n protected string GenerateSetParameters(IEnumerable\u0026lt;string\u0026gt; values)\n  values: IEnumerable\u0026lt;string\u0026gt; - an array with column names returns: string - generated list of column sets  GenerateValues Generates a list of column parameters.\n protected List\u0026lt;object\u0026gt; GenerateValues(AnyValueMap map)\n  values: AnyValueMap - key-value map with columns and values returns: List\u0026lt;object\u0026gt; - generated list of column values  GetCountByFilterAsync Gets a number of data items retrieved by a given filter.\nThis method shall be called by a public GetCountByFilterAsync method from the child class that receives FilterParams and converts them into a filter function.\n protected virtual Task\u0026lt;long\u0026gt; GetCountByFilterAsync(string correlationId, string filter)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. filter: string - (optional) JSON object filter returns: Promise\u0026lt;number\u0026gt; - number of filtered items.  GetListByFilterAsync Gets a list of data items retrieved by a given filter and sorted according to sort parameters.\nThis method shall be called by a public GetListByFilterAsync method from a child class that receives FilterParams and converts them into a filter function.\n protected Task\u0026lt;List\u0026lt;T\u0026gt;\u0026gt; GetListByFilterAsync(string correlationId, string filter, string sort = null, string select = null)\n  correlationId: string - (optional) transaction id to trace execution through the call chain. filter: string - (optional) a filter JSON object. sort: string - (optional) sorting parameters select: string - (optional) projection parameters (not used yet) returns: Task\u0026lt;List\u0026lt;T\u0026gt;\u0026gt; - data list of results by filter.  GetOneRandomAsync Gets a random item from items that match to a given filter.\nThis method shall be called by a public GetOneRandomAsync method from a child class that receives FilterParams and converts them into a filter function.\n protected virtual Task\u0026lt;T\u0026gt; GetOneRandomAsync(string correlationId, string filter)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. filter: string - (optional) a filter JSON object returns: Task\u0026lt;T\u0026gt; - a random item.  GetPageByFilterAsync Gets a page of data items retrieved by a given filter and sorted according to sort parameters.\nThis method shall be called by a public GetPageByFilterAsync method from the a child class that receives FilterParams and converts them into a filter function.\n public virtual async Task\u0026lt;DataPage\u0026gt; GetPageByFilterAsync(string correlationId, string filter, PagingParams paging = null, string sort = null, string select = null)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. filter: string - (optional) filter for JSON objects. paging: PagingParams - (optional) paging parameters sort: string - (optional) sorting JSON object select: string - (optional) projection JSON object returns: Task\u0026lt;DataPage\u0026gt; - a data page of result by filter  IsOpen Checks if the component is opened.\n public virtual bool IsOpen()\n  returns: bool - True if the component has been opened and False otherwise.  OpenAsync Opens the component.\n public virtual Task OpenAsync(string correlationId)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain.  QuoteIdentifier Adds single quotes to a string.\n protected string QuoteIdentifier(string value)\n  value: string - string where quotes need to be added returns: string - string with added quotes  SetReferences Sets references to dependent components.\n public virtual void SetReferences(IReferences references)\n  references: IReferences - references to locate the component dependencies.  UnsetReferences Unsets (clears) previously set references to dependent components.\n public virtual void UnsetReferences()\n Examples class MyMySqlPersistence: MySqlPersistence\u0026lt;MyData\u0026gt; { public MyMySqlPersistence() { base(\u0026#34;mydata\u0026#34;); } public MyData getByName(string correlationId, string name) { var builder = Builders\u0026lt;BeaconV1\u0026gt;.Filter; var filter = builder.Eq(x =\u0026gt; x.Name, name); var result = await _collection.Find(filter).FirstOrDefaultAsync(); return result; } public MyData set(String correlatonId, MyData item) { var filter = Builders\u0026lt;T\u0026gt;.Filter.Eq(x =\u0026gt; x.Id, item.Id); var options = new FindOneAndReplaceOptions\u0026lt;T\u0026gt; { ReturnDocument = ReturnDocument.After, IsUpsert = true }; var result = await _collection.FindOneAndReplaceAsync(filter, item, options); return result; } } var persistence = new MyMySqlPersistence(); persistence.Configure(ConfigParams.FromTuples( \u0026#34;host\u0026#34;, \u0026#34;localhost\u0026#34;, \u0026#34;port\u0026#34;, 27017 ) ); persitence.Open(\u0026#34;123\u0026#34;); var mydata = new MyData(\u0026#34;ABC\u0026#34;); persistence.Set(\u0026#34;123\u0026#34;, mydata); persistence.GetByName(\u0026#34;123\u0026#34;, \u0026#34;ABC\u0026#34;); Console.Out.WriteLine(item); // Result: { name: \u0026#34;ABC\u0026#34; } ","description":"Abstract persistence component that stores data in MySQL using the official driver.\n","image":null,"permalink":"/net/mysql/persistence/mysql_persistence/","subtitle":null,"tags":null,"title":"MySqlPersistence\u003cT\u003e"},{"content":"Implements: IReferenceable, IUnreferenceable, IConfigurable, IOpenable, ICleanable\nDescription The MySqlPersistence class allows you to create persistence components that store data in MySQL databases using the official driver.\nImportant points\n This is the most basic persistence component that is only able to store data items of any type. Specific CRUD operations over the data items must be implemented in child classes by accessing this._db or this._collection properties.  Configuration parameters  collection: (optional) MySQL collection name connection(s): discovery_key: (optional) key to retrieve the connection from IDiscovery host: host name or IP address port: port number (default: 27017) uri: resource URI or connection string with all parameters in it  credential(s):\n store_key: (optional) key to retrieve the credentials from ICredentialStore username: (optional) username password: (optional) user\u0026rsquo;s password  options:\n connect_timeout: (optional) number of milliseconds to wait before timing out when connecting a new client (default: 0) idle_timeout: (optional) number of milliseconds a client must sit idle in the pool and not be checked out (default: 10000) max_pool_size: (optional) maximum number of clients the pool should contain (default: 10)  References  *:logger:*:*:1.0 - (optional) ILogger components to pass log messages *:discovery:*:*:1.0 - (optional) IDiscovery services *:credential-store:*:*:1.0 - (optional) ICredentialStore to resolve credentials  Constructors Creates a new instance of the persistence component.\n public constructor(tableName?: string)\n  tableName: string - (optional) table name.  Fields _databaseName The MySql table object.\n protected _databaseName: string\n _dependencyResolver The dependency resolver.\n protected _dependencyResolver: DependencyResolver\n _logger The logger.\n protected _logger: CompositeLogger\n _connection The MySql connection component.\n protected _connection: MySqlConnection\n _client The MySql connection pool object.\n protected _client: any\n _databaseName The MySql database name.\n protected _databaseName: string\n _tableName The MySQL table object.\n protected _tableName: string\n _maxPageSize The maximum number of records to return from the database per request.\n protected _maxPageSize: number = 100\n  Instance methods autoCreateObject Adds a statement to schema definition.\n This is a deprecated method. Use ensureSchema instead.   protected autoCreateObject(schemaStatement: string)\n  schemaStatement: string - statement to be added to the schema  clear Clears a component\u0026rsquo;s state.\n public clear(correlationId: string): Promise\u0026lt;void\u0026gt;\n  correlationId: string - (optional) transaction id used to trace execution through the call chain.  clearSchema Clears all auto-created objects\n protected clearSchema(): void\n close Closes a component and frees the used resources.\n public close(correlationId: string): Promise\u0026lt;void\u0026gt;\n  correlationId: string - (optional) transaction id used to trace execution through the call chain.  configure Configures component by passing configuration parameters.\n public configure(config: ConfigParams): void\n  config:: ConfigParams - configuration parameters to be set.  convertFromPublic Converts object value from public to internal format.\n protected convertFromPublic(value: any): any\n  value: any - object in public format to convert. returns: any - converted object in internal format.  convertToPublic Converts object value from internal to public format.\n protected convertToPublic(value: any): any\n  value: any - object in internal format to convert. returns: any - converted object in public format.  create Creates a data item.\n public create(correlationId: string, item: T): Promise\u0026lt;T\u0026gt;\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. item: T - item to be created. returns: Promise\u0026lt;T\u0026gt; - created item  createSchema Checks if a table exists and if not, it creates the necessary database objects.\n protected createSchema(correlationId: string): Promise\u0026lt;void\u0026gt;\n  correlationId: string - (optional) transaction id used to trace execution through the call chain.  defineSchema Defines database schema via auto create objects or convenience methods.\n protected defineSchema(): void\n deleteByFilter Deletes data items that match to a given filter. This method shall be called by a public deleteByFilter method from child class that receives FilterParams and converts them into a filter function.\n protected deleteByFilter(correlationId: string, filter: any): Promise\u0026lt;void\u0026gt;\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. filter: any - (optional) filter function to filter items.  ensureIndex Adds index definition to create it on opening.\n protected ensureIndex(keys: any, options)\n  keys: any - index keys (fields) options: any - index options  ensureSchema Adds a statement to schema definition.\n protected ensureSchema(schemaStatement: string): void\n  schemaStatement: string - statement to be added to the schema  generateColumns Generates a list of column names to use in SQL statements like: \u0026ldquo;column1,column2,column3\u0026rdquo;.\n protected generateColumns(values: any): string\n  values: any - array with column values or a key-value map returns: string - generated list of column names  generateParameters Generates a list of value parameters to use in SQL statements like: \u0026quot;@1,@2,@3\u0026quot;.\n protected generateParameters(values: any): string\n  values: any - array with values or a key-value map returns: string - generated list of value parameters  generateSetParameters Generates a list of column sets to use in UPDATE statements like: \u0026quot;@1,@2,@3\u0026quot;.\n protected generateSetParameters(values: any): string\n  values: any - key-value map with columns and values returns: string - generated list of column sets  generateValues Generates a list of column parameters.\n protected generateValues(values: any): any[]\n  values: any - key-value map with columns and values returns: any[] - generated list of column values  getCountByFilter Gets a number of data items retrieved by a given filter.\nThis method shall be called by a public getCountByFilter method from the child class that receives FilterParams and converts them into a filter function.\n protected getCountByFilter(correlationId: string, filter: any): Promise\u0026lt;number\u0026gt;\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. filter: any - (optional) JSON object filter returns: Promise\u0026lt;number\u0026gt; - number of filtered items.  getListByFilter Gets a list of data items retrieved by a given filter and sorted according to sort parameters.\nThis method shall be called by a public getListByFilter method from a child class that receives FilterParams and converts them into a filter function.\n protected getListByFilter(correlationId: string, filter: any, sort: any, select: any): Promise\u0026lt;T[]\u0026gt;\n  correlationId: string - (optional) transaction id to trace execution through the call chain. filter: any - (optional) filter function to filter items sort: any - (optional) sorting parameters select: any - (optional) projection parameters (not used yet) returns: Promise\u0026lt;T[]\u0026gt; - data list of results by filter.  getOneRandom Gets a random item from items that match to a given filter.\nThis method shall be called by a public getOneRandom method from a child class that receives FilterParams and converts them into a filter function.\n protected getOneRandom(correlationId: string, filter: any): Promise\u0026lt;T\u0026gt;\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. filter: any - (optional) a filter JSON object returns: Promise\u0026lt;T\u0026gt; - a random item.  getPageByFilter Gets a page of data items retrieved by a given filter and sorted according to sort parameters.\nThis method shall be called by a public getPageByFilter method from the a child class that receives FilterParams and converts them into a filter function.\n protected getPageByFilter(correlationId: string, filter: any, paging: PagingParams, sort: any, select: any): Promise\u0026lt;DataPage\u0026gt;\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. filter: any - (optional) filter for JSON objects. paging: PagingParams - (optional) paging parameters sort: any - (optional) sorting JSON object select: any - (optional) projection JSON object returns: Promise\u0026lt;DataPage\u0026gt; - a data page of result by filter  isOpen Checks if the component is opened.\n public isOpen(): boolean\n  returns: boolean - True if the component has been opened and False otherwise.  open Opens the component.\n public open(correlationId: string): Promise\u0026lt;void\u0026gt;\n  correlationId: string - (optional) transaction id used to trace execution through the call chain.  quoteIdentifier Adds single quotes to a string.\n protected quoteIdentifier(value: string): string\n  value: string - string where quotes need to be added returns: string - string with added quotes  setReferences Sets references to dependent components.\n public setReferences(references: IReferences): void\n  references: IReferences - references to locate the component dependencies.  unsetReferences Unsets (clears) previously set references to dependent components.\n public unsetReferences(): void\n Examples class MyMySqlPersistence extends MySqlPersistence\u0026lt;MyData\u0026gt; { public constructor() { base(\u0026#34;mydata\u0026#34;); } public getByName(correlationId: string, name: string, callback: (err, item) =\u0026gt; void): void { let criteria = { name: name }; this._model.findOne(criteria, callback); }); public set(correlatonId: string, item: MyData, callback: (err) =\u0026gt; void): void { let criteria = { name: item.name }; let options = { upsert: true, new: true }; this._model.findOneAndUpdate(criteria, item, options, callback); } } let persistence = new MyMySqlPersistence(); persistence.configure(ConfigParams.fromTuples( \u0026#34;host\u0026#34;, \u0026#34;localhost\u0026#34;, \u0026#34;port\u0026#34;, 27017 )); persitence.open(\u0026#34;123\u0026#34;, (err) =\u0026gt; { ... }); persistence.set(\u0026#34;123\u0026#34;, { name: \u0026#34;ABC\u0026#34; }, (err) =\u0026gt; { persistence.getByName(\u0026#34;123\u0026#34;, \u0026#34;ABC\u0026#34;, (err, item) =\u0026gt; { console.log(item); // Result: { name: \u0026#34;ABC\u0026#34; }  }); }); ","description":"Abstract persistence component that stores data in MySQL using the official driver.\n","image":null,"permalink":"/node/mysql/persistence/mysql_persistence/","subtitle":null,"tags":null,"title":"MySqlPersistence\u003cT\u003e"},{"content":"Implements: IReferenceable, IUnreferenceable, IConfigurable, IOpenable, ICleanable\nDescription The MySqlPersistence class allows you to create persistence components that store data in MySQL databases using the official driver.\nImportant points\n This is the most basic persistence component that is only able to store data items of any type. Specific CRUD operations over the data items must be implemented in child classes by accessing self._db or self._collection properties.  Configuration parameters  collection: (optional) MySQL collection name connection(s): discovery_key: (optional) key to retrieve the connection from IDiscovery host: host name or IP address port: port number (default: 27017) uri: resource URI or connection string with all parameters in it  credential(s):\n store_key: (optional) key to retrieve the credentials from ICredentialStore username: (optional) username password: (optional) user\u0026rsquo;s password  options:\n connect_timeout: (optional) number of milliseconds to wait before timing out when connecting a new client (default: 0) idle_timeout: (optional) number of milliseconds a client must sit idle in the pool and not be checked out (default: 10000) max_pool_size: (optional) maximum number of clients the pool should contain (default: 10)  References  *:logger:*:*:1.0 - (optional) ILogger components to pass log messages *:discovery:*:*:1.0 - (optional) IDiscovery services *:credential-store:*:*:1.0 - (optional) ICredentialStore to resolve credentials  Constructors Creates a new instance of the persistence component.\n MySqlPersistence(table_name: str = None)\n  table_name: str - (optional) table name.  Fields _table_name The MySql table object.\n _table_name: str\n _dependency_resolver The dependency resolver.\n _dependency_resolver: DependencyResolver\n _logger The logger.\n _logger: CompositeLogger\n _connection The MySql connection component.\n _connection: MySqlConnection\n _client The MySql connection pool object.\n _client: Any\n _database_name The MySql database name.\n _database_name: str\n _max_page_size The maximum number of records to return from the database per request.\n _max_page_size = 100\n  Instance methods _auto_create_object Adds a statement to schema definition.\n This is a deprecated method. Use _ensure_schema instead.   _auto_create_object(schema_statement: str)\n  schema_statement: str - statement to be added to the schema  clear Clears a component\u0026rsquo;s state.\n clear(correlation_id: Optional[str])\n  correlation_id: Optional[str]- (optional) transaction id used to trace execution through the call chain.  _clear_schema Clears all auto-created objects\n _clear_schema()\n close Closes a component and frees the used resources.\n close(correlation_id: Optional[str])\n  correlation_id: Optional[str]- (optional) transaction id used to trace execution through the call chain.  configure Configures component by passing configuration parameters.\n configure(config: ConfigParams)\n  config:: ConfigParams - configuration parameters to be set.  _convert_from_public Converts object value from public to internal format.\n _convert_from_public(value: Any): Any\n  value: Any - object in public format to convert. returns: Any - converted object in internal format.  _convert_to_public Converts object value from internal to public format.\n _convert_to_public(value: Any): Any\n  value: Any - object in internal format to convert. returns: Any - converted object in public format.  create Creates a data item.\n create(correlation_id: Optional[str], item: T): Optional[T]\n  correlation_id: Optional[str] - (optional) transaction id used to trace execution through the call chain. item: T - item to be created. returns: Optional[T] - created item  _create_schema Checks if a table exists and if not, it creates the necessary database objects.\n _create_schema(correlation_id: Optional[str])\n  correlation_id: Optional[str] - (optional) transaction id used to trace execution through the call chain.  _define_schema Defines database schema via auto create objects or convenience methods.\n _define_schema()\n delete_by_filter Deletes data items that match to a given filter. This method shall be called by a public delete_by_filter method from child class that receives FilterParams and converts them into a filter function.\n delete_by_filter(correlation_id: Optional[str], filter: Any)\n  correlation_id: Optional[str] - (optional) transaction id used to trace execution through the call chain. filter: Any - (optional) filter function to filter items.  _ensure_index Adds index definition to create it on opening.\n _ensure_index(keys: Any, options: Any = None)\n  keys: Any - index keys (fields) options: Any - index options  _ensure_schema Adds a statement to schema definition.\n _ensure_schema(schema_statement: str)\n  schema_statement: str - statement to be added to the schema  _generate_columns Generates a list of column names to use in SQL statements like: \u0026ldquo;column1,column2,column3\u0026rdquo;.\n _generate_columns(values: Any): str\n  values: Any - array with column values or a key-value map returns: str - generated list of column names  _generate_parameters Generates a list of value parameters to use in SQL statements like: \u0026quot;$1,$2,$3\u0026quot;.\n _generate_parameters(values: Any): str\n  values: Any - array with values or a key-value map returns: str - generated list of value parameters  _generate_set_parameters Generates a list of column sets to use in UPDATE statements like: column1=$1,column2=$2.\n _generate_set_parameters(values: Any): str\n  values: Any - key-value map with columns and values returns: str - generated list of column sets  _generate_values Generates a list of column parameters.\n _generate_values(values: Any): List[Any]\n  values: Any - key-value map with columns and values returns: List[Any] - generated list of column values  get_count_by_filter Gets a number of data items retrieved by a given filter.\nThis method shall be called by a public get_count_by_filter method from the child class that receives FilterParams and converts them into a filter function.\n get_count_by_filter(correlation_id: Optional[str], filter: Any): int\n  correlation_id: Optional[str] - (optional) transaction id used to trace execution through the call chain. filter: Any - (optional) JSON object filter returns: int - number of filtered items.  get_list_by_filter Gets a list of data items retrieved by a given filter and sorted according to sort parameters.\nThis method shall be called by a public get_list_by_filter method from a child class that receives FilterParams and converts them into a filter function.\n get_list_by_filter(correlation_id: Optional[str], filter: Any, sort: Any = None, select: Any = None): List[T]\n  correlation_id: Optional[str] - (optional) transaction id to trace execution through the call chain. filter: Any - (optional) filter function to filter items sort: Any - (optional) sorting parameters select: Any - (optional) projection parameters (not used yet) returns: List[T] - data list of results by filter.  get_one_random Gets a random item from items that match to a given filter.\nThis method shall be called by a public get_one_random method from a child class that receives FilterParams and converts them into a filter function.\n get_one_random(correlation_id: Optional[str], filter: Any): T\n  correlation_id: Optional[str] - (optional) transaction id used to trace execution through the call chain. filter: Any - (optional) a filter function to filter items. returns: T - a random item.  get_page_by_filter Gets a page of data items retrieved by a given filter and sorted according to sort parameters.\nThis method shall be called by a public get_page_by_filter method from the a child class that receives FilterParams and converts them into a filter function.\n get_page_by_filter(correlation_id: Optional[str], filter: Any, paging: PagingParams, sort: Any = None, select: Any = None): DataPage\n  correlation_id: Optional[str] - (optional) transaction id used to trace execution through the call chain. filter: Any - (optional) filter for JSON objects. paging: PagingParams - (optional) paging parameters sort: Any - (optional) sorting JSON object select: Any - (optional) projection JSON object returns: DataPage - a data page of result by filter  is_open Checks if the component is opened.\n is_open(): bool\n  returns: bool - True if the component has been opened and False otherwise.  open Opens the component.\n open(correlation_id: Optional[str])\n  correlation_id: Optional[str] - (optional) transaction id used to trace execution through the call chain.  _quote_identifier Adds single quotes to a string.\n _quote_identifier(value: str): Optional[str]\n  value: str - string where quotes need to be added returns: Optional[str] - string with added quotes  set_references Sets references to dependent components.\n set_references(references: IReferences)\n  references: IReferences - references to locate the component dependencies.  unset_references Unsets (clears) previously set references to dependent components.\n unset_references()\n Examples class MyMySqlPersistence(MySqlPersistence): def __init__(self): super(MyMySqlPersistence, self).__init__(\u0026#39;mydata\u0026#39;) def get_by_name(self, correlation_id, name): criteria = {\u0026#39;name\u0026#39;:name} return self._model.find_one(criteria) def set(self,correlation_id, item): criteria = {\u0026#39;name\u0026#39;: item[\u0026#39;name\u0026#39;]} options = {\u0026#39;upsert\u0026#39;: True, \u0026#39;new\u0026#39;: True} return self._model.find_one_and_update(criteria, item, options) persistence =MyMySqlPersistence() persistence.configure(ConfigParams.from_tuples( \u0026#34;host\u0026#34;, \u0026#34;localhost\u0026#34;, \u0026#34;port\u0026#34;, 27017 )) persistence.open(\u0026#39;123\u0026#39;) persistence.set(\u0026#39;123\u0026#39;, {\u0026#39;name\u0026#39;:\u0026#39;ABC\u0026#39;}) item = persistence.get_by_name(\u0026#39;123\u0026#39;, \u0026#39;ABC\u0026#39;) print(item) # Result: { name: \u0026#34;ABC\u0026#34; } ","description":"Abstract persistence component that stores data in MySQL using the official driver.\n","image":null,"permalink":"/python/mysql/persistence/mysql_persistence/","subtitle":null,"tags":null,"title":"MySqlPersistence"},{"content":"Description A helper class that allows to extract component \u0026ldquo;name\u0026rdquo; from configuration parameters. The name can be defined in the \u0026ldquo;id\u0026rdquo; or \u0026ldquo;name\u0026rdquo; parameters or inside a component of type descriptor.\nMethods Resolve Resolves a component name from configuration parameters. The name can be stored in \u0026ldquo;id\u0026rdquo;, \u0026ldquo;name\u0026rdquo; fields or inside a component descriptor. If name cannot be determined it returns a empty string.\n (c *TNameResolver) Resolve(config *ConfigParams) string\n  config: *ConfigParams - configuration parameters that may contain a component name. returns: string - resolved name or \u0026quot;\u0026quot; if the name cannot be determined.  ResolveWithDefault Resolves a component name from configuration parameters. The name can be stored in \u0026ldquo;id\u0026rdquo;, \u0026ldquo;name\u0026rdquo; fields or inside a component descriptor. If name cannot be determined it returns a defaultName.\n (c *TNameResolver) ResolveWithDefault(config *ConfigParams, defaultName string) string\n  config: *ConfigParams - configuration parameters that may contain a component name. defaultName: string - (optional) a default component name. returns: string - resolved name or default name if the name cannot be determined.  Examples config := NewConfigParamsFromTuples( \u0026#34;descriptor\u0026#34;, \u0026#34;myservice:connector:aws:connector1:1.0\u0026#34;, \u0026#34;param1\u0026#34;, \u0026#34;ABC\u0026#34;, \u0026#34;param2\u0026#34;, 123 ); name := NameResolver.Resolve(config); // Result: connector1  ","description":"A helper class that allows to extract component \"name\" from configuration parameters.\n","image":null,"permalink":"/golang/commons/config/name_resolver/","subtitle":null,"tags":null,"title":"NameResolver"},{"content":"Description A helper class that allows to extract component \u0026ldquo;name\u0026rdquo; from configuration parameters. The name can be defined in the \u0026ldquo;id\u0026rdquo; or \u0026ldquo;name\u0026rdquo; parameters or inside a component of descriptor type.\nStatic Methods Resolve Resolves a component\u0026rsquo;s name from configuration parameters. The name can be stored in \u0026ldquo;id\u0026rdquo;, \u0026ldquo;name\u0026rdquo; fields or inside a descriptor component. If name cannot be determined, it returns a defaultName.\n public static string Resolve(ConfigParams config, string defaultName = null)\n  config: ConfigParams - configuration parameters that may contain a component\u0026rsquo;s name. defaultName: string - (optional) default component\u0026rsquo;s name. returns: string - resolved name or default name, if the name cannot be determined.  Examples // Using the descriptor class (which has the following parameters: \u0026#34;group\u0026#34;, \u0026#34;type\u0026#34;, \u0026#34;kind\u0026#34;, \u0026#34;name\u0026#34;, \u0026#34;version\u0026#34;) will extract the value of the \u0026#34;name\u0026#34; parameter. var config = ConfigParams.FromTuples(\u0026#34;descriptor\u0026#34;, \u0026#34;myservice:connector:aws:connector1:1.0\u0026#34;, \u0026#34;param1\u0026#34;, \u0026#34;ABC\u0026#34;, \u0026#34;param2\u0026#34;, 123); var name = NameResolver.Resolve(config); // Returns connector1  // Using name config = ConfigParams.FromTuples(\u0026#34;name\u0026#34;, \u0026#34;myservice:connector:aws:connector1:1.0\u0026#34;, \u0026#34;param1\u0026#34;, \u0026#34;ABC\u0026#34;, \u0026#34;param2\u0026#34;, 123); name = NameResolver.Resolve(config) // Returns myservice:connector:aws:connector1:1.0  // Using id config = ConfigParams.FromTuples(\u0026#34;id\u0026#34;, \u0026#34;myservice:connector:aws:connector1:1.0\u0026#34;, \u0026#34;param1\u0026#34;, \u0026#34;ABC\u0026#34;, \u0026#34;param2\u0026#34;, 123); var id = NameResolver.Resolve(config); // Returns myservice:connector:aws:connector1:1.0  // If name cannot be determined config = ConfigParams.FromTuples(\u0026#34;param1\u0026#34;, \u0026#34;ABC\u0026#34;, \u0026#34;param2\u0026#34;, 123); name = NameResolver.Resolve(config,\u0026#34;default name\u0026#34;); // Returns \u0026#34;default name\u0026#34; ","description":"A helper class that allows to extract component \"name\" from configuration parameters.\n","image":null,"permalink":"/net/commons/config/name_resolver/","subtitle":null,"tags":null,"title":"NameResolver"},{"content":"Description A helper class that allows to extract a component\u0026rsquo;s \u0026ldquo;name\u0026rdquo; from its configuration parameters. The name can be defined in the \u0026ldquo;id\u0026rdquo; or \u0026ldquo;name\u0026rdquo; parameters or inside a component of type descriptor.\nStatic Methods resolve Resolves a component\u0026rsquo;s name from configuration parameters. The name can be stored in \u0026ldquo;id\u0026rdquo;, \u0026ldquo;name\u0026rdquo; fields or inside a component descriptor. If the name cannot be determined it returns a defaultName.\n public static resolve(config: ConfigParams, defaultName: string = null): string\n  config: ConfigParams - configuration parameters that may contain a component name. defaultName: string - (optional) default component name. returns: string - resolved name or default name if the name cannot be determined.  Examples // Using the descriptor class (which has the following parameters: \u0026#34;group\u0026#34;, \u0026#34;type\u0026#34;, \u0026#34;kind\u0026#34;, \u0026#34;name\u0026#34;, \u0026#34;version\u0026#34;) will extract the value of the \u0026#34;name\u0026#34; parameter. let config = ConfigParams.fromTuples(\u0026#34;descriptor\u0026#34;, \u0026#34;myservice:connector:aws:connector1:1.0\u0026#34;, \u0026#34;param1\u0026#34;, \u0026#34;ABC\u0026#34;, \u0026#34;param2\u0026#34;, 123); let name = NameResolver.resolve(config); // Returns connector1  // Using name config = ConfigParams.fromTuples(\u0026#34;name\u0026#34;, \u0026#34;myservice:connector:aws:connector1:1.0\u0026#34;, \u0026#34;param1\u0026#34;, \u0026#34;ABC\u0026#34;, \u0026#34;param2\u0026#34;, 123); name = NameResolver.resolve(config) // Returns myservice:connector:aws:connector1:1.0  // Using id config = ConfigParams.fromTuples(\u0026#34;id\u0026#34;, \u0026#34;myservice:connector:aws:connector1:1.0\u0026#34;, \u0026#34;param1\u0026#34;, \u0026#34;ABC\u0026#34;, \u0026#34;param2\u0026#34;, 123); let id = NameResolver.resolve(config); // Returns myservice:connector:aws:connector1:1.0  // If name cannot be determined config = ConfigParams.fromTuples(\u0026#34;param1\u0026#34;, \u0026#34;ABC\u0026#34;, \u0026#34;param2\u0026#34;, 123); name = NameResolver.resolve(config,\u0026#34;default name\u0026#34;); // Returns \u0026#34;default name\u0026#34; ","description":"A helper class that allows to extract a component's \"name\" from its configuration parameters.\n","image":null,"permalink":"/node/commons/config/name_resolver/","subtitle":null,"tags":null,"title":"NameResolver"},{"content":"Description A helper class that allows to extract component \u0026ldquo;name\u0026rdquo; from configuration parameters. The name can be defined in the \u0026ldquo;id\u0026rdquo; or \u0026ldquo;name\u0026rdquo; parameters or inside a component of type descriptor.\nStatic Methods resolve Resolves a component name from configuration parameters. The name can be stored in \u0026ldquo;id\u0026rdquo;, \u0026ldquo;name\u0026rdquo; fields or inside a component descriptor. If name cannot be determined it returns a defaultName.\n static resolve(config: ConfigParams, default_name: str = None): str\n  config: ConfigParams - configuration parameters that may contain a component name. default_name: str - (optional) a default component name. returns: str - resolved name or default name if the name cannot be determined.  Examples # Using the descriptor class (which has the following parameters: \u0026#34;group\u0026#34;, \u0026#34;type\u0026#34;, \u0026#34;kind\u0026#34;, \u0026#34;name\u0026#34;, \u0026#34;version\u0026#34;) will extract the value of the \u0026#34;name\u0026#34; parameter. config = ConfigParams.from_tuples(\u0026#34;descriptor\u0026#34;, \u0026#34;myservice:connector:aws:connector1:1.0\u0026#34;, \u0026#34;param1\u0026#34;, \u0026#34;ABC\u0026#34;, \u0026#34;param2\u0026#34;, 123) name = NameResolver.resolve(config) # Returns connector1 # Using name config = ConfigParams.from_tuples(\u0026#34;name\u0026#34;, \u0026#34;myservice:connector:aws:connector1:1.0\u0026#34;, \u0026#34;param1\u0026#34;, \u0026#34;ABC\u0026#34;, \u0026#34;param2\u0026#34;, 123) name = NameResolver.resolve(config) # Returns myservice:connector:aws:connector1:1.0 # Using id config = ConfigParams.from_tuples(\u0026#34;id\u0026#34;, \u0026#34;myservice:connector:aws:connector1:1.0\u0026#34;, \u0026#34;param1\u0026#34;, \u0026#34;ABC\u0026#34;, \u0026#34;param2\u0026#34;, 123) id = NameResolver.resolve(config) # Returns myservice:connector:aws:connector1:1.0 # If name cannot be determined config = ConfigParams.from_tuples(\u0026#34;param1\u0026#34;, \u0026#34;ABC\u0026#34;, \u0026#34;param2\u0026#34;, 123) name = NameResolver.resolve(config,\u0026#34;default name\u0026#34;) #Returns \u0026#34;default name\u0026#34; ","description":"A helper class that allows to extract component \"name\" from configuration parameters.\n","image":null,"permalink":"/python/commons/config/name_resolver/","subtitle":null,"tags":null,"title":"NameResolver"},{"content":"Description The NotFoundError class is used to manage errors caused by attempts to access missing objects.\nConstructors NewNotFoundError Creates an error instance and assigns its values.\n NewNotFoundError(correlationId, code, message string) *ApplicationError\n  correlationId: string - (optional) unique transaction id used to trace execution through the call chain. code: string - (optional) unique error code. Default: \u0026ldquo;UNKNOWN\u0026rdquo; message: string - (optional) a human-readable description of the error.  ","description":"Errors caused by attempts to access missing objects.\n","image":null,"permalink":"/golang/commons/errors/not_found_error/","subtitle":null,"tags":null,"title":"NotFoundError"},{"content":"Inherits: ApplicationException\nDescription The NotFoundException class is used to manage errors caused by attempts to access missing objects.\nConstructors Creates an error instance and assigns its values.\n public NotFoundException(string correlationId = null, string code = null, string message = null)\n  correlationId: string - (optional) unique transaction id used to trace execution through the call chain. code: string - (optional) unique error code. Default: \u0026ldquo;UNKNOWN\u0026rdquo; message: string - (optional) human-readable description of the error.  Creates an error instance with error message\n public NotFoundException(string message)\n  message: string - human-readable description of the error.  Creates an error instance and assigns its values.\n public NotFoundException(Exception innerException)\n  innerException: Exception - error object  Creates an error instance by processing native C# Exceptions.\n protected NotFoundException(SerializationInfo info, StreamingContext context)\n  info: SerializationInfo - serialized information containing the serialized object data about the exception being thrown. context: StreamingContext - streaming context containing contextual information about the source or destination.  ","description":"Errors caused by attempts to access missing objects.\n","image":null,"permalink":"/net/commons/errors/not_found_exception/","subtitle":null,"tags":null,"title":"NotFoundException"},{"content":"Extends: ApplicationException\nDescription The NotFoundException class is used to manage errors caused by attempts to access missing objects.\nConstructors Creates an error instance and assigns its values.\n public NotFoundException(correlation_id: string = null, code: string = null, message: string = null)\n  correlation_id: string - (optional) unique transaction id used to trace execution through a call chain. code: string - (optional) unique error code. Default: \u0026ldquo;UNKNOWN\u0026rdquo;. message: string - (optional) human-readable description of the error.  ","description":"Errors caused by attempts to access missing objects.\n","image":null,"permalink":"/node/commons/errors/not_found_exception/","subtitle":null,"tags":null,"title":"NotFoundException"},{"content":"Implements: ApplicationException\nDescription The NotFoundException class is used to manage errors caused by attempts to access missing objects.\nConstructors Creates an error instance and assigns its values.\n NotFoundException(correlation_id: Optional[str] = None, code: str = None, message: str = None)\n  correlation_id: Optional[str] - (optional) a unique transaction id to trace execution through call chain. code: str - (optional) a unique error code. Default: \u0026ldquo;UNKNOWN\u0026rdquo; message: str - (optional) a human-readable description of the error.  ","description":"Errors caused by attempts to access missing objects.\n","image":null,"permalink":"/python/commons/errors/not_found_exception/","subtitle":null,"tags":null,"title":"NotFoundException"},{"content":"Description The Notifier class is a helper class that can be used to notify one or more components.\nMethods Notify Sets execution parameters.\n (c *TNotifier) Notify(correlationId string, components []interface{}, args *Parameters)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. components: []interface{} - list of components that are to be notified. args: *Parameters - notification arguments.  NotifyOne Notifies specific component.\nTo be notiied components must implement INotifiable interface. If they don\u0026rsquo;t the call to this method has no effect.\n (c *TNotifier) NotifyOne(correlationId string, component interface{}, args *Parameters)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. component: interface{} - component that is to be notified. args: Parameters - notification arguments.  See also   INotifiable   ","description":"Helper class that can be used to notify one or more components.\n","image":null,"permalink":"/golang/commons/run/notifier/","subtitle":null,"tags":null,"title":"Notifier"},{"content":"Description The Notifier class is a helper class that can be use to notify one or more components.\nStatic methods NotifyAsync Sets execution parameters.\n public static Task NotifyAsync(string correlationId, IEnumerable components, Parameters args)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. components: IEnumerable - list of components that are to be notified. args: Parameters - notification arguments.  NotifyOneAsync Notifies specific component.\nTo be notiied, components must implement INotifiable interface. If they don\u0026rsquo;t, the call to this method has no effect.\n public static Task NotifyOneAsync(string correlationId, object component, Parameters args)\n  correlationId: string - (optional) transaction id used to trace execution through teh call chain. component: object - component that is to be notified. args: Parameters - notifiation arguments.  See also   INotifiable   ","description":"Helper class that can be use to notify one or more components.\n","image":null,"permalink":"/net/commons/run/notifier/","subtitle":null,"tags":null,"title":"Notifier"},{"content":"Description The Notifier class is a helper class that can be use to notify one or more components.\nStatic methods notify Sets execution parameters.\n public static notify(correlationId: string, components: any[], args: Parameters): void\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. components: any[] - list of components that are to be notified. args: Parameters - notification arguments.  notifyOne Notifies a specific component.\nTo be notiied, components must implement the INotifiable interface. If they don\u0026rsquo;t, the call to this method has no effect.\n public static notifyOne(correlationId: string, component: any, args: Parameters): void\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. component: any - component that is to be notified. args: Parameters - notifiation arguments.  See also   INotifiable   ","description":"Helper class that can be use to notify one or more components.\n","image":null,"permalink":"/node/commons/run/notifier/","subtitle":null,"tags":null,"title":"Notifier"},{"content":"Description The Notifier class is a helper class that can be use to notify one or more components.\nStatic methods notify Sets execution parameters.\n static notify(correlation_id: Optional[str], components: List[Any], args: Parameters)\n  correlation_id: Optional[str] - (optional) transaction id to trace execution through call chain. components: List[Any] - a list of components that are to be notified. args: Parameters - notification arguments.  notify_one Notifies specific component.\nTo be notiied components must implement INotifiable interface. If they don\u0026rsquo;t, the call to this method has no effect.\n static notify_one(correlation_id: Optional[str], component: Any, args: Parameters)\n  correlation_id: Optional[str] - (optional) transaction id to trace execution through call chain. component: Any - the component that is to be notified. args: Parameters - notifiation arguments.  See also   INotifiable   ","description":"Helper class that can be use to notify one or more components.\n","image":null,"permalink":"/python/commons/run/notifier/","subtitle":null,"tags":null,"title":"Notifier"},{"content":"Description The NotRule class allows you to negate a rule. Thus, when the embedded rule returns errors, then the negated rule returns no errors and vice versa.\nConstructors NewNotRule Creates a new validation rule and sets its values\n NewNotRule(rule IValidationRule) *NotRule\n  rule: IValidationRule - rule to be negated.  Methods Validate Validates a given value against this rule.\n (c *NotRule) Validate(path string, schema ISchema, value interface{}) []*ValidationResult\n  path: string - dot notation path to the value. schema: ISchema - schema this rule is called from value: interface{} - value to be validated. results: []*ValidationResult - list with validation results to add new results.  Examples var schema = NewSchema() .WithRule(NewNotRule( NewValueComparisonRule(\u0026#34;EQ\u0026#34;, 1) )); schema.Validate(1); // Result: error schema.Validate(5); // Result: no error  See also   IValidationRule   ","description":"Validation rule used to negate another rule.\n","image":null,"permalink":"/golang/commons/validate/not_rule/","subtitle":null,"tags":null,"title":"NotRule"},{"content":"Inherits: IValidationRule\nDescription The NotRule class allows you to negate a rule. Thus, when the embedded rule returns errors, then the negated rule returns no errors and vice versa.\nConstructors Creates a new validation rule and sets its values.\n public NotRule(IValidationRule rule)\n  rule: IValidationRule - rule to be negated.  Instance methods Validate Validates a given value against this rule.\n public void Validate(string path, Schema schema, object value, List\u0026lt;ValidationResult\u0026gt; results)\n  path: string - dot notation path to the value. schema: Schema - schema this rule is called from value: object - value to be validated. results: List\u0026lt;ValidationResult\u0026gt; - list with validation results to add new results.  Examples var schema = new Schema().WithRule( new NotRule(new ValueComparisonRule(\u0026#34;EQ\u0026#34;, 1))); schema.Validate(1); // Result: error schema.Validate(5); // Result: no error  See also   IValidationRule   ","description":"Validation rule used to negate another rule.\n","image":null,"permalink":"/net/commons/validate/not_rule/","subtitle":null,"tags":null,"title":"NotRule"},{"content":"Implements: IValidationRule\nDescription The NotRule class allows you to negate a rule. Thus, when the embedded rule returns errors, then the negated rule returns no errors and vice versa.\nConstructors Creates a new validation rule and sets its values\n public constructor(rule: IValidationRule)\n  rule: IValidationRule - rule to be negated.  Instance methods validate Validates a given value against this rule.\n public validate(path: string, schema: Schema, value: any, results: ValidationResult[]): void\n  path: string - dot notation path to the value. schema: Schema - schema this rule is called from value: any - value to be validated. results: ValidationResult[] - list with validation results to add new results.  Examples let schema = new Schema() .withRule(new NotRule( new ValueComparisonRule(\u0026#34;EQ\u0026#34;, 1) )); schema.validate(1); // Result: error schema.validate(5); // Result: no error  See also   IValidationRule   ","description":"Validation rule used to negate another rule.\n","image":null,"permalink":"/node/commons/validate/not_rule/","subtitle":null,"tags":null,"title":"NotRule"},{"content":"Implements: IValidationRule\nDescription The NotRule class allows you to negate a rule. Thus, when the embedded rule returns errors, then the negated rule returns no errors and vice versa.\nConstructors Creates a new validation rule and sets its values\n NotRule(rule: IValidationRule)\n  rule: IValidationRule - a rule to be negated.  Instance methods validate Validates a given value against this rule.\n validate(path: str, schema: Schema, value: Any, results: List[ValidationResult])\n  path: str - a dot notation path to the value. schema: Schema - a schema this rule is called from value: Any - a value to be validated. results: List[ValidationResult] - a list with validation results to add new results.  Examples schema = Schema().with_rule(NotRule(ValueComparisonRule(\u0026#34;EQ\u0026#34;, 1))) schema.validate(1) # Result: error schema.validate(5) # Result: no error See also   IValidationRule   ","description":"Validation rule used to negate another rule.\n","image":null,"permalink":"/python/commons/validate/not_rule/","subtitle":null,"tags":null,"title":"NotRule"},{"content":"Description The NullCache class allows you to implement a dummy cache that doesn\u0026rsquo;t do anything.\nImportant points\n It can be used in testing or in situations where a cache is required but must be disabled.  Constructors NewNullCache Creates a new instance of the cache.\n NewNullCache() *NullCache\n Methods Remove Removes a value from the cache by its key.\n (c *NullCache) Remove(correlationId string, key string) error\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. key: string - unique value key. returns: error - return error if the value was not removed.  Retrieve Retrieves a cached value from the cache using its key. If the value is missing in the cache or expired, it returns nil.\n (c *NullCache) Retrieve(correlationId string, key string) (interface{}, error)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. key: string - unique value key. returns: (interface{}, error) - cached value or nil, if value wasn\u0026rsquo;t found or timeout expired.  RetrieveAs Retrieves a cached value from the cache using its key and restores it into a reference object. If the value is missing in the cache or expired, it returns false.\n (c *MemoryCache) RetrieveAs(correlationId string, key string, result interface{}) (interface{}, error)\n  correlationId: string - transaction id used to trace execution through the call chain. key: string - unique value key. result: (interface{}, error) - pointer to object for restore  Store Stores value in the cache with an expiration time.\n (c *NullCache) Store(correlationId string, key string, value interface{}, timeout int64) (interface{}, error)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. key: string - unique value key. value: interface{} - value to store. timeout: int64 - expiration timeout in milliseconds. returns: (interface{}, error) - cached value stored in the cache.  See also   ICache   ","description":"Dummy cache implementation that doesn't do anything.\n","image":null,"permalink":"/golang/components/cache/null_cache/","subtitle":null,"tags":null,"title":"NullCache"},{"content":"Inherits: ICache\nDescription The NullCache class allows you to implement a dummy cache that doesn\u0026rsquo;t do anything.\nImportant points\n It can be used in testing or in situations where a cache is required but must be disabled.  Static methods RemoveAsync Removes a value from the cache by its key.\n public override Task Remove(string correlationId, string key)\n  correlationId: string - (optional) transaction id to trace execution through a call chain. key: string - a unique value key.  RetrieveAsync Retrieves cached value from the cache using its key. If value is missing in the cache or expired, it returns null.\n public Task\u0026lt;T\u0026gt; RetrieveAsync\u0026lt;T\u0026gt;(string correlationId, string key)\n  correlationId: string - (optional) transaction id to trace execution through a call chain. key: string - a unique value key. returns: Task\u0026lt;T\u0026gt; - a cached value or null, if value wasn\u0026rsquo;t found or timeout expired.  StoreAsync Stores value in the cache with expiration time.\n public Task\u0026lt;T\u0026gt; StoreAsync\u0026lt;T\u0026gt;(string correlationId, string key, T value, long timeout)\n  correlationId: string - (optional) transaction id to trace execution through call chain. key: string - a unique value key. value: T - a value to store. timeout: long - expiration timeout in milliseconds. returns: Task\u0026lt;T\u0026gt; - a cached value stored in the cache.  See also   ICache   ","description":"Dummy cache implementation that doesn't do anything.\n","image":null,"permalink":"/net/components/cache/null_cache/","subtitle":null,"tags":null,"title":"NullCache"},{"content":"Implements: ICache\nDescription The NullCache class allows you to implement a dummy cache that doesn\u0026rsquo;t do anything.\nImportant points\n It can be used in testing or in situations where a cache is required but must be disabled.  Static methods remove Removes a value from the cache by its key.\n public remove(correlationId: string, key: string): Promise\u0026lt;void\u0026gt;\n  correlationId: string - (optional) transaction id to trace execution through a call chain. key: string - a unique value key.  retrieve Retrieves cached value from the cache using its key. If value is missing in the cache or expired, it returns null.\n public retrieve(correlationId: string, key: string): Promise\u0026lt;any\u0026gt;\n  correlationId: string - (optional) transaction id to trace execution through a call chain. key: string - a unique value key. returns: Promise\u0026lt;any\u0026gt; - a cached value or null, if value wasn\u0026rsquo;t found or timeout expired.  store Stores value in the cache with expiration time.\n public store(correlationId: string, key: string, value: any, timeout: number): Promise\u0026lt;any\u0026gt;\n  correlationId: string - (optional) transaction id to trace execution through call chain. key: string - a unique value key. value: any - a value to store. timeout: number - expiration timeout in milliseconds. returns: Promise\u0026lt;any\u0026gt; - a cached value stored in the cache.  See also   ICache   ","description":"Dummy cache implementation that doesn't do anything.\n","image":null,"permalink":"/node/components/cache/null_cache/","subtitle":null,"tags":null,"title":"NullCache"},{"content":"Implements: ICache\nDescription The NullCache class allows you to implement a dummy cache that doesn\u0026rsquo;t do anything.\nImportant points\n It can be used in testing or in situations where a cache is required but must be disabled.  Static methods remove Removes a value from the cache by its key.\n remove(correlation_id: Optional[str], key: str)\n  correlation_id: Optional[str] - (optional) transaction id to trace execution through a call chain. key: str - a unique value key.  retrieve Retrieves cached value from the cache using its key. If value is missing in the cache or expired, it returns None.\n retrieve(correlation_id: Optional[str], key: str): Any\n  correlation_id: Optional[str] - (optional) transaction id to trace execution through a call chain. key: str - a unique value key. returns: Any - a cached value or None, if value wasn\u0026rsquo;t found or timeout expired.  store Stores value in the cache with expiration time.\n store(correlation_id: Optional[str], key: str, value: Any, timeout: int): Any\n  correlation_id: Optional[str] - (optional) transaction id to trace execution through call chain. key: str - a unique value key. value: Any - a value to store. timeout: int - expiration timeout in milliseconds. returns: Any - a cached value stored in the cache.  See also   ICache   ","description":"Dummy cache implementation that doesn't do anything.\n","image":null,"permalink":"/python/components/cache/null_cache/","subtitle":null,"tags":null,"title":"NullCache"},{"content":"Implements: ICounters\nDescription The NullCounters class allows you to create dummy performance counters.\nImportant points\n It can be used in testing or in situations when a counter is required but must be disabled.  Constructors NewNullCounters Creates a new instance of the counter.\n NewNullCounters() *NullCounters\n Methods BeginTiming Begins measurement of execution time interval. It returns *CounterTiming object which has to be called at CounterTiming.EndTiming to end the measurement and update the counter.\n (c *NullCounters) BeginTiming(name string) *CounterTiming\n  name: string - counter name of Interval type. returns: *CounterTiming - callback object to end timing.  Increment Increments counter by given value.\n (c *NullCounters) Increment(name string, value float32)\n  name: string - counter name of Increment type. value: float32 - value to add to the counter.  IncrementOne Increments counter by 1.\n (c *NullCounters) IncrementOne(name string)\n  name: string - counter name of Increment type.  Last Records the last calculated measurement value. Usually this method is used by metrics calculated externally.\n (c *NullCounters) Last(name string, value float32)\n  name: string - counter name of Last type. value: float32 - last value to record.  Stats Calculates min/average/max statistics based on the current and previous values.\n (c *NullCounters) Stats(name string, value float32)\n  name: string - counter name of Statistics type value: float32 - value to update statistics  Timestamp Records the given timestamp.\n (c *NullCounters) Timestamp(name string, value time.Time)\n  name: string - counter name of Timestamp type. value: time.Time - timestamp to record.  TimestampNow Records the current time as a timestamp.\n (c *NullCounters) TimestampNow(name string)\n  name: string - counter name of Timestamp type.  See also  ICounters  ","description":"Dummy implementation of performance counters.\n","image":null,"permalink":"/golang/components/count/null_counters/","subtitle":null,"tags":null,"title":"NullCounters"},{"content":"Inherits: ICounters\nDescription The NullCounters class allows you to create dummy performance counters.\nImportant points\n It can be used in testing or in situations when a counter is required but must be disabled.  Instance methods BeginTiming Begins measurement of execution time interval. It returns CounterTiming object which has to be called at CounterTiming.EndTiming to end the measurement and update the counter.\n public CounterTiming BeginTiming(string name)\n  name: string - a counter name of Interval type. returns: CounterTiming - a callback object to end timing.  Increment Increments counter by given value.\n public void Increment(string name, int value)\n  name: string - a counter name of Increment type. value: int - a value to add to the counter.  IncrementOne Increments counter by 1.\n public void IncrementOne(string name)\n  name: string - a counter name of Increment type.  Last Records the last calculated measurement value. Usually this method is used by metrics calculated externally.\n public void Last(string name, float value)\n  name: string - a counter name of Last type. value: float - a last value to record.  Stats Calculates min/average/max statistics based on the current and previous values.\n public void Stats(string name, float value)\n  name: string - a counter name of Statistics type value: float - a value to update statistics  Timestamp Records the given timestamp.\n public void Timestamp(string name, DateTime value)\n  name: string - a counter name of Timestamp type. value: Date - a timestamp to record.  timestampNow Records the current time as a timestamp.\n public void timestampNow(string name)\n  name: string - a counter name of Timestamp type.  See also  ICounters  ","description":"Dummy implementation of performance counters.\n","image":null,"permalink":"/net/components/count/null_counters/","subtitle":null,"tags":null,"title":"NullCounters"},{"content":"Implements: ICounters\nDescription The NullCounters class allows you to create dummy performance counters.\nImportant points\n It can be used in testing or in situations when a counter is required but must be disabled.  Instance methods beginTiming Begins measurement of execution time interval. It returns CounterTiming object which has to be called at CounterTiming.endTiming to end the measurement and update the counter.\n public beginTiming(name: string): CounterTiming: void\n  name: string - a counter name of Interval type. returns: CounterTiming - a callback object to end timing.  increment Increments counter by given value.\n public increment(name: string, value: number): void\n  name: string - a counter name of Increment type. value: number - a value to add to the counter.  incrementOne Increments counter by 1.\n public incrementOne(name: string): void\n  name: string - a counter name of Increment type.  last Records the last calculated measurement value. Usually this method is used by metrics calculated externally.\n public last(name: string, value: number): void\n  name: string - a counter name of Last type. value: number - a last value to record.  stats Calculates min/average/max statistics based on the current and previous values.\n public stats(name: string, value: number): void\n  name: string - a counter name of Statistics type value: number - a value to update statistics  timestamp Records the given timestamp.\n public timestamp(name: string, value: Date): void\n  name: string - a counter name of Timestamp type. value: Date - a timestamp to record.  timestampNow Records the current time as a timestamp.\n public timestampNow(name: string): void\n  name: string - a counter name of Timestamp type.  See also  ICounters  ","description":"Dummy implementation of performance counters.\n","image":null,"permalink":"/node/components/count/null_counters/","subtitle":null,"tags":null,"title":"NullCounters"},{"content":"Implements: ICounters\nDescription The NullCounters class allows you to create dummy performance counters.\nImportant points\n It can be used in testing or in situations when a counter is required but must be disabled.  Instance methods begin_timing Begins measurement of execution time interval. It returns CounterTiming object which has to be called at CounterTiming.end_timing to end the measurement and update the counter.\n begin_timing(name: str): CounterTiming\n  name: str - a counter name of Interval type. returns: CounterTiming - a callback object to end timing.  increment Increments counter by given value.\n increment(name: str, value: float)\n  name: str - a counter name of Increment type. value: float - a value to add to the counter.  increment_one Increments counter by 1.\n increment_one(name: str)\n  name: str - a counter name of Increment type.  last Records the last calculated measurement value. Usually this method is used by metrics calculated externally.\n last(name: str, value: float)\n  name: str - a counter name of Last type. value: float - a last value to record.  stats Calculates min/average/max statistics based on the current and previous values.\n stats(name: str, value: float)\n  name: str - a counter name of Statistics type value: float - a value to update statistics  timestamp Records the given timestamp.\n timestamp(name: str, value: datetime.datetime)\n  name: str - a counter name of Timestamp type. value: datetime.datetime - a timestamp to record.  timestamp_now Records the current time as a timestamp.\n timestamp_now(name: str)\n  name: str - a counter name of Timestamp type.  See also  ICounters  ","description":"Dummy implementation of performance counters.\n","image":null,"permalink":"/python/components/count/null_counters/","subtitle":null,"tags":null,"title":"NullCounters"},{"content":"Implements: ILock\nDescription The NullLock allows you to create a dummy lock with no real effect.\nImportant points\n It can be used in testing or in situations when a lock is required but must be disabled.  Constructors NewNullLock Creates a new null lock\n NewNullLock() *NullLock\n Methods AcquireLock Makes multiple attempts to acquire a lock by its key within a given time interval.\n (c *NullLock) AcquireLock(correlationId string, key string, ttl int, timeout int) error\n  correlationId: string -(optional) transaction id used to trace execution through the call chain. key: string - unique lock key to acquire. ttl: int - lock timeout (time to live) in milliseconds. timeout: int - lock acquisition timeout. returns: error - returns error if not acquired.  ReleaseLock Releases a prevously acquired lock by its key.\n (c *NullLock) ReleaseLock(correlationId string, key string) error\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. key: string - unique lock key to release. returns: error - returns error if not released.  TryAcquireLock Makes a single attempt to acquire a lock by its key. It returns immediately a positive or negative result.\n (c *NullLock) TryAcquireLock(correlationId string, key string, ttl int) (bool, error)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. key: string - unique lock key to acquire. ttl: int - lock timeout (time to live) in milliseconds. returns: (bool, error) - lock result  See also   ILock   ","description":"Dummy lock implementation with no real effect.\n","image":null,"permalink":"/golang/components/lock/null_lock/","subtitle":null,"tags":null,"title":"NullLock"},{"content":"Inherits: ILock\nDescription The NullLock allows you to create a dummy lock with no real effect.\nImportant points\n It can be used in testing or in situations when a lock is required but must be disabled.  Instance methods AcquireLock Makes multiple attempts to acquire a lock by its key within a given time interval.\n public AcquireLock(string correlationId, string key, long ttl, long timeout)\n  correlationId: string -(optional) transaction id to trace execution through call chain. key: string - a unique lock key to acquire. ttl: long - a lock timeout (time to live) in milliseconds. timeout: long - a lock acquisition timeout.  ReleaseLock Releases prevously acquired lock by its key.\n public ReleaseLock(string correlationId, string key)\n  correlationId: string - (optional) transaction id to trace execution through call chain. key: string - a unique lock key to release.  TryAcquireLock Makes a single attempt to acquire a lock by its key. It returns immediately a positive or negative result.\n public bool TryAcquireLock(string correlationId, string key, long ttl)\n  correlationId: string - (optional) transaction id to trace execution through a call chain. key: string - a unique lock key to acquire. ttl: long - a lock timeout (time to live) in milliseconds. returns: bool - lock result  See also   ILock   ","description":"Dummy lock implementation with no real effect.\n","image":null,"permalink":"/net/components/lock/null_lock/","subtitle":null,"tags":null,"title":"NullLock"},{"content":"Implements: ILock\nDescription The NullLock allows you to create a dummy lock with no real effect.\nImportant points\n It can be used in testing or in situations when a lock is required but must be disabled.  Instance methods acquireLock Makes multiple attempts to acquire a lock by its key within a given time interval.\n public acquireLock(correlationId: string, key: string, ttl: number, timeout: number)\n  correlationId: string -(optional) transaction id to trace execution through call chain. key: string - a unique lock key to acquire. ttl: number - a lock timeout (time to live) in milliseconds. timeout: number - a lock acquisition timeout.  releaseLock Releases prevously acquired lock by its key.\n public releaseLock(correlationId: string, key: string)\n  correlationId: string - (optional) transaction id to trace execution through call chain. key: string - a unique lock key to release.  tryAcquireLock Makes a single attempt to acquire a lock by its key. It returns immediately a positive or negative result.\n public tryAcquireLock(correlationId: string, key: string, ttl: number): bool\n  correlationId: string - (optional) transaction id to trace execution through a call chain. key: string - a unique lock key to acquire. ttl: number - a lock timeout (time to live) in milliseconds. returns: bool - lock result  See also   ILock   ","description":"Dummy lock implementation with no real effect.\n","image":null,"permalink":"/node/components/lock/null_lock/","subtitle":null,"tags":null,"title":"NullLock"},{"content":"Implements: ILock\nDescription The NullLock allows you to create a dummy lock with no real effect.\nImportant points\n It can be used in testing or in situations when a lock is required but must be disabled.  Instance methods acquire_lock Makes multiple attempts to acquire a lock by its key within a given time interval.\n acquire_lock(correlation_id: Optional[str], key: str, ttl: float, timeout: float)\n  correlation_id: Optional[str] -(optional) transaction id to trace execution through call chain. key: str - a unique lock key to acquire. ttl: float - a lock timeout (time to live) in milliseconds. timeout: float - a lock acquisition timeout.  release_lock Releases prevously acquired lock by its key.\n release_lock(correlation_id: Optional[str], key: str)\n  correlation_id: Optional[str] - (optional) transaction id to trace execution through call chain. key: str - a unique lock key to release.  try_acquire_lock Makes a single attempt to acquire a lock by its key. It returns immediately a positive or negative result.\n try_acquire_lock(correlation_id: Optional[str], key: str, ttl: float): bool\n  correlation_id: Optional[str] - (optional) transaction id to trace execution through a call chain. key: str - a unique lock key to acquire. ttl: float - a lock timeout (time to live) in milliseconds. returns: bool - lock result  See also   ILock   ","description":"Dummy lock implementation with no real effect.\n","image":null,"permalink":"/python/components/lock/null_lock/","subtitle":null,"tags":null,"title":"NullLock"},{"content":"Implements: ILogger\nDescription The NullLogger class provides a dummy logger with no real effect.\nImportant points\n It can be used in testing or in situations when a logger is required but must be disabled.  Constructors NewNullLogger  NewNullLogger() *NullLogger\n Methods Level Gets the maximum log level. Messages with higher log level are filtered out.\n (c *Logger) Level() int\n  returns: int - maximum log level.  Info Logs an important information message\n (c *Logger) Info(correlationId string, message string, args \u0026hellip;interface{})\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. message: string - human-readable message to log. args: \u0026hellip;interface{} - arguments to parameterize the message.  Log Logs a message at a specified log level.\n (c *Logger) Log(level int, correlationId string, err error, message string, args \u0026hellip;interface{})\n  level: int - log level. correlationId: string - (optional) transaction used id to trace execution through the call chain. error: error - error object associated with this message. message: string - human-readable message to log. args: \u0026hellip;interface{} - arguments to parameterize the message.  SetLevel Sets the maximum log level.\n (c *Logger) SetLevel(value int)\n  value: int - new maximum log level.  Trace Logs a low-level debug information for troubleshooting.\n (c *Logger) Trace(correlationId string, message string, args \u0026hellip;interface{})\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. message: string - human-readable message to log. args: \u0026hellip;interface{}- arguments to parameterize the message.  Warn Logs a warning that may or may not have a negative impact.\n (c *Logger) Warn(correlationId string, message string, args \u0026hellip;interface{})\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. message: string - human-readable message to log. args: \u0026hellip;interface{} - arguments to parameterize the message.  See also   ILogger   ","description":"Dummy implementation of logger with no real effect.\n","image":null,"permalink":"/golang/components/log/null_logger/","subtitle":null,"tags":null,"title":"NullLogger"},{"content":"Inherits: ILogger\nDescription The NullLogger class provides a dummy logger with no real effect.\nImportant points\n It can be used in testing or in situations when a logger is required but must be disabled.  Instance methods ComposeError Composes an human-readable error description\n protected string ComposeError(Exception error)\n  error: Exception - an error to format. returns: string - a human-redable error description.  Configure Configures component by passing configuration parameters.\n public virtual void Configure(ConfigParams config)\n  config: ConfigParams - configuration parameters to be set.  Debug Logs high-level debug information for troubleshooting.\n public void Debug(string correlationId, string message, params object[] args)\n  correlationId: string - (optional) transaction id to trace execution through a call chain. message: string - a human-readable message to log. args: object[] - arguments to parameterize the message.  Debug Logs high-level debug information for troubleshooting.\n public void Debug(string correlationId, Exception error, string message = null, params object[] args)\n  correlationId: string - (optional) transaction id to trace execution through a call chain. error: Exception - an error object associated with this message. message: string - a human-readable message to log. args: object[] - arguments to parameterize the message.  Error Logs recoverable application error.\n public void Error(string correlationId, string message, params object[] args)\n  correlationId: string - (optional) transaction id to trace execution through a call chain. message: string - a human-readable message to log. args: object[] - arguments to parameterize the message.  Error Logs recoverable application error.\n public void Error(string correlationId, Exception error, string message = null, params object[] args)\n  correlationId: string - (optional) transaction id to trace execution through a call chain. error: Exception - an error object associated with this message. message: string - a human-readable message to log. args: object[] - arguments to parameterize the message.  Fatal Logs fatal (unrecoverable) message that caused the process to crash.\n public void Fatal(string correlationId, string message, params object[] args)\n  correlationId: string - (optional) transaction id to trace execution through a call chain. message: string - a human-readable message to log. args: object[] - arguments to parameterize the message.  Fatal Logs fatal (unrecoverable) message that caused the process to crash.\n public void Fatal(string correlationId, Exception error, string message = null, params object[] args)\n  correlationId: string - (optional) transaction id to trace execution through a call chain. error: Exception - an error object associated with this message. message: string - a human-readable message to log. args: object[] - arguments to parameterize the message.  FormatAndWrite Formats the log message and writes it to the logger destination.\n protected void FormatAndWrite(LogLevel level, string correlationId, Exception error, string message, object[] args)\n  level: LogLevel - a log level. correlationId: string - (optional) transaction id to trace execution through call chain. error: Exception - an error object associated with this message. message: string - a human-readable message to log. args: object[]- arguments to parameterize the message.  Info Logs an important information message\n public void Info(string correlationId, string message, params object[] args): void\n  correlationId: string - (optional) transaction id to trace execution through a call chain. message: string - a human-readable message to log. args: object[] - arguments to parameterize the message.  Info Logs an important information message\n public void Info(string correlationId, Exception error, string message = null, params object[] args): void\n  correlationId: string - (optional) transaction id to trace execution through a call chain. error: Exception - an error object associated with this message. message: string - a human-readable message to log. args: object[] - arguments to parameterize the message.  Log Logs a message at a specified log level.\n public void Log(LogLevel level, string correlationId, Exception error, string message, params object[] args)\n  level: LogLevel - a log level. correlationId: string - (optional) transaction id to trace execution through a call chain. error: Exception - an error object associated with this message. message: string - a human-readable message to log. args: object[] - arguments to parameterize the message.  SetReferences Sets references to dependent components.\n public override void SetReferences(IReferences references)\n  references: IReferences - references to locate the component dependencies.  Trace Logs low-level debug information for troubleshooting.\n public void Trace(string correlationId, string message, params object[] args)\n  correlationId: string - (optional) transaction id to trace execution through call chain. message: string - a human-readable message to log. args: object[] - arguments to parameterize the message.  Trace Logs low-level debug information for troubleshooting.\n public void Trace(string correlationId, Exception error, string message = null, params object[] args)\n  correlationId: string - (optional) transaction id to trace execution through call chain. error: Exception - an error object associated with this message. message: string - a human-readable message to log. args: object[] - arguments to parameterize the message.  Warn Logs a warning that may or may not have a negative impact.\n public void Warn(string correlationId, string message, params object[] args)\n  correlationId: string - (optional) transaction id to trace execution through call chain. message: string - a human-readable message to log. args: object[] - arguments to parameterize the message.  Warn Logs a warning that may or may not have a negative impact.\n public void Warn(string correlationId, Exception error, string message = null, params object[] args)\n  correlationId: string - (optional) transaction id to trace execution through call chain. error: Exception - an error object associated with this message message: string - a human-readable message to log. args: object[] - arguments to parameterize the message.  See also   ILogger   ","description":"Dummy implementation of logger with no real effect.\n","image":null,"permalink":"/net/components/log/null_logger/","subtitle":null,"tags":null,"title":"NullLogger"},{"content":"Implements: ILogger\nDescription The NullLogger class provides a dummy logger with no real effect.\nImportant points\n It can be used in testing or in situations when a logger is required but must be disabled.  Instance methods debug Logs high-level debug information for troubleshooting.\n public debug(correlation_id: string, message: string, \u0026hellip;args: any[])\n  correlation_id: string - (optional) transaction id to trace execution through a call chain. message: string - a human-readable message to log. args: any[] - arguments to parameterize the message.  error Logs recoverable application error.\n public error(correlation_id: string, error: Error, message: string, \u0026hellip;args: any[])\n  correlation_id: string - (optional) transaction id to trace execution through a call chain. error: Error - an error object associated with this message. message: string - a human-readable message to log. args: any[] - arguments to parameterize the message.  fatal Logs fatal (unrecoverable) message that caused the process to crash.\n public fatal(correlation_id: string, error: Error, message: string, \u0026hellip;args: any[])\n  correlation_id: string - (optional) transaction id to trace execution through a call chain. error: Error - an error object associated with this message. message: string - a human-readable message to log. args: any[] - arguments to parameterize the message.  getLevel Gets the maximum log level. Messages with higher log level are filtered out.\n public getLevel(): LogLevel\n  returns: LogLevel - the maximum log level.  info Logs an important information message\n public info(correlation_id: string, message: string, \u0026hellip;args: any[])\n  correlation_id: string - (optional) transaction id to trace execution through a call chain. message: string - a human-readable message to log. args: any[] - arguments to parameterize the message.  log Logs a message at specified log level.\n public log(level: LogLevel, correlation_id: string, error: Error, message: string, \u0026hellip;args: any[])\n  level: LogLevel - a log level. correlation_id: string - (optional) transaction id to trace execution through a call chain. error: Error - an error object associated with this message. message: string - a human-readable message to log. args: any[] - arguments to parameterize the message.  trace Logs low-level debug information for troubleshooting.\n public trace(correlation_id: string, message: string, \u0026hellip;args: any[])\n  correlation_id: string - (optional) transaction id to trace execution through a call chain. message: string - a human-readable message to log. args: any[] - arguments to parameterize the message.  warn Logs a warning that may or may not have a negative impact.\n public warn(correlation_id: string, message: Error, \u0026hellip;args: any[])\n  correlation_id: string - (optional) transaction id to trace execution through a call chain. message: string - a human-readable message to log. args: any[] - arguments to parameterize the message.  See also   ILogger   ","description":"Dummy implementation of logger with no real effect.\n","image":null,"permalink":"/node/components/log/null_logger/","subtitle":null,"tags":null,"title":"NullLogger"},{"content":"Implements: ILogger\nDescription The NullLogger class provides a dummy logger with no real effect.\nImportant points\n It can be used in testing or in situations when a logger is required but must be disabled.  Instance methods debug Logs high-level debug information for troubleshooting.\n debug(correlation_id: Optional[str], message: str, *args: Any, **kwargs: Any)\n  correlation_id: Optional[str] - (optional) transaction id to trace execution through a call chain. message: str - a human-readable message to log. args: Any - arguments to parameterize the message. kwargs: Any - arguments to parameterize the message.  error Logs recoverable application error.\n error(correlation_id: Optional[str], error: Exception, message: str, *args: Any, **kwargs: Any)\n  correlation_id: Optional[str] - (optional) transaction id to trace execution through a call chain. error: Exception - an error object associated with this message. message: str - a human-readable message to log. args: Any - arguments to parameterize the message. kwargs: Any - arguments to parameterize the message.  fatal Logs fatal (unrecoverable) message that caused the process to crash.\n fatal(correlation_id: Optional[str], error: Exception, message: str, *args: Any, **kwargs: Any)\n  correlation_id: Optional[str] - (optional) transaction id to trace execution through a call chain. error: Exception - an error object associated with this message. message: str - a human-readable message to log. args: Any - arguments to parameterize the message. kwargs: Any - arguments to parameterize the message.  get_level Gets the maximum log level. Messages with higher log level are filtered out.\n get_level(): LogLevel\n  returns: LogLevel - the maximum log level.  info Logs an important information message\n info(correlation_id: Optional[str], message: str, *args: Any, **kwargs: Any)\n  correlation_id: Optional[str] - (optional) transaction id to trace execution through a call chain. message: str - a human-readable message to log. args: Any - arguments to parameterize the message. kwargs: Any - arguments to parameterize the message.  log Logs a message at specified log level.\n log(level: LogLevel, correlation_id: Optional[str], error: Optional[Exception], message: Optional[str], *args: Any, **kwargs: Any)\n  level: LogLevel - a log level. correlation_id: Optional[str] - (optional) transaction id to trace execution through a call chain. error: Optional[Exception] - an error object associated with this message. message: Optional[str] - a human-readable message to log. args: Any - arguments to parameterize the message. kwargs: Any - arguments to parameterize the message.  trace Logs low-level debug information for troubleshooting.\n trace(correlation_id: Optional[str], message: str, *args: Any, **kwargs: Any)\n  correlation_id: Optional[str] - (optional) transaction id to trace execution through a call chain. message: str - a human-readable message to log. args: Any - arguments to parameterize the message. kwargs: Any - arguments to parameterize the message.  warn Logs a warning that may or may not have a negative impact.\n warn(correlation_id: Optional[str], message: str, *args: Any, **kwargs: Any)\n  correlation_id: Optional[str] - (optional) transaction id to trace execution through a call chain. message: str - a human-readable message to log. args: Any - arguments to parameterize the message. kwargs: Any - arguments to parameterize the message.  See also   ILogger   ","description":"Dummy implementation of logger with no real effect.\n","image":null,"permalink":"/python/components/log/null_logger/","subtitle":null,"tags":null,"title":"NullLogger"},{"content":"Implements: ITracer\nDescription The NullTracer class allows you to create a dummy tracer with no real effect.\nImportant points\n It can be used in testing or in situations when tracing is required but must be disabled.  Constructors NewNullTracer Creates a new instance of the tracer.\n NewNullTracer() *NullTracer\n Methods BeginTrace Begings recording an operation\u0026rsquo;s trace\n (c *NullTracer) BeginTrace(correlationId string, component string, operation string) *TraceTiming\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. component: string - name of the called component operation: string - name of the executed operation. return: *TraceTiming - trace timing object.  Failure Records an operation\u0026rsquo;s failure with its name, duration and error\n (c *NullTracer) Failure(correlationId string, component string, operation string, err error, duration int64)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. component: string - name of the called component operation: string - name of the executed operation. err: error - error object associated with this trace. duration: int64 - execution duration in milliseconds.  Trace Records an operation\u0026rsquo;s trace with its name and duration.\n (c *NullTracer) Trace(correlationId string, component string, operation string, duration int64)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. component: string - name of the called component operation: string - name of the executed operation. duration: int64 - execution duration in milliseconds.  See also   ITracer   ","description":"Dummy implementation of tracer that doesn't do anything.\n","image":null,"permalink":"/golang/components/trace/null_tracer/","subtitle":null,"tags":null,"title":"NullTracer"},{"content":"Inherits: ITracer\nDescription The NullTracer class allows you to create a dummy tracer with no real effect.\nImportant points\n It can be used in testing or in situations when tracing is required but must be disabled.  Instance methods BeginTrace Begings recording an operation trace.\n public TraceTiming BeginTrace(string correlationId, string component, string operation)\n  correlationId: string - (optional) transaction id to trace execution through a call chain. component: string - name of the called component operation: string - name of the executed operation. return: TraceTiming - a trace timing object.  Failure Records an operation failure with its name, duration and error\n public void Failure(string correlationId, string component, string operation, Exception error, long duration)\n  correlationId: string - (optional) transaction id to trace execution through call chain. component: string - name of the called component operation: string - name of the executed operation. error: Exception - an error object associated with this trace. duration: long - execution duration in milliseconds.  Trace Records an operation trace with its name and duration.\n public void Trace(string correlationId, string component, string operation, long duration)\n  correlationId: string - (optional) transaction id to trace execution through a call chain. component: string - name of the called component operation: string - name of the executed operation. duration: long - execution duration in milliseconds.  See also   ITracer   ","description":"Dummy implementation of tracer that doesn't do anything.\n","image":null,"permalink":"/net/components/trace/null_tracer/","subtitle":null,"tags":null,"title":"NullTracer"},{"content":"Implements: ITracer\nDescription The NullTracer class allows you to create a dummy tracer with no real effect.\nImportant points\n It can be used in testing or in situations when tracing is required but must be disabled.  Instance methods beginTrace Begings recording an operation trace\n public beginTrace(correlationId: string, component: string, operation: string): TraceTiming\n  correlationId: string - (optional) transaction id to trace execution through call chain. component: string - name of the called component operation: string - name of the executed operation. return: TraceTiming - a trace timing object.  failure Records an operation failure with its name, duration and error\n public failure(correlationId: string, component: string, operation: string, error: Error, duration: number): void\n  correlationId: string - (optional) transaction id to trace execution through a call chain. component: string - name of the called component operation: string - name of the executed operation. error: Error - an error object associated with this trace. duration: number - execution duration in milliseconds.  trace Records an operation trace with its name and duration.\n public trace(correlationId: string, component: string, operation: string, duration: number): void\n  correlationId: string - (optional) transaction id to trace execution through a call chain. component: string - name of the called component operation: string - name of the executed operation. duration: number - execution duration in milliseconds.  See also   ITracer   ","description":"Dummy implementation of tracer that doesn't do anything.\n","image":null,"permalink":"/node/components/trace/null_tracer/","subtitle":null,"tags":null,"title":"NullTracer"},{"content":"Implements: ITracer\nDescription The NullTracer class allows you to create a dummy tracer with no real effect.\nImportant points\n It can be used in testing or in situations when tracing is required but must be disabled.  Instance methods begin_trace Begings recording an operation trace\n begin_trace(correlation_id: Optional[str], component: str, operation: str): TraceTiming\n  correlation_id: Optional[str] - (optional) transaction id to trace execution through call chain. component: str - name of the called component operation: str - name of the executed operation. return: TraceTiming - a trace timing object.  failure Records an operation failure with its name, duration and error\n failure(correlation_id: Optional[str], component: str, operation: str, error: Exception, duration: float)\n  correlation_id: Optional[str] - (optional) transaction id to trace execution through a call chain. component: str - name of the called component operation: str - name of the executed operation. error: Exception - an error object associated with this trace. duration: float - execution duration in milliseconds.  trace Records an operation trace with its name and duration.\n trace(correlation_id: Optional[str], component: str, operation: str, duration: float)\n  correlation_id: Optional[str] - (optional) transaction id to trace execution through a call chain. component: str - name of the called component operation: str - name of the executed operation. duration: float - execution duration in milliseconds.  See also   ITracer   ","description":"Dummy implementation of tracer that doesn't do anything.\n","image":null,"permalink":"/python/components/trace/null_tracer/","subtitle":null,"tags":null,"title":"NullTracer"},{"content":"Records historical positions of controlled objects.\n Server implementations: NodeJS Communication protocols: Direct, Commandable HTTP, Commandable GRPC, GRPC Persistence: Memory, Flat Files, MongoDB, Couchbase Deployment options: Monolith, Process, Docker, AWS Lambda Client implementations: NodeJS  ","description":null,"image":null,"permalink":"/microservices/iot/object_positions/","subtitle":null,"tags":null,"title":"Object positions Microservice"},{"content":"Records historical routes of controlled objects.\n Server implementations: NodeJS Communication protocols: Direct, Commandable HTTP, Commandable GRPC, GRPC Persistence: Memory, Flat Files, MongoDB, Couchbase Deployment options: Monolith, Process, Docker, AWS Lambda Client implementations: NodeJS  ","description":null,"image":null,"permalink":"/microservices/iot/object_routes/","subtitle":null,"tags":null,"title":"Object routes Microservice"},{"content":"Description The ObjectComparator class allows you to perform a comparison over two values of any type.\nMethods Equal Checks if two values are equal. The operation can be performed over values of any type.\n (c *TObjectComparator) AreEqual(value1 interface{}, value2 interface{}) bool\n  value1: interface{} - first value to compare value2: interface{} - second value to compare returns: bool - true if values are equal and false otherwise  AreNotEqual Checks if two values are NOT equal The operation can be performed over values of any type.\n (c *TObjectComparator) AreNotEqual(value1 interface{}, value2 interface{}) bool\n  value1: interface{} - first value to compare value2: interface{} - second value to compare returns: bool - true if values are NOT equal and false otherwise  Compare Perform comparison operation over two arguments. The operation can be performed over values of any type.\n (c *TObjectComparator) Compare(value1 interface{}, operation string, value2 interface{}) bool\n  value1: interface{} - first argument to compare operation: string - comparison operation: \u0026quot;==\u0026quot; (\u0026quot;=\u0026quot;, \u0026ldquo;EQ\u0026rdquo;), \u0026ldquo;!= \u0026quot; (\u0026quot;\u0026lt;\u0026gt;\u0026rdquo;, \u0026ldquo;NE\u0026rdquo;); \u0026ldquo;\u0026lt;\u0026quot;/\u0026quot;\u0026gt;\u0026rdquo; (\u0026ldquo;LT\u0026rdquo;/\u0026ldquo;GT\u0026rdquo;), \u0026ldquo;\u0026lt;=\u0026quot;/\u0026quot;\u0026gt;=\u0026rdquo; (\u0026ldquo;LE\u0026rdquo;/\u0026ldquo;GE\u0026rdquo;); \u0026ldquo;LIKE\u0026rdquo;. value2: interface{} - second argument to compare returns: bool - result of the comparison operation  IsGreater Checks if the first value is greater than the second one. The operation can be performed over numbers or strings.\n (c *TObjectComparator) IsGreater(value1 interface{}, value2 interface{}) bool\n  value1: interface{} - first value to compare value2: interface{} - second value to compare returns: bool - true if the first value is greater than second and false otherwise.  IsLess Checks if the first value is less than the second one. The operation can be performed over numbers or strings.\n (c *TObjectComparator) IsLess(value1 interface{}, value2 interface{}) bool\n  value1: interface{} - first value to compare value2: interface{} - second value to compare returns: bool - true if the first value is less than second and false otherwise.  Match Checks if a string matches a regular expression\n (c *TObjectComparator) Match(value1 interface{}, value2 interface{}) bool\n  value: interface{} - string value to match regexp: interface{} - regular expression string returns: bool - true if the value matches the regular expression and false otherwise.  Examples ObjectComparator.Compare(2, \u0026#34;GT\u0026#34;, 1); // Result: true ObjectComparator.AreEqual(\u0026#34;A\u0026#34;, \u0026#34;B\u0026#34;); // Result: false  ","description":"Comparator over two values of any type.\n","image":null,"permalink":"/golang/commons/validate/object_comparator/","subtitle":null,"tags":null,"title":"ObjectComparator"},{"content":"Description The ObjectComparator class allows you to perform a comparison over two values of any type.\nStatic methods AreEqual Checks if two values are equal. The operation can be performed over values of any type.\n public static bool AreEqual(object value1, object value2)\n  value1: object - first value to compare value2: object - second value to compare returns: bool - true if values are equal and false otherwise  AreNotEqual Checks if two values are NOT equal The operation can be performed over values of any type.\n public static bool AreNotEqual(object value1, object value2)\n  value1: object - first value to compare value2: object - second value to compare returns: bool - true if values are NOT equal and false otherwise  Compare Perform a comparison operation over two arguments. The operation can be performed over values of any type.\n public static bool Compare(object value1, string operation, object value2)\n  value1: object - first argument to compare operation: string - the comparison operation: \u0026quot;==\u0026quot; (\u0026quot;=\u0026quot;, \u0026ldquo;EQ\u0026rdquo;), \u0026ldquo;!= \u0026quot; (\u0026quot;\u0026lt;\u0026gt;\u0026rdquo;, \u0026ldquo;NE\u0026rdquo;); \u0026ldquo;\u0026lt;\u0026quot;/\u0026quot;\u0026gt;\u0026rdquo; (\u0026ldquo;LT\u0026rdquo;/\u0026ldquo;GT\u0026rdquo;), \u0026ldquo;\u0026lt;=\u0026quot;/\u0026quot;\u0026gt;=\u0026rdquo; (\u0026ldquo;LE\u0026rdquo;/\u0026ldquo;GE\u0026rdquo;); \u0026ldquo;LIKE\u0026rdquo;. value2: object - second argument to compare returns: bool - result of the comparison operation  IsGreater Checks if the first value is greater than the second one. The operation can be performed over numbers or strings.\n public static bool IsGreater(object value1, object value2)\n  value1: object - first value to compare value2: object - second value to compare returns: bool - true if the first value is greater than second and false otherwise.  IsLess Checks if the first value is less than the second one. The operation can be performed over numbers or strings.\n public static bool IsLess(object value1, object value2)\n  value1: object - first value to compare value2: object - second value to compare returns: bool - true if the first value is less than second and false otherwise.  Match Checks if a string matches a regular expression\n public static bool Match(object value1, object value2)\n  value1: object - string value to match value2: object - regular expression string returns: bool - true if the value matches regular expression and false otherwise.  Examples ObjectComparator.Compare(2, \u0026#34;GT\u0026#34;, 1); // Result: true ObjectComparator.AreEqual(\u0026#34;A\u0026#34;, \u0026#34;B\u0026#34;); // Result: false  ","description":"Comparator over two values of any type.\n","image":null,"permalink":"/net/commons/validate/object_comparator/","subtitle":null,"tags":null,"title":"ObjectComparator"},{"content":"Description The ObjectComparator class allows you to perform a comparison over two values of any type.\nStatic methods areEqual Checks if two values are equal. The operation can be performed over values of any type.\n public static areEqual(value1: any, value2: any): boolean\n  value1: any - first value to compare. value2: any - second value to compare. returns: boolean - true if values are equal and false otherwise.  areNotEqual Checks if two values are NOT equal. The operation can be performed over values of any type.\n public static areNotEqual(value1: any, value2: any): boolean\n  value1: any - first value to compare value2: any - second value to compare returns: boolean - true if values are NOT equal and false otherwise  compare Perform a comparison operation over two arguments. The operation can be performed over values of any type.\n public static compare(value1: any, operation: string, value2: any): boolean\n  value1: any - first argument to compare. operation: string - comparison operation: \u0026quot;==\u0026quot; (\u0026quot;=\u0026quot;, \u0026ldquo;EQ\u0026rdquo;), \u0026ldquo;!= \u0026quot; (\u0026quot;\u0026lt;\u0026gt;\u0026rdquo;, \u0026ldquo;NE\u0026rdquo;); \u0026ldquo;\u0026lt;\u0026quot;/\u0026quot;\u0026gt;\u0026rdquo; (\u0026ldquo;LT\u0026rdquo;/\u0026ldquo;GT\u0026rdquo;), \u0026ldquo;\u0026lt;=\u0026quot;/\u0026quot;\u0026gt;=\u0026rdquo; (\u0026ldquo;LE\u0026rdquo;/\u0026ldquo;GE\u0026rdquo;); \u0026ldquo;LIKE\u0026rdquo;. value2: any - the second argument to compare. returns: boolean - result of the comparison operation.  isGreater Checks if the first value is greater than the second one. The operation can be performed over numbers or strings.\n public static isGreater(value1: any, value2: any): boolean\n  value1: any - first value to compare value2: any - second value to compare returns: boolean - true if the first value is greater than second and false otherwise.  isLess Checks if first value is less than the second one. The operation can be performed over numbers or strings.\n public static isLess(value1: any, value2: any): boolean\n  value1: any - first value to compare value2: any - second value to compare returns: boolean - true if the first value is less than second and false otherwise.  match Checks if a string matches a regular expression\n public static match(value: any, regexp: any): boolean\n  value: any - string value to match. regexp: any - regular expression string. returns: boolean - true if the value matches the regular expression and false otherwise.  Examples ObjectComparator.compare(2, \u0026#34;GT\u0026#34;, 1); // Result: true ObjectComparator.areEqual(\u0026#34;A\u0026#34;, \u0026#34;B\u0026#34;); // Result: false  ","description":"Comparator over two values of any type.\n","image":null,"permalink":"/node/commons/validate/object_comparator/","subtitle":null,"tags":null,"title":"ObjectComparator"},{"content":"Description The ObjectComparator class allows you to perform a comparison over two values of any type.\nStatic methods are_equal Checks if two values are equal. The operation can be performed over values of any type.\n static are_equal(value1: Any, value2: Any): bool\n  value1: Any - the first value to compare value2: Any - the second value to compare returns: bool - true if values are equal and false otherwise  are_not_equal Checks if two values are NOT equal. The operation can be performed over values of any type.\n static are_not_equal(value1: Any, value2: Any): bool\n  value1: Any - the first value to compare value2: Any - the second value to compare returns: bool - true if values are NOT equal and false otherwise  compare Perform comparison operation over two arguments. The operation can be performed over values of any type.\n static compare(value1: Any, operation: str, value2: Any): bool\n  value1: Any - the first argument to compare operation: str - the comparison operation: \u0026quot;==\u0026quot; (\u0026quot;=\u0026quot;, \u0026ldquo;EQ\u0026rdquo;), \u0026ldquo;!= \u0026quot; (\u0026quot;\u0026lt;\u0026gt;\u0026rdquo;, \u0026ldquo;NE\u0026rdquo;); \u0026ldquo;\u0026lt;\u0026quot;/\u0026quot;\u0026gt;\u0026rdquo; (\u0026ldquo;LT\u0026rdquo;/\u0026ldquo;GT\u0026rdquo;), \u0026ldquo;\u0026lt;=\u0026quot;/\u0026quot;\u0026gt;=\u0026rdquo; (\u0026ldquo;LE\u0026rdquo;/\u0026ldquo;GE\u0026rdquo;); \u0026ldquo;LIKE\u0026rdquo;. value2: Any - the second argument to compare returns: bool - result of the comparison operation  is_greater Checks if first value is greater than the second one. The operation can be performed over numbers or strings.\n static is_greater(value1: Any, value2: Any): bool\n  value1: Any - the first value to compare value2: Any - the second value to compare returns: bool - true if the first value is greater than second and false otherwise.  is_less Checks if first value is less than the second one. The operation can be performed over numbers or strings.\n static is_less(value1: Any, value2: Any): bool\n  value1: Any - the first value to compare value2: Any - the second value to compare returns: bool - true if the first value is less than second and false otherwise.  match Checks if string matches a regular expression\n static match(value: Any, regexp: Any): bool\n  value: Any - a string value to match regexp: Any - a regular expression string returns: bool - true if the value matches regular expression and false otherwise.  Examples ObjectComparator.compare(2, \u0026#34;GT\u0026#34;, 1) # Result: true ObjectComparator.are_equal(\u0026#34;A\u0026#34;, \u0026#34;B\u0026#34;) # Result: false ","description":"Comparator over two values of any type.\n","image":null,"permalink":"/python/commons/validate/object_comparator/","subtitle":null,"tags":null,"title":"ObjectComparator"},{"content":"Description The ObjectReader class allows you to examine the properties of an object (property instrospection) and to dynamically read them.\nImportant points\n In contrast to PropertyReflector which only introspects regular objects, this ObjectReader is also able to handle maps and arrays. For maps, properties are key-pairs identified by string keys. For arrays, properties are elements identified by an integer index. This class has a symmetric implementation across all languages supported by the Pip.Services toolkit and it is used to support dynamic data processing. Because all languages have different casing and case sensitivity rules, this ObjectReader treats all property names as case insensitive.  Methods GetProperties Get values of all properties in a specified object and returns them as a map.\nThe object can be a user defined object, map or array. Returned properties correspondently are object properties, map key-pairs or array elements with their indexes.\n (c *TObjectReader) GetProperties(obj interface{}) map[string]interface{}\n  obj: interface{} - object to get properties from. returns: map[string]interface{} - map, containing the names of the object\u0026rsquo;s properties and their values.  GetProperty Gets value of object property specified by its name.\nThe object can be a user defined object, map or array. The property name correspondently must be an object property, map key or array index.\n (c *TObjectReader) GetProperty(obj interface{}, name string) interface{}\n  obj: interface{} - object to read a property from. name: string - name of the property to get. returns: interface{} - property value or nil if property doesn\u0026rsquo;t exist or introspection failed.  GetPropertyNames Gets the names of all properties implemented in a specified object.\nThe object can be a user defined object, map or array. Returned property name correspondently are object properties, map keys or array indexes.\n (c *TObjectReader) GetPropertyNames(obj interface{}) []string\n  obj: interface{} - objec to introspect. returns: []string - list with property names.  GetValue Gets a real object value. If object is a wrapper, it unwraps the value behind it. Otherwise it returns the same object value.\n (c *TObjectReader) GetValue(obj interface{}) interface{}\n  obj: interface{} - object to unwrap.. returns: interface{} - actual (unwrapped) object value.  HasProperty Checks if object has a property with a specified name.\nThe object can be a user defined object, map or array. The property name correspondently must be an object property, map key or array index.\n (c *TObjectReader) HasProperty(obj interface{}, name string) bool\n  obj: interface{} - object to introspect. name: string - name of the property to check. returns: bool - true if the object has the property and false if it doesn\u0026rsquo;t.  Examples myObj := MyObject{} properties := ObjectReader.GetPropertyNames() ObjectReader.HasProperty(myObj, \u0026#34;myProperty\u0026#34;) value := PropertyReflector.GetProperty(myObj, \u0026#34;myProperty\u0026#34;) myMap := { key1: 123, key2: \u0026#34;ABC\u0026#34; } ObjectReader.HasProperty(myMap, \u0026#34;key1\u0026#34;) value := ObjectReader.GetProperty(myMap, \u0026#34;key1\u0026#34;) myArray := [1, 2, 3] ObjectReader.HasProperty(myArrat, \u0026#34;0\u0026#34;) value := ObjectReader.GetProperty(myArray, \u0026#34;0\u0026#34;) See also   PropertyReflector   ","description":"Helper class that allows you to examine the properties of an object (property instrospection) and to dynamically read them.\n","image":null,"permalink":"/golang/commons/reflect/object_reader/","subtitle":null,"tags":null,"title":"ObjectReader"},{"content":"Description The ObjectReader class allows you to examine the properties of an object (property instrospection) and to dynamically read them.\nImportant points\n In contrast to PropertyReflector which only introspects regular objects, this ObjectReader is also able to handle maps and arrays. For maps, properties are key-pairs identified by string keys. For arrays, properties are elements identified by integer index. This class has a symmetric implementation across all languages supported by the Pip.Services toolkit and it is used to support dynamic data processing. Because all languages have different casing and case sensitivity rules, this ObjectReader treats all property names as case insensitive.  Static methods GetProperties Get the values of all properties in specified object and returns them as a map.\nThe object can be a user defined object, map or array. Returned properties correspondently are object properties, map key-pairs or array elements with their indexes.\n public static Dictionary\u0026lt;string, object\u0026gt; GetProperties(object obj)\n  obj: object - object to get properties from. returns: Dictionary\u0026lt;string, object\u0026gt; - map containing the names of the object\u0026rsquo;s properties and their values.  GetProperty Gets value of a object property specified by its name.\nThe object can be a user defined object, map or array. The property name correspondently must be and object property, map key or array index.\n public static object GetProperty(object obj, string name)\n  obj: object - object to read property from. name: string - name of the property to get. returns: object - property value or null if property doesn\u0026rsquo;t exist or introspection failed.  GetPropertyNames Gets the names of all properties implemented in a specified object.\nThe object can be a user defined object, map or array. Returned property name correspondently are object properties, map keys or array indexes.\n public static List\u0026lt;string\u0026gt; GetPropertyNames(object obj)\n  obj: object - objec to introspect. returns: List\u0026lt;string\u0026gt; - list with property names.  GetValue Gets a real object value. If object is a wrapper, it unwraps the value behind it. Otherwise, it returns the same object value.\n public static object GetValue(object obj)\n  obj: object - object to unwrap.. returns: object - actual (unwrapped) object value.  HasProperty Checks if an object has a property with the specified name.\nThe object can be a user defined object, map or array. The property name correspondently must be an object property, a map key or an array index.\n public static bool HasProperty(object obj, string name)\n  obj: object - object to introspect. name: string - name of the property to check. returns: bool - true if the object has the property and false if it doesn\u0026rsquo;t.  Examples var myObj = new MyObject(); var properties = ObjectReader.GetPropertyNames(); ObjectReader.HasProperty(myObj, \u0026#34;myProperty\u0026#34;); var value = PropertyReflector.GetProperty(myObj, \u0026#34;myProperty\u0026#34;); var myMap = new Dictionary\u0026lt;string, object\u0026gt;(){ {\u0026#34;key1\u0026#34;, 123}, {\u0026#34;key2\u0026#34;, \u0026#34;ABC\u0026#34;}; }; ObjectReader.HasProperty(myMap, \u0026#34;key1\u0026#34;); var value = ObjectReader.getProperty(myMap, \u0026#34;key1\u0026#34;); int[] myArray = new int[] { 1, 2, 3 }; ObjectReader.HasProperty(myArrat, \u0026#34;0\u0026#34;); var value = ObjectReader.GetProperty(myArray, \u0026#34;0\u0026#34;); See also   PropertyReflector   ","description":"Helper class that allows you to examine the properties of an object (property instrospection) and to dynamically read them.\n","image":null,"permalink":"/net/commons/reflect/object_reader/","subtitle":null,"tags":null,"title":"ObjectReader"},{"content":"Description The ObjectReader class allows you to examine the properties of an object (property instrospection) and to dynamically read them.\nImportant points\n In contrast to PropertyReflector which only introspects regular objects, this ObjectReader is also able to handle maps and arrays. For maps, properties are key-pairs identified by string keys. For arrays, properties are elements identified by integer indexes. This class has a symmetric implementation across all languages supported by the Pip.Services toolkit and it is used to support dynamic data processing. Because all languages have different casing and case sensitivity rules, this ObjectReader treats all property names as case insensitive.  Static methods getProperties Get values of all properties in a specified object and returns them as a map.\nThe object can be a user defined object, map or array. Returned properties correspondently are object properties, map key-pairs or array elements with their indexes.\n public static getProperties(obj: any): any\n  obj: any - object to get properties from. returns: any - map, containing the names of the object\u0026rsquo;s properties and their values.  getProperty Gets the value of an object\u0026rsquo;s property specified by its name.\nThe object can be a user defined object, map or array. The property name correspondently must be an object property, map key or array index.\n public static getProperty(obj: any, name: string): any\n  obj: any - object to read property from. name: string - name of the property to get. returns: any - property value or null if the property doesn\u0026rsquo;t exist or introspection failed.  getPropertyNames Gets the names of all the properties implemented in a specified object.\nThe object can be a user defined object, map or array. Returned property names correspondently are object properties, map keys or array indexes.\n public static getPropertyNames(obj: any): string[]\n  obj: any - object to introspect. returns: string[] - list with property names.  getValue Gets an object\u0026rsquo;s value. If object is a wrapper, it unwraps the value behind it. Otherwise it returns the same object value.\n public static getValue(obj: any): any\n  obj: any - object to unwrap.. returns: any - actual (unwrapped) object value.  hasProperty Checks if an object has a property with a specified name.\nThe object can be a user defined object, map or array. The property name correspondently must be an object property, map key or array index.\n public static hasProperty(obj: any, name: string): boolean\n  obj: any - object to introspect. name: string - name of the property to check. returns: boolean - true if the object has the property and false if it doesn\u0026rsquo;t.  Examples let myObj = new MyObject(); let properties = ObjectReader.getPropertyNames(); ObjectReader.hasProperty(myObj, \u0026#34;myProperty\u0026#34;); let value = PropertyReflector.getProperty(myObj, \u0026#34;myProperty\u0026#34;); let myMap = { key1: 123, key2: \u0026#34;ABC\u0026#34; }; ObjectReader.hasProperty(myMap, \u0026#34;key1\u0026#34;); let value = ObjectReader.getProperty(myMap, \u0026#34;key1\u0026#34;); let myArray = [1, 2, 3] ObjectReader.hasProperty(myArrat, \u0026#34;0\u0026#34;); let value = ObjectReader.getProperty(myArray, \u0026#34;0\u0026#34;); See also   PropertyReflector   ","description":"Helper class that allows you to examine the properties of an object (property instrospection) and to dynamically read them.\n","image":null,"permalink":"/node/commons/reflect/object_reader/","subtitle":null,"tags":null,"title":"ObjectReader"},{"content":"Description The ObjectReader class allows you to examine the properties of an object (property instrospection) and to dynamically read them.\nImportant points\n In contrast to PropertyReflector which only introspects regular objects, this ObjectReader is also able to handle maps and arrays. For maps, properties are key-pairs identified by string keys. For arrays, properties are elements identified by integer index. This class has a symmetric implementation across all languages supported by the Pip.Services toolkit and it is used to support dynamic data processing. Because all languages have different casing and case sensitivity rules, this ObjectReader treats all property names as case insensitive.  Static methods get_properties Get values of all properties in specified object and returns them as a map.\nThe object can be a user defined object, map or array. Returned properties correspondently are object properties, map key-pairs or array elements with their indexes.\n static get_properties(obj: Any): Any\n  obj: Any - an object to get properties from. returns: Any - a map, containing the names of the object\u0026rsquo;s properties and their values.  get_property Gets value of object property specified by its name.\nThe object can be a user defined object, map or array. The property name correspondently must be object property, map key or array index.\n static get_property(obj: Any, name: str): Any\n  obj: Any - an object to read property from. name: str - a name of the property to get. returns: Any - the property value or None if property doesn\u0026rsquo;t exist or introspection failed.  get_property_names Gets names of all properties implemented in specified object.\nThe object can be a user defined object, map or array. Returned property name correspondently are object properties, map keys or array indexes.\n static get_property_names(obj: Any): List[str]\n  obj: Any - an objec to introspect. returns: List[str] - a list with property names.  get_value Gets a real object value. If object is a wrapper, it unwraps the value behind it. Otherwise it returns the same object value.\n static get_value(obj: Any): Any\n  obj: Any - an object to unwrap.. returns: Any - an actual (unwrapped) object value.  has_property Checks if object has a property with specified name.\nThe object can be a user defined object, map or array. The property name correspondently must be object property, map key or array index.\n static has_property(obj: Any, name: str): bool\n  obj: Any - an object to introspect. name: str - a name of the property to check. returns: bool - true if the object has the property and false if it doesn\u0026rsquo;t.  Examples mybj = MyObject() properties = ObjectReader.get_property_names() ObjectReader.has_property(myObj, \u0026#34;myProperty\u0026#34;) args = PropertyReflector.get_property(myObj, \u0026#34;myProperty\u0026#34;) myMap = { key1: 123, key2: \u0026#34;ABC\u0026#34; } ObjectReader.has_property(myMap, \u0026#34;key1\u0026#34;) args = ObjectReader.get_property(myMap, \u0026#34;key1\u0026#34;) myArray = [1, 2, 3] ObjectReader.has_property(myArrat, \u0026#34;0\u0026#34;) args = ObjectReader.get_property(myArray, \u0026#34;0\u0026#34;) See also   PropertyReflector   ","description":"Helper class that allows you to examine the properties of an object (property instrospection) and to dynamically read them.\n","image":null,"permalink":"/python/commons/reflect/object_reader/","subtitle":null,"tags":null,"title":"ObjectReader"},{"content":"Implements: Schema\nDescription The ObjectSchema class allows you to create a validation schema that can be used to validate user defined objects.\nConstructors NewObjectSchemaWithRules Creates a new validation schema and sets its values. See IValidationRule\n NewObjectSchemaWithRules(allowUndefined bool, required bool, rules []IValidationRule) *ObjectSchema\n  allowUndefined: bool - true to allow properties undefines in the schema required: bool - (optional) true to always require non-nil values. rules: []IValidationRule - (optional) list with validation rules.  NewObjectSchema Creates a new validation schema and sets its values.\n NewObjectSchema() *ObjectSchema\n Methods AllowUndefined Sets a flag to allow for undefined properties This method returns a reference to this exception to implement the Builder pattern to chain additional calls.\n (c *ObjectSchema) AllowUndefined(value bool) *ObjectSchema\n  value: bool - true to allow undefined properties and false otherwise. returns: ObjectSchema - validation schema.  Properties Gets validation schemas for object properties. See PropertySchema\n (c *ObjectSchema) Properties() []*PropertySchema\n  returns: []*PropertySchema - list of property validation schemas.  PerformValidation Validates a given value against the schema and configured validation rules.\n (c *ObjectSchema) PerformValidation(path string, value interface{}) []*ValidationResult\n  path: string - dot notation path to the value. value: interface{} - value to be validated. results: []*ValidationResult - list with validation results to add new results.  SetUndefinedAllowed Sets a flag to allow for undefined properties\n (c [*ObjectSchema]) SetUndefinedAllowed(value bool)\n  value: bool - true to allow for undefined properties and false otherwise.  SetProperties Sets validation schemas for object properties. See PropertySchema\n (c *ObjectSchema) SetProperties(value []*PropertySchema)\n  value: []*PropertySchema - list of property validation schemas.  UndefinedAllowed Gets a flag to allow for undefined properties\n (c *ObjectSchema) UndefinedAllowed() bool\n  returns: bool - true to allow for undefined properties and false otherwise.  WithOptionalProperty Adds a validation schema for an optional object property.\n (c *ObjectSchema) WithOptionalProperty(name string, typ interface{}, rules \u0026hellip;IValidationRule) *ObjectSchema\n  name: string - property name. typ: interface{} - (optional) property schema or type. rules: \u0026hellip;IValidationRule - (optional) list of property validation rules.  WithProperty Adds a validation schema for an object property. This method returns a reference to this exception to implement the Builder pattern to chain additional calls. See PropertySchema\n (c *ObjectSchema) WithProperty(schema *PropertySchema) *ObjectSchema\n  schema: *PropertySchema - property validation schema to be added. returns: ObjectSchema - validation schema.  WithRequiredProperty Adds a validation schema for a required object property.\n (c *ObjectSchema) WithRequiredProperty(name string, typ interface{}, rules \u0026hellip;IValidationRule) *ObjectSchema\n  name: string - property name. typ: interface{} - (optional) property schema or type. rules: \u0026hellip;IValidationRule[] - (optional) list of property validation rules. returns: ObjectSchema - validation schema  Examples var schema = NewObjectSchema(false) .WithOptionalProperty(\u0026#34;id\u0026#34;, TypeCode.String) .WithRequiredProperty(\u0026#34;name\u0026#34;, TypeCode.String); schema.validate({ id: \u0026#34;1\u0026#34;, name: \u0026#34;ABC\u0026#34; }); // Result: no errors schema.validate({ name: \u0026#34;ABC\u0026#34; }); // Result: no errors schema.validate({ id: 1, name: \u0026#34;ABC\u0026#34; }); // Result: id type mismatch schema.validate({ id: 1, _name: \u0026#34;ABC\u0026#34; }); // Result: name is missing, unexpected _name schema.validate(\u0026#34;ABC\u0026#34;); // Result: type mismatch  ","description":"Schema to validate user defined objects.\n","image":null,"permalink":"/golang/commons/validate/object_schema/","subtitle":null,"tags":null,"title":"ObjectSchema"},{"content":"Inherits: Schema\nDescription The ObjectSchema class allows you to create a validation schema that can be used to validate user defined objects.\nConstructors Creates a new validation schema. See IValidationRule\n public ObjectSchema()\n Properties IsUndefinedAllowed Gets and sets a flag to allow undefined properties. True to allow undefined properties and false to disallow.\n public bool IsUndefinedAllowed { get; set; }\n Properties Gets and sets validation schemas for object properties. See PropertySchema\n public List\u0026lt;PropertySchema\u0026gt; Properties [get, set]\n Instance methods AllowUndefined Sets a flag to allow undefined properties This method returns a reference to this exception to the implement the Builder pattern to chain additional calls.\n public ObjectSchema AllowUndefined(bool value)\n  value: bool - true to allow undefined properties and false to disallow. returns: ObjectSchema - validation schema.  PerformValidation Validates a given value against the schema and configured validation rules.\n protected internal override void PerformValidation(string path, object value, List\u0026lt;ValidationResult\u0026gt; results)\n  path: string - dot notation path to the value. value: object - value to be validated. results: List\u0026lt;ValidationResult\u0026gt; - list with validation results to add new results.  WithOptionalProperty Adds a validation schema for an optional object property.\n public ObjectSchema WithOptionalProperty(string name, object type, params IValidationRule[] rules)\n  name: string - property name. type: object - (optional) property schema or type. rules: IValidationRule[] - (optional) list of property validation rules.  WithProperty Adds a validation schema for an object property. This method returns a reference to this exception to implement the Builder pattern to chain additional calls. See PropertySchema\n public ObjectSchema WithProperty(PropertySchema schema)\n  schema: PropertySchema - property validation schema to be added. returns: ObjectSchema - validation schema.  WithRequiredProperty Adds a validation schema for a required object property.\n public ObjectSchema WithRequiredProperty(string name, object type, params IValidationRule[] rules)\n  name: string - property name. type: object - (optional) property schema or type. rules: IValidationRule[] - (optional) list of property validation rules. returns: ObjectSchema - validation schema  Examples var schema = new ObjectSchema().WithOptionalProperty(\u0026#34;id\u0026#34;, TypeCode.String) .WithRequiredProperty(\u0026#34;name\u0026#34;, TypeCode.String); schema.Validate({ id: \u0026#34;1\u0026#34;, name: \u0026#34;ABC\u0026#34; }); // Result: no errors schema.Validate({ name: \u0026#34;ABC\u0026#34; }); // Result: no errors schema.Validate({ id: 1, name: \u0026#34;ABC\u0026#34; }); // Result: id type mismatch schema.Validate({ id: 1, _name: \u0026#34;ABC\u0026#34; }); // Result: name is missing, unexpected _name schema.Validate(\u0026#34;ABC\u0026#34;); // Result: type mismatch  ","description":"Schema to validate user defined objects.\n","image":null,"permalink":"/net/commons/validate/object_schema/","subtitle":null,"tags":null,"title":"ObjectSchema"},{"content":"Extends: Schema\nDescription The ObjectSchema class allows you to create a validation schema that can be used to validate user defined objects.\nConstructors Creates a new validation schema and sets its values. See IValidationRule\n public constructor(allowUndefined?: boolean, required?: boolean, rules?: IValidationRule[])\n  allowUndefined: boolean - true to allow properties undefined in the schema. required: boolean - (optional) true to always require non-null values. rules: IValidationRule[] - (optional) list with validation rules.  Properties isUndefinedAllowed Gets a flag used to allow undefined properties.\n public isUndefinedAllowed(): boolean\n  returns: boolean - true to allow undefined properties and false to disallow.  Sets a flag used to allow undefined properties.\n public isUndefinedAllowed(value: boolean): void\n  value: boolean - true to allow undefined properties and false to disallow.  Instance methods allowUndefined Sets a flag used to allow undefined properties. This method returns a reference to this exception to implement the Builder pattern to chain additional calls.\n public allowUndefined(value: boolean): ObjectSchema\n  value: boolean - true to allow undefined properties and false to disallow. returns: ObjectSchema - validation schema.  getProperties Gets validation schemas for object properties. See PropertySchema\n public getProperties(): PropertySchema[]\n  returns: PropertySchema[] - list of property validation schemas.  performValidation Validates a given value against the schema and configured validation rules.\n protected performValidation(path: string, value: any, results: ValidationResult[]): void\n  path: string - dot notation path to the value. value: any - value to be validated. results: ValidationResult[] - list with validation results.  setProperties Sets validation schemas for object properties. See PropertySchema\n public setProperties(value: PropertySchema[]): void\n  value: PropertySchema[] - list of property validation schemas.  withOptionalProperty Adds a validation schema for an optional object property.\n public withOptionalProperty(name: string, type?: any, \u0026hellip;rules: IValidationRule[]): ObjectSchema\n  name: string - property name. type: any - (optional) property schema or type. rules: IValidationRule[] - (optional) list of property validation rules.  withProperty Adds a validation schema for an object property. This method returns a reference to this exception to implement the Builder pattern to chain additional calls. See PropertySchema\n public withProperty(schema: PropertySchema): ObjectSchema\n  schema: PropertySchema - property validation schema to be added. returns: ObjectSchema - validation schema.  withRequiredProperty Adds a validation schema for a required object property.\n public withRequiredProperty(name: string, type?: any, \u0026hellip;rules: IValidationRule[]): ObjectSchema\n  name: string - property name. type: any - (optional) property schema or type. rules: IValidationRule[] - (optional) list of property validation rules. returns: ObjectSchema - validation schema.  Examples let schema = new ObjectSchema(false) .withOptionalProperty(\u0026#34;id\u0026#34;, TypeCode.String) .withRequiredProperty(\u0026#34;name\u0026#34;, TypeCode.String); schema.validate({ id: \u0026#34;1\u0026#34;, name: \u0026#34;ABC\u0026#34; }); // Result: no errors schema.validate({ name: \u0026#34;ABC\u0026#34; }); // Result: no errors schema.validate({ id: 1, name: \u0026#34;ABC\u0026#34; }); // Result: id type mismatch schema.validate({ id: 1, _name: \u0026#34;ABC\u0026#34; }); // Result: name is missing, unexpected _name schema.validate(\u0026#34;ABC\u0026#34;); // Result: type mismatch  ","description":"Schema to validate user defined objects.\n","image":null,"permalink":"/node/commons/validate/object_schema/","subtitle":null,"tags":null,"title":"ObjectSchema"},{"content":"Extends: Schema\nDescription The ObjectSchema class allows you to create a validation schema that can be used to validate user defined objects.\nConstructors Creates a new validation schema and sets its values. See IValidationRule\n ObjectSchema(allow_undefined: bool = False, required: bool = None, rules: List[IValidationRule] = None):\n  allow_undefined?: bool - true to allow properties undefined in the schema required: bool - (optional) true to always require non-None values. rules: List[IValidationRule] - (optional) a list with validation rules.  Properties is_undefined_allowed Gets flag to allow undefined properties\n is_undefined_allowed(): bool\n  returns: bool - true to allow undefined properties and false to disallow.  Sets flag to allow undefined properties\n is_undefined_allowed(value: bool)\n  value: bool - true to allow undefined properties and false to disallow.  Instance methods allow_undefined Sets flag to allow undefined properties This method returns reference to this exception to implement Builder pattern to chain additional calls.\n allow_undefined(value: bool): ObjectSchema\n  value: bool - true to allow undefined properties and false to disallow. returns: ObjectSchema - this validation schema.  get_properties Gets validation schemas for object properties. See PropertySchema\n get_properties(): List[PropertySchema]\n  returns: List[PropertySchema] - the list of property validation schemas.  perform_validation Validates a given value against the schema and configured validation rules.\n _perform_validation(path: str, value: Any, results: List[ValidationResult])\n  path: str - a dot notation path to the value. value: Any - a value to be validated. results: List[ValidationResult] - a list with validation results to add new results.  set_properties Sets validation schemas for object properties. See PropertySchema\n set_properties(value: List[PropertySchema])\n  value: List[PropertySchema] - a list of property validation schemas.  with_optional_property Adds a validation schema for an optional object property.\n with_optional_property(name: str, typ: Any, *rules: IValidationRule): ObjectSchema\n  name: str - a property name. typ: Any - (optional) a property schema or type. rules: IValidationRule - (optional) a list of property validation rules.  with_property Adds a validation schema for an object property. This method returns reference to this exception to implement Builder pattern to chain additional calls. See PropertySchema\n with_property(schema: PropertySchema): ObjectSchema\n  schema: PropertySchema - a property validation schema to be added. returns: ObjectSchema - this validation schema.  with_required_property Adds a validation schema for a required object property.\n with_required_property(name: str, typ: Any, *rules: IValidationRule): ObjectSchema\n  name: str - a property name. typ: Any - (optional) a property schema or type. rules: IValidationRule - (optional) a list of property validation rules.  Examples schema = ObjectSchema(false) .with_optional_property(\u0026#34;id\u0026#34;, TypeCode.String) .with_required_property(\u0026#34;name\u0026#34;, TypeCode.String) schema.validate({ id: \u0026#34;1\u0026#34;, name: \u0026#34;ABC\u0026#34; }) # Result: no errors schema.validate({ name: \u0026#34;ABC\u0026#34; }) # Result: no errors schema.validate({ id: 1, name: \u0026#34;ABC\u0026#34; }) # Result: id type mismatch schema.validate({ id: 1, __name: \u0026#34;ABC\u0026#34; }) # Result: name is missing, unexpected __name schema.validate(\u0026#34;ABC\u0026#34;) # Result: type mismatch ","description":"Schema to validate user defined objects.\n","image":null,"permalink":"/python/commons/validate/object_schema/","subtitle":null,"tags":null,"title":"ObjectSchema"},{"content":"Description The ObjectWriter class allows you to dynamically set the properties of an object.\nImportant points\n In contrast to PropertyReflector which only introspects regular objects, the ObjectWriter class is also able to handle maps and arrays. For maps, properties are key-pairs identified by string keys, For arrays, properties are elements identified by integer index. This class has symmetric implementation across all languages supported by the Pip.Services toolkit and it is used to support dynamic data processing. Because all languages have different casing and case sensitivity rules, the ObjectWriter class treats all property names as case insensitive.  Methods SetProperties Sets values of some (all) object properties.\nThe object can be a user defined object, map or array. Property values correspondently are object properties, map key-pairs or array elements with their indexes.\nIf some properties do not exist or introspection fails they are just silently skipped and no errors thrown.\n (c *TObjectWriter) SetProperties(obj interface{}, values map[string]interface{})\n  obj: interface{} - object to write properties to. values: map[string]interface{} - map, containing property names and their values.  SetProperty Sets value of an object property specified by its name.\nThe object can be a user defined object, map or array. The property name correspondently must be an object property, map key or array index.\nIf the property does not exist or introspection fails this method doesn\u0026rsquo;t do anything and doesn\u0026rsquo;t any throw errors.\n (c *TObjectWriter) SetProperty(obj interface{}, name string, value interface{})\n  obj: interface{} - object to write property to. name: string - name of the property to set. value: interface{} - new value for the property to set.  Examples myObj := MyObject{} ObjectWriter.SetProperty(myObj, \u0026#34;myProperty\u0026#34;, 123) myMap := { key1: 123, key2: \u0026#34;ABC\u0026#34; } ObjectWriter.SetProperty(myMap, \u0026#34;key1\u0026#34;, \u0026#34;XYZ\u0026#34;) myArray := [1, 2, 3] ObjectWriter.SetProperty(myArray, \u0026#34;0\u0026#34;, 123) See also   PropertyReflector   ","description":"Helper class that allows you to dynamically set the properties of an object. \n","image":null,"permalink":"/golang/commons/reflect/object_writer/","subtitle":null,"tags":null,"title":"ObjectWriter"},{"content":"Description The ObjectWriter class allows you to dynamically set the properties of an object.\nImportant points\n In contrast to PropertyReflector which only introspects regular objects, the ObjectWriter class is also able to handle maps and arrays. For maps, properties are key-pairs identified by string keys, For arrays, properties are elements identified by integer index. This class has symmetric implementation across all languages supported by the Pip.Services toolkit and it is used to support dynamic data processing. Because all languages have different casing and case sensitivity rules, the ObjectWriter class treats all property names as case insensitive.  Static methods SetProperties Sets values of some (all) object properties.\nThe object can be a user a defined object, a map or an array. Property values correspondently are object properties, map key-pairs or array elements with their indexes.\nIf some properties do not exist or introspection fails they are just silently skipped and no errors thrown.\n public static void SetProperties(object obj, IDictionary\u0026lt;string, object\u0026gt; values)\n  obj: object - object to write properties to. values: IDictionary\u0026lt;string, object\u0026gt; - map containing property names and their values.  SetProperty Sets the value of an object\u0026rsquo;s property specified by its name.\nThe object can be a user a defined object, a map or an array. The property name correspondently must be an object\u0026rsquo;s property, a map key or an array index.\nIf the property does not exist or introspection fails this method doesn\u0026rsquo;t do anything and doesn\u0026rsquo;t any throw errors.\n public static void SetProperty(object obj, object string name, object value)\n  obj: object - object to write property to. name: string - name of the property to set. value: object - new value for the property to set.  Examples var myObj = new MyObject(); ObjectWriter.SetProperty(myObj, \u0026#34;myProperty\u0026#34;, 123); var myMap = new Dictionary\u0026lt;string, object\u0026gt;(){ {\u0026#34;key1\u0026#34;, 123}, {\u0026#34;key2\u0026#34;, \u0026#34;ABC\u0026#34;} }; ObjectWriter.SetProperty(myMap, \u0026#34;key1\u0026#34;, \u0026#34;XYZ\u0026#34;); var myArray = new int[] { 1, 2, 3 }; ObjectWriter.SetProperty(myArray, \u0026#34;0\u0026#34;, 123); See also   PropertyReflector   ","description":"Helper class that allows you to dynamically set the properties of an object. \n","image":null,"permalink":"/net/commons/reflect/object_writer/","subtitle":null,"tags":null,"title":"ObjectWriter"},{"content":"Description The ObjectWriter class allows you to dynamically set the properties of an object.\nImportant points\n In contrast to PropertyReflector which only introspects regular objects, the ObjectWriter class is also able to handle maps and arrays. For maps, properties are key-pairs identified by string keys, For arrays, properties are elements identified by integer indexes. This class has symmetric implementation across all languages supported by the Pip.Services toolkit and it is used to support dynamic data processing. Because all languages have different casing and case sensitivity rules, the ObjectWriter class treats all property names as case insensitive.  Static methods setProperties Sets values of some (all) object properties.\nThe object can be a user defined object, map or array. Property values correspondently are object properties, map key-pairs or array elements with their indexes.\nIf some properties do not exist or introspection fails, they are just silently skipped and no errors thrown.\n public static setProperties(obj: any, values: any): void\n  obj: any - object to write properties to. values: any - map containing property names and their values.  setProperty Sets the value of an object\u0026rsquo;s property specified by its name.\nThe object can be a user defined object, map or array. The property name correspondently must be object property, map key or array index.\nIf the property does not exist or introspection fails, this method doesn\u0026rsquo;t do anything and doesn\u0026rsquo;t throw any errors.\n public static setProperty(obj: any, name: string, value: any): void\n  obj: any - object to write the property to. name: string - name of the property to set. value: any - new value for the property to set.  Examples let myObj = new MyObject(); ObjectWriter.setProperty(myObj, \u0026#34;myProperty\u0026#34;, 123); let myMap = { key1: 123, key2: \u0026#34;ABC\u0026#34; }; ObjectWriter.setProperty(myMap, \u0026#34;key1\u0026#34;, \u0026#34;XYZ\u0026#34;); let myArray = [1, 2, 3] ObjectWriter.setProperty(myArray, \u0026#34;0\u0026#34;, 123); See also   PropertyReflector   ","description":"Helper class that allows you to dynamically set the properties of an object. \n","image":null,"permalink":"/node/commons/reflect/object_writer/","subtitle":null,"tags":null,"title":"ObjectWriter"},{"content":"Description The ObjectWriter class allows you to dynamically set the properties of an object.\nImportant points\n In contrast to PropertyReflector which only introspects regular objects, the ObjectWriter class is also able to handle maps and arrays. For maps, properties are key-pairs identified by string keys, For arrays, properties are elements identified by integer index. This class has symmetric implementation across all languages supported by the Pip.Services toolkit and it is used to support dynamic data processing. Because all languages have different casing and case sensitivity rules, the ObjectWriter class treats all property names as case insensitive.  Static methods set_properties Sets values of some (all) object properties.\nThe object can be a user defined object, map or array. Property values correspondently are object properties, map key-pairs or array elements with their indexes.\nIf some properties do not exist or introspection fails they are just silently skipped and no errors thrown.\n static set_properties(obj: Any, values: Any)\n  obj: Any - an object to write properties to. values: Any - a map, containing property names and their values.  set_property Sets value of object property specified by its name.\nThe object can be a user defined object, map or array. The property name correspondently must be object property, map key or array index.\nIf the property does not exist or introspection fails this method doesn\u0026rsquo;t do anything and doesn\u0026rsquo;t throw any errors.\n static set_property(obj: Any, name: str, value: Any)\n  obj: Any - an object to write property to. name: str - a name of the property to set. value: Any - a new value for the property to set.  Examples myObj = MyObject() ObjectWriter.set_property(myObj, \u0026#34;myProperty\u0026#34;, 123) myMap = { key1: 123, key2: \u0026#34;ABC\u0026#34; } ObjectWriter.set_property(myMap, \u0026#34;key1\u0026#34;, \u0026#34;XYZ\u0026#34;) myArray = [1, 2, 3] ObjectWriter.set_property(myArray, \u0026#34;0\u0026#34;, 123) See also   PropertyReflector   ","description":"Helper class that allows you to dynamically set the properties of an object. \n","image":null,"permalink":"/python/commons/reflect/object_writer/","subtitle":null,"tags":null,"title":"ObjectWriter"},{"content":"Description The OnlyOneExistsRule allows you to check that only one property of a list of properties exists in an object.\nConstructors NewOnlyOneExistsRule Creates a new validation rule and sets its values\n NewOnlyOneExistsRule(properties \u0026hellip;string) *OnlyOneExistsRule\n  properties: \u0026hellip;string - list of property names where only one property must exist  Methods Validate Validates a given value against this rule.\n (c *OnlyOneExistsRule) Validate(path string, schema ISchema, value interface{}) []*ValidationResult\n  path: string - dot notation path to the value. schema: ISchema - schema this rule is called from value: interface{} - value to be validated. results: ValidationResult[] - list with validation results to add new results.  Examples var schema = NewSchema().WithRule(NewOnlyOneExistsRule(\u0026#34;field1\u0026#34;, \u0026#34;field2\u0026#34;)); schema.Validate({ field1: 1, field2: \u0026#34;A\u0026#34; }); // Result: only one of properties field1, field2 must exist schema.Validate({ field1: 1 }); // Result: no errors schema.Validate({ }); // Result: only one of properties field1, field2 must exist  See also   IValidationRule   ","description":"Validation rule that checks that only one property of a list of properties exists in an object.\n","image":null,"permalink":"/golang/commons/validate/only_one_exists_rule/","subtitle":null,"tags":null,"title":"OnlyOneExistsRule"},{"content":"Inherits: IValidationRule\nDescription The OnlyOneExistsRule allows you to check that only one property of a list of properties exists in an object.\nConstructors Creates a new validation rule and sets its values\n public OnlyOneExistsRule(params string[] properties)\n  properties: string[] - list of property names where only one property must exist  Instance methods Validate Validates a given value against this rule.\n public void Validate(string path, Schema schema, object value, List\u0026lt;ValidationResult\u0026gt; results)\n  path: string - dot notation path to the value. schema: Schema - schema this rule is called from value: object - value to be validated. results: ValidationResult[] - list with validation results to add new results.  Examples var schema = new Schema().WithRule(new OnlyOneExistsRule(\u0026#34;field1\u0026#34;, \u0026#34;field2\u0026#34;)); schema.Validate({ field1: 1, field2: \u0026#34;A\u0026#34; }); // Result: only one of properties field1, field2 must exist schema.Validate({ field1: 1 }); // Result: no errors schema.Validate({ }); // Result: only one of properties field1, field2 must exist  See also   IValidationRule   ","description":"Validation rule that checks that only one property of a list of properties exists in an object.\n","image":null,"permalink":"/net/commons/validate/only_one_exists_rule/","subtitle":null,"tags":null,"title":"OnlyOneExistsRule"},{"content":"Implements: IValidationRule\nDescription The OnlyOneExistsRule allows you to check that only one property of a list of properties exists in an object.\nConstructors Creates a new validation rule and sets its values.\n public constructor(\u0026hellip;properties: string[])\n  properties: string[] - list of property names where only one property must exist  Instance methods validate Validates a given value against this rule.\n public validate(path: string, schema: Schema, value: any, results: ValidationResult[]): void\n  path: string - dot notation path to the value. schema: Schema - schema this rule is called from value: any - value to be validated. results: ValidationResult[] - list with validation results.  Examples let schema = new Schema() .withRule(new OnlyOneExistsRule(\u0026#34;field1\u0026#34;, \u0026#34;field2\u0026#34;)); schema.validate({ field1: 1, field2: \u0026#34;A\u0026#34; }); // Result: only one of properties field1, field2 must exist schema.validate({ field1: 1 }); // Result: no errors schema.validate({ }); // Result: only one of properties field1, field2 must exist  See also   IValidationRule   ","description":"Validation rule that checks that only one property of a list of properties exists in an object.\n","image":null,"permalink":"/node/commons/validate/only_one_exists_rule/","subtitle":null,"tags":null,"title":"OnlyOneExistsRule"},{"content":"Implements: IValidationRule\nDescription The OnlyOneExistsRule allows you to check that only one property of a list of properties exists in an object.\nConstructors Creates a new validation rule and sets its values\n OnlyOneExistsRule(*properties: str)\n  properties: str - a list of property names where at only one property must exist  Instance methods validate Validates a given value against this rule.\n validate(path: str, schema: Schema, value: Any, results: List[ValidationResult])\n  path: str - a dot notation path to the value. schema: Schema - a schema this rule is called from value: Any - a value to be validated. results: List[ValidationResult] - a list with validation results to add new results.  Examples schema = Schema().with_rule(OnlyOneExistsRule(\u0026#34;field1\u0026#34;, \u0026#34;field2\u0026#34;)) schema.validate({ field1: 1, field2: \u0026#34;A\u0026#34; }) # Result: only one of properties field1, field2 must exist schema.validate({ field1: 1 }) # Result: no errors schema.validate({ }) # Result: only one of properties field1, field2 must exist See also   IValidationRule   ","description":"Validation rule that checks that only one property of a list of properties exists in an object.\n","image":null,"permalink":"/python/commons/validate/only_one_exists_rule/","subtitle":null,"tags":null,"title":"OnlyOneExistsRule"},{"content":"Description The Opener class can be used to check whether all components are opened or not, a component is opened or not, and to open one or more components.\nMethods IsOpen Checks if all components are opened.\nTo be checked components must implement the IOpenable interface. If they don\u0026rsquo;t, the call to this method returns true.\n (c *TOpener) IsOpen(components []interface{}) bool\n  components: []interface{} - list of components that are to be checked. returns: bool - true if all components are opened and false if at least one component is closed.  IsOpenOne Checks if a specified component is opened. To be checked components must implement the IOpenable interface. If they don\u0026rsquo;t, the call to this method returns true.\n (c *TOpener) IsOpenOne(component interface{}) bool\n  component: interface{} - component that is to be checked. returns: bool - true if component is opened and false otherwise.  Open Opens multiple components. To be opened components must implement the IOpenable interface. If they don\u0026rsquo;t, the call to this method has no effect.\n (c *TOpener) Open(correlationId string, components []interface{}) error\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. components: []interface{} - list of components that are to be closed. returns: error - return error if not opened  OpenOne Opens a specific component. To be opened components must implement the IOpenable interface. If they don\u0026rsquo;t, the call to this method has no effect.\n (c *TOpener) OpenOne(correlationId string, component interface{}) error\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. component: interface{} - component that is to be opened. returns: error - error returned if not opened  See also   IOpenable   ","description":"Helper class that can be used to check whether all components are opened or not, a component is opened or not, and to open one or more components.\n","image":null,"permalink":"/golang/commons/run/opener/","subtitle":null,"tags":null,"title":"Opener"},{"content":"Description The Opener class can be used to check whether all components are opened or not, a component is opened or not, and to open one or more components.\nStatic methods IsOpen Checks if all components are opened.\nTo be checked, components must implement the IOpenable interface. If they don\u0026rsquo;t, the call to this method returns true.\n public static bool IsOpen(IEnumerable components)\n  components: IEnumerable - list of components that are to be checked. returns: bool - true if all components are opened and false if at least one component is closed.  IsOpenOne Checks if a specified component is opened. To be checked, components must implement the IOpenable interface. If they don\u0026rsquo;t, the call to this method returns true.\n public static bool IsOpenOne(object component)\n  component: object - component that is to be checked. returns: bool - true if component is opened and false otherwise.  OpenAsync Opens multiple components. To be opened, components must implement the IOpenable interface. If they don\u0026rsquo;t, the call to this method has no effect.\n public static Task OpenAsync(string correlationId, IEnumerable components)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. components: IEnumerable - list of components that are to be closed.  OpenOneAsync Opens specific component. To be opened, components must implement the IOpenable interface. If they don\u0026rsquo;t, the call to this method has no effect.\n public static Task OpenOneAsync(string correlationId, object component)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. component: object - component that is to be opened.  See also   IOpenable   ","description":"Helper class that can be used to check whether all components are opened or not, a component is opened or not, and to open one or more components.\n","image":null,"permalink":"/net/commons/run/opener/","subtitle":null,"tags":null,"title":"Opener"},{"content":"Description The Opener class can be used to check whether all components are opened or not, a component is opened or not, and to open one or more components.\nStatic methods isOpen Checks if all components are opened.\nTo be checked, components must implement the IOpenable interface. If they don\u0026rsquo;t, the call to this method returns true.\n public static isOpen(components: any[]): boolean\n  components: any[] - list of components that are to be checked. returns: boolean - true if all components are opened and false if at least one component is closed.  isOpenOne Checks if a specified component is opened. To be checked, components must implement the IOpenable interface. If they don\u0026rsquo;t, the call to this method returns true.\n public static isOpenOne(component: any): boolean\n  component: any - component that is to be checked. returns: boolean - true if the component is opened and false otherwise.  open Opens multiple components. To be opened, components must implement IOpenable interface. If they don\u0026rsquo;t, the call to this method has no effect.\n public static open(correlationId: string, components: any[]): Promise\u0026lt;void\u0026gt;\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. components: any[] - list of components that are to be closed.  openOne Opens a specific component. To be opened, components must implement the IOpenable interface. If they don\u0026rsquo;t, the call to this method has no effect.\n public static openOne(correlationId: string, component: any): Promise\u0026lt;void\u0026gt;\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. component: any - component that is to be opened.  See also   IOpenable   ","description":"Helper class that can be used to check whether all components are opened or not, a component is opened or not, and to open one or more components.\n","image":null,"permalink":"/node/commons/run/opener/","subtitle":null,"tags":null,"title":"Opener"},{"content":"Description The Opener class can be used to check whether all components are opened or not, a component is opened or not, and to open one or more components.\nStatic methods is_open Checks if all components are opened.\nTo be checked, components must implement IOpenable interface. If they don\u0026rsquo;t, the call to this method returns true.\n static is_open(components: List[Any]): bool\n  components: List[Any] - a list of components that are to be checked. returns: bool - true if all components are opened and false if at least one component is closed.  is_open_one Checks if specified component is opened. To be checked, components must implement IOpenable interface. If they don\u0026rsquo;t, the call to this method returns true.\n static is_open_one(component: Any): bool\n  component: Any - the component that is to be checked. returns: bool - true if component is opened and false otherwise.  open Opens multiple components. To be opened components must implement IOpenable interface. If they don\u0026rsquo;t the call to this method has no effect.\n static open(correlation_id: Optional[str], components: List[Any])\n  correlation_id: Optional[str] - (optional) transaction id to trace execution through call chain. components: List[Any] - the list of components that are to be closed.  open_one Opens specific component. To be opened, components must implement IOpenable interface. If they don\u0026rsquo;t, the call to this method has no effect.\n static open_one(correlation_id: Optional[str], component: Any)\n  correlation_id: Optional[str] - (optional) transaction id to trace execution through call chain. component: Any - the component that is to be opened.  See also   IOpenable   ","description":"Helper class that can be used to check whether all components are opened or not, a component is opened or not, and to open one or more components.\n","image":null,"permalink":"/python/commons/run/opener/","subtitle":null,"tags":null,"title":"Opener"},{"content":"Description The OperationTrace class allows you to create a data object used to store captured operation traces.\nImportant points\n This object is used by CachedTracer.  Fields Time Time when an operation was executed\n Time: time.Time\n Source Source (context name)\n Source: string\n Component Name of the component\n Component: string\n Operation Name of the executed operation\n Operation: string\n CorrelationId Transaction id used to trace execution through the call chain.\n CorrelationId: string\n Duration The duration of the operation in milliseconds\n Duration: int64\n Error The description of the captured error.\nSee also ErrorDescription, ApplicationException\n Error: ErrorDescription\n  ","description":"Data object to store captured operation traces.\n","image":null,"permalink":"/golang/components/trace/operation_trace/","subtitle":null,"tags":null,"title":"OperationTrace"},{"content":"Description The OperationTrace class allows you to create a data object used to store captured operation traces.\nImportant points\n This object is used by CachedTracer.  Fields Time The time when operation was executed\n public Time: DateTime\n Source The source (context name)\n public Source: string\n component The name of the component\n public Component: string\n Operation The name of the executed operation\n public Operation: string\n CorrelationId The transaction id to trace execution through call chain.\n public CorrelationId: string\n Duration The duration of the operation in milliseconds\n public Duration: long\n Error The description of the captured error.\nSee also ErrorDescription, ApplicationException\n public Error: ErrorDescription\n  ","description":"Data object to store captured operation traces.\n","image":null,"permalink":"/net/components/trace/operation_trace/","subtitle":null,"tags":null,"title":"OperationTrace"},{"content":"Description The OperationTrace class allows you to create a data object used to store captured operation traces.\nImportant points\n This object is used by CachedTracer.  Constructors Create new instance of OperationTrace\n public constructor(time: Date, source: string, component: string, operation: string, correlationId: string, duration: number, error: ErrorDescription)\n  time: Date - The time when operation was executed source: string - source (context name) component: string - name of the component operation: string - name of the executed operation correlationId: string - transaction id to trace execution through call chain. duration: number - duration of the operation in milliseconds error: ErrorDescription - The description of the captured error   Fields time The time when operation was executed\n public time: Date\n source The source (context name)\n public source: string\n component The name of the component\n public component: string\n operation The name of the executed operation\n public operation: string\n correlationId The transaction id to trace execution through call chain.\n public correlationId: string\n duration The duration of the operation in milliseconds\n public duration: number\n error The description of the captured error.\nSee also ErrorDescription, ApplicationException\n public error: ErrorDescription\n  ","description":"Data object to store captured operation traces.\n","image":null,"permalink":"/node/components/trace/operation_trace/","subtitle":null,"tags":null,"title":"OperationTrace"},{"content":"Description The OperationTrace class allows you to create a data object used to store captured operation traces.\nImportant points\n This object is used by CachedTracer.  Constructors Create new instance of OperationTrace\n OperationTrace(time: datetime, source: str, component: str, operation: str, correlation_id: str, duration: float, error: ErrorDescription)\n  time: datetime - The time when operation was executed source: str - source (context name) component: str - name of the component operation: str - name of the executed operation correlation_id: str - transaction id to trace execution through call chain. duration: float - duration of the operation in milliseconds error: ErrorDescription - The description of the captured error   Fields time The time when operation was executed\n time: datetime\n source The source (context name)\n source: str\n component The name of the component\n component: str\n operation The name of the executed operation\n operation: str\n correlation_id The transaction id to trace execution through call chain.\n correlation_id: str\n duration The duration of the operation in milliseconds\n duration: float\n error The description of the captured error.\nSee also ErrorDescription, ApplicationException\n error: ErrorDescription\n  ","description":"Data object to store captured operation traces.\n","image":null,"permalink":"/python/components/trace/operation_trace/","subtitle":null,"tags":null,"title":"OperationTrace"},{"content":"Description The OptionResolver class can be use to obtain all the parameters under the section \u0026ldquo;options\u0026rdquo; from a CongifParams object. It has a single method called \u0026ldquo;resolve\u0026rdquo;.\nMethods Resolve Resolves an \u0026ldquo;options\u0026rdquo; configuration section from component configuration parameters.\n (c *TOptionsResolver) Resolve(config *ConfigParams) *ConfigParams\n  config: *ConfigParams - configuration parameters returns: *ConfigParams - configuration parameters from \u0026ldquo;options\u0026rdquo; section  ResolveWithDefault Resolves an \u0026ldquo;options\u0026rdquo; configuration section from component configuration parameters.\n (c *TOptionsResolver) ResolveWithDefault(config *ConfigParams) *ConfigParams\n  config: *ConfigParams - default configuration parameters returns: *ConfigParams - configuration parameters from \u0026ldquo;options\u0026rdquo; section  Examples config := NewConfigParamsFromTuples( ... \u0026#34;options.param1\u0026#34;, \u0026#34;ABC\u0026#34;, \u0026#34;options.param2\u0026#34;, 123 ); options := OptionsResolver.resolve(config); // Result: param1=ABC;param2=123  ","description":"A helper class to parameters from \"options\" configuration section.\n","image":null,"permalink":"/golang/commons/config/option_resolver/","subtitle":null,"tags":null,"title":"OptionResolver"},{"content":"Description The OptionResolver class can be use to obtain all the parameters under the section \u0026ldquo;options\u0026rdquo; from a CongifParams object. It has a single method called \u0026ldquo;resolve\u0026rdquo;.\nStatic methods Resolve Resolves an \u0026ldquo;options\u0026rdquo; configuration section from component configuration parameters.\n public static ConfigParams resolve(ConfigParams config, boolean configAsDefault = true)\n  config: ConfigParams - configuration parameters configAsDefault: bool - (optional) when set to true the method returns the entire parameter set when the \u0026ldquo;options\u0026rdquo; section is not found. Default: false returns: ConfigParams - configuration parameters from \u0026ldquo;options\u0026rdquo; section  Examples var config = ConfigParams.FromTuples( \u0026#34;abc.param1\u0026#34;, \u0026#34;ABC\u0026#34;, \u0026#34;options.param1\u0026#34;, \u0026#34;ABC\u0026#34;, \u0026#34;options.param2\u0026#34;, 123); var options = OptionsResolver.Resolve(config); // Returns {\u0026#39;param1\u0026#39;: \u0026#39;ABC\u0026#39;, \u0026#39;param2\u0026#39;: \u0026#39;123\u0026#39;}  // If the configuration doesn\u0026#39;t contain an \u0026#34;options\u0026#34; section, it returns an empty ConfigParams object. config = ConfigParams.FromTuples( \u0026#34;section1.key1\u0026#34;, \u0026#34;AAA\u0026#34;, \u0026#34;section1.key2\u0026#34;, 123, ); options = OptionsResolver.Resolve(config); // Returns {}  ","description":"A helper class to parameters from \"options\" configuration section.\n","image":null,"permalink":"/net/commons/config/option_resolver/","subtitle":null,"tags":null,"title":"OptionResolver"},{"content":"Description The OptionResolver class can be use to obtain all the parameters under the section \u0026ldquo;options\u0026rdquo; from a CongifParams object. It has a single method called \u0026ldquo;resolve\u0026rdquo;.\nStatic methods resolve Resolves an \u0026ldquo;options\u0026rdquo; configuration section from component configuration parameters.\n public static resolve(config: ConfigParams, configAsDefault: boolean = false): ConfigParams\n  config: ConfigParams - configuration parameters configAsDefault: boolean - (optional) When set true the method returns the entire parameter set when \u0026ldquo;options\u0026rdquo; section is not found. Default: false returns: ConfigParams - configuration parameters from \u0026ldquo;options\u0026rdquo; section  Examples let config = ConfigParams.fromTuples( \u0026#34;abc.param1\u0026#34;, \u0026#34;ABC\u0026#34;, \u0026#34;options.param1\u0026#34;, \u0026#34;ABC\u0026#34;, \u0026#34;options.param2\u0026#34;, 123) let options = OptionsResolver.resolve(config) // Returns {\u0026#39;param1\u0026#39;: \u0026#39;ABC\u0026#39;, \u0026#39;param2\u0026#39;: \u0026#39;123\u0026#39;}  // If the configuration doesn\u0026#39;t contain an \u0026#34;options\u0026#34; section, it returns an empty ConfigParams object. config = ConfigParams.fromTuples( \u0026#34;section1.key1\u0026#34;, \u0026#34;AAA\u0026#34;, \u0026#34;section1.key2\u0026#34;, 123, ); options = OptionsResolver.resolve(config); // Returns {}  ","description":"A helper class used to obtain all the parameters from the \"options\" configuration section.\n","image":null,"permalink":"/node/commons/config/option_resolver/","subtitle":null,"tags":null,"title":"OptionResolver"},{"content":"Description The OptionResolver class can be use to obtain all the parameters under the section \u0026ldquo;options\u0026rdquo; from a CongifParams object. It has a single method called \u0026ldquo;resolve\u0026rdquo;.\nStatic methods resolve Returns a ConfigParams object containing all the parameters under the section \u0026ldquo;option\u0026rdquo;.\n static resolve(config: ConfigParams, config_as_default: bool = False): ConfigParams\n  config: ConfigParams - configuration parameters config_as_default: bool - (optional) When set true the method returns the entire parameter set when \u0026ldquo;options\u0026rdquo; section is not found. Default: false returns: ConfigParams - configuration parameters from \u0026ldquo;options\u0026rdquo; section  Examples config = ConfigParams.from_tuples( \u0026#34;abc.param1\u0026#34;, \u0026#34;ABC\u0026#34;, \u0026#34;options.param1\u0026#34;, \u0026#34;ABC\u0026#34;, \u0026#34;options.param2\u0026#34;, 123) options = OptionsResolver.resolve(config) # Returns {\u0026#39;param1\u0026#39;: \u0026#39;ABC\u0026#39;, \u0026#39;param2\u0026#39;: \u0026#39;123\u0026#39;} # If the configuration doesn\u0026#39;t contain an \u0026#34;options\u0026#34; section, it returns an empty ConfigParams object. config = ConfigParams.from_tuples( \u0026#34;section1.key1\u0026#34;, \u0026#34;AAA\u0026#34;, \u0026#34;section1.key2\u0026#34;, 123, ) options = OptionsResolver.resolve(config) # Returns {} ","description":"A helper class to parameters from \"options\" configuration section.\n","image":null,"permalink":"/python/commons/config/option_resolver/","subtitle":null,"tags":null,"title":"OptionResolver"},{"content":"Keeps list of working organizations.\n Server implementations: NodeJS Communication protocols: Direct, Commandable HTTP, Commandable GRPC, GRPC Persistence: Memory, Flat Files, MongoDB, Couchbase Deployment options: Monolith, Process, Docker, AWS Lambda Client implementations: NodeJS, Golang  ","description":null,"image":null,"permalink":"/microservices/users/organizations/","subtitle":null,"tags":null,"title":"Organizations Microservice"},{"content":"Description The OrRule class allows you to validate combinations of rules created with the OR logical operations.\nImportant points\n When one of the combined rules returns no errors, then this rule also returns no errors. When all combined rules return errors, then this rule returns all the errors.  Constructors NewOrRule Creates a new validation rule and sets its values.\n NewOrRule(rules \u0026hellip;IValidationRule) *OrRule\n  rules: \u0026hellip;IValidationRule - list of rules to join with OR operator  Methods validate Validates a given value against this rule.\n (c *OrRule) Validate(path string, schema ISchema, value interface{}) []*ValidationResult\n  path: string - dot notation path to the value. schema: ISchema - schema this rule is called from value: interface{} - value to be validated. results: []*ValidationResult - list with validation results to add new results.  Examples var schema = NewSchema() .WithRule(NewOrRule( NewValueComparisonRle(\u0026#34;LT\u0026#34;, 1), NewValueComparisonule(\u0026#34;GT\u0026#34;, 10) )); schema.Validate(); // Result: no error schema.Validate5); // Result: 5 must be less than 1 or 5 must be more than 10 schema.Validate(20); // Result: no error  See also   IValidationRule   ","description":"Validation rule that allows you to check combinations of rules created with the OR logical operations.\n","image":null,"permalink":"/golang/commons/validate/or_rule/","subtitle":null,"tags":null,"title":"OrRule"},{"content":"Inherits: IValidationRule\nDescription The OrRule class allows you to validate combinations of rules created with OR logical operations.\nImportant points\n When one of the combined rules returns no errors, then this rule also returns no errors. When all combined rules return errors, then this rule returns all the errors.  Constructors Creates a new validation rule and sets its values.\n public OrRule(params IValidationRule[] rules)\n  rules: IValidationRule[] - list of rules to join with OR operators  Instance methods Validate Validates a given value against this rule.\n public void Validate(string path, Schema schema, object value, List\u0026lt;ValidationResult\u0026gt; results)\n  path: string - dot notation path to the value. schema: Schema - schema this rule is called from value: object - value to be validated. results: List\u0026lt;ValidationResult\u0026gt; - list with validation results to add new results.  Examples var schema = new Schema().WithRule(new OrRule(new ValueComparisonRule(\u0026#34;LT\u0026#34;, 1), new ValueComparisonRule(\u0026#34;GT\u0026#34;, 10))); schema.Validate(0); // Result: no error schema.Validate(5); // Result: 5 must be less than 1 or 5 must be more than 10 schema.Validate(20); // Result: no error  See also   IValidationRule   ","description":"Validation rule that allows you to check combinations of rules created with OR logical operations.\n","image":null,"permalink":"/net/commons/validate/or_rule/","subtitle":null,"tags":null,"title":"OrRule"},{"content":"Implements: IValidationRule\nDescription The OrRule class allows you to validate combinations of rules created with OR logical operations.\nImportant points\n When one of the combined rules returns no errors, then this rule also returns no errors. When all combined rules return errors, then this rule returns all the errors.  Constructors Creates a new validation rule and sets its values.\n public constructor(\u0026hellip;rules: IValidationRule[])\n  rules: IValidationRule[] - list of rules to join with an OR operator.  Instance methods validate Validates a given value against this rule.\n public validate(path: string, schema: Schema, value: any, results: ValidationResult[]): void\n  path: string - dot notation path to the value. schema: Schema - schema this rule is called from. value: any - value to be validated. results: ValidationResult[] - list with validation results.  Examples let schema = new Schema() .withRule(new OrRule( new ValueComparisonRule(\u0026#34;LT\u0026#34;, 1), new ValueComparisonRule(\u0026#34;GT\u0026#34;, 10) )); schema.validate(0); // Result: no error schema.validate(5); // Result: 5 must be less than 1 or 5 must be more than 10 schema.validate(20); // Result: no error  See also   IValidationRule   ","description":"Validation rule that allows you to check combinations of rules created with OR logical operations.\n","image":null,"permalink":"/node/commons/validate/or_rule/","subtitle":null,"tags":null,"title":"OrRule"},{"content":"Implements: IValidationRule\nDescription The OrRule class allows you to validate combinations of rules created with OR logical operations.\nImportant points\n When one of the combined rules returns no errors, then this rule also returns no errors. When all combined rules return errors, then this rule returns all the errors.  Constructors Creates a new validation rule and sets its values.\n OrRule(*rules: IValidationRule)\n  rules: IValidationRule - a list of rules to join with OR operator  Instance methods validate Validates a given value against this rule.\n validate(path: str, schema: Schema, value: Any, results: List[ValidationResult])\n  path: str - a dot notation path to the value. schema: Schema - a schema this rule is called from value: Any - a value to be validated. results: List[ValidationResult] - a list with validation results to add new results.  Examples schema = Schema().with_rule(OrRule(ValueComparisonRule(\u0026#34;LT\u0026#34;, 1), ValueComparisonRule(\u0026#34;GT\u0026#34;, 10))) schema.validate(0) # Result: no error schema.validate(5) # Result: 5 must be less than 1 or 5 must be more than 10 schema.validate(20) # Result: no error See also   IValidationRule   ","description":"Validation rule that allows you to check combinations of rules created with OR logical operations.\n","image":null,"permalink":"/python/commons/validate/or_rule/","subtitle":null,"tags":null,"title":"OrRule"},{"content":"Description The OwnerAuthManager class provides access granting methods for owners and administrators.\nInstance methods Owner Access is granted only for the session owner.\nThrows UnauthorizedException exception if not authorized or not owner.\n (c *OwnerAuthManager) Owner(idParam string) func(res http.ResponseWriter, req *http.Request, next http.HandlerFunc)\n  idParam: string - id of the current owner. returns: func(res http.ResponseWriter, req *http.Request, next http.HandlerFunc) - returns owner handler.  OwnerOrAdmin Access is granted only to authorized users.\nThrows UnauthorizedException exception if not authorized or not owner.\n (c *OwnerAuthManager) OwnerOrAdmin(idParam string) func(res http.ResponseWriter, req *http.Request, next http.HandlerFunc)\n  idParam: string - id of the current owner. returns: func(res http.ResponseWriter, req *http.Request, next http.HandlerFunc) - returns owner or admin handler.  ","description":"Access granting methods for owners and administrators.\n","image":null,"permalink":"/golang/rpc/auth/owner_auth_manager/","subtitle":null,"tags":null,"title":"OwnerAuthManager"},{"content":"Description The OwnerAuthorizer class provides access granting methods for owners and administrators.\nInstance methods Owner Access is granted only for the session owner.\nThrows UnauthorizedException exception if not authorized or not owner.\n public Func\u0026lt;HttpRequest, HttpResponse, ClaimsPrincipal, RouteData, Func\u0026lt;Task\u0026gt;, Task\u0026gt; Owner(string idParam = \u0026ldquo;user_id\u0026rdquo;)\n  idParam: string - id of the current owner. returns: Func\u0026lt;HttpRequest, HttpResponse, ClaimsPrincipal, RouteData, Func\u0026lt;Task\u0026gt;, Task\u0026gt; - returns owner handler.  OwnerOrAdmin Access is granted only to authorized users.\nThrows UnauthorizedException exception if not authorized or not owner.\n public Func\u0026lt;HttpRequest, HttpResponse, ClaimsPrincipal, RouteData, Func\u0026lt;Task\u0026gt;, Task\u0026gt; OwnerOrAdmin(string idParam = \u0026ldquo;user_id\u0026rdquo;)\n  idParam: string - id of the current owner. returns: Func\u0026lt;HttpRequest, HttpResponse, ClaimsPrincipal, RouteData, Func\u0026lt;Task\u0026gt;, Task\u0026gt; - returns owner or admin handler.  ","description":"Access granting methods for owners and administrators.\n","image":null,"permalink":"/net/rpc/auth/owner_authorizer/","subtitle":null,"tags":null,"title":"OwnerAuthorizer"},{"content":"Description The OwnerAuthorizer class provides access granting methods for owners and administrators.\nInstance methods owner Access is granted only for the session owner.\nThrows UnauthorizedException exception if not authorized or not owner.\n public owner(idParam: string = \u0026lsquo;user_id\u0026rsquo;): (req: any, res: any, next: () =\u0026gt; void) =\u0026gt; void\n  idParam: string - id of the current owner. returns: (req: any, res: any, next: () =\u0026gt; void) =\u0026gt; void - returns owner handler.  ownerOrAdmin Access is granted only to authorized users.\nThrows UnauthorizedException exception if not authorized or not owner.\n public ownerOrAdmin(idParam: string = \u0026lsquo;user_id\u0026rsquo;): (req: any, res: any, next: () =\u0026gt; void) =\u0026gt; void\n  idParam: string - id of the current owner. returns: (req: any, res: any, next: () =\u0026gt; void) =\u0026gt; void - returns owner or admin handler.  ","description":"Access granting methods for owners and administrators.\n","image":null,"permalink":"/node/rpc/auth/owner_authorizer/","subtitle":null,"tags":null,"title":"OwnerAuthorizer"},{"content":"Description The OwnerAuthorizer class provides access granting methods for owners and administrators.\nInstance methods owner Access is granted only for the session owner.\nThrows UnauthorizedException exception if not authorized or not owner.\n owner(id_param: str = \u0026lsquo;user_id\u0026rsquo;): Callable\n  id_param: str - id of the current owner. returns: Callable - returns owner handler.  owner_or_admin Access is granted only to authorized users.\nThrows UnauthorizedException exception if not authorized or not owner.\n owner_or_admin(id_param: str = \u0026lsquo;user_id\u0026rsquo;): Callable\n  id_param: str - id of the current owner. returns: Callable - returns owner or admin handler.  ","description":"Access granting methods for owners and administrators.\n","image":null,"permalink":"/python/rpc/auth/owner_authorizer/","subtitle":null,"tags":null,"title":"OwnerAuthorizer"},{"content":"Description The PagingParams class allows you to create data transfer objects used to pass paging parameters for queries.\nImportant points\n A page is defined by two parameters:  skip: number of items to skip. take: number of items to return in a page.   Additionally, the optional total parameter defines whether to return the total number of items or not. However, not all implementations support the total parameter, because its generation may lead to severe performance implications.  Constructors NewPagingParams Creates a new instance and sets its values.\n NewPagingParams(skip, take, total interface{}) *PagingParams\n  skip: interface{} - the number of items to skip. take: interface{} - the number of items to return. total: interface{} - true to return the total number of items.  NewPagingParamsFromMap Creates a new PagingParams and sets its parameters from the specified map\n NewPagingParamsFromMap(value *AnyValueMap) *PagingParams\n  map: *AnyValueMap - AnyValueMap or StringValueMap to initialize this PagingParams returns: *PagingParams - newly created PagingParams.  NewPagingParamsFromTuples Creates a new PagingParams from a list of key-value pairs called tuples.\n NewPagingParamsFromTuples(tuples \u0026hellip;interface{}) *PagingParams\n  tuples: \u0026hellip;interface{} - list of values where odd elements are keys and the following even elements are values returns: *PagingParams - newly created PagingParams.  NewPagingParamsFromValue Converts specified value into PagingParams.\n NewPagingParamsFromValue(value interface{}) *PagingParams\n  value: interface{} - value to be converted returns: *PagingParams - newly created PagingParams.  NewEmptyPagingParams Creates a new instance.\n NewEmptyPagingParams() *PagingParams\n Fields Skip Number of items to skip.\n Skip: *int64\n take Number of items to return.\n take: *int64\n Total Flag to return the total number of items.\n Total: bool\n  Methods GetSkip Gets the number of items to skip.\n (c *PagingParams) GetSkip(minSkip int64) int64\n  minSkip: int64 - minimum number of items to skip. returns: int64 - number of items to skip.  GetTake Gets the number of items to return in a page.\n (c *PagingParams) GetTake(maxTake int64) int64\n  maxTake: int64 - Maximum number of items to return. returns: int64 - Number of items to return.  Examples filter := NewFilterParamsFromTuples(\u0026#34;type\u0026#34;, \u0026#34;Type1\u0026#34;); paging := NewPagingParams(0, 100); err, page = myDataClient.getDataByFilter(filter, paging); ","description":"Defines a data transfer object used to pass paging parameters for queries.\n","image":null,"permalink":"/golang/commons/data/paging_params/","subtitle":null,"tags":null,"title":"PagingParams"},{"content":"Description The PagingParams class allows you to create data transfer objects used to pass paging parameters for queries.\nImportant points\n A page is defined by two parameters:  skip: number of items to skip. take: number of items to return in a page.   Additionally, the optional total parameter defines whether to return the total number of items or not. However, not all implementations support the total parameter, because its generation may lead to severe performance implications.  Constructors Creates a new instance and sets its values.\n public PagingParams(object skip, object take, object total = null)\n  skip: object - number of items to skip. take: object - number of items to return. total: bool - true to return the total number of items.  Properties Skip Number of items to skip.\n public long Skip { get; set; }\n Take Number of items to return.\n public long Take { get; set; }\n Total Flag used to return the total number of items.\n public bool Total { get; set; }\n Instance methods GetSkip Gets the number of items to skip.\n public long GetSkip(long minSkip = 0)\n  minSkip: long - minimum number of items to skip. returns: long - number of items to skip.  GetTake Gets the number of items to return in a page.\n public long GetTake(long maxTake)\n  maxTake: long - maximum number of items to return. returns: long - number of items to return.  Static methods FromMap Creates a new PagingParams and sets its parameters from the specified map.\n public static PagingParams FromMap(AnyValueMap map)\n  map: AnyValueMap - AnyValueMap or StringValueMap used to initialize this PagingParams returns: PagingParams - newly created PagingParams.  FromTuples Creates a new PagingParams from a list of key-value pairs called tuples.\n public static PagingParams FromTuples(params object[] tuples)\n  tuples: object[] - list of values where odd elements are keys and the following even elements are values. returns: PagingParams - newly created PagingParams.  FromValue Converts a specified value into PagingParams.\n public static PagingParams FromValue(object value)\n  value: object - value to be converted returns: PagingParams - newly created PagingParams.  Examples var filter = FilterParams.FromTuples(\u0026#34;type\u0026#34;, \u0026#34;Type1\u0026#34;); var paging = new PagingParams(0, 100); myDataClient.GetDataByFilter(filter, paging); ","description":"Defines a data transfer object used to pass paging parameters for queries.\n","image":null,"permalink":"/net/commons/data/paging_params/","subtitle":null,"tags":null,"title":"PagingParams"},{"content":"Description The PagingParams class allows you to create data transfer objects used to pass paging parameters for queries.\nImportant points\n A page is defined by two parameters:  skip: number of items to skip. take: number of items to return in a page.   Additionally, the optional total parameter defines whether to return the total number of items or not. However, not all implementations support the total parameter, because its generation may lead to severe performance implications.  Constructors Creates a new instance and sets its values.\n public constructor(skip: number = null, take: number = null, total: boolean = null)\n  skip: number - number of items to skip. take: number - number of items to return. total: boolean - true to return the total number of items.  Fields skip Number of items to skip.\n public skip: number\n take Number of items to return.\n public take: number\n total Flag to return the total number of items.\n public total: boolean\n  Instance methods getSkip Gets the number of items to skip.\n public getSkip(minSkip: number): number\n  minSkip: number - minimum number of items to skip. returns: number - number of items to skip.  getTake Gets the number of items to return in a page.\n public getTake(maxTake: number): number\n  maxTake: number - maximum number of items to return. returns: number - number of items to return.  Static methods fromMap Creates a new PagingParams object and sets it parameters from the specified map.\n public static fromMap(map: any): PagingParams\n  map: any - AnyValueMap or StringValueMap used to initialize this PagingParams returns: PagingParams - newly created PagingParams object.  fromTuples Creates a new PagingParams object from a list of key-value pairs called tuples.\n public static fromTuples(\u0026hellip;tuples: any[]): PagingParams\n  tuples: any[] - list of values where odd elements are keys and the following even elements are values returns: PagingParams - newly created PagingParams object.  fromValue Converts a specified value into PagingParams object.\n public static fromValue(value: any): PagingParams\n  value: any - value to be converted returns: PagingParams - newly created PagingParams object.  Examples let filter = FilterParams.fromTuples(\u0026#34;type\u0026#34;, \u0026#34;Type1\u0026#34;); let paging = new PagingParams(0, 100); myDataClient.getDataByFilter(filter, paging, (err, page) =\u0026gt; {...}); ","description":"Defines a data transfer object used to pass paging parameters for queries.\n","image":null,"permalink":"/node/commons/data/paging_params/","subtitle":null,"tags":null,"title":"PagingParams"},{"content":"Description The PagingParams class allows you to create data transfer objects used to pass paging parameters for queries.\nImportant points\n A page is defined by two parameters:  skip: number of items to skip. take: number of items to return in a page.   Additionally, the optional total parameter defines whether to return the total number of items or not. However, not all implementations support the total parameter, because its generation may lead to severe performance implications.  Constructors Creates a new instance and sets its values.\n PagingParams(skip: int = None, take: int = None, total: bool = False)\n  skip: int - the number of items to skip. take: int - the number of items to return. total: bool - true to return the total number of items.  Fields skip The number of items to skip.\n skip: int\n take The number of items to return.\n take: int\n total The flag to return the total number of items.\n total: bool\n  Instance methods get_skip Gets the number of items to skip.\n get_skip(min_skip: int): int\n  min_skip: int - the minimum number of items to skip. returns: int - the number of items to skip.  get_take Gets the number of items to return in a page.\n get_take(max_take: int): int\n  max_take: int - the maximum number of items to return. returns: int - the number of items to return.  Static methods from_map Creates a new PagingParams and sets it parameters from the specified map.\n static from_map(map: Any): PagingParams\n  map: Any - a AnyValueMap or StringValueMap to initialize this PagingParams returns: PagingParams - a newly created PagingParams.  from_tuples Creates a new PagingParams from a list of key-value pairs called tuples.\n static from_tuples(*tuples: Any): PagingParams\n  tuples: Any - a list of values where odd elements are keys and the following even elements are values returns: PagingParams - a newly created PagingParams.  from_value Converts specified value into PagingParams.\n static from_value(value: Any): PagingParams\n  value: Any - value to be converted returns: PagingParams - a newly created PagingParams.  Examples filter = FilterParams.fromTuples(\u0026#34;type\u0026#34;, \u0026#34;Type1\u0026#34;) paging = PagingParams(0, 100) myDataClient.get_data_by_filter(filter, paging) ","description":"Defines a data transfer object used to pass paging parameters for queries.\n","image":null,"permalink":"/python/commons/data/paging_params/","subtitle":null,"tags":null,"title":"PagingParams"},{"content":"Description The PagingParamsSchema class allows you to create a schema to validate PagingParams.\nConstructors NewPagingParamsSchema  NewPagingParamsSchema() *ObjectSchema\n See also   PagingParams   ","description":"Schema to validate [PagingParams](../../data/paging_params).\n","image":null,"permalink":"/golang/commons/validate/paging_params_schema/","subtitle":null,"tags":null,"title":"PagingParamsSchema"},{"content":"Inherits: ObjectSchema\nDescription The PagingParamsSchema class allows you to create a schema to validate PagingParams.\nConstructors  public PagingParamsSchema()\n See also   PagingParams   ","description":"Schema to validate [PagingParams](../../data/paging_params).\n","image":null,"permalink":"/net/commons/validate/paging_params_schema/","subtitle":null,"tags":null,"title":"PagingParamsSchema"},{"content":"Extends: ObjectSchema\nDescription The PagingParamsSchema class allows you to create a schema to validate PagingParams.\nConstructors  public constructor()\n See also   PagingParams   ","description":"Schema to validate [PagingParams](../../data/paging_params).\n","image":null,"permalink":"/node/commons/validate/paging_params_schema/","subtitle":null,"tags":null,"title":"PagingParamsSchema"},{"content":"Implements: ObjectSchema\nDescription The PagingParamsSchema class allows you to create a schema to validate PagingParams.\nConstructors  PagingParamsSchema()\n See also   PagingParams   ","description":"Schema to validate [PagingParams](../../data/paging_params).\n","image":null,"permalink":"/python/commons/validate/paging_params_schema/","subtitle":null,"tags":null,"title":"PagingParamsSchema"},{"content":"Implements: AnyValueMap\nDescription The Parameters class contains a map with execution paramters.\nImportant points\n In general, this map may contain non-serializable values. In contrast with other maps, its getters and setters support dot notation and are able to access properties in the entire object graph. This class is often used to pass execution and notification arguments, and parameterize classes before execution.  Constructors NewParameters Creates a new instance of the map and assigns its value.\n NewParameters(values map[string]interface{}) *Parameters\n  map: map[string]interface{} - (optional) values to initialize this map.  NewParametersFromConfig Creates a new Parameters object from a ConfigMap object. See ConfigParams\n NewParametersFromConfig(config *config.ConfigParams) *Parameters\n  config: *config.ConfigParams - ConfigParams object that contains parameters. returns: *Parameters - new Parameters object.  NewParametersFromMaps Creates a new Parameters by merging two or more maps. Maps defined later in the list override values from previously defined maps.\n NewParametersFromMaps(maps \u0026hellip;map[string]interface{}) *Parameters\n  maps: \u0026hellip;map[string]interface{} - array of maps to be merged returns: Parameters - new Parameters object.  NewParametersFromTuples Creates a new Parameters object filled with provided key-value pairs called tuples. Tuples parameters contain a sequence of key1, value1, key2, value2, \u0026hellip; pairs. See AnyValueMap.FromTuplesArray\n NewParametersFromTuples(tuples \u0026hellip;interface{}) *Parameters\n  tuples: \u0026hellip;interface{} - ConfigParams object that contains parameters. returns: *Parameters - new Parameters object.  NewParametersFromValue Creates a new Parameters object filled with key-value pairs from a specified object.\n NewParametersFromValue(value interface{}) *Parameters\n  value: interface{} - object with key-value pairs used to initialize a new Parameters. returns: Parameters - new Parameters object.  NewEmptyParameters Creates a new instance of the map and assigns its value.\n NewEmptyParameters() *Parameters\n Methods AssignTo Assigns (copies over) properties from the specified value to this map.\n (c *Parameters) AssignTo(value interface{})\n  value: interface{} - value whose properties shall be copied over.  Contains Checks if the map contains an element with a specified key.\nThe key can be defined using dot notation and allows to recursively access elements of elements.\n (c *Parameters) Contains(key string) bool\n  key: string - key to be checked returns: bool - true if this map contains the key or false otherwise.  Get Gets a map\u0026rsquo;s element specified by its key. The key can be defined using dot notation and allows to recursively access elements of elements.\n (c *Parameters) Get(key string) interface{}\n  key: string - key of the element to get. returns: interface{} - value of the map\u0026rsquo;s element.  GetAsNullableParameters Converts a map\u0026rsquo;s element into an Parameters object or returns nil if the conversion is not possible.\n (c *Parameters) GetAsNullableParameters(key string) *Parameters\n  key: string - key of element to get. returns: *Parameters - Parameters value of the element or nil if the conversion is not supported.  GetAsParameters Converts map element into an Parameters or returns empty Parameters if the conversion is not possible.\n (c *Parameters) GetAsParameters(key string) *Parameters\n  key: string - key of element to get. returns: *Parameters - Parameters value of the element or empty Parameters if the conversion is not supported.  GetAsParametersWithDefault Converts a map\u0026rsquo;s element into a Parameters object or returns a default value if the conversion is not possible.\n (c *Parameters) GetAsParametersWithDefault(key string, defaultValue *Parameters) *Parameters\n  key: string - key of element to get. defaultValue: *Parameters - default value returns: *Parameters - Parameters value of the element or default value if the conversion is not supported.  Omit Omits selected parameters from the Parameters object and returns the rest as a new Parameters object.\n (c *Parameters) Omit(paths \u0026hellip;string) *Parameters\n  paths: string[] - keys to be omitted from copying over to a new Parameters. returns: *Parameters - new *Parameters object.  Override Overrides parameters with new values from specified Parameters and returns a new Parameters object.\n (c *Parameters) Override(parameters *Parameters, recursive bool) *Parameters\n  parameters: *Parameters - Parameters with parameters to override the current values. recursive: bool - (optional) true to perform deep copy, and false for shallow copy. Default: false returns: *Parameters - new Parameters object.  Pick Picks select parameters from the Parameters object and returns them as a new Parameters object.\n (c *Parameters) Pick(paths \u0026hellip;string) *Parameters\n  paths: string[] - keys to be picked and copied over to the new Parameters object. returns: *Parameters - new Parameters object.  Put Puts a new value into a map element specified by its key. The key can be defined using dot notation and allows to recursively access elements of elements.\n (c *Parameters) Put(key string, value interface{})\n  key: string - key of the element to put. value: interface{} - new value for the map element.  SetDefaults Set default values from specified Parameters and returns a new Parameters object.\n (c *Parameters) SetDefaults(defaultParameters *Parameters, recursive bool) *Parameters\n  defaultParameters: *Parameters - Parameters object with default parameter values. recursive: bool - (optional) true to perform deep copy, and false for shallow copy. Default: false returns: *Parameters - new Parameters object.  See also   IParameterized   AnyValueMap   ","description":"Contains a map with execution parameters.\n","image":null,"permalink":"/golang/commons/run/parameters/","subtitle":null,"tags":null,"title":"Parameters"},{"content":"Inherits: AnyValueMap\nDescription The Parameters class contains a map with execution paramters.\nImportant points\n In general, this map may contain non-serializable values. In contrast to other maps, its getters and setters support dot notation and are able to access properties in the entire object graph. This class is often used to pass execution and notification arguments, and parameterize classes before execution.  Constructors Creates a new instance of the map and assigns its value.\n public Parameters(IDictionary map)\n  map: IDictionary - (optional) values used to initialize this map.  Creates a new instance of the map.\n public Parameters()\n Instance methods AssignTo Assigns (copies over) properties from the specified value to this map.\n public void AssignTo(object value)\n  value: object - value whose properties shall be copied over.  ContainsKey Checks if this map contains an element with a specified key.\nThe key can be defined using dot notation and allows to recursively access elements of elements.\n public bool ContainsKey(string key)\n  key: string - key to be checked returns: bool - true if this map contains the key or false otherwise.  Get Gets a map element specified by its key. The key can be defined using dot notation and allows to recursively access elements of elements.\n public override object Get(string key)\n  key: string - key of the element to get. returns: object - value of the map element.  GetAsNullableParameters Converts map element into a Parameters object or returns null if the conversion is not possible.\n public Parameters GetAsNullableParameters(string key)\n  key: string - key of element to get. returns: Parameters - Parameters object with the value of the element or null if conversion is not supported.  GetAsParameters Converts a map element into a Parameters object or returns an empty Parameters object if the conversion is not possible.\n public Parameters GetAsParameters(string key)\n  key: string - key of element to get. returns: Parameters - Parameters object with the value of the element or an empty Parameters object if the conversion is not supported.  GetAsParametersWithDefault Converts a map element into a Parameters object or returns a given default Parameters object if the conversion is not possible.\n public Parameters GetAsParametersWithDefault(string key, Parameters defaultValue)\n  key: string - key of element to get. defaultValue: Parameters - default value returns: Parameters - Parameters object with the value of the element or given default Parameters object if conversion is not supported.  Omit Omits selected parameters from this Parameters object and returns the remaining ones as a new Parameters object.\n public Parameters Omit(params string[] paths)\n  paths: string[] - keys to be omitted from copying over to new Parameters. returns: Parameters - new Parameters object.  Override Overrides parameters with new values from specified Parameters object and returns a new Parameters object.\n public Parameters Override(Parameters parameters)\n  parameters: Parameters - Parameters object with the parameters to override the current values. returns: Parameters - new Parameters object.  Override Overrides parameters with new values from a specified Parameters object and returns a new Parameters object.\n public Parameters Override(Parameters parameters, bool recursive)\n  parameters: Parameters - Parameters object with parameters to override the current values. recursive: bool - (optional) true to perform deep copy, and false for shallow copy. Default: false returns: Parameters - new Parameters object.  Pick Picks select parameters from this Parameters object and returns them as a new Parameters object.\n public Parameters Pick(params string[] paths)\n  paths: string[] - keys to be picked and copied over to a new Parameters object. returns: Parameters - new Parameters object.  Set Sets a new value into a map element specified by its key. The key can be defined using dot notation and allows to recursively access elements of elements.\n public override void Set(string key, object value)\n  key: string - key of the element to put. value: object - new value for map element.  SetDefaults Set default values from a specified Parameters object and returns a new Parameters object.\n public Parameters SetDefaults(Parameters defaultParameters)\n  defaultParameters: Parameters - Parameters object with default parameter values. returns: Parameters - new Parameters object.  SetDefaults Set default values from a specified Parameters object and returns a new Parameters object.\n public Parameters SetDefaults(Parameters defaultParameters, bool recursive)\n  defaultParameters: Parameters - Parameters object with default parameter values. recursive: bool - (optional) true to perform deep copy, and false for shallow copy. Default: false returns: Parameters - new Parameters object.  Static methods FromConfig Creates new Parameters object from a ConfigMap object. See ConfigParams\n public static Parameters FromConfig(ConfigParams config)\n  config: ConfigParams - ConfigParams object that contain parameters. returns: Parameters - new Parameters object.  FromJson Creates a new Parameters from a ConfigMap object.\n public static Parameters FromJson(string json)\n  config: string - json string that contain parameters. returns: Parameters - new Parameters object.  FromTuples Creates a new Parameters object filled with provided key-value pairs called tuples. Tuples parameters contain a sequence of key1, value1, key2, value2, \u0026hellip; pairs. See AnyValueMap.FromTuplesArray\n public static Parameters FromTuples(params object[] tuples)\n  tuples: object[] - ConfigParams object that contain parameters. returns: Parameters - new Parameters object.  FromValue! Note: this method is not availale for this language Creates a new Parameters object filled with key-value pairs from specified object.\n public static Parameters FromValue(object value)\n  tuples: object - object with key-value pairs used to initialize a new Parameters. returns: Parameters - new Parameters object.  MergeParams Merges two or more Parameters objects into one. The following Parameters override previously defined parameters. See AnyValueMap.fromMaps\n public static Parameters MergeParams(params Parameters[] parameters)\n  parameters: Parameters[] - list of Parameters objects to be merged. returns: Parameters - new Parameters object.  ToJson Converts this map to a JSON object.\n public string string ToJson()\n  returns: string - JSON representation of this map.  See also   IParameterized   AnyValueMap   ","description":"Contains a map with execution parameters.\n","image":null,"permalink":"/net/commons/run/parameters/","subtitle":null,"tags":null,"title":"Parameters"},{"content":"Extends: AnyValueMap\nDescription The Parameters class contains a map with execution paramters.\nImportant points\n In general, this map may contain non-serializable values. In contrast with other maps, its getters and setters support dot notation and are able to access properties in the entire object graph. This class is often used to pass execution and notification arguments, and parameterize classes before execution.  Constructors Creates a new instance of the map and assigns its value.\n public constructor(map: any = null)\n  map: any - (optional) values to initialize this map.  Instance methods assignTo Assigns (copies over) properties from the specified value to this map.\n public assignTo(value: any): void\n  value: any - value whose properties shall be copied over.  containsKey Checks if this map contains an element with a specified key.\nThe key can be defined using dot notation and allows to recursively access elements of elements.\n public containsKey(key: string): boolean\n  key: string - key to be checked returns: boolean - true if this map contains the key or false otherwise.  get Gets a map\u0026rsquo;s element specified by its key. The key can be defined using dot notation and allows to recursively access elements of elements.\n public get(key: string): any\n  key: string - key of the element to get. returns: any - value of the map element.  getAsNullableParameters Converts a map\u0026rsquo;s element into a Parameters object or returns null if the conversion is not possible.\n public getAsNullableParameters(key: string): Parameters\n  key: string - key of the element to get. returns: Parameters - Parameters value of the element or null if the conversion is not supported.  getAsParameters Converts a map\u0026rsquo;s element into a Parameters object or returns an empty Parameters object if the conversion is not possible.\n public getAsParameters(key: string): Parameters\n  key: string - key of element to get. returns: Parameters - Parameters value of the element or empty Parameters object if the conversion is not supported.  getAsParametersWithDefault Converts a map\u0026rsquo;s element into an Parameters or returns a given default value if the conversion is not possible.\n public getAsParametersWithDefault(key: string, defaultValue: Parameters): Parameters\n  key: string - key of element to get. defaultValue: Parameters - default value returns: Parameters - Parameters value of the element or default value if the conversion is not supported.  omit Omits selected parameters from this Parameters object and returns the rest as a new Parameters object.\n public omit(\u0026hellip;paths: string[]): Parameters\n  paths: string[] - keys to be omitted from copying over to new Parameters. returns: Parameters - new Parameters object.  override Overrides parameters with new values from a specified Parameters object and returns a new Parameters object.\n public override(parameters: Parameters, recursive: boolean = false): Parameters\n  parameters: Parameters - Parameters with parameters to override the current values. recursive: boolean - (optional) true to perform a deep copy, and false for a shallow copy. Default: false returns: Parameters - new Parameters object.  pick Picks select parameters from this Parameters object and returns them as a new Parameters object.\n public pick(\u0026hellip;paths: string[]): Parameters\n  paths: string[] - keys to be picked and copied over to the new Parameters object. returns: Parameters - new Parameters object.  put Puts a new value into a map\u0026rsquo;s element specified by its key. The key can be defined using dot notation and allows to recursively access elements of elements.\n public put(key: string, value: any): any\n  key: string - key of the element to put. value: any - new value for map element.  setDefaults Sets default values from a specified Parameters object and returns a new Parameters object.\n public setDefaults(defaultParameters: Parameters, recursive: boolean = false): Parameters\n  defaultParameters: Parameters - Parameters object with default parameter values. recursive: boolean - (optional) true to perform a deep copy, and false for a shallow copy. Default: false. returns: Parameters - new Parameters object.  toJson Converts this map to a JSON object.\n public toJson(): string\n  returns: string - JSON representation of this map.  Static methods fromConfig Creates new Parameters object from a ConfigMap object. See ConfigParams\n public static fromConfig(config: ConfigParams): Parameters\n  config: ConfigParams - ConfigParams object that contains parameters. returns: Parameters - new Parameters object.  fromJson Creates new Parameters object from a JSON string.\n public static fromJson(json: string): Parameters\n  config: string - json string that contains parameters. returns: Parameters - new Parameters object.  fromTuples Creates a new Parameters object filled with provided key-value pairs called tuples. Tuples parameters contain a sequence of key1, value1, key2, value2, \u0026hellip; pairs. See AnyValueMap.fromTuplesArray\n public static fromTuples(\u0026hellip;tuples: any[]): Parameters\n  tuples: any[] - ConfigParams object that contain parameters. returns: Parameters - new Parameters object.  fromValue Creates a new Parameters object filled with key-value pairs from a specified object.\n public static fromValue(value: any): Parameters\n  tuples: any - object with key-value pairs used to initialize a new Parameters object. returns: Parameters - new Parameters object.  mergeParams Merges two or more Parameters objects into one. The resulting Parameters object overrides previously defined parameters. See AnyValueMap.fromMaps\n public static mergeParams(\u0026hellip;parameters: Parameters[]): Parameters\n  parameters: Parameters[] - list of Parameters objects to be merged. returns: Parameters - new Parameters object.  See also   IParameterized   AnyValueMap   ","description":"Contains a map with execution parameters.\n","image":null,"permalink":"/node/commons/run/parameters/","subtitle":null,"tags":null,"title":"Parameters"},{"content":"Implements: AnyValueMap\nDescription The Parameters class contains a map with execution paramters.\nImportant points\n In general, this map may contain non-serializable values. In contrast with other maps, its getters and setters support dot notation and are able to access properties in the entire object graph. This class is often used to pass execution and notification arguments, and parameterize classes before execution.  Constructors Creates a new instance of the map and assigns its value.\n Parameters(map: Any = None)\n  map: Any - (optional) values to initialize this map.  Instance methods assign_to Assigns (copies over) properties from the specified value to this map.\n assign_to(value: Any)\n  value: Any - value whose properties shall be copied over.  contains_key Checks if this map contains an element with a specified key.\nThe key can be defined using dot notation and allows to recursively access elements of elements.\n contains_key(key: str): bool\n  key: str - a key to be checked returns: bool - true if this map contains the key or false otherwise.  get Gets a map element specified by its key. The key can be defined using dot notation and allows to recursively access elements of elements.\n get(key: str): Any\n  key: str - a key of the element to get. returns: Any - the value of the map element.  get_as_nullable_parameters Converts map element into an Parameters or returns None if conversion is not possible.\n get_as_nullable_parameters(key: str): Parameters\n  key: str - a key of element to get. returns: Parameters - Parameters value of the element or None if conversion is not supported.  get_as_parameters Converts map elements into Parameters or returns empty Parameters if conversion is not possible.\n get_as_parameters(key: str): Parameters\n  key: str - a key of element to get. returns: Parameters - Parameters value of the element or empty Parameters if conversion is not supported.  get_as_parameters_with_default Converts map elements into Parameters or returns default value if conversion is not possible.\n get_as_parameters_with_default(key: str, default_value: Parameters): Parameters\n  key: str - a key of element to get. default_value: Parameters - the default value returns: Parameters - Parameters value of the element or default value if conversion is not supported.  omit Omits selected parameters from this Parameters and returns the rest as a new Parameters object.\n omit(*paths: str): Parameters\n  paths: str - keys to be omitted from copying over to new Parameters. returns: Parameters - a new Parameters object.  override Overrides parameters with new values from specified Parameters and returns a new Parameters object.\n override(parameters: Parameters, recursive: bool = false): Parameters\n  parameters: Parameters - Parameters with parameters to override the current values. recursive: bool - (optional) true to perform deep copy, and false for shallow copy. Default: false returns: Parameters - a new Parameters object.  pick Picks selected parameters from a Parameters object and returns them as a new Parameters object.\n pick(*paths: str): Parameters\n  paths: str - keys to be picked and copied over to new Parameters. returns: Parameters - a new Parameters object.  put Puts a new value into map element specified by its key. The key can be defined using dot notation and allows to recursively access elements of elements.\n put(key: str, value: Any): Any\n  key: str - a key of the element to put. value: Any - a new value for map element.  set_defaults Set default values from specified Parameters and returns a new Parameters object.\n set_defaults(default_parameters: Parameters, recursive: bool = false): Parameters\n  default_parameters: Parameters - Parameters with default parameter values. recursive: bool - (optional) true to perform deep copy, and false for shallow copy. Default: false returns: Parameters - a new Parameters object.  to_json Converts this map to a JSON object.\n to_json(): str\n  returns: str - a JSON representation of this map.  Static methods from_config Creates new Parameters from ConfigMap object. See ConfigParams\n static from_config(config: ConfigParams): Parameters\n  config: ConfigParams - a ConfigParams that contain parameters. returns: Parameters - a new Parameters object.  from_json Creates new Parameters object from a ConfigMap object.\n static from_json(json: str): Parameters\n  config: str - a json string that contain parameters. returns: Parameters - a new Parameters object.  from_tuples Creates a new Parameters object filled with provided key-value pairs called tuples. Tuples parameters contain a sequence of key1, value1, key2, value2, \u0026hellip; pairs. See AnyValueMap.fromTuplesArray.\n static fro_tuples(*tuples: Any): Parameters\n  tuples: Any - a ConfigParams that contain parameters. returns: Parameters - a new Parameters object.  from_value Creates a new Parameters object filled with key-value pairs from specified object.\n static from_value(value: Any): Parameters\n  tuples: Any - an object with key-value pairs used to initialize a new Parameters object. returns: Parameters - a new Parameters object.  merge_params Merges two or more Parameters into one. The following Parameters override previously defined parameters. See AnyValueMap.fromMaps\n static merge_params(*parameters: Parameters): Parameters\n  parameters: Parameters - a list of Parameters objects to be merged. returns: Parameters - a new Parameters object.  See also   IParameterized   AnyValueMap   ","description":"Contains map with execution parameters.\n","image":null,"permalink":"/python/commons/run/parameters/","subtitle":null,"tags":null,"title":"Parameters"},{"content":"Inherits: IdentifiableMongoDbPersistence\u0026lt;T, K\u0026gt;\nDescription The MongoDbPersistence class allows you to create persistence components that store data in MongoDBs using the official MongoDB driver.\nImportant points\nWhere T : IIdentifiable. Where K : class.\nIn basic scenarios child classes shall only override GetPageByFilterAsync(), GetListByFilterAsync() or DeleteByFilterAsync() operations with specific filter function. All other operations can be used out of the box.\nIn complex scenarios child classes can implement additional operations by accessing this._collection and this._model properties.\nConfiguration parameters  collection: (optional) MongoDB collection name  connection(s):\n discovery_key: (optional) key to retrieve the connection from IDiscovery host: host name or IP address port: port number (default: 27017) uri: resource URI or connection string with all parameters in it  credential(s):\n store_key: (optional) key to retrieve the credentials from ICredentialStore username: (optional) username password: (optional) user\u0026rsquo;s password  options:\n max_pool_size: (optional) maximum connection pool size (default: 2) keep_alive: (optional) enable connection keep alive (default: true) connect_timeout: (optional) connection timeout in milliseconds (default: 5 sec) auto_reconnect: (optional) enable auto reconnection (default: true) max_page_size: (optional) maximum page size (default: 100) debug: (optional) enable debug output (default: false).  References  *:logger:*:*:1.0 - (optional) ILogger components to pass log messages *:discovery:*:*:1.0 - (optional) IDiscovery services *:credential-store:*:*:1.0 - (optional) credential stores to resolve credentials  Constructors Creates a new instance of the persistence component.\n public PartitionMongoDbPersistence(string collectionName, string partitionKey)\n  collectionName: string - (optional) collection name. partitionKey: string - TODO add description  Fields _partitionKey TODO: add description\n protected _partitionKey: string\n \u0026lt;/span\nInstance methods Configure Configures component by passing configuration parameters.\n public void Configure(ConfigParams config)\n  config: ConfigParams - configuration parameters to be set.  DeleteByIdAsync Deleted a data item by it\u0026rsquo;s unique id.\n public override Task\u0026lt;T\u0026gt; DeleteByIdAsync(string correlationId, K id)\n  correlationId: string - object to convert from the public partial format. id: K - an id of the item to be deleted  GetOneByFilterAsync Gets one first data item by filter.\n public Task\u0026lt;T\u0026gt; GetOneByFilterAsync(string correlationId, FilterDefinition\u0026lt;T\u0026gt; filterDefinition)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. filterDefinition: FilterDefinition\u0026lt;T\u0026gt; - (optional) a filter JSON object returns: Task\u0026lt;T\u0026gt; - a data item by id.  Gets one first data item by filter.\n protected Task\u0026lt;object\u0026gt; GetOneByFilterAsync(string correlationId, FilterDefinition\u0026lt;T\u0026gt; filterDefinition, ProjectionParams projection)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. filterDefinition: FilterDefinition\u0026lt;T\u0026gt; - (optional) a filter JSON object. projection: ProjectionParams - (optional) projection parameters. returns: Task\u0026lt;object\u0026gt; - a data item by id.  ModifyByIdAsync Modify a data item by it\u0026rsquo;s unique id.\n public override Task\u0026lt;T\u0026gt; ModifyByIdAsync(string correlationId, K id, UpdateDefinition\u0026lt;T\u0026gt; updateDefinition)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. id: K - (optional) filter function used to filter items. updateDefinition: UpdateDefinition\u0026lt;T\u0026gt; - (optional) a JSON object to update returns: Task\u0026lt;T\u0026gt; - updated item.  SetAsync Sets a data item. If the data item exists it updates it, otherwise it create a new data item.\n public override Task\u0026lt;T\u0026gt; SetAsync(string correlationId, T item)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. item: T - an item to be set. returns: Task\u0026lt;T\u0026gt; - updated item.  UpdateAsync Updates a data item.\n public override Task\u0026lt;T\u0026gt; UpdateAsync(string correlationId, T item)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. item: T - an item to be updated. returns: Task\u0026lt;T\u0026gt; - updated item.  Examples class MyMongoDbPersistence: PartitionMongoDbPersistence\u0026lt;MyData, string\u0026gt; { public constructor() { base(\u0026#34;mydata\u0026#34;, MyData.class); } private FilterDefinition\u0026lt;MyData\u0026gt; ComposeFilter(FilterParams filter) { filterParams = filterParams ?? new FilterParams(); var builder = Builders\u0026lt;BeaconV1\u0026gt;.Filter; var filter = builder.Empty; String name = filter.getAsNullableString(\u0026#39;name\u0026#39;); if (name != null) filter \u0026amp;= builder.Eq(b =\u0026gt; b.Name, name); return filter; } public GetPageByFilter(String correlationId, FilterParams filter, PagingParams paging) { base.GetPageByFilter(correlationId, this.ComposeFilter(filter), paging, null, null); } } var persistence = new MyMongoDbPersistence(); persistence.Configure(ConfigParams.FromTuples( \u0026#34;host\u0026#34;, \u0026#34;localhost\u0026#34;, \u0026#34;port\u0026#34;, 27017 ) ); persitence.Open(\u0026#34;123\u0026#34;); persistence.Create(\u0026#34;123\u0026#34;, new MyData(\u0026#34;1\u0026#34;, \u0026#34;ABC\u0026#34;)); var mydata = persistence.GetPageByFilter( \u0026#34;123\u0026#34;, FilterParams.FromTuples(\u0026#34;name\u0026#34;, \u0026#34;ABC\u0026#34;)); Console.Out.WriteLine(mydata.Data); // Result: { id: \u0026#34;1\u0026#34;, name: \u0026#34;ABC\u0026#34; }  persistence.DeleteById(\u0026#34;123\u0026#34;, \u0026#34;1\u0026#34;); ... ","description":"Abstract persistence component that stores data in MongoDB and implements a number of CRUD operations over data items with partitionKey. The data items must implement IIdentifiable interface.  \n","image":null,"permalink":"/net/mongodb/persistence/partition_mongodb_persistence/","subtitle":null,"tags":null,"title":"PartitionMongoDbPersistence\u003cT, K\u003e"},{"content":"Logs important party activities like signups, signins, creation, changes or deletion of data items and so on.\n Server implementations: NodeJS, Dart Communication protocols: Direct, Commandable HTTP, Commandable GRPC, GRPC Persistence: Memory, Flat Files, MongoDB, Couchbase Deployment options: Monolith, Process, Docker, AWS Lambda Client implementations: NodeJS, Golang, Dart  ","description":null,"image":null,"permalink":"/microservices/users/party_activities/","subtitle":null,"tags":null,"title":"Party Activities Microservice"},{"content":"Password authentication microservice.\n  Sets user passwords and authenticate\n  Safely change passwords\n  Reset and recover passwords via emails\n  Server implementations: NodeJS, Dart\n  Communication protocols: Direct, Commandable HTTP, Commandable GRPC, GRPC\n  Persistence: Memory, Flat Files, MongoDB, Couchbase\n  Deployment options: Monolith, Process, Docker, AWS Lambda\n  Client implementations: NodeJS, Golang, Dart\n  This microservice has optional dependencies on the following microservices:\n Party Activities - to log user activities Email Delivery - to send email notifications to users  ","description":null,"image":null,"permalink":"/microservices/users/passwords/","subtitle":null,"tags":null,"title":"Passwords Microservice"},{"content":"Payment\n Server implementations: NodeJS Communication protocols: Direct, Commandable HTTP, Commandable GRPC, GRPC Persistence: Memory, Flat Files, MongoDB, Couchbase Deployment options: Monolith, Process, Docker, AWS Lambda Client implementations: NodeJS  ","description":null,"image":null,"permalink":"/microservices/ecommrce/payments/","subtitle":null,"tags":null,"title":"Payment"},{"content":"Payment methods\n Server implementations: NodeJS Communication protocols: Direct, Commandable HTTP, Commandable GRPC, GRPC Persistence: Memory, Flat Files, MongoDB, Couchbase Deployment options: Monolith, Process, Docker, AWS Lambda Client implementations: NodeJS  ","description":null,"image":null,"permalink":"/microservices/ecommrce/payment_methods/","subtitle":null,"tags":null,"title":"Payment methods"},{"content":"Payroll checks.\n Server implementations: NodeJS Communication protocols: Direct, Commandable HTTP, Commandable GRPC, GRPC Persistence: Memory, Flat Files, MongoDB, Couchbase Deployment options: Monolith, Process, Docker, AWS Lambda Client implementations: NodeJS  ","description":null,"image":null,"permalink":"/microservices/ecommrce/payroll_checks/","subtitle":null,"tags":null,"title":"Payroll checks"},{"content":"Collects performance metrics from distributed microservices, stores and provides a single entry point to read all of them.\n Server implementations: NodeJS Communication protocols: Direct, Commandable HTTP, Commandable GRPC, GRPC Persistence: Memory, Flat Files, MongoDB, Couchbase Deployment options: Monolith, Process, Docker, AWS Lambda Client implementations: NodeJS, .NET  ","description":null,"image":null,"permalink":"/microservices/infrastructure/perfmon/","subtitle":null,"tags":null,"title":"Perfmon Microservice"},{"content":"Implements: IReferenceable, IConfigurable, IOpenable\nDescription The PostgresConnection class allows you to create connections to PostgreSQL databases using the official driver.\nImportant points\n By defining a connection and sharing it through multiple persistence components you can reduce the number of used database connections.  Configuration parameters connection(s):\n discovery_key: (optional) key to retrieve the connection from IDiscovery host: host name or IP address port: port number (default: 27017) uri: resource URI or connection string with all parameters in it  credential(s):\n store_key: (optional) key to retrieve the credentials from ICredentialStore username: username password: user\u0026rsquo;s password  options:\n connect_timeout: (optional) number of milliseconds to wait before timing out when connecting a new client (default: 0) idle_timeout: (optional) number of milliseconds a client must sit idle in the pool and not be checked out (default: 10000) max_pool_size: (optional) maximum number of clients the pool can contain (default: 10)  References  *:logger:*:*:1.0 - (optional) ILogger components to pass log messages *:discovery:*:*:1.0 - (optional) IDiscovery services *:credential-store:*:*:1.0 (optional) credential stores used to resolve credentials  Constructors NewPostgresConnection NewPostgresConnection creates a new instance of the connection component.\n NewPostgresConnection() *PostgresConnection\n Fields Connection The PostgreSQL connection pool object.\n Connection: *pgxpool.Pool\n ConnectionResolver The connection resolver.\n ConnectionResolver: *PostgresConnectionResolver\n DatabaseName The PostgreSQL database name.\n DatabaseName: string\n Logger The logger.\n Logger: CompositeLogger\n Options The configuration options.\n Options: *ConfigParams\n  Methods Close Closes the component and frees used resources.\n (c *PostgresConnection) Close(correlationId string) error\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. returns: error - returns error if not received.  Configure Configures the component by passing its configuration parameters.\n (c *PostgresConnection) Configure(config *cconf.ConfigParams)\n  config: *cconf.ConfigParams - configuration parameters to be set.  GetConnection Gets a connection to a Postgres database.\n (c *PostgresConnection) GetConnection() *pgxpool.Pool\n  returns: *pgxpool.Pool - connection to a Postgres database.  GetDatabaseName Gets the database name.\n (c *PostgresConnection) GetDatabaseName() string\n  returns: string - database name  ","description":"PostgreSQL connection using the official driver.\n","image":null,"permalink":"/golang/postgres/connect/postgres_connection/","subtitle":null,"tags":null,"title":"PostgresConnection"},{"content":"Inherits: IReferenceable, IConfigurable, IOpenable\nDescription The PostgresConnection class allows you to create connections to PostgreSQL databases using the official driver.\nImportant points\n By defining a connection and sharing it through multiple persistence components you can reduce the number of used database connections.  Configuration parameters connection(s):\n discovery_key: (optional) key to retrieve the connection from IDiscovery host: host name or IP address port: port number (default: 27017) uri: resource URI or connection string with all parameters in it  credential(s):\n store_key: (optional) key to retrieve the credentials from ICredentialStore username: username password: user\u0026rsquo;s password  options:\n max_pool_size: (optional) maximum connection pool size (default: 2) keep_alive: (optional) enable connection keep alive (default: true) connect_timeout: (optional) connection timeout in milliseconds (default: 5 sec) auto_reconnect: (optional) enable auto reconnection (default: true) max_page_size: (optional) maximum page size (default: 100) debug: (optional) enable debug output (default: false).  References  *:logger:*:*:1.0 - (optional) ILogger components to pass log messages *:discovery:*:*:1.0 - (optional) IDiscovery services *:credential-store:*:*:1.0 (optional) credential stores used to resolve credentials  Fields _connection The PostgreSQL connection pool object.\n protected _connection: NpgsqlConnection\n _connectionResolver The connection resolver.\n protected _connectionResolver: PostgresConnectionResolver\n _databaseName The PostgreSQL database name.\n protected _databaseName: string\n _logger The logger.\n protected _logger: CompositeLogger\n _options The configuration options.\n protected _options: ConfigParams\n  Instance methods Configure Configures the component by passing its configuration parameters.\n public virtual void Configure(ConfigParams config)\n  config: ConfigParams - configuration parameters to be set.  IsOpen Checks if the component is opened.\n public virtual bool IsOpen()\n  returns: bool - true if the component has been opened and false otherwise.  OpenAsync Opens the component.\n public virtual Task OpenAsync(string correlationId)\n  correlationId: string - (optional) transaction id to trace execution through call chain.  GetConnection Gets a connection to a Postgres database.\n public NpgsqlConnection GetConnection()\n  returns: NpgsqlConnection - connection to a Postgres database.  GetDatabaseName Gets the database name.\n public string GetDatabaseName()\n  returns: string - database name  SetReferences Sets references to dependent components.\n public void SetReferences(IReferences references)\n  references: IReferences - references to locate the component dependencies.  ","description":"PostgreSQL connection using the official driver.\n","image":null,"permalink":"/net/postgres/connect/postgres_connection/","subtitle":null,"tags":null,"title":"PostgresConnection"},{"content":"Implements: IReferenceable, IConfigurable, IOpenable\nDescription The PostgresConnection class allows you to create connections to PostgreSQL databases using the official driver.\nImportant points\n By defining a connection and sharing it through multiple persistence components you can reduce the number of used database connections.  Configuration parameters connection(s):\n discovery_key: (optional) key to retrieve the connection from IDiscovery host: host name or IP address port: port number (default: 27017) uri: resource URI or connection string with all parameters in it  credential(s):\n store_key: (optional) key to retrieve the credentials from ICredentialStore username: username password: user\u0026rsquo;s password  options:\n connect_timeout: (optional) number of milliseconds to wait before timing out when connecting a new client (default: 0) idle_timeout: (optional) number of milliseconds a client must sit idle in the pool and not be checked out (default: 10000) max_pool_size: (optional) maximum number of clients the pool can contain (default: 10)  References  *:logger:*:*:1.0 - (optional) ILogger components to pass log messages *:discovery:*:*:1.0 - (optional) IDiscovery services *:credential-store:*:*:1.0 (optional) credential stores used to resolve credentials  Fields _connection The PostgreSQL connection pool object.\n protected _connection: any\n _connectionResolver The connection resolver.\n protected _connectionResolver: PostgresConnectionResolver\n _databaseName The PostgreSQL database name.\n protected _databaseName: string\n _logger The logger.\n protected _logger: CompositeLogger\n _options The configuration options.\n protected _options: ConfigParams\n  Instance methods close Closes the component and frees used resources.\n public close(correlationId: string): Promise\u0026lt;void\u0026gt;\n  correlationId: string - (optional) transaction id used to trace execution through the call chain.  configure Configures the component by passing its configuration parameters.\n public configure(config: ConfigParams): void\n  config: ConfigParams - configuration parameters to be set.  getConnection Gets a connection to a Postgres database.\n public getConnection(): any\n  returns: any - connection to a Postgres database.  getDatabaseName Gets the database name.\n public getDatabaseName(): string\n  returns: string - database name  ","description":"PostgreSQL connection using the official driver.\n","image":null,"permalink":"/node/postgres/connect/postgres_connection/","subtitle":null,"tags":null,"title":"PostgresConnection"},{"content":"Implements: IReferenceable, IConfigurable, IOpenable\nDescription The PostgresConnection class allows you to create connections to PostgreSQL databases using the official driver.\nImportant points\n By defining a connection and sharing it through multiple persistence components you can reduce the number of used database connections.  Configuration parameters connection(s):\n discovery_key: (optional) key to retrieve the connection from IDiscovery host: host name or IP address port: port number (default: 27017) uri: resource URI or connection string with all parameters in it  credential(s):\n store_key: (optional) key to retrieve the credentials from ICredentialStore username: username password: user\u0026rsquo;s password  options:\n connect_timeout: (optional) number of milliseconds to wait before timing out when connecting a new client (default: 0) idle_timeout: (optional) number of milliseconds a client must sit idle in the pool and not be checked out (default: 10000) max_pool_size: (optional) maximum number of clients the pool can contain (default: 10)  References  *:logger:*:*:1.0 - (optional) ILogger components to pass log messages *:discovery:*:*:1.0 - (optional) IDiscovery services *:credential-store:*:*:1.0 (optional) credential stores used to resolve credentials  Fields _connection The PostgreSQL connection pool object.\n _connection: Any\n _connection_resolver The connection resolver.\n _connection_resolver: PostgresConnectionResolver\n _database_name The PostgreSQL database name.\n _database_name: str\n _logger The logger.\n _logger: CompositeLogger\n _options The configuration options.\n _options: ConfigParams\n  Instance methods close Closes the component and frees used resources.\n close(correlation_id: Optional[str])\n  correlation_id: Optional[str] - (optional) transaction id used to trace execution through the call chain.  configure Configures the component by passing its configuration parameters.\n configure(config: ConfigParams)\n  config: ConfigParams - configuration parameters to be set.  get_connection Gets a connection to a Postgres database.\n get_connection(): Any\n  returns: Any - connection to a Postgres database.  get_database_name Gets the database name.\n get_database_name(): str\n  returns: str - database name  ","description":"PostgreSQL connection using the official driver.\n","image":null,"permalink":"/python/postgres/connect/postgres_connection/","subtitle":null,"tags":null,"title":"PostgresConnection"},{"content":"Implements: IReferenceable, IConfigurable\nDescription The PostgresConnectionResolver class allows you to create a PostgresSQL connection and credential parameters resolver that validates these parameters and generates a connection URI.\nImportant points\n It is able to process multiple connections to PostgreSQL cluster nodes.  Configuration parameters connection(s):\n discovery_key: (optional) key to retrieve the connection from IDiscovery host: host name or IP address port: port number (default: 27017) database: database name uri: resource URI or connection string with all parameters in it  credential(s):\n store_key: (optional) key to retrieve the credentials from ICredentialStore username: username password: user\u0026rsquo;s password  References  *:discovery:*:*:1.0 - (optional) IDiscovery services *:credential-store:*:*:1.0 - (optional) credential stores to resolve credentials (ICredentialStore)  Constructors NewPostgresConnectionResolver NewPostgresConnectionResolver creates new connection resolver\n NewPostgresConnectionResolver() *PostgresConnectionResolver\n Fields ConnectionResolver The connection resolver\n ConnectionResolver: ConnectionResolver\n _credentialResolver The credential resolver\n ConnectionResolver: CredentialResolver\n  Methods Configure Configures component by passing configuration parameters.\n (c *PostgresConnectionResolver) Configure(config *cconf.ConfigParams)\n  config: *cconf.ConfigParams - configuration parameters to be set.  Resolve Resolves PostgreSQL config from connection and credential parameters.\n (c *PostgresConnectionResolver) Resolve(correlationId string) (uri string, err error)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. returns: (uri string, err error) - resolved connection config or raised error.  SetReferences Sets references to dependent components.\n (c *PostgresConnectionResolver) SetReferences(references crefer.IReferences)\n  references: crefer.IReferences - references to locate the component dependencies.  ","description":"Helper class that resolves PostgreSQL connection and credential parameters, validates them and generates a connection URI.\n","image":null,"permalink":"/golang/postgres/connect/postgres_connection_resolver/","subtitle":null,"tags":null,"title":"PostgresConnectionResolver"},{"content":"Inherits: IReferenceable, IConfigurable\nDescription The PostgresConnectionResolver class allows you to create a PostgresSQL connection and credential parameters resolver that validates these parameters and generates a connection URI.\nImportant points\n It is able to process multiple connections to PostgreSQL cluster nodes.  Configuration parameters connection(s):\n discovery_key: (optional) key to retrieve the connection from IDiscovery host: host name or IP address port: port number (default: 27017) database: database name uri: resource URI or connection string with all parameters in it  credential(s):\n store_key: (optional) key to retrieve the credentials from ICredentialStore username: username password: user\u0026rsquo;s password  References  *:discovery:*:*:1.0 - (optional) IDiscovery services *:credential-store:*:*:1.0 - (optional) credential stores to resolve credentials (ICredentialStore)  Fields _connectionResolver The connection resolver\n protected _connectionResolver: ConnectionResolver\n _credentialResolver The credential resolver\n protected _credentialResolver: CredentialResolver\n  Instance methods Configure Configures component by passing configuration parameters.\n public Configure(ConfigParams config)\n  config: ConfigParams - configuration parameters to be set.  ResolveAsync Resolves PostgreSQL config from connection and credential parameters.\n public Task\u0026lt;string\u0026gt; ResolveAsync(string correlationId)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. returns: Task\u0026lt;string\u0026gt; - resolved connection config or raised error.  SetReferences Sets references to dependent components.\n public void SetReferences(IReferences references)\n  references: IReferences - references to locate the component dependencies.  ","description":"Helper class that resolves PostgreSQL connection and credential parameters, validates them and generates a connection URI.\n","image":null,"permalink":"/net/postgres/connect/postgres_connection_resolver/","subtitle":null,"tags":null,"title":"PostgresConnectionResolver"},{"content":"Implements: IReferenceable, IConfigurable\nDescription The PostgresConnectionResolver class allows you to create a PostgresSQL connection and credential parameters resolver that validates these parameters and generates a connection URI.\nImportant points\n It is able to process multiple connections to PostgreSQL cluster nodes.  Configuration parameters connection(s):\n discovery_key: (optional) key to retrieve the connection from IDiscovery host: host name or IP address port: port number (default: 27017) database: database name uri: resource URI or connection string with all parameters in it  credential(s):\n store_key: (optional) key to retrieve the credentials from ICredentialStore username: username password: user\u0026rsquo;s password  References  *:discovery:*:*:1.0 - (optional) IDiscovery services *:credential-store:*:*:1.0 - (optional) credential stores to resolve credentials (ICredentialStore)  Fields _connectionResolver The connection resolver\n protected _connectionResolver: ConnectionResolver\n _credentialResolver The credential resolver\n protected _credentialResolver: CredentialResolver\n  Instance methods configure Configures component by passing configuration parameters.\n public configure(config: ConfigParams): void\n  config: ConfigParams - configuration parameters to be set.  resolve Resolves PostgreSQL config from connection and credential parameters.\n public resolve(correlationId: string): Promise\u0026lt;any\u0026gt;\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. returns: Promise\u0026lt;any\u0026gt; - resolved connection config or raised error.  setReferences Sets references to dependent components.\n public setReferences(references: IReferences): void\n  references: IReferences - references to locate the component dependencies.  ","description":"Helper class that resolves PostgreSQL connection and credential parameters, validates them and generates a connection URI.\n","image":null,"permalink":"/node/postgres/connect/postgres_connection_resolver/","subtitle":null,"tags":null,"title":"PostgresConnectionResolver"},{"content":"Implements: IReferenceable, IConfigurable\nDescription The PostgresConnectionResolver class allows you to create a PostgresSQL connection and credential parameters resolver that validates these parameters and generates a connection URI.\nImportant points\n It is able to process multiple connections to PostgreSQL cluster nodes.  Configuration parameters connection(s):\n discovery_key: (optional) key to retrieve the connection from IDiscovery host: host name or IP address port: port number (default: 27017) database: database name uri: resource URI or connection string with all parameters in it  credential(s):\n store_key: (optional) key to retrieve the credentials from ICredentialStore username: username password: user\u0026rsquo;s password  References  *:discovery:*:*:1.0 - (optional) IDiscovery services *:credential-store:*:*:1.0 - (optional) credential stores to resolve credentials (ICredentialStore)  Constructors Creates a new instance of the connection component.\n PostgresConnectionResolver()\n Fields _connection_resolver The connection resolver\n _connection_resolver: ConnectionResolver\n _credential_resolver The credential resolver\n _credential_resolver: CredentialResolver\n  Instance methods configure Configures component by passing configuration parameters.\n configure(config: ConfigParams)\n  config: ConfigParams - configuration parameters to be set.  resolve Resolves PostgreSQL config from connection and credential parameters.\n resolve(correlation_id: Optional[str]): Any\n  correlation_id: Optional[str] - (optional) transaction id used to trace execution through the call chain. returns: Any - resolved connection config or raised error.  set_references Sets references to dependent components.\n set_references(references: IReferences)\n  references: IReferences - references to locate the component dependencies.  ","description":"Helper class that resolves PostgreSQL connection and credential parameters, validates them and generates a connection URI.\n","image":null,"permalink":"/python/postgres/connect/postgres_connection_resolver/","subtitle":null,"tags":null,"title":"PostgresConnectionResolver"},{"content":"Implements: IReferenceable, IUnreferenceable, IConfigurable, IOpenable, ICleanable\nDescription The PostgresPersistence class allows you to create persistence components that store data in PostgreSQL using the official driver.\nImportant points\n This is the most basic persistence component that is only able to store data items of any type. Specific CRUD operations over the data items must be implemented in child classes by accessing c.Db or c.Collection properties.  Configuration parameters  collection: (optional) PostgreSQL collection name connection(s): discovery_key: (optional) key to retrieve the connection from IDiscovery host: host name or IP address port: port number (default: 27017) uri: resource URI or connection string with all parameters in it  credential(s):\n store_key: (optional) key to retrieve the credentials from ICredentialStore username: (optional) username password: (optional) user\u0026rsquo;s password  options:\n connect_timeout: (optional) number of milliseconds to wait before timing out when connecting a new client (default: 0) idle_timeout: (optional) number of milliseconds a client must sit idle in the pool and not be checked out (default: 10000) max_pool_size: (optional) maximum number of clients the pool can contain (default: 10)  References  *:logger:*:*:1.0 - (optional) ILogger components to pass log messages *:discovery:*:*:1.0 - (optional) IDiscovery services *:credential-store:*:*:1.0 - (optional) credential stores to resolve credentials  Constructors InheritPostgresPersistence Creates a new instance of the persistence component.\n InheritPostgresPersistence(overrides IPostgresPersistenceOverrides, proto reflect.Type, tableName string) *PostgresPersistence\n  overrides: IPostgresPersistenceOverrides - References to override virtual methods. proto: reflect.Type - TODO: add description. tableName: string - (optional) a collection name.  Fields TableName The PostgreSQL table object.\n TableName: string\n DependencyResolver The dependency resolver.\n DependencyResolver: *DependencyResolver\n Logger The logger.\n Logger: *CompositeLogger\n _connection The PostgreSQL connection component.\n Connection: *PostgresConnection\n Client The PostgreSQL connection pool object.\n Client: *pgxpool.Pool\n DatabaseName The PostgreSQL database name.\n DatabaseName: string\n TableName The PostgreSQL table object.\n TableName: string\n MaxPageSize The maximum number of records to return from the database.\n MaxPageSize: int\n  Methods Clear Clears a component\u0026rsquo;s state.\n (c *PostgresPersistence) Clear(correlationId string) error\n  correlationId: string- object to convert from the public partial format. returns: error - returns error if not received.  ClearSchema Clears all auto-created objects.\n (c *PostgresPersistence) ClearSchema()\n Close Closes the component and frees used resources.\n (c *PostgresPersistence) Close(correlationId string) (err error)\n  correlationId: string- object to convert from the public partial format. returns: (err error) - returns error if not received.  Configure Configures the component.\n (c *PostgresPersistence) Configure(config *conf.ConfigParams)\n  config: *conf.ConfigParams - configuration parameters to set.  ConvertFromPublic Converts an object value from public to internal format.\n (c *PostgresPersistence) ConvertFromPublic(value interface{}) interface{}\n  value: interface{} - object in public format to convert. returns: interface{} - converted object in internal format.  ConvertToPublic Converts an object value from internal to public format.\n (c *PostgresPersistence) ConvertToPublic(rows pgx.Rows) interface{}\n  item: pgx.Rows - object in internal format to convert. returns: interface{} - converted object in public format.  Create Creates a data item.\n (c *PostgresPersistence) Create(correlationId string, item interface{}) (result interface{}, err error)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. item: interface{} - item to be created. returns: (result interface{}, err error) - created item  CreateSchema Checks if a table exists and if it doesn\u0026rsquo;t, it creates the necessary database objects.\n (c *PostgresPersistence) CreateSchema(correlationId string) (err error)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. returns: (err error) - returns error if not received.  DefineSchema Defines database schema via auto create objects or convenience methods.\n (c *PostgresPersistence) DefineSchema()\n DeleteByFilter Deletes data items that match to a given filter. This method shall be called by a public DeleteByFilter method from child class that receives FilterParams and converts them into a filter function.\n (c *PostgresPersistence) DeleteByFilter(correlationId string, filter string) (err error)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. filter: string - (optional) a filter JSON object. returns: (err error) - returns error if not received.  EnsureIndex Adds index definition to create it on opening.\n (c *PostgresPersistence) EnsureIndex(name string, keys map[string]string, options map[string]string)\n  keys: map[string]string - index keys (fields) options: map[string]string - index options  EnsureSchema Adds a statement to schema definition.\n (c *PostgresPersistence) EnsureSchema(schemaStatement string)\n  schemaStatement: string - statement to be added to the schema  GenerateColumns Generates a list of column names to use in SQL statements like: \u0026ldquo;column1,column2,column3\u0026rdquo;.\n (c *PostgresPersistence) GenerateColumns(values interface{}) string\n  values: interface{} - array with column values or a key-value map returns: string - generated list of column names  GenerateParameters Generates a list of value parameters to use in SQL statements like: \u0026quot;$1,$2,$3\u0026quot;.\n (c *PostgresPersistence) GenerateParameters(values interface{}) string\n  values: interface{} - array with values or a key-value map returns: string - generated list of value parameters  GenerateSetParameters Generates a list of column sets to use in UPDATE statements like: \u0026quot;$1,$2,$3\u0026quot;.\n (c *PostgresPersistence) GenerateSetParameters(values interface{}) (setParams string, columns string)\n  values: interface{} - key-value map with columns and values returns: (setParams string, columns string) - generated list of column sets  GenerateValues Generates a list of column parameters.\n (c *PostgresPersistence) GenerateValues(columns string, values interface{}) []interface{}\n  values: interface{} - key-value map with columns and values returns: []interface{} - generated list of column values  GetCountByFilter Gets a number of data items retrieved by a given filter.\nThis method shall be called by a public GetCountByFilter method from a child class that receives FilterParams and converts them into a filter function.\n (c *PostgresPersistence) GetCountByFilter(correlationId string, filter interface{}) (count int64, err error)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. filter: interface{} - (optional) JSON object filter. returns: (count int64, err error) - number of filtered items.  GetListByFilter Gets a list of data items retrieved by a given filter and sorted according to sort parameters.\nThis method shall be called by a public getListByFilter method from a child class that receives FilterParams and converts them into a filter function.\n (c *PostgresPersistence) GetListByFilter(correlationId string, filter interface{}, sort interface{}, sel interface{}) (items []interface{}, err error)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. filter: interface{} - (optional) filter function to filter items sort: interface{} - (optional) sorting parameters sel: interface{} - (optional) projection parameters (not used yet) returns: (items []interface{}, err error) - data list of filtered results.  GetOneRandom Gets a random item from items that match to a given filter.\nThis method shall be called by a public getOneRandom method from a child class that receives FilterParams and converts them into a filter function.\n (c *PostgresPersistence) GetOneRandom(correlationId string, filter interface{}) (item interface{}, err error)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. filter: interface{} - (optional) a filter JSON object returns: (item interface{}, err error) - random item.  GetPageByFilter Gets a page of data items retrieved by a given filter and sorted according to sort parameters.\nThis method shall be called by a public GetPageByFilter method from a child class that receives FilterParams and converts them into a filter function.\n (c *PostgresPersistence) GetPageByFilter(correlationId string, filter interface{}, paging *cdata.PagingParams, sort interface{}, sel interface{}) (page *cdata.DataPage, err error)\n  correlationId: string - (optional) transaction id used to trace execution through a call chain. filter: interface{} - (optional) filter for JSON objects paging: *cdata.PagingParams - (optional) paging parameters sort: interface{} - (optional) sorting JSON object sel: interface{} - (optional) projection JSON object returns: (page *cdata.DataPage, err error) - data page with filtered result  IsOpen Checks if the component is opened.\n (c *PostgresPersistence) IsOpen() bool\n  returns: bool - True if the component has been opened and False otherwise.  Open Opens the component.\n (c *PostgresPersistence) Open(correlationId string) (err error)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. returns: (err error) - returns error if not received.  QuoteIdentifier Adds a single quote to each side of the string.\n (c *PostgresPersistence) QuoteIdentifier(value string) string\n  value: string - string where quotes need to be added returns: string - string with added quotes  SetReferences Sets references to dependent components.\n (c *PostgresPersistence) SetReferences(references cref.IReferences)\n  references: cref.IReferences - references to locate the component dependencies.  UnsetReferences Unsets (clears) previously set references to dependent components.\n (c *PostgresPersistence) UnsetReferences()\n Examples TODO: add example ","description":"Abstract persistence component that stores data in PostgreSQL using the official driver.\n","image":null,"permalink":"/golang/postgres/persistence/postgres_persistence/","subtitle":null,"tags":null,"title":"PostgresPersistence"},{"content":"Inherits: IReferenceable, IUnreferenceable, IConfigurable, IOpenable, ICleanable\nDescription The PostgresPersistence class allows you to create persistence components that store data in PostgreSQL using the official driver.\nImportant points\n This is the most basic persistence component that is only able to store data items of any type. Specific CRUD operations over the data items must be implemented in child classes by accessing this._db or this._collection properties.  Configuration parameters  collection: (optional) PostgreSQL collection name connection(s): discovery_key: (optional) key to retrieve the connection from IDiscovery host: host name or IP address port: port number (default: 27017) uri: resource URI or connection string with all parameters in it  credential(s):\n store_key: (optional) key to retrieve the credentials from ICredentialStore username: (optional) username password: (optional) user\u0026rsquo;s password  options:\n connect_timeout: (optional) number of milliseconds to wait before timing out when connecting a new client (default: 0) idle_timeout: (optional) number of milliseconds a client must sit idle in the pool and not be checked out (default: 10000) max_pool_size: (optional) maximum number of clients the pool can contain (default: 10)  References  *:logger:*:*:1.0 - (optional) ILogger components to pass log messages *:discovery:*:*:1.0 - (optional) IDiscovery services *:credential-store:*:*:1.0 - (optional) credential stores to resolve credentials  Constructors Creates a new instance of the persistence component.\n public PostgresPersistence(string tableName = null, string schemaName = null)\n  tableName: string - (optional) table name. schemaName: string - (optional) a schema name.  Fields _tableName The PostgreSQL table object.\n protected _tableName: string\n _dependencyResolver The dependency resolver.\n protected _dependencyResolver: DependencyResolver\n _logger The logger.\n protected _logger: CompositeLogger\n _connection The PostgreSQL connection component.\n protected _connection: PostgresConnection\n _client The PostgreSQL connection pool object.\n protected _client: NpgsqlConnection\n _databaseName The PostgreSQL database name.\n protected _databaseName: string\n _maxPageSize The maximum number of records to return from the database.\n protected _maxPageSize = 100\n _schemaName The PostgreSQL schema object.\n protected _schemaName: string\n  Instance methods ClearAsync Clears a component\u0026rsquo;s state.\n public virtual Task ClearAsync(string correlationId)\n  correlationId: string- object to convert from the public partial format.  ClearSchema Clears all auto-created objects.\n protected void ClearSchema()\n CloseAsync Closes the component and frees used resources.\n public virtual Task CloseAsync(string correlationId)\n  correlationId: string- object to convert from the public partial format.  Configure Configures the component.\n public virtual void Configure(ConfigParams config)\n  config: ConfigParams - configuration parameters to set.  ConvertFromPublic Converts an object value from public to internal format.\n protected virtual AnyValueMap ConvertFromPublic(T value)\n  value: T - object in public format to convert. returns: AnyValueMap - converted object in internal format.  ConvertToPublic Converts an object value from internal to public format.\n protected virtual T ConvertToPublic(AnyValueMap map)\n  value: AnyValueMap - object in internal format to convert. returns: T - converted object in public format.  CreateAsync Creates a data item.\n public virtual Task\u0026lt;T\u0026gt; CreateAsync(string correlationId, T item)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. item: T - item to be created. returns: Task\u0026lt;T\u0026gt; - created item  CreateSchemaAsync Checks if a table exists and if it doesn\u0026rsquo;t, it creates the necessary database objects.\n protected Task CreateSchemaAsync(string correlationId)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain.  DefineSchema Defines database schema via auto create objects or convenience methods.\n protected virtual void DefineSchema()\n deleteByFilter Deletes data items that match to a given filter. This method shall be called by a public DeleteByFilterAsync method from child class that receives FilterParams and converts them into a filter function.\n public virtual Task DeleteByFilterAsync(string correlationId, string filter)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. filter: string - (optional) a filter JSON object.  EnsureIndex Adds index definition to create it on opening.\n protected void EnsureIndex(string name, Dictionary\u0026lt;string, bool\u0026gt; keys, IndexOptions options)\n  name: string - the index name. keys: Dictionary\u0026lt;string, bool\u0026gt; - index keys (fields). options: IndexOptions - index options.  EnsureSchema Adds a statement to schema definition.\n protected void EnsureSchema(string schemaStatement)\n  schemaStatement: string - statement to be added to the schema  GenerateColumns Generates a list of column names to use in SQL statements like: \u0026ldquo;column1,column2,column3\u0026rdquo;.\n protected string GenerateColumns(AnyValueMap map)\n  map: AnyValueMap - array with column values or a key-value map returns: string - generated list of column names  GenerateParameters Generates a list of value parameters to use in SQL statements like: \u0026ldquo;@Param1,@Param2,@Param3\u0026rdquo;\n protected string GenerateParameters(AnyValueMap map)\n  map: AnyValueMap - array with values or a key-value map returns: string - generated list of value parameters  Generates a list of column sets to use in UPDATE statements like: column1=%s,column2=%s.\n protected string GenerateParameters\u0026lt;K\u0026gt;(IEnumerable\u0026lt;K\u0026gt; values)\n  values: IEnumerable\u0026lt;K\u0026gt; - key-value map with columns and values returns: string - generated list of column sets  GenerateValues Generates a list of column parameters.\n protected List\u0026lt;object\u0026gt; GenerateValues(AnyValueMap map)\n  values: AnyValueMap - key-value map with columns and values returns: List\u0026lt;object\u0026gt; - generated list of column values  GetCountByFilterAsync Gets a number of data items retrieved by a given filter.\nThis method shall be called by a public GetCountByFilterAsync method from a child class that receives FilterParams and converts them into a filter function.\n protected virtual Task\u0026lt;long\u0026gt; GetCountByFilterAsync(string correlationId, string filter)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. filter: string - (optional) JSON object filter. returns: Task\u0026lt;long\u0026gt; - number of filtered items.  GetListByFilterAsync Gets a list of data items retrieved by a given filter and sorted according to sort parameters.\nThis method shall be called by a public GetListByFilterAsync method from a child class that receives FilterParams and converts them into a filter function.\n protected Task\u0026lt;List\u0026lt;T\u0026gt;\u0026gt; GetListByFilterAsync(string correlationId, string filter, string sort = null, string select = null)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. filter: string - (optional) filter function to filter items sort: string - (optional) sorting parameters select: string - (optional) projection parameters (not used yet) returns: Task\u0026lt;List\u0026lt;T\u0026gt;\u0026gt; - data list of filtered results.  GetOneRandomAsync Gets a random item from items that match to a given filter.\nThis method shall be called by a public getOneRandom method from a child class that receives FilterParams and converts them into a filter function.\n protected virtual Task\u0026lt;T\u0026gt; GetOneRandomAsync(string correlationId, string filter)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. filter: string - (optional) filter for JSON objects returns: Task\u0026lt;T\u0026gt; - random item.  GetPageByFilterAsync Gets a page of data items retrieved by a given filter and sorted according to sort parameters.\nThis method shall be called by a public GetPageByFilterAsync method from a child class that receives FilterParams and converts them into a filter function.\n public virtual Task\u0026lt;DataPage\u0026gt; GetPageByFilterAsync(string correlationId, string filter, PagingParams paging = null, string sort = null, string select = null)\n  correlationId: string - (optional) transaction id used to trace execution through a call chain. filter: string - (optional) filter for JSON objects paging: PagingParams - (optional) paging parameters sort: string - (optional) sorting JSON object select: string - (optional) projection JSON object returns: Task\u0026lt;DataPage\u0026gt; - data page with filtered result  IsOpen Checks if the component is opened.\n public virtual bool IsOpen()\n  returns: bool - True if the component has been opened and False otherwise.  OpenAsync Opens the component.\n public virtual Task OpenAsync(string correlationId)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain.  QuoteIdentifier Adds a single quote to each side of the string.\n protected string QuoteIdentifier(string value)\n  value: string - string where quotes need to be added returns: string - string with added quotes  SetReferences Sets references to dependent components.\n public virtual void SetReferences(IReferences references)\n  references: IReferences - references to locate the component dependencies.  UnsetReferences Unsets (clears) previously set references to dependent components.\n public virtual void UnsetReferences()\n Examples class MyPostgresPersistence: PostgresPersistence\u0026lt;MyData\u0026gt; { public MyPostgresPersistence() { base(\u0026#34;mydata\u0026#34;); } public MyData getByName(string correlationId, string name) { var builder = Builders\u0026lt;BeaconV1\u0026gt;.Filter; var filter = builder.Eq(x =\u0026gt; x.Name, name); var result = await _collection.Find(filter).FirstOrDefaultAsync(); return result; } public MyData set(String correlatonId, MyData item) { var filter = Builders\u0026lt;T\u0026gt;.Filter.Eq(x =\u0026gt; x.Id, item.Id); var options = new FindOneAndReplaceOptions\u0026lt;T\u0026gt; { ReturnDocument = ReturnDocument.After, IsUpsert = true }; var result = await _collection.FindOneAndReplaceAsync(filter, item, options); return result; } } var persistence = new MyPostgresPersistence(); persistence.Configure(ConfigParams.FromTuples( \u0026#34;host\u0026#34;, \u0026#34;localhost\u0026#34;, \u0026#34;port\u0026#34;, 27017 ) ); persitence.Open(\u0026#34;123\u0026#34;); var mydata = new MyData(\u0026#34;ABC\u0026#34;); persistence.Set(\u0026#34;123\u0026#34;, mydata); persistence.GetByName(\u0026#34;123\u0026#34;, \u0026#34;ABC\u0026#34;); Console.Out.WriteLine(item); // Result: { name: \u0026#34;ABC\u0026#34; }  ","description":"Abstract persistence component that stores data in PostgreSQL using the official driver.\n","image":null,"permalink":"/net/postgres/persistence/postgres_persistence/","subtitle":null,"tags":null,"title":"PostgresPersistence"},{"content":"Implements: IReferenceable, IUnreferenceable, IConfigurable, IOpenable, ICleanable\nDescription The PostgresPersistence class allows you to create persistence components that store data in PostgreSQL using the official driver.\nImportant points\n This is the most basic persistence component that is only able to store data items of any type. Specific CRUD operations over the data items must be implemented in child classes by accessing this._db or this._collection properties.  Configuration parameters  collection: (optional) PostgreSQL collection name connection(s): discovery_key: (optional) key to retrieve the connection from IDiscovery host: host name or IP address port: port number (default: 27017) uri: resource URI or connection string with all parameters in it  credential(s):\n store_key: (optional) key to retrieve the credentials from ICredentialStore username: (optional) username password: (optional) user\u0026rsquo;s password  options:\n connect_timeout: (optional) number of milliseconds to wait before timing out when connecting a new client (default: 0) idle_timeout: (optional) number of milliseconds a client must sit idle in the pool and not be checked out (default: 10000) max_pool_size: (optional) maximum number of clients the pool can contain (default: 10)  References  *:logger:*:*:1.0 - (optional) ILogger components to pass log messages *:discovery:*:*:1.0 - (optional) IDiscovery services *:credential-store:*:*:1.0 - (optional) credential stores to resolve credentials  Constructors Creates a new instance of the persistence component.\n public constructor(tableName?: string)\n  tableName: string - (optional) table name.  Fields _tableName The PostgreSQL table object.\n protected _tableName: string\n _dependencyResolver The dependency resolver.\n protected _dependencyResolver: DependencyResolver\n _logger The logger.\n protected _logger: CompositeLogger\n _connection The PostgreSQL connection component.\n protected _connection: PostgresConnection\n _client The PostgreSQL connection pool object.\n protected _client: any\n _databaseName The PostgreSQL database name.\n protected _databaseName: string\n _maxPageSize The maximum number of records to return from the database.\n protected _maxPageSize = 100\n  Instance methods clear Clears a component\u0026rsquo;s state.\n public clear(correlationId: string): Promise\u0026lt;void\u0026gt;\n  correlationId: string- object to convert from the public partial format.  clearSchema Clears all auto-created objects.\n protected clearSchema(): void\n close Closes the component and frees used resources.\n public close(correlationId: string): Promise\u0026lt;void\u0026gt;\n  correlationId: string- object to convert from the public partial format.  configure Configures the component.\n public configure(config: ConfigParams): void\n  config: ConfigParams - configuration parameters to set.  convertFromPublic Converts an object value from public to internal format.\n protected convertFromPublic(value: any): any\n  value: any - object in public format to convert. returns: any - converted object in internal format.  convertToPublic Converts an object value from internal to public format.\n protected convertToPublic(value: any): any\n  value: any - object in internal format to convert. returns: any - converted object in public format.  create Creates a data item.\n public create(correlationId: string, item: T): Promise\u0026lt;T\u0026gt;\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. item: T - item to be created. returns: Promise\u0026lt;T\u0026gt; - created item  createSchema Checks if a table exists and if it doesn\u0026rsquo;t, it creates the necessary database objects.\n protected createSchema(correlationId: string): Promise\u0026lt;void\u0026gt;\n  correlationId: string - (optional) transaction id used to trace execution through the call chain.  defineSchema Defines database schema via auto create objects or convenience methods.\n protected defineSchema(): void\n deleteByFilter Deletes data items that match to a given filter. This method shall be called by a public deleteByFilter method from child class that receives FilterParams and converts them into a filter function.\n deleteByFilter(correlationId: string, filter: any): Promise\u0026lt;void\u0026gt;\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. filter: any - (optional) filter function used to filter items.  ensureIndex Adds index definition to create it on opening.\n protected ensureIndex(name: string, keys: any, options?: any): void\n  keys: any - index keys (fields) options: any - index options  ensureSchema Adds a statement to schema definition.\n protected ensureSchema(schemaStatement: string): void\n  schemaStatement: string - statement to be added to the schema  generateColumns Generates a list of column names to use in SQL statements like: \u0026ldquo;column1,column2,column3\u0026rdquo;.\n protected generateColumns(values: any): string\n  values: any - array with column values or a key-value map returns: string - generated list of column names  generateParameters Generates a list of value parameters to use in SQL statements like: \u0026quot;@1,@2,@3\u0026quot;.\n protected generateParameters(values: any): string\n  values: any - array with values or a key-value map returns: string - generated list of value parameters  generateSetParameters Generates a list of column sets to use in UPDATE statements like: \u0026quot;@1,@2,@3\u0026quot;.\n protected generateSetParameters(values: any): string\n  values: any - key-value map with columns and values returns: string - generated list of column sets  generateValues Generates a list of column parameters.\n protected generateValues(values: any): any[]\n  values: any - key-value map with columns and values returns: any[] - generated list of column values  getCountByFilter Gets a number of data items retrieved by a given filter.\nThis method shall be called by a public getCountByFilter method from a child class that receives FilterParams and converts them into a filter function.\n protected getCountByFilter(correlationId: string, filter: any): Promise\u0026lt;number\u0026gt;\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. filter: any - (optional) JSON object filter. returns: Promise\u0026lt;number\u0026gt; - number of filtered items.  getListByFilter Gets a list of data items retrieved by a given filter and sorted according to sort parameters.\nThis method shall be called by a public getListByFilter method from a child class that receives FilterParams and converts them into a filter function.\n protected getListByFilter(correlationId: string, filter: any, sort: any, select: any): Promise\u0026lt;T[]\u0026gt;\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. filter: any - (optional) filter function to filter items sort: any - (optional) sorting parameters select: any - (optional) projection parameters (not used yet) returns: Promise\u0026lt;T[]\u0026gt; - data list of filtered results.  getOneRandom Gets a random item from items that match to a given filter.\nThis method shall be called by a public getOneRandom method from a child class that receives FilterParams and converts them into a filter function.\n protected getOneRandom(correlationId: string, filter: any): Promise\u0026lt;T\u0026gt;\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. filter: any - (optional) filter for JSON objects returns: Promise\u0026lt;T\u0026gt; - random item.  getPageByFilter Gets a page of data items retrieved by a given filter and sorted according to sort parameters.\nThis method shall be called by a public getPageByFilter method from a child class that receives FilterParams and converts them into a filter function.\n protected getPageByFilter(correlationId: string, filter: any, paging: PagingParams, sort: any, select: any): Promise\u0026lt;DataPage\u0026gt;\n  correlationId: string - (optional) transaction id used to trace execution through a call chain. filter: any - (optional) filter for JSON objects paging: PagingParams - (optional) paging parameters sort: any - (optional) sorting JSON object select: any - (optional) projection JSON object returns: Promise\u0026lt;DataPage\u0026gt; - data page with filtered result  isOpen Checks if the component is opened.\n public isOpen(): boolean\n  returns: boolean - True if the component has been opened and False otherwise.  open Opens the component.\n public open(correlationId: string): Promise\u0026lt;void\u0026gt;\n  correlationId: string - (optional) transaction id used to trace execution through the call chain.  quoteIdentifier Adds a single quote to each side of the string.\n protected quoteIdentifier(value: string): string\n  value: string - string where quotes need to be added returns: string - string with added quotes  setReferences Sets references to dependent components.\n public setReferences(references: IReferences): void\n  references: IReferences - references to locate the component dependencies.  unsetReferences Unsets (clears) previously set references to dependent components.\n public unsetReferences(): void\n Examples class MyPostgresPersistence extends PostgresPersistence\u0026lt;MyData\u0026gt; { public constructor() { base(\u0026#34;mydata\u0026#34;); } public getByName(correlationId: string, name: string): Promise\u0026lt;MyData\u0026gt; { let criteria = { name: name }; return new Promise((resolve, reject) =\u0026gt; { this._model.findOne(criteria, (err, item) =\u0026gt; { if (err != null) { reject(err); return; } item = this.convertToPublic(item); resolve(item); }); }); }); public set(correlatonId: string, item: MyData): Promise\u0026lt;MyData\u0026gt; { let criteria = { name: item.name }; let options = { upsert: true, new: true }; return new Promise((resolve, reject) =\u0026gt; { this.findOneAndUpdate(criteria, item, options, (err, item) =\u0026gt; { if (err != null) { reject(err); return; } item = this.convertToPublic(item); resolve(item); }); }); } } let persistence = new MyPostgresPersistence(); persistence.configure(ConfigParams.fromTuples( \u0026#34;host\u0026#34;, \u0026#34;localhost\u0026#34;, \u0026#34;port\u0026#34;, 27017 )); await persitence.open(\u0026#34;123\u0026#34;); let item = await persistence.set(\u0026#34;123\u0026#34;, { name: \u0026#34;ABC\u0026#34; }); item = await persistence.getByName(\u0026#34;123\u0026#34;, \u0026#34;ABC\u0026#34;); console.log(item); // Result: { name: \u0026#34;ABC\u0026#34; }  ","description":"Abstract persistence component that stores data in PostgreSQL using the official driver.\n","image":null,"permalink":"/node/postgres/persistence/postgres_persistence/","subtitle":null,"tags":null,"title":"PostgresPersistence"},{"content":"Implements: IReferenceable, IUnreferenceable, IConfigurable, IOpenable, ICleanable\nDescription The PostgresPersistence class allows you to create persistence components that store data in PostgreSQL using the official driver.\nImportant points\n This is the most basic persistence component that is only able to store data items of any type. Specific CRUD operations over the data items must be implemented in child classes by accessing self._db or self._collection properties.  Configuration parameters  collection: (optional) PostgreSQL collection name connection(s): discovery_key: (optional) key to retrieve the connection from IDiscovery host: host name or IP address port: port number (default: 27017) uri: resource URI or connection string with all parameters in it  credential(s):\n store_key: (optional) key to retrieve the credentials from ICredentialStore username: (optional) username password: (optional) user\u0026rsquo;s password  options:\n connect_timeout: (optional) number of milliseconds to wait before timing out when connecting a new client (default: 0) idle_timeout: (optional) number of milliseconds a client must sit idle in the pool and not be checked out (default: 10000) max_pool_size: (optional) maximum number of clients the pool can contain (default: 10)  References  *:logger:*:*:1.0 - (optional) ILogger components to pass log messages *:discovery:*:*:1.0 - (optional) IDiscovery services *:credential-store:*:*:1.0 - (optional) credential stores to resolve credentials  Constructors Creates a new instance of the persistence component.\n PostgresPersistence(table_name: str = None)\n  table_name: str - (optional) table name.  Fields _table_name The PostgreSQL table object.\n _table_name: str\n _dependency_resolver The dependency resolver.\n _dependency_resolver: DependencyResolver\n _logger The logger.\n _logger: CompositeLogger\n _connection The PostgreSQL connection component.\n _connection: PostgresConnection\n _client The PostgreSQL connection pool object.\n _client: Any\n _database_name The PostgreSQL database name.\n _database_name: str\n _max_page_size The maximum number of records to return from the database.\n _max_page_size = 100\n  Instance methods clear Clears a component\u0026rsquo;s state.\n clear(correlation_id: Optional[str])\n  correlation_id: Optional[str]- object to convert from the public partial format.  _clear_schema Clears all auto-created objects.\n _clear_schema()\n close Closes the component and frees used resources.\n close(correlation_id: Optional[str])\n  correlation_id: Optional[str]- object to convert from the public partial format.  configure Configures the component.\n configure(config: ConfigParams)\n  correlation_id: Optional[str]- the object to convert from the public partial format.  _convert_from_public Converts an object value from public to internal format.\n _convert_from_public(value: Any): Any\n  value: Any - object in public format to convert. returns: Any - converted object in internal format.  _convert_to_public Converts an object value from internal to public format.\n _convert_to_public(value: Any): Any\n  value: Any - object in internal format to convert. returns: Any - converted object in public format.  create Creates a data item.\n create(correlation_id: Optional[str], item: T): Optional[T]\n  correlation_id: Optional[str] - (optional) transaction id used to trace execution through the call chain. item: T - item to be created. returns: Optional[T] - created item  _create_schema Checks if a table exists and if it doesn\u0026rsquo;t, it creates the necessary database objects.\n _create_schema(correlation_id: Optional[str])\n  correlation_id: Optional[str] - (optional) transaction id used to trace execution through the call chain.  _define_schema Defines database schema via auto create objects or convenience methods.\n _define_schema()\n delete_by_filter Deletes data items that match to a given filter. This method shall be called by a public delete_by_filter method from child class that receives FilterParams and converts them into a filter function.\n delete_by_filter(correlation_id: Optional[str], filter: Any)\n  correlation_id: Optional[str] - (optional) transaction id used to trace execution through the call chain. filter: Any - (optional) filter function used to filter items.  _ensure_index Adds index definition to create it on opening.\n _ensure_index(keys: Any, options: Any = None)\n  keys: Any - index keys (fields) options: Any - index options  _ensure_schema Adds a statement to schema definition.\n _ensure_schema(schema_statement: str)\n  schema_statement: str - statement to be added to the schema  _generate_columns Generates a list of column names to use in SQL statements like: \u0026ldquo;column1,column2,column3\u0026rdquo;.\n _generate_columns(values: Any): str\n  values: Any - array with column values or a key-value map returns: str - generated list of column names  _generate_parameters Generates a list of value parameters to use in SQL statements like: \u0026ldquo;%s,%s,%s\u0026rdquo;.\n _generate_parameters(values: Any): str\n  values: Any - array with values or a key-value map returns: str - generated list of value parameters  _generate_set_parameters Generates a list of column sets to use in UPDATE statements like: column1=%s,column2=%s.\n _generate_set_parameters(values: Any): str\n  values: Any - key-value map with columns and values returns: str - generated list of column sets  _generate_values Generates a list of column parameters.\n _generate_values(values: Any): List[Any]\n  values: Any - key-value map with columns and values returns: List[Any] - generated list of column values  get_count_by_filter Gets a number of data items retrieved by a given filter.\nThis method shall be called by a public get_count_by_filter method from a child class that receives FilterParams and converts them into a filter function.\n get_count_by_filter(correlation_id: Optional[str], filter: Any): int\n  correlation_id: Optional[str] - (optional) transaction id used to trace execution through the call chain. filter: Any - (optional) JSON object filter. returns: int - number of filtered items.  get_list_by_filter Gets a list of data items retrieved by a given filter and sorted according to sort parameters.\nThis method shall be called by a public get_list_by_filter method from a child class that receives FilterParams and converts them into a filter function.\n get_list_by_filter(correlation_id: Optional[str], filter: Any, sort: Any = None, select: Any = None): List[T]\n  correlation_id: Optional[str] - (optional) transaction id used to trace execution through the call chain. filter: Any - (optional) filter function to filter items sort: Any - (optional) sorting parameters select: Any - (optional) projection parameters (not used yet) returns: List[T] - data list of filtered results.  get_one_random Gets a random item from items that match to a given filter.\nThis method shall be called by a public get_one_random method from a child class that receives FilterParams and converts them into a filter function.\n get_one_random(correlation_id: Optional[str], filter: Any): T\n  correlation_id: Optional[str] - (optional) transaction id used to trace execution through the call chain. filter: Any - (optional) a filter function to filter items. returns: T - random item.  get_page_by_filter Gets a page of data items retrieved by a given filter and sorted according to sort parameters.\nThis method shall be called by a public get_page_by_filter method from a child class that receives FilterParams and converts them into a filter function.\n get_page_by_filter(correlation_id: Optional[str], filter: Any, paging: PagingParams, sort: Any = None, select: Any = None): DataPage\n  correlation_id: Optional[str] - (optional) transaction id used to trace execution through a call chain. filter: Any - (optional) filter for JSON objects paging: PagingParams - (optional) paging parameters sort: Any - (optional) sorting JSON object select: Any - (optional) projection JSON object returns: DataPage - data page with filtered result  is_open Checks if the component is opened.\n is_open(): bool\n  returns: bool - True if the component has been opened and False otherwise.  open Opens the component.\n open(correlation_id: Optional[str])\n  correlation_id: Optional[str] - (optional) transaction id used to trace execution through the call chain.  _quote_identifier Adds a single quote to each side of the string.\n _quote_identifier(value: str): Optional[str]\n  value: str - string where quotes need to be added returns: Optional[str] - string with added quotes  set_references Sets references to dependent components.\n set_references(references: IReferences)\n  references: IReferences - references to locate the component dependencies.  unset_references Unsets (clears) previously set references to dependent components.\n unset_references()\n Examples class MyPostgresPersistence(PostgresPersistence): def __init__(self): super(MyPostgresPersistence, self).__init__(\u0026#39;mydata\u0026#39;) def get_by_name(self, correlation_id, name): criteria = {\u0026#39;name\u0026#39;: name} return self._model.find_one(criteria) def set(self, correlation_id, item): criteria = {\u0026#39;name\u0026#39;: item[\u0026#39;name\u0026#39;]} options = { \u0026#39;upsert\u0026#39;: True, \u0026#39;new\u0026#39;: True } return self._model.find_one_and_update(criteria, item, options) persistence = MyPostgresPersistence() persistence.configure(ConfigParams.from_tuples( \u0026#34;host\u0026#34;, \u0026#34;localhost\u0026#34;, \u0026#34;port\u0026#34;, 27017 )) persistence.open(\u0026#34;123\u0026#34;) persistence.set(\u0026#34;123\u0026#34;, {\u0026#39;name\u0026#39;: \u0026#34;ABC\u0026#34;}) item = persistence.get_by_name(\u0026#34;123\u0026#34;, \u0026#34;ABC\u0026#34;) print(item) # Result: { \u0026#39;name\u0026#39;: \u0026#34;ABC\u0026#34; } # ... ","description":"Abstract persistence component that stores data in PostgreSQL using the official driver.\n","image":null,"permalink":"/python/postgres/persistence/postgres_persistence/","subtitle":null,"tags":null,"title":"PostgresPersistence"},{"content":"Implements: Container\nDescription The ProcessContainer class allows you to create an inversion of control (IoC) container that runs as a system process.\nImportant points\n It processes command line arguments and handles unhandled exceptions and Ctrl-C signal to shutdown the container properly.  Command line arguments  \u0026ndash;config / -c path to a JSON or YAML file with the container\u0026rsquo;s configuration (default: \u0026ldquo;./config/config.yml\u0026rdquo;) \u0026ndash;param / \u0026ndash;params / -p configuration parameters \u0026ndash;help / -h prints the container usage help  Constructors NewProcessContainer Creates a new instance of the container.\n NewProcessContainer(name string, description string) *ProcessContainer\n  name: string - (optional) container\u0026rsquo;s name (accessible via ContextInfo) description: string - (optional) container\u0026rsquo;s description (accessible via ContextInfo)  NewEmptyProcessContainer Creates a new instance of the container.\n NewEmptyProcessContainer() *ProcessContainer\n  name: string - (optional) container\u0026rsquo;s name (accessible via ContextInfo) description: string - (optional) container\u0026rsquo;s description (accessible via ContextInfo)  Fields configPath Path to the configuration file.\n configPath: string = \u0026ldquo;./config/config.yml\u0026rdquo;\n  Methods Run Runs the container by instantiating and running components inside the container.\nIt reads the container configuration, and creates, configures, references and opens components. On process exit; it closes, unreferences and destroys components in order to shutdown properly.\n (c *ProcessContainer) Run(args []string)\n  args: string[] - command line arguments  Examples container = NewEmptyProcessContainer(); container.Container.AddFactory(NewMyComponentFactory()); container.Run(process.args); See also   Container   ","description":"Inversion of control (IoC) container that runs as a system process.\n","image":null,"permalink":"/golang/container/containers/process_container/","subtitle":null,"tags":null,"title":"ProcessContainer"},{"content":"Inherits: Container\nDescription The ProcessContainer class allows you to create an inversion of control (IoC) container that runs as a system process.\nImportant points\n It processes command line arguments and handles unhandled exceptions and Ctrl-C signal to shutdown the container properly.  Command line arguments  \u0026ndash;config / -c path to a JSON or YAML file with the container\u0026rsquo;s configuration (default: \u0026ldquo;./config/config.yml\u0026rdquo;) \u0026ndash;param / \u0026ndash;params / -p configuration parameters \u0026ndash;help / -h prints the container usage help  Constructors Creates a new instance of the container.\n public ProcessContainer(string name = null, string description = null)\n  name: string - (optional) container\u0026rsquo;s name (accessible via ContextInfo) description: string - (optional) container\u0026rsquo;s description (accessible via ContextInfo)  Fields _configPath Path to the configuration file.\n protected _configPath: string = \u0026ldquo;./config/config.yml\u0026rdquo;\n  Instance methods Run Runs the container by instantiating and running components inside the container.\nIt reads the container configuration, and creates, configures, references and opens components. On process exit; it closes, unreferences and destroys components in order to shutdown properly.\n public Task RunAsync(string[] args)\n  args: string[] - command line arguments  Examples var container = new ProcessContainer(); container.AddFactory(new MyComponentFactory()); container.RunAsync(process.getArgs()); See also   Container   ","description":"Inversion of control (IoC) container that runs as a system process.\n","image":null,"permalink":"/net/container/containers/process_container/","subtitle":null,"tags":null,"title":"ProcessContainer"},{"content":"Extends: Container\nDescription The ProcessContainer class allows you to create an inversion of control (IoC) container that runs as a system process.\nImportant points\n It processes command line arguments and handles unhandled exceptions and Ctrl-C signal to shutdown the container properly.  Command line arguments  \u0026ndash;config / -c path to a JSON or YAML file with the container\u0026rsquo;s configuration (default: \u0026ldquo;./config/config.yml\u0026rdquo;) \u0026ndash;param / \u0026ndash;params / -p configuration parameters \u0026ndash;help / -h prints the container usage help  Constructors Creates a new instance of the container.\n public constructor(name?: string, description?: string)\n  name: string - (optional) container\u0026rsquo;s name (accessible via ContextInfo) description: string - (optional) container\u0026rsquo;s description (accessible via ContextInfo)  Fields _configPath Path to the configuration file.\n protected _configPath: string = \u0026ldquo;./config/config.yml\u0026rdquo;\n  Instance methods run Runs the container by instantiating and running components inside the container.\nIt reads the container configuration, and creates, configures, references and opens components. On process exit; it closes, unreferences and destroys components in order to shutdown properly.\n public run(args: string[]): void\n  args: string[] - command line arguments  Examples let container = new ProcessContainer(); container.addFactory(new MyComponentFactory()); container.run(process.args); See also   Container   ","description":"Inversion of control (IoC) container that runs as a system process.\n","image":null,"permalink":"/node/container/containers/process_container/","subtitle":null,"tags":null,"title":"ProcessContainer"},{"content":"Implements: Container\nDescription The ProcessContainer class allows you to create an inversion of control (IoC) container that runs as a system process.\nImportant points\n It processes command line arguments and handles unhandled exceptions and Ctrl-C signal to shutdown the container properly.  Command line arguments  \u0026ndash;config / -c path to a JSON or YAML file with the container\u0026rsquo;s configuration (default: \u0026ldquo;./config/config.yml\u0026rdquo;) \u0026ndash;param / \u0026ndash;params / -p configuration parameters \u0026ndash;help / -h prints the container usage help  Constructors Creates a new instance of the container.\n ProcessContainer(name: str = None, description: str = None)\n  name: str - (optional) container\u0026rsquo;s name (accessible via ContextInfo) description: str - (optional) container\u0026rsquo;s description (accessible via ContextInfo)  Fields _config_path Path to the configuration file.\n _config_path: str = \u0026ldquo;./config/config.yml\u0026rdquo;\n _logger Logger.\n _logger: ILogger\n  Instance methods run Runs the container by instantiating and running components inside the container.\nIt reads the container configuration, and creates, configures, references and opens components. On process exit; it closes, unreferences and destroys components in order to shutdown properly.\n run()\n Examples container = ProcessContainer() container.add_factory(MyComponentFactory()) container.run() See also   Container   ","description":"Inversion of control (IoC) container that runs as a system process.\n","image":null,"permalink":"/python/container/containers/process_container/","subtitle":null,"tags":null,"title":"ProcessContainer"},{"content":"Description The ProjectionParams class allows you to define projection parameters with a list of fields to be included in your query results.\nImportant points\n The parameters support two formats: dot and nested. The dot format is the standard way to define the included fields and subfields by using dot object notation. E.g. \u0026ldquo;field1,field2.field21,field2.field22.field221\u0026rdquo;. As an alternative, the nested format offers a more compact representation. E.g. \u0026ldquo;field1,field2(field21,field22(field221))\u0026quot;.  Constructors NewEmptyProjectionParams Creates a new instance of the projection parameters and assigns its value.\n NewEmptyProjectionParams() *ProjectionParams\n NewProjectionParamsFromStrings Creates a new instance of the projection parameters and assigns its value.\n NewProjectionParamsFromStrings(values []string) *ProjectionParams\n  values: []string - (optional) values to initialize this object.  NewProjectionParamsFromAnyArray Creates a new instance of the projection parameters and assigns its value.\n NewProjectionParamsFromAnyArray(values *AnyValueArray) *ProjectionParams\n  values: []string - (optional) values to initialize this object.  Methods String Gets a string representation of the object. The result is a comma-separated list of projection fields \u0026ldquo;field1,field2.field21,field2.field22.field221\u0026rdquo;\n (c *ProjectionParams) String() string\n  returns: string - string representation of the object.  NewProjectionParamsFromStrings Parses a comma-separated list of projection fields.\n NewProjectionParamsFromStrings(values []string) *ProjectionParams\n  values: []string - one or more comma-separated lists of projection fields returns: *ProjectionParams - newly created ProjectionParams.  NewProjectionParamsFromValue Converts specified value into ProjectionParams.\nSee AnyValueArray.NewAnyValueArrayFromValue\n NewProjectionParamsFromValue(value interface{}) *ProjectionParams\n  value: interface{} - value to be converted returns: *ProjectionParams - newly created ProjectionParams.  Examples filter := NewFilterParamsFromTuples(\u0026#34;type\u0026#34;, \u0026#34;Type1\u0026#34;); paging := NewPagingParams(0, 100); projection = NewProjectionParamsFromString(\u0026#34;field1,field2(field21,field22)\u0026#34;) err, page := myDataClient.getDataByFilter(filter, paging, projection); ","description":"Defines projection parameters with a list of fields to be included in the query results.\n","image":null,"permalink":"/golang/commons/data/projection_params/","subtitle":null,"tags":null,"title":"ProjectionParams"},{"content":"Inherits: List\u0026lt;string\u0026gt;\nDescription The ProjectionParams class allows you to define projection parameters with a list of fields to be included in your query results.\nImportant points\n The parameters support two formats: dot and nested. The dot format is the standard way to define the included fields and subfields by using dot object notation. E.g. \u0026ldquo;field1,field2.field21,field2.field22.field221\u0026rdquo;. As an alternative, the nested format offers a more compact representation. E.g. \u0026ldquo;field1,field2(field21,field22(field221))\u0026quot;.  Constructors Creates a new instance of the projection parameters and assigns its value.\n public ProjectionParams(string[] values)\n  values: string[] - (optional) values to initialize this object.  Creates a new instance of the projection parameters and assigns its value.\n public ProjectionParams(AnyValueArray values)\n  values: AnyValueArray - (optional) values used to initialize this object.  Creates a new instance of the projection parameters.\n public ProjectionParams()\n Instance methods ToString Gets a string representation of the object. The result is a comma-separated list of projection fields \u0026ldquo;field1,field2.field21,field2.field22.field221\u0026rdquo;\n public override string ToString()\n  returns: string - string representation of the object.  Static methods FromValue Converts a specified value to ProjectionParams.\nSee AnyValueArray.FromValue\n public static ProjectionParams FromValue(object value)\n  value: object - value to be converted returns: ProjectionParams - newly created ProjectionParams.  FromValues Parses a comma-separated list of projection fields.\n public static ProjectionParams FromValues(params string[] value)\n  value: string[] - one or more comma-separated lists of projection fields returns: ProjectionParams - newly created ProjectionParams.  FromValues Parses a comma-separated list of projection fields.\n public static ProjectionParams FromValues(char delimiter, params string[] value)\n  delimiter: char - certain type of delimiter value: string[] - one or more comma-separated lists of projection fields returns: ProjectionParams - newly created ProjectionParams.  Examples var filter = FilterParams.FromTuples(\u0026#34;type\u0026#34;, \u0026#34;Type1\u0026#34;); var paging = new PagingParams(0, 100); var projection = ProjectionParams.FromString(\u0026#34;field1,field2(field21,field22)\u0026#34;); myDataClient.GetDataByFilter(filter, paging, projection); ","description":"Defines projection parameters with a list of fields to be included in the query results.\n","image":null,"permalink":"/net/commons/data/projection_params/","subtitle":null,"tags":null,"title":"ProjectionParams"},{"content":"Extends: Array\u0026lt;string\u0026gt;\nDescription The ProjectionParams class allows you to define projection parameters with a list of fields to be included in your query results.\nImportant points\n The parameters support two formats: dot and nested. The dot format is the standard way to define the included fields and subfields by using dot object notation. E.g. \u0026ldquo;field1,field2.field21,field2.field22.field221\u0026rdquo;. As an alternative, the nested format offers a more compact representation. E.g. \u0026ldquo;field1,field2(field21,field22(field221))\u0026quot;.  Constructors Creates a new instance of ProjectionParams and assigns its value.\n public constructor(values: any[] = null)\n  values: any[] - (optional) values used to initialize this object.  Instance methods toString Gets a string representation of the object. The result is a comma-separated list of projection fields \u0026ldquo;field1,field2.field21,field2.field22.field221\u0026rdquo;\n public toString(): string\n  returns: string - string representation of the object.  Static methods fromString Parses a comma-separated list of projection fields.\n public static fromString(\u0026hellip;values: string[])\n  values: string[] - one or more comma-separated lists of projection fields returns: ProjectionParams - newly created ProjectionParams object.  fromValue Converts a specified value into a ProjectionParams object.\nSee AnyValueArray.fromValue\n public static fromValue(value: any): ProjectionParams\n  value: any - value to be converted returns: ProjectionParams - newly created ProjectionParams object.  Examples let filter = FilterParams.fromTuples(\u0026#34;type\u0026#34;, \u0026#34;Type1\u0026#34;); let paging = new PagingParams(0, 100); let projection = ProjectionParams.fromString(\u0026#34;field1,field2(field21,field22)\u0026#34;) myDataClient.getDataByFilter(filter, paging, projection, (err, page) =\u0026gt; {...}); ","description":"Defines projection parameters with a list of fields to be included in the query results.\n","image":null,"permalink":"/node/commons/data/projection_params/","subtitle":null,"tags":null,"title":"ProjectionParams"},{"content":"Implements: list\nDescription The ProjectionParams class allows you to define projection parameters with a list of fields to be included in your query results.\nImportant points\n The parameters support two formats: dot and nested. The dot format is the standard way to define the included fields and subfields by using dot object notation. E.g. \u0026ldquo;field1,field2.field21,field2.field22.field221\u0026rdquo;. As an alternative, the nested format offers a more compact representation. E.g. \u0026ldquo;field1,field2(field21,field22(field221))\u0026quot;.  Constructors Creates a new instance of the projection parameters and assigns its value.\n ProjectionParams(values: Sequence[Any] = None)\n  values: Sequence[Any] - (optional) values to initialize this object.  Instance methods to_string Gets a string representation of the object. The result is a comma-separated list of projection fields \u0026ldquo;field1,field2.field21,field2.field22.field221\u0026rdquo;\n to_string(): str\n  returns: str - a string representation of the object.  Static methods from_string Parses comma-separated list of projection fields.\n static from_string(*values: str): ProjectionParams\n  values: str - one or more comma-separated lists of projection fields. returns: ProjectionParams - a newly created ProjectionParams.  from_value Converts specified value into ProjectionParams.\nSee AnyValueArray.from_value\n static from_value(value: Any): ProjectionParams: ProjectionParams\n  value: Any - value to be converted. returns: ProjectionParams - a newly created ProjectionParams.  Examples filter = FilterParams.fromTuples(\u0026#34;type\u0026#34;, \u0026#34;Type1\u0026#34;) paging = PagingParams(0, 100) projection = ProjectionParams.from_value([\u0026#34;field1\u0026#34;,\u0026#34;field2(field21,field22)\u0026#34;]) or projection = ProjectionParams.from_string(\u0026#34;field1,field2(field21,field22)\u0026#34;) myDataClient.get_data_by_filter(filter, paging, projection) ","description":"Defines projection parameters with a list of fields to be included in the query results.\n","image":null,"permalink":"/python/commons/data/projection_params/","subtitle":null,"tags":null,"title":"ProjectionParams"},{"content":"Description The ProjectionParamsSchema class allows you to create a schema to validate ProjectionParams.\nConstructors NewProjectionParamsSchema  NewProjectionParamsSchema() *ArraySchema\n See also   ProjectionParams.   ","description":"Schema to validate [ProjectionParams](../../data/projection_params).\n","image":null,"permalink":"/golang/commons/validate/projection_params_schema/","subtitle":null,"tags":null,"title":"ProjectionParamsSchema"},{"content":"Inherits: ArraySchema\nDescription The ProjectionParamsSchema class allows you to create a schema to validate ProjectionParams.\nConstructors  public ProjectionParamsSchema()\n See also   ProjectionParams.   ","description":"Schema to validate [ProjectionParams](../../data/projection_params).\n","image":null,"permalink":"/net/commons/validate/projection_params_schema/","subtitle":null,"tags":null,"title":"ProjectionParamsSchema"},{"content":"Implements: ArraySchema\nDescription The ProjectionParamsSchema class allows you to create a schema to validate ProjectionParams.\nConstructors  public constructor()\n See also   ProjectionParams.   ","description":"Schema to validate [ProjectionParams](../../data/projection_params).\n","image":null,"permalink":"/node/commons/validate/projection_params_schema/","subtitle":null,"tags":null,"title":"ProjectionParamsSchema"},{"content":"Implements: ArraySchema\nDescription The ProjectionParamsSchema class allows you to create a schema to validate ProjectionParams.\nConstructors  ProjectionParamsSchema()\n See also   ProjectionParams.   ","description":"Schema to validate [ProjectionParams](../../data/projection_params).\n","image":null,"permalink":"/python/commons/validate/projection_params_schema/","subtitle":null,"tags":null,"title":"ProjectionParamsSchema"},{"content":"Description The PrometheusCounterConverter class allows you to convert performance counter values into a response from Prometheus metrics service.\nMethods ToString Converts the given counters to a string that is returned by Prometheus metrics service.\n (c *TPrometheusCounterConverter) ToString(counters []*ccount.Counter, source string, instance string) string\n  counters: []*ccount.Counter - list of counters to convert. source: string - source (context) name. instance: string - unique instance name (usually a host name). returns: string - converted counter  ","description":"Helper class that converts performance counter values into a response from Prometheus metrics service.\n","image":null,"permalink":"/golang/prometheus/count/prometheus_counter_converter/","subtitle":null,"tags":null,"title":"PrometheusCounterConverter"},{"content":"Description The PrometheusCounterConverter class allows you to convert performance counter values into a response from Prometheus metrics service.\nStatic methods ToString Converts the given counters to a string that is returned by Prometheus metrics service.\n public static string ToString(IEnumerable\u0026lt;Counter\u0026gt; counters, string source, string instance)\n  counters: IEnumerable\u0026lt;Counter\u0026gt; - list of counters to convert. source: string - source (context) name. instance: string - unique instance name (usually a host name). returns: string - converted counter  ","description":"Helper class that converts performance counter values into a response from Prometheus metrics service.\n","image":null,"permalink":"/net/prometheus/count/prometheus_counter_converter/","subtitle":null,"tags":null,"title":"PrometheusCounterConverter"},{"content":"Description The PrometheusCounterConverter class allows you to convert performance counter values into a response from Prometheus metrics service.\nStatic methods toString Converts the given counters to a string that is returned by Prometheus metrics service.\n public static toString(counters: Counter[], source: string, instance: string): string\n  counters: Counter[] - list of counters to convert. source: string - source (context) name. instance: string - unique instance name (usually a host name). returns: string - converted counter  ","description":"Helper class that converts performance counter values into a response from Prometheus metrics service.\n","image":null,"permalink":"/node/prometheus/count/prometheus_counter_converter/","subtitle":null,"tags":null,"title":"PrometheusCounterConverter"},{"content":"Description The PrometheusCounterConverter class allows you to convert performance counter values into a response from Prometheus metrics service.\nStatic methods to_string Converts the given counters to a string that is returned by Prometheus metrics service.\n static to_string(counters: List[Counter], source: Optional[str], instance: Optional[str]): str\n  counters: List[Counter] - list of counters to convert. source: Optional[str] - source (context) name. instance: Optional[str] - unique instance name (usually a host name). returns: str - converted counter  ","description":"Helper class that converts performance counter values into a response from Prometheus metrics service.\n","image":null,"permalink":"/python/prometheus/count/prometheus_counter_converter/","subtitle":null,"tags":null,"title":"PrometheusCounterConverter"},{"content":"Extends: CachedCounters\nImplements: IReferenceable, IOpenable\nDescription The PrometheusCounters class allows you to create performance counters that send their metrics to Pormetheus service.\nImportant points\n The component is normally used in passive mode conjunction with PrometheusMetricsService. Alternatively, when connection parameters are set, it can push metrics to Prometheus PushGateway.  Configuration parameters connection(s):\n discovery_key: (optional) key to retrieve the connection from IDiscovery protocol: connection protocol: http or https host: host name or IP address port: port number uri: resource URI or connection string with all parameters in it  options:\n retries: number of retries (default: 3) connect_timeout: connection timeout in milliseconds (default: 10 sec) timeout: invocation timeout in milliseconds (default: 10 sec)  References  *:logger:*:*:1.0 - (optional) ILogger components to pass log messages *:discovery:*:*:1.0 - (optional) IDiscovery services *:counters:*:*:1.0 - (optional) ICounters components to pass collected measurements  Constructors NewPrometheusCounters Creates a new instance of the performance counters.\n NewPrometheusCounters() *PrometheusCounters\n Methods Close Closes the component and frees used resources.\n (c *PrometheusCounters) Close(correlationId string) error\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. returns: error - error or nil no errors occured.  Configure Configures the component by passing its configuration parameters.\n (c *PrometheusCounters) Configure(config *cconf.ConfigParams)\n  config: *cconf.ConfigParams - configuration parameters to be set.  IsOpen Checks if the component is opened.\n (c *PrometheusCounters) IsOpen() bool\n  returns: bool - True if the component is open and False otherwise.  Open Opens the component.\n (c *PrometheusCounters) Open(correlationId string) (err error)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. returns: (err error) - error or nil no errors occured.  Save Saves the current counters' measurements.\n (c *PrometheusCounters) Save(counters []*ccount.Counter) (err error)\n  counters: []*ccount.Counter - current counters measurements to be saved. returns: (err error) - error or nil no errors occured.  SetReferences Sets references to dependent components.\n (c *PrometheusCounters) SetReferences(references cref.IReferences)\n  references: cref.IReferences - references to locate the component dependencies.  Examples counters = NewPrometheusCounters(); counters.Configure(cconf.NewConfigParamsFromTuples( \u0026#34;connection.protocol\u0026#34;, \u0026#34;http\u0026#34;, \u0026#34;connection.host\u0026#34;, \u0026#34;localhost\u0026#34;, \u0026#34;connection.port\u0026#34;, 8080 )); counters.Open(\u0026#34;123\u0026#34;) counters.Increment(\u0026#34;mycomponent.mymethod.calls\u0026#34;); timing := counters.BeginTiming(\u0026#34;mycomponent.mymethod.exec_time\u0026#34;); ... timing.EndTiming(); counters.Dump(); See also   RestService   CommandableHttpService   ","description":"Performance counters that send their metrics to Prometheus service.\n","image":null,"permalink":"/golang/prometheus/count/prometheus_counters/","subtitle":null,"tags":null,"title":"PrometheusCounters"},{"content":"Inherits: CachedCounters, IReferenceable, IOpenable\nDescription The PrometheusCounters class allows you to create performance counters that send their metrics to Pormetheus service.\nImportant points\n The component is normally used in passive mode conjunction with PrometheusMetricsService. Alternatively, when connection parameters are set, it can push metrics to Prometheus PushGateway.  Configuration parameters connection(s):\n discovery_key: (optional) key to retrieve the connection from IDiscovery protocol: connection protocol: http or https host: host name or IP address port: port number uri: resource URI or connection string with all parameters in it  options:\n retries: number of retries (default: 3) connect_timeout: connection timeout in milliseconds (default: 10 sec) timeout: invocation timeout in milliseconds (default: 10 sec)  References  *:logger:*:*:1.0 - (optional) ILogger components to pass log messages *:discovery:*:*:1.0 - (optional) IDiscovery services *:counters:*:*:1.0 - (optional) ICounters components to pass collected measurements  Constructors Creates a new instance of the performance counters.\n public constructor()\n Instance methods CloseAsync Closes the component and frees used resources.\n public Task CloseAsync(string correlationId)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain.  Configure Configures the component by passing its configuration parameters.\n public override void Configure(ConfigParams config)\n  config: ConfigParams - configuration parameters to be set.  IsOpen Checks if the component is opened.\n public bool IsOpen()\n  returns: bool - True if the component is open and False otherwise.  OpenAsync Opens the component.\n public Task OpenAsync(string correlationId)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain.  Save Saves the current counters' measurements.\n protected override void Save(IEnumerable\u0026lt;Counter\u0026gt; counters)\n  counters: IEnumerable\u0026lt;Counter\u0026gt; - current counters measurements to be saved.  SetReferences Sets references to dependent components.\n public virtual void SetReferences(IReferences references)\n  references: IReferences - references to locate the component dependencies.  Examples var counters = new PrometheusCounters(); counters.Configure(ConfigParams.FromTuples( \u0026#34;connection.protocol\u0026#34;, \u0026#34;http\u0026#34;, \u0026#34;connection.host\u0026#34;, \u0026#34;localhost\u0026#34;, \u0026#34;connection.port\u0026#34;, 8080 )); counters.Open(\u0026#34;123\u0026#34;); counters.Increment(\u0026#34;mycomponent.mymethod.calls\u0026#34;); var timing = counters.BeginTiming(\u0026#34;mycomponent.mymethod.exec_time\u0026#34;); try { ... } finally { timing.endTiming(); } counters.dump(); See also   RestService   CommandableHttpService   ","description":"Performance counters that send their metrics to Prometheus service.\n","image":null,"permalink":"/net/prometheus/count/prometheus_counters/","subtitle":null,"tags":null,"title":"PrometheusCounters"},{"content":"Extends: CachedCounters\nImplements: IReferenceable, IOpenable\nDescription The PrometheusCounters class allows you to create performance counters that send their metrics to Pormetheus service.\nImportant points\n The component is normally used in passive mode conjunction with PrometheusMetricsService. Alternatively, when connection parameters are set, it can push metrics to Prometheus PushGateway.  Configuration parameters connection(s):\n discovery_key: (optional) key to retrieve the connection from IDiscovery protocol: connection protocol: http or https host: host name or IP address port: port number uri: resource URI or connection string with all parameters in it  options:\n retries: number of retries (default: 3) connect_timeout: connection timeout in milliseconds (default: 10 sec) timeout: invocation timeout in milliseconds (default: 10 sec)  References  *:logger:*:*:1.0 - (optional) ILogger components to pass log messages *:discovery:*:*:1.0 - (optional) IDiscovery services *:counters:*:*:1.0 - (optional) ICounters components to pass collected measurements  Constructors Creates a new instance of the performance counters.\n public constructor()\n Instance methods close Closes the component and frees used resources.\n public close(correlationId: string)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain.  configure Configures the component by passing its configuration parameters.\n public configure(config: ConfigParams): void\n  config: ConfigParams - configuration parameters to be set.  isOpen Checks if the component is opened.\n public isOpen(): boolean\n  returns: boolean - True if the component is open and False otherwise.  open Opens the component.\n public open(correlationId: string): Promise\u0026lt;void\u0026gt;\n  correlationId: string - (optional) transaction id used to trace execution through the call chain.  save Saves the current counters' measurements.\n protected save(counters: Counter[]): void\n  counters: Counter[] - current counters measurements to be saved.  setReferences Sets references to dependent components.\n public setReferences(references: IReferences): void\n  references: IReferences - references to locate the component dependencies.  Examples let counters = new PrometheusCounters(); counters.configure(ConfigParams.fromTuples( \u0026#34;connection.protocol\u0026#34;, \u0026#34;http\u0026#34;, \u0026#34;connection.host\u0026#34;, \u0026#34;localhost\u0026#34;, \u0026#34;connection.port\u0026#34;, 8080 )); await counters.open(\u0026#34;123\u0026#34;); counters.increment(\u0026#34;mycomponent.mymethod.calls\u0026#34;); let timing = counters.beginTiming(\u0026#34;mycomponent.mymethod.exec_time\u0026#34;); try { ... } finally { timing.endTiming(); } counters.dump(); See also   RestService   CommandableHttpService   ","description":"Performance counters that send their metrics to Prometheus service.\n","image":null,"permalink":"/node/prometheus/count/prometheus_counters/","subtitle":null,"tags":null,"title":"PrometheusCounters"},{"content":"Implements: CachedCounters, IReferenceable, IOpenable\nDescription The PrometheusCounters class allows you to create performance counters that send their metrics to Pormetheus service.\nImportant points\n The component is normally used in passive mode conjunction with PrometheusMetricsService. Alternatively, when connection parameters are set, it can push metrics to Prometheus PushGateway.  Configuration parameters connection(s):\n discovery_key: (optional) key to retrieve the connection from IDiscovery protocol: connection protocol: http or https host: host name or IP address port: port number uri: resource URI or connection string with all parameters in it  options:\n retries: number of retries (default: 3) connect_timeout: connection timeout in milliseconds (default: 10 sec) timeout: invocation timeout in milliseconds (default: 10 sec)  References  *:logger:*:*:1.0 - (optional) ILogger components to pass log messages *:discovery:*:*:1.0 - (optional) IDiscovery services *:counters:*:*:1.0 - (optional) ICounters components to pass collected measurements  Constructors Creates a new instance of the performance counters.\n PrometheusCounters()\n Instance methods close Closes the component and frees used resources.\n close(correlation_id: Optional[str])\n  correlation_id: Optional[str] - (optional) transaction id used to trace execution through the call chain.  configure Configures the component by passing its configuration parameters.\n configure(config: ConfigParams)\n  config: ConfigParams - configuration parameters to be set.  is_open Checks if the component is opened.\n is_open(): bool\n  returns: bool - True if the component is open and False otherwise.  open Opens the component.\n open(correlation_id: Optional[str])\n  correlation_id: Optional[str] - (optional) transaction id used to trace execution through the call chain.  _save Saves the current counters' measurements.\n _save(counters: List[Counter])\n  counters: List[Counter] - current counters measurements to be saved.  set_references Sets references to dependent components.\n set_references(references: IReferences)\n  references: IReferences - references to locate the component dependencies.  Examples counters = PrometheusCounters() counters.configure(ConfigParams.from_tuples( \u0026#34;connection.protocol\u0026#34;, \u0026#34;http\u0026#34;, \u0026#34;connection.host\u0026#34;, \u0026#34;localhost\u0026#34;, \u0026#34;connection.port\u0026#34;, 8080 )) counters.open(\u0026#34;123\u0026#34;) counters.increment(\u0026#34;mycomponent.mymethod.calls\u0026#34;) timing = counters.begin_timing(\u0026#34;mycomponent.mymethod.exec_time\u0026#34;) try: ... finally: timing.end_timing() counters.dump() See also   RestService   CommandableHttpService   ","description":"Performance counters that send their metrics to Prometheus service.\n","image":null,"permalink":"/python/prometheus/count/prometheus_counters/","subtitle":null,"tags":null,"title":"PrometheusCounters"},{"content":"Implements: RestService\nDescription The PrometheusMetricsService class allows you to create services that expose the \u0026quot;/metrics\u0026quot; and \u0026quot;/metricsandreset\u0026quot; routes for Prometheus to obtain performance metrics.\nConfiguration parameters dependencies:\n endpoint: override for HTTP Endpoint dependency prometheus_counters: override for PrometheusCounters dependency  connection(s):\n discovery_key: (optional) key to retrieve the connection from IDiscovery protocol: connection protocol: http or https host: host name or IP address port: port number uri: resource URI or connection string with all parameters in it  References    *:logger:*:*:1.0 - (optional) ILogger components to pass log messages     *:counters:*:*:1.0 - (optional) ICounters components to pass collected measurements     *:discovery:*:*:1.0 - (optional) IDiscovery services to resolve connections     *:endpoint:http:*:1.0 - (optional) HttpEndpoint reference to expose REST operations     *:counters:prometheus:*:1.0 - PrometheusCounters reference to retrieve collected metrics    Constructors NewPrometheusMetricsService Creates a new instance of this service.\n NewPrometheusMetricsService() *PrometheusMetricsService\n Methods SetReferences Sets references to dependent components.\n (c *PrometheusMetricsService) SetReferences(references cref.IReferences)\n  references: cref.IReferences - references to locate the component dependencies.  Register Registers all service routes in a HTTP endpoint.\n (c *PrometheusMetricsService) Register()\n Examples service := NewPrometheusMetricsService(); service.Configure(cconf.NewConfigParamsFromTuples( \u0026#34;connection.protocol\u0026#34;, \u0026#34;http\u0026#34;, \u0026#34;connection.host\u0026#34;, \u0026#34;localhost\u0026#34;, \u0026#34;connection.port\u0026#34;, \u0026#34;8080\u0026#34;, )); err := service.Open(\u0026#34;123\u0026#34;) if err == nil { fmt.Println(\u0026#34;The Prometheus metrics service is accessible at http://localhost:8080/metrics\u0026#34;); defer service.Close(\u0026#34;\u0026#34;) } See also   RestService   RestClient   ","description":"Service that exposes the **\"/metrics\"** and **\"/metricsandreset\"** routes  for Prometheus to obtain performance metrics.\n","image":null,"permalink":"/golang/prometheus/services/prometheus_metrics_service/","subtitle":null,"tags":null,"title":"PrometheusMetricsService"},{"content":"Inherits: RestService\nDescription The PrometheusMetricsService class allows you to create services that expose the \u0026quot;/metrics\u0026quot; and \u0026quot;/metricsandreset\u0026quot; routes for Prometheus to obtain performance metrics.\nConfiguration parameters dependencies:\n endpoint: override for HTTP Endpoint dependency prometheus_counters: override for PrometheusCounters dependency  connection(s):\n discovery_key: (optional) key to retrieve the connection from IDiscovery protocol: connection protocol: http or https host: host name or IP address port: port number uri: resource URI or connection string with all parameters in it  References    *:logger:*:*:1.0 - (optional) ILogger components to pass log messages     *:counters:*:*:1.0 - (optional) ICounters components to pass collected measurements     *:discovery:*:*:1.0 - (optional) IDiscovery services to resolve connections     *:endpoint:http:*:1.0 - (optional) HttpEndpoint reference to expose REST operations     *:counters:prometheus:*:1.0 - PrometheusCounters reference to retrieve collected metrics    Constructors Creates a new instance of this service.\n public PrometheusMetricsService()\n Instance methods SetReferences Sets references to dependent components.\n public override void SetReferences(IReferences references)\n  references: IReferences - references to locate the component dependencies.  Register Registers all service routes in a HTTP endpoint.\n public override void Register()\n Examples var service = new PrometheusMetricsService(); service.Configure(ConfigParams.FromTuples( \u0026#34;connection.protocol\u0026#34;, \u0026#34;http\u0026#34;, \u0026#34;connection.host\u0026#34;, \u0026#34;localhost\u0026#34;, \u0026#34;connection.port\u0026#34;, 8080 )); service.Open(\u0026#34;123\u0026#34;); Console.Out.WriteLine(\u0026#34;The Prometheus metrics service is accessible at http://+:8080/metrics\u0026#34;); See also   RestService   RestClient   ","description":"Service that exposes the **\"/metrics\"** and **\"/metricsandreset\"** routes  for Prometheus to obtain performance metrics.\n","image":null,"permalink":"/net/prometheus/services/prometheus_metrics_service/","subtitle":null,"tags":null,"title":"PrometheusMetricsService"},{"content":"Extends: RestService\nDescription The PrometheusMetricsService class allows you to create services that expose the \u0026quot;/metrics\u0026quot; and \u0026quot;/metricsandreset\u0026quot; routes for Prometheus to obtain performance metrics.\nConfiguration parameters dependencies:\n endpoint: override for HTTP Endpoint dependency prometheus_counters: override for PrometheusCounters dependency  connection(s):\n discovery_key: (optional) key to retrieve the connection from IDiscovery protocol: connection protocol: http or https host: host name or IP address port: port number uri: resource URI or connection string with all parameters in it  References    *:logger:*:*:1.0 - (optional) ILogger components to pass log messages     *:counters:*:*:1.0 - (optional) ICounters components to pass collected measurements     *:discovery:*:*:1.0 - (optional) IDiscovery services to resolve connections     *:endpoint:http:*:1.0 - (optional) HttpEndpoint reference to expose REST operations     *:counters:prometheus:*:1.0 - PrometheusCounters reference to retrieve collected metrics    Constructors Creates a new instance of this service.\n public constructor()\n Instance methods setReferences Sets references to dependent components.\n public setReferences(references: IReferences): void\n  references: IReferences - references to locate the component dependencies.  register Registers all service routes in a HTTP endpoint.\n public register(): void\n Examples let service = new PrometheusMetricsService(); service.configure(ConfigParams.fromTuples( \u0026#34;connection.protocol\u0026#34;, \u0026#34;http\u0026#34;, \u0026#34;connection.host\u0026#34;, \u0026#34;localhost\u0026#34;, \u0026#34;connection.port\u0026#34;, 8080 )); await service.open(\u0026#34;123\u0026#34;); console.log(\u0026#34;The Prometheus metrics service is accessible at http://+:8080/metrics\u0026#34;); See also   RestService   RestClient   ","description":"Service that exposes the **\"/metrics\"** and **\"/metricsandreset\"** routes  for Prometheus to obtain performance metrics.\n","image":null,"permalink":"/node/prometheus/services/prometheus_metrics_service/","subtitle":null,"tags":null,"title":"PrometheusMetricsService"},{"content":"Implements: RestService\nDescription The PrometheusMetricsService class allows you to create services that expose the \u0026quot;/metrics\u0026quot; and \u0026quot;/metricsandreset\u0026quot; routes for Prometheus to obtain performance metrics.\nConfiguration parameters dependencies:\n endpoint: override for HTTP Endpoint dependency prometheus_counters: override for PrometheusCounters dependency  connection(s):\n discovery_key: (optional) key to retrieve the connection from IDiscovery protocol: connection protocol: http or https host: host name or IP address port: port number uri: resource URI or connection string with all parameters in it  References    *:logger:*:*:1.0 - (optional) ILogger components to pass log messages     *:counters:*:*:1.0 - (optional) ICounters components to pass collected measurements     *:discovery:*:*:1.0 - (optional) IDiscovery services to resolve connections     *:endpoint:http:*:1.0 - (optional) HttpEndpoint reference to expose REST operations     *:counters:prometheus:*:1.0 - PrometheusCounters reference to retrieve collected metrics    Constructors Creates a new instance of this service.\n PrometheusMetricsService()\n Instance methods set_references Sets references to dependent components.\n set_references(references: IReferences)\n  references: IReferences - references to locate the component dependencies.  register Registers all service routes in a HTTP endpoint.\n register()\n Examples service = PrometheusMetricsService() service.configure(ConfigParams.from_tuples( \u0026#34;connection.protocol\u0026#34;, \u0026#34;http\u0026#34;, \u0026#34;connection.host\u0026#34;, \u0026#34;localhost\u0026#34;, \u0026#34;connection.port\u0026#34;, 8080 )) try: service.open(\u0026#34;123\u0026#34;) print(\u0026#34;The Prometheus metrics service is accessible at http://+:8080/metrics\u0026#34;) except Exception as err: # do something See also   RestService   RestClient   ","description":"Service that exposes the **\"/metrics\"** and **\"/metricsandreset\"** routes  for Prometheus to obtain performance metrics.\n","image":null,"permalink":"/python/prometheus/services/prometheus_metrics_service/","subtitle":null,"tags":null,"title":"PrometheusMetricsService"},{"content":"Implements: IValidationRule\nDescription The PropertiesComparisonRule class allows you to create a validation rule to compare two object properties.\nConstructors NewPropertiesComparisonRule Creates a new validation rule and sets its arguments. See ObjectComparator.compare\n NewPropertiesComparisonRule(property1 string, operation string, property2 string) *PropertiesComparisonRule\n  property1: string - name of the first property to compare. operation: string - comparison operation: \u0026quot;==\u0026quot; (\u0026quot;=\u0026quot;, \u0026ldquo;EQ\u0026rdquo;), \u0026ldquo;!= \u0026quot; (\u0026quot;\u0026lt;\u0026gt;\u0026rdquo;, \u0026ldquo;NE\u0026rdquo;); \u0026ldquo;\u0026lt;\u0026quot;/\u0026quot;\u0026gt;\u0026rdquo; (\u0026ldquo;LT\u0026rdquo;/\u0026ldquo;GT\u0026rdquo;), \u0026ldquo;\u0026lt;=\u0026quot;/\u0026quot;\u0026gt;=\u0026rdquo; (\u0026ldquo;LE\u0026rdquo;/\u0026ldquo;GE\u0026rdquo;); \u0026ldquo;LIKE\u0026rdquo;. property2: string - name of the second property to compare.  Methods Validate Validates a given value against this rule.\n (c *PropertiesComparisonRule) Validate(path string, schema ISchema, value interface{}) []*ValidationResult\n  path: string - dot notation path to the value. schema: ISchema - schema this rule is called from value: interface{} - value to be validated. results: []*ValidationResult - list with validation results to add new results.  Examples var schema = NewObjectSchema() .WithRule(NewPropertyComparisonRule(\u0026#34;field1\u0026#34;, \u0026#34;NE\u0026#34;, \u0026#34;field2\u0026#34;)); schema.Validate({ field1: 1, field2: 2 }); // Result: no errors schema.Validate({ field1: 1, field2: 1 }); // Result: field1 shall not be equal to field2 schema.Validate({}); // Result: no errors  See also   IValidationRule   ","description":"Validation rule that compares two object properties.\n","image":null,"permalink":"/golang/commons/validate/properties_comparison_rule/","subtitle":null,"tags":null,"title":"PropertiesComparisonRule"},{"content":"Inherits: IValidationRule\nDescription The PropertiesComparisonRule class allows you to create a validation rule to compare two object properties.\nConstructors Creates a new validation rule and sets its arguments. See ObjectComparator.compare\n public PropertiesComparisonRule(string property1, string operation, string property2)\n  property1: string - name of the first property to compare. operation: string - comparison operation: \u0026quot;==\u0026quot; (\u0026quot;=\u0026quot;, \u0026ldquo;EQ\u0026rdquo;), \u0026ldquo;!= \u0026quot; (\u0026quot;\u0026lt;\u0026gt;\u0026rdquo;, \u0026ldquo;NE\u0026rdquo;); \u0026ldquo;\u0026lt;\u0026quot;/\u0026quot;\u0026gt;\u0026rdquo; (\u0026ldquo;LT\u0026rdquo;/\u0026ldquo;GT\u0026rdquo;), \u0026ldquo;\u0026lt;=\u0026quot;/\u0026quot;\u0026gt;=\u0026rdquo; (\u0026ldquo;LE\u0026rdquo;/\u0026ldquo;GE\u0026rdquo;); \u0026ldquo;LIKE\u0026rdquo;. property2: string - name of the second property to compare.  Instance methods Validate Validates a given value against this rule.\n public void Validate(string path, Schema schema, object value, List\u0026lt;ValidationResult\u0026gt; results)\n  path: string - dot notation path to the value. schema: Schema - schema this rule is called from value: object - value to be validated. results: List\u0026lt;ValidationResult\u0026gt; - list with validation results to add new results.  Examples var schema = new ObjectSchema().WithRule(new PropertyComparisonRule(\u0026#34;field1\u0026#34;, \u0026#34;NE\u0026#34;, \u0026#34;field2\u0026#34;)); schema.Validate({ field1: 1, field2: 2 }); // Result: no errors schema.Validate({ field1: 1, field2: 1 }); // Result: field1 shall not be equal to field2 schema.Validate({ }); // Result: no errors  See also   IValidationRule   ","description":"Validation rule that compares two object properties.\n","image":null,"permalink":"/net/commons/validate/properties_comparison_rule/","subtitle":null,"tags":null,"title":"PropertiesComparisonRule"},{"content":"Implements: IValidationRule\nDescription The PropertiesComparisonRule class allows you to create a validation rule used to compare two object\u0026rsquo;s properties.\nConstructors Creates a new validation rule and sets its arguments. See ObjectComparator.compare\n public constructor(property1: string, operation: string, property2: string)\n  property1: string - name of the first property to compare. operation: string - comparison operation: \u0026quot;==\u0026quot; (\u0026quot;=\u0026quot;, \u0026ldquo;EQ\u0026rdquo;), \u0026ldquo;!= \u0026quot; (\u0026quot;\u0026lt;\u0026gt;\u0026rdquo;, \u0026ldquo;NE\u0026rdquo;); \u0026ldquo;\u0026lt;\u0026quot;/\u0026quot;\u0026gt;\u0026rdquo; (\u0026ldquo;LT\u0026rdquo;/\u0026ldquo;GT\u0026rdquo;), \u0026ldquo;\u0026lt;=\u0026quot;/\u0026quot;\u0026gt;=\u0026rdquo; (\u0026ldquo;LE\u0026rdquo;/\u0026ldquo;GE\u0026rdquo;); \u0026ldquo;LIKE\u0026rdquo;. property2: string - name of the second property to compare.  Instance methods validate Validates a given value against this rule.\n public validate(path: string, schema: Schema, value: any, results: ValidationResult[]): void\n  path: string - dot notation path to the value. schema: Schema - schema this rule is called from value: any - value to be validated. results: ValidationResult[] - list with validation results to add new results.  Examples let schema = new ObjectSchema() .withRule(new PropertyComparisonRule(\u0026#34;field1\u0026#34;, \u0026#34;NE\u0026#34;, \u0026#34;field2\u0026#34;)); schema.validate({ field1: 1, field2: 2 }); // Result: no errors schema.validate({ field1: 1, field2: 1 }); // Result: field1 shall not be equal to field2 schema.validate({}); // Result: no errors  See also   IValidationRule   ","description":"Validation rule that compares two object properties.\n","image":null,"permalink":"/node/commons/validate/properties_comparison_rule/","subtitle":null,"tags":null,"title":"PropertiesComparisonRule"},{"content":"Implements: IValidationRule\nDescription The PropertiesComparisonRule class allows you to create a validation rule to compare two object properties.\nConstructors Creates a new validation rule and sets its arguments. See ObjectComparator.compare\n PropertiesComparisonRule(property1: str, operation: str, property2: str)\n  property1: str - a name of the first property to compare. operation: str - a comparison operation: \u0026quot;==\u0026quot; (\u0026quot;=\u0026quot;, \u0026ldquo;EQ\u0026rdquo;), \u0026ldquo;!= \u0026quot; (\u0026quot;\u0026lt;\u0026gt;\u0026rdquo;, \u0026ldquo;NE\u0026rdquo;); \u0026ldquo;\u0026lt;\u0026quot;/\u0026quot;\u0026gt;\u0026rdquo; (\u0026ldquo;LT\u0026rdquo;/\u0026ldquo;GT\u0026rdquo;), \u0026ldquo;\u0026lt;=\u0026quot;/\u0026quot;\u0026gt;=\u0026rdquo; (\u0026ldquo;LE\u0026rdquo;/\u0026ldquo;GE\u0026rdquo;); \u0026ldquo;LIKE\u0026rdquo;. property2: str - a name of the second property to compare.  Instance methods validate Validates a given value against this rule.\n validate(path: str, schema: Schema, value: Any, results: List[ValidationResult])\n  path: str - a dot notation path to the value. schema: Schema - a schema this rule is called from value: Any - a value to be validated. results: List[ValidationResult] - a list with validation results to add new results.  Examples schema = ObjectSchema().with_rule(PropertyComparisonRule(\u0026#34;field1\u0026#34;, \u0026#34;NE\u0026#34;, \u0026#34;field2\u0026#34;)) schema.validate({ field1: 1, field2: 2 }) # Result: no errors schema.validate({ field1: 1, field2: 1 }) # Result: field1 shall not be equal to field2 schema.validate({}) # Result: no errors See also   IValidationRule   ","description":"Validation rule that compares two object properties.\n","image":null,"permalink":"/python/commons/validate/properties_comparison_rule/","subtitle":null,"tags":null,"title":"PropertiesComparisonRule"},{"content":"Description The PropertyReflector class allows you to examine an object\u0026rsquo;s properties and to dynamically get and set their values.\nImportant points\n This class has symmetric implementation across all languages supported by the Pip.Services toolkit and it is used to support dynamic data processing. Because all languages have different casing and case sensitivity rules, the PropertyReflector class treats all property names as case insensitive.  Methods GetProperties Get values of all properties in a specified object and returns them as a map.\n (c *TPropertyReflector) GetProperties(obj interface{}) map[string]interface{}\n  obj: interface{} - object to get properties from. returns: map[string]interface{} - map, containing the names of the object\u0026rsquo;s properties and their values.  GetProperty Gets the value of an object\u0026rsquo;s property specified by its name.\n (c *TPropertyReflector) GetProperty(obj interface{}, name string) interface{}\n  obj: interface{} - object to read property from. name: string - name of the property to get. returns: interface{} - property value or nil if property doesn\u0026rsquo;t exist or introspection failed.  GetPropertyNames Gets the names of all properties implemented in a specified object.\n (c *TPropertyReflector) GetPropertyNames(obj interface{}) []string\n  obj:interface{}any - object to introspect. returns: []string - list with property names.  HasProperty Checks if an object has a property with a specified name.\n (c *TPropertyReflector) HasProperty(obj interface{}, name string) bool\n  obj: interface{} - object to introspect. name: string - name of the property to check. returns: bool - true if the object has the property and false if it doesn\u0026rsquo;t.  SetProperties Sets values of some (all) object properties.\nIf some properties do not exist or introspection fails they are just silently skipped and no errors thrown.\n (c *TPropertyReflector) SetProperties(obj interface{}, values map[string]interface{})\n  obj: interface{} - object to write properties to. values: map[string]interface{} - map, containing property names and their values.  SetProperty Sets the value of an object\u0026rsquo;s property specified by its name.\nIf the property does not exist or introspection fails this method doesn\u0026rsquo;t do anything and doesn\u0026rsquo;t throw any errors.\n (c *TPropertyReflector) SetProperty(obj interface{}, name string, value interface{})\n  obj: interface{} - object to write property to. name: string - name of the property to set. value: interface{} - new value for the property to set.  Examples myObj := MyObject{} properties := PropertyReflector.GetPropertyNames() PropertyReflector.HasProperty(myObj, \u0026#34;myProperty\u0026#34;) value := PropertyReflector.GetProperty(myObj, \u0026#34;myProperty\u0026#34;) PropertyReflector.SetProperty(myObj, \u0026#34;myProperty\u0026#34;, 123) ","description":"Helper class that allows you to examine an object's properties and to dynamically get and set their values.\n","image":null,"permalink":"/golang/commons/reflect/property_reflector/","subtitle":null,"tags":null,"title":"PropertyReflector"},{"content":"Description The PropertyReflector class allows you to examine an object\u0026rsquo;s properties and to dynamically get and set their values.\nImportant points\n This class has symmetric implementation across all languages supported by the Pip.Services toolkit and it is used to support dynamic data processing. Because all languages have different casing and case sensitivity rules, the PropertyReflector class treats all property names as case insensitive.  Static methods GetProperties Get the values of all the properties in a specified object and returns them as a map.\n public static Dictionary\u0026lt;string, object\u0026gt; GetProperties(object obj)\n  obj: object - object to get properties from. returns: Dictionary\u0026lt;string, object\u0026gt; - map containing the names of the object\u0026rsquo;s properties and their values.  GetProperty Gets value of an object\u0026rsquo;s property specified by its name.\n public static object GetProperty(object obj, string name)\n  obj: object - object to read property from. name: string - name of the property to get. returns: object - property\u0026rsquo;s value or null if the property doesn\u0026rsquo;t exist or introspection failed.  GetPropertyNames Gets the names of all the properties implemented in a specified object.\n public static List\u0026lt;string\u0026gt; GetPropertyNames(object obj)\n  obj: object - object to introspect. returns: List\u0026lt;string\u0026gt; - list with property names.  HasProperty Checks if object has a property with a specified name.\n public static bool HasProperty(object obj, string name)\n  obj: object - object to introspect. name: string - name of the property to check. returns: bool - true if the object has the property and false if it doesn\u0026rsquo;t.  SetProperties Sets values of some (all) object\u0026rsquo;s properties.\nIf some properties do not exist or introspection fails they are just silently skipped and no errors thrown.\n public static void SetProperties(object obj, Dictionary\u0026lt;string, object\u0026gt; values)\n  obj: object - object to write properties to. values: Dictionary\u0026lt;string, object\u0026gt; - map containing property names and their values.  SetProperty Sets value of an object\u0026rsquo;s property specified by its name.\nIf the property does not exist or introspection fails this method doesn\u0026rsquo;t do anything and doesn\u0026rsquo;t any throw errors.\n public static void SetProperty(object obj, string name, object value)\n  obj: object - object to write property to. name: string - name of the property to set. value: object - new value for the property to set.  Examples var myObj = new MyObject(); var properties = PropertyReflector.GetPropertyNames(); PropertyReflector.HasProperty(myObj, \u0026#34;myProperty\u0026#34;); var value = PropertyReflector.GetProperty(myObj, \u0026#34;myProperty\u0026#34;); PropertyReflector.SetProperty(myObj, \u0026#34;myProperty\u0026#34;, 123); ","description":"Helper class that allows you to examine an object's properties and to dynamically get and set their values.\n","image":null,"permalink":"/net/commons/reflect/property_reflector/","subtitle":null,"tags":null,"title":"PropertyReflector"},{"content":"Description The PropertyReflector class allows you to examine an object\u0026rsquo;s properties and to dynamically get and set their values.\nImportant points\n This class has symmetric implementation across all languages supported by the Pip.Services toolkit and it is used to support dynamic data processing. Because all languages have different casing and case sensitivity rules, the PropertyReflector class treats all property names as case insensitive.  Static methods getProperties Gets the values of all properties in specified object and returns them as a map.\n public static getProperties(obj: any): any\n  obj: any - object to get properties from. returns: any - map containing the names of the object\u0026rsquo;s properties and their values.  getProperty Gets the value of an object\u0026rsquo;s property specified by its name.\n public static getProperty(obj: any, name: string): any\n  obj: any - object to read the property from. name: string - name of the property to get. returns: any - property value or null if property doesn\u0026rsquo;t exist or introspection failed.  getPropertyNames Gets names of all properties implemented in a specified object.\n public static getPropertyNames(obj: any): string[]\n  obj: any - objec to introspect. returns: string[] - list with property names.  hasProperty Checks if an object has a property with a specified name.\n public static hasProperty(obj: any, name: string): boolean\n  obj: any - object to introspect. name: string - name of the property to check. returns: boolean - true if the object has the property and false if it doesn\u0026rsquo;t.  setProperties Sets the values of some (all) object properties.\nIf some properties do not exist or introspection fails, they are just silently skipped and no errors thrown.\n public static setProperties(obj: any, values: any): void\n  obj: any - object to write properties to. values: any - map containing property names and their values.  setProperty Sets value of an object\u0026rsquo;s property specified by its name.\nIf the property does not exist or introspection fails, this method doesn\u0026rsquo;t do anything and doesn\u0026rsquo;t any throw errors.\n public static setProperty(obj: any, name: string, value: any): void\n  obj: any - object to write a property to. name: string - name of the property to set. value: any - new value for the property to set.  Examples let myObj = new MyObject(); let properties = PropertyReflector.getPropertyNames(); PropertyReflector.hasProperty(myObj, \u0026#34;myProperty\u0026#34;); let value = PropertyReflector.getProperty(myObj, \u0026#34;myProperty\u0026#34;); PropertyReflector.setProperty(myObj, \u0026#34;myProperty\u0026#34;, 123); ","description":"Helper class that allows you to examine an object's properties and to dynamically get and set their values.\n","image":null,"permalink":"/node/commons/reflect/property_reflector/","subtitle":null,"tags":null,"title":"PropertyReflector"},{"content":"Description The PropertyReflector class allows you to examine an object\u0026rsquo;s properties and to dynamically get and set their values.\nImportant points\n This class has symmetric implementation across all languages supported by the Pip.Services toolkit and it is used to support dynamic data processing. Because all languages have different casing and case sensitivity rules, the PropertyReflector class treats all property names as case insensitive.  Static methods get_properties Get values of all properties in specified object and returns them as a map.\n static get_properties(obj: Any): Any\n  obj: Any - an object to get properties from. returns: Any - a map, containing the names of the object\u0026rsquo;s properties and their values.  get_property Gets value of object property specified by its name.\n static getProperty(obj: Any, name: str): Any\n  obj: Any - an object to read a property from. name: str - the name of the property to get. returns: Any - the property value or None if property doesn\u0026rsquo;t exist or introspection failed.  get_property_names Gets names of all properties implemented in the specified object.\n static get_property_names(obj: Any): List[str]\n  obj: Any - an objec to introspect. returns: List[str] - a list with property names.  has_property Checks if object has a property with a specified name.\n static has_property(obj: Any, name: str): bool\n  obj: Any - an object to introspect. name: str - a name of the property to check. returns: bool - true if the object has the property and false if it doesn\u0026rsquo;t.  set_properties Sets values of some (all) object properties.\nIf some properties do not exist or introspection fails they are just silently skipped and no errors thrown.\n static set_properties(obj: Any, values: Any)\n  obj: Any - an object to write properties to. values: Any - a map, containing property names and their values.  set_property Sets value of object property specified by its name.\nIf the property does not exist or introspection fails this method doesn\u0026rsquo;t do anything and doesn\u0026rsquo;t throw any errors.\n static set_property(obj: Any, name: str, value: Any)\n  obj: Any - an object to write property to. name: str - a name of the property to set. value: Any - a new value for the property to set.  Examples myObj = MyObject() properties = PropertyReflector.get_property_names() PropertyReflector.has_property(myObj, \u0026#34;myProperty\u0026#34;) args = PropertyReflector.get_property(myObj, \u0026#34;myProperty\u0026#34;) PropertyReflector.set_property(myObj, \u0026#34;myProperty\u0026#34;, 123) ","description":"Helper class that allows you to examine an object's properties and to dynamically get and set their values.\n","image":null,"permalink":"/python/commons/reflect/property_reflector/","subtitle":null,"tags":null,"title":"PropertyReflector"},{"content":"Implements: Schema\nDescription The PropertySchema class allows you to create schemas to validate object properties.\nConstructors NewPropertySchemaWithRules Creates a new validation rule and sets its arguments. See IValidationRule, TypeCode\n NewPropertySchemaWithRules(name string, typ interface{}, required bool, rules []IValidationRule) *PropertySchema\n  name: string - (optional) property name typ: interface{} - (optional) property type required: bool - (optional) true to always require non-nil values. rules: []IValidationRule - (optional) list with validation rules.  Creates a new validation schema and sets its values.\n NewPropertySchema() *PropertySchema\n Methods Name Gets the property name.\n (c *PropertySchema) Name() string\n  returns: string - the property name.  Type Gets the property type.\n (c *PropertySchema) Type() interface{}\n  returns: interface{} - property type.  PerformValidation Validates a given value against the schema and configured validation rules.\n (c *PropertySchema) PerformValidation(path string, value interface{}) []*ValidationResult\n  path: string - dot notation path to the value. value: interface{} - value to be validated. results: []*ValidationResult - list with validation results to add new results.  SetName Sets the property name.\n (c *PropertySchema) SetName(value string)\n  value: string - new property name.  SetType Sets a new property type. The type can be defined as type, type name or TypeCode\n (c *PropertySchema) SetType(value interface{})\n  value: interface{} - new property type.  Examples var schema = NewObjectSchema() .WithProperty(NewPropertySchema(\u0026#34;id\u0026#34;, TypeCode.String)); schema.Validate({ id: \u0026#34;1\u0026#34;, name: \u0026#34;ABC\u0026#34; }); // Result: no errors schema.Validate({ name: \u0026#34;ABC\u0026#34; }); // Result: no errors schema.Validate({ id: 1, name: \u0026#34;ABC\u0026#34; }); // Result: id type mismatch  See also   ObjectSchema   ","description":"Schema to validate object properties\n","image":null,"permalink":"/golang/commons/validate/property_schema/","subtitle":null,"tags":null,"title":"PropertySchema"},{"content":"Inherits: Schema\nDescription The PropertySchema class allows you to create schemas to validate object properties.\nConstructors Creates a new validation rule and sets its arguments. See IValidationRule, TypeCode\n public PropertySchema(string name, object type)\n  name: string - (optional) property name type: object - (optional) property type  Creates a new validation schema.\n public PropertySchema()\n Properties Name Gets and sets the property name.\n public string Name { get; set; }\n Type Gets and sets the property type. The type can be defined as type, type name or TypeCode\n public object Type { get; set; }\n Instance methods PerformValidation Validates a given value against the schema and configured validation rules.\n public internal override void PerformValidation(string path, object value, List\u0026lt;ValidationResult\u0026gt; results)\n  path: string - dot notation path to the value. value: object - value to be validated. results: List\u0026lt;ValidationResult\u0026gt; - list with validation results to add new results.  Examples var schema = new ObjectSchema().WithProperty(new PropertySchema(\u0026#34;id\u0026#34;, TypeCode.String)); schema.Validate({ id: \u0026#34;1\u0026#34;, name: \u0026#34;ABC\u0026#34; }); // Result: no errors schema.Validate({ name: \u0026#34;ABC\u0026#34; }); // Result: no errors schema.Validate({ id: 1, name: \u0026#34;ABC\u0026#34; }); // Result: id type mismatch  See also   ObjectSchema   ","description":"Schema to validate object properties\n","image":null,"permalink":"/net/commons/validate/property_schema/","subtitle":null,"tags":null,"title":"PropertySchema"},{"content":"Extends: Schema\nDescription The PropertySchema class allows you to create schemas to validate object properties.\nConstructors Creates a new validation rule and sets its arguments. See IValidationRule, TypeCode\n public constructor(name?: string, type?: any, required?: boolean, rules?: IValidationRule[])\n  name: string - (optional) property name type: any - (optional) property type required: boolean - (optional) true to always require non-null values. rules: IValidationRule[] - (optional) list with validation rules.  Instance methods getName Gets the property name.\n public getName(): string\n  returns: string - property name.  getType Gets the property type.\n public getType(): any\n  returns: any - property type.  performValidation Validates a given value against the schema and configured validation rules.\n public performValidation(path: string, value: any, results: ValidationResult[]): void\n  path: string - dot notation path to the value. value: any - value to be validated. results: ValidationResult[] - list with validation results.  setName Sets the property name.\n public setName(value: string): void\n  value: string - new property name.  setType Sets a new property type. The type can be defined as type, type name or TypeCode\n public setType(value: any): void\n  value: string - new property type.  Examples let schema = new ObjectSchema() .withProperty(new PropertySchema(\u0026#34;id\u0026#34;, TypeCode.String)); schema.validate({ id: \u0026#34;1\u0026#34;, name: \u0026#34;ABC\u0026#34; }); // Result: no errors schema.validate({ name: \u0026#34;ABC\u0026#34; }); // Result: no errors schema.validate({ id: 1, name: \u0026#34;ABC\u0026#34; }); // Result: id type mismatch  See also   ObjectSchema   ","description":"Schema to validate object properties\n","image":null,"permalink":"/node/commons/validate/property_schema/","subtitle":null,"tags":null,"title":"PropertySchema"},{"content":"Implements: Schema\nDescription The PropertySchema class allows you to create schemas to validate object properties.\nConstructors Creates a new validation rule and sets its arguments. See IValidationRule, TypeCode\n PropertySchema(name: str, typ: Any, required: bool, rules: List[IValidationRule])\n  name: str - (optional) a property name typ: Any - (optional) a property type required: bool - (optional) true to always require non-None values. rules: List[IValidationRule] - (optional) a list with validation rules.  Instance methods get_name Gets the property name.\n get_name(): str\n  returns: str - the property name.  getType Gets the property type.\n get_type(): Any\n  returns: Any - the property type.  perform_validation Validates a given value against the schema and configured validation rules.\n _perform_validation(path: str, value: Any, results: List[ValidationResult])\n  path: str - a dot notation path to the value. value: Any - a value to be validated. results: List[ValidationResult] - a list with validation results to add new results.  set_name Sets the property name.\n set_name(value: str)\n  value: str - a new property name.  set_type Sets a new property type. The type can be defined as type, type name or TypeCode\n set_type(value: Any)\n  value: str - a new property type.  Examples schema = ObjectSchema().with_property(PropertySchema(\u0026#34;id\u0026#34;, TypeCode.String)) schema.validate({ id: \u0026#34;1\u0026#34;, name: \u0026#34;ABC\u0026#34; }) # Result: no errors schema.validate({ name: \u0026#34;ABC\u0026#34; }) # Result: no errors schema.validate({ id: 1, name: \u0026#34;ABC\u0026#34; }) # Result: id type mismatch See also   ObjectSchema   ","description":"Schema to validate object properties\n","image":null,"permalink":"/python/commons/validate/property_schema/","subtitle":null,"tags":null,"title":"PropertySchema"},{"content":"Purchase orders.\n Server implementations: NodeJS Communication protocols: Direct, Commandable HTTP, Commandable GRPC, GRPC Persistence: Memory, Flat Files, MongoDB, Couchbase Deployment options: Monolith, Process, Docker, AWS Lambda Client implementations: NodeJS  ","description":null,"image":null,"permalink":"/microservices/ecommrce/purchase_orders/","subtitle":null,"tags":null,"title":"Purchase orders"},{"content":"Manages system notification separated by individual sections. Each section contains multiple key-value parameter pairs.\n Server implementations: NodeJS Communication protocols: Direct, Commandable HTTP, Commandable GRPC, GRPC Persistence: Memory, Flat Files, MongoDB, Couchbase Deployment options: Monolith, Process, Docker, AWS Lambda Client implementations: NodeJS  ","description":null,"image":null,"permalink":"/microservices/infrastructure/pushnotifications/","subtitle":null,"tags":null,"title":"PushNotifications Microservice"},{"content":"Description TODO: add description\nProperties Name TODO: add description\n public string Name { get; set; }\n TypeCode TODO: add description\n public TypeCode TypeCode { get; set; }\n Required TODO: add description\n public bool Required { get; set; }\n DefaultValue TODO: add description\n public object DefaultValue { get; set; }\n Description TODO: add description\n public string Description { get; set; }\n ","description":"TODO: add description\n","image":null,"permalink":"/net/rpc/data/query_param/","subtitle":null,"tags":null,"title":"QueryParam"},{"content":"Shows to users inspirational quotes on various topics. ‍\n Server implementations: NodeJS, .NET Communication protocols: Direct, Commandable HTTP, Commandable GRPC, GRPC Persistence: Memory, Flat Files, MongoDB, Couchbase Deployment options: Monolith, Process, Docker, AWS Lambda Client implementations: NodeJS. .NET, Golang, Java  ","description":null,"image":null,"permalink":"/microservices/content/quotes/","subtitle":null,"tags":null,"title":"Quotes Microservice"},{"content":"Description The RandomArray class can be used as a random generator for array objects.\nMethods Pick Picks a random element from a specified array.\n (c *TRandomArray) Pick(value interface{}) interface{}\n  values: interface{} - array of any type returns: interface{} - randomly picked item.  Examples value1 := RandomArray.Pick([1, 2, 3, 4]); // Possible result: 3  ","description":"Random generator for array objects.\n","image":null,"permalink":"/golang/commons/random/random_array/","subtitle":null,"tags":null,"title":"RandomArray"},{"content":"Description The RandomArray class can be used as a random generator for array objects.\nStatic methods Pick Picks a random element from specified array. T - the class type\n public static T Pick\u0026lt;T\u0026gt;(T[] values)\n  values: T[] - array of any type returns: T - randomly picked item.  Pick Picks a random element from specified list. T - class type\n public static T Pick\u0026lt;T\u0026gt;(List\u0026lt;T\u0026gt; values)\n  values: List\u0026lt;T\u0026gt; - array of any type returns: T - randomly picked item.  Examples var value1 = RandomArray.Pick(new int []{1, 2, 3, 4}); // Possible result: 3 ","description":"Random generator for array objects.\n","image":null,"permalink":"/net/commons/random/random_array/","subtitle":null,"tags":null,"title":"RandomArray"},{"content":"Description The RandomArray class can be used as a random generator for array objects.\nStatic methods pick Picks a random element from a specified array.\n public static pick\u0026lt;T\u0026gt;(values: T[]): T\n  values: T[] - array of any type returns: T - randomly picked item.  Examples let value1 = RandomArray.pick([1, 2, 3, 4]); // Possible result: 3  ","description":"Random generator for array objects.\n","image":null,"permalink":"/node/commons/random/random_array/","subtitle":null,"tags":null,"title":"RandomArray"},{"content":"Description The RandomArray class can be used as a random generator for array objects.\nStatic methods pick Picks a random element from specified array.\n static pick(values: List[Any]): Any\n  values: List[Any] - an array of any type returns: Any - a randomly picked item.  Examples value1 = RandomArray.pick([1, 2, 3, 4]) # Possible result: 3 ","description":"Random generator for array objects.\n","image":null,"permalink":"/python/commons/random/random_array/","subtitle":null,"tags":null,"title":"RandomArray"},{"content":"Description The RandomBoolean class allows you to generate random boolean values.\nMethods Chance Calculates \u0026ldquo;chance\u0026rdquo; out of \u0026ldquo;max chances\u0026rdquo;. Example: 1 chance out of 3 chances (or 33.3%)\n (c *TRandomBoolean) Chance(chances int, maxChances int) bool\n  chances: int - chance proportional to maxChances. maxChances: int - maximum number of chances returns: bool - true or false for a settled chance  NextBoolean Generates a random boolean value.\n (c *TRandomBoolean) NextBoolean() bool\n  returns: bool - random boolean.  Examples value1 := RandomBoolean.NextBoolean(); // Possible result: true value2 := RandomBoolean.Chance(1,3); // Possible result: false  ","description":"Random generator for boolean values.\n","image":null,"permalink":"/golang/commons/random/random_boolean/","subtitle":null,"tags":null,"title":"RandomBoolean"},{"content":"Description The RandomBoolean class allows you to generate random boolean values.\nStatic methods Chance Calculates \u0026ldquo;chance\u0026rdquo; out of \u0026ldquo;max chances\u0026rdquo;. Example: 1 chance out of 3 chances (or 33.3%)\n public static bool Chance(float chance, float maxChances)\n  chance: float - chance proportional to maxChances. maxChances: float - maximum number of chances returns: bool - true or false for settled chance  NextBoolean Generates a random boolean value.\n public static bool NextBoolean()\n  returns: bool - random boolean.  Examples var value1 = RandomBoolean.NextBoolean(); // Possible result: true var value2 = RandomBoolean.Chance(1,3); // Possible result: false  ","description":"Random generator for boolean values.\n","image":null,"permalink":"/net/commons/random/random_boolean/","subtitle":null,"tags":null,"title":"RandomBoolean"},{"content":"Description The RandomBoolean class allows you to generate random boolean values.\nStatic methods chance Calculates \u0026ldquo;chance\u0026rdquo; out of \u0026ldquo;max chances\u0026rdquo;. Example: 1 chance out of 3 chances (or 33.3%)\n public static chance(chance: number, maxChances: number): boolean\n  chance: number - chance proportional to maxChances. maxChances: number - maximum number of chances. returns: boolean - true or false for settled chance.  nextBoolean Generates a random boolean value.\n public static nextBoolean(): boolean\n  returns: boolean - random boolean.  Examples let value1 = RandomBoolean.nextBoolean() // Possible result: True let value2 = RandomBoolean.chance(1,3) // Possible result: False  ","description":"Random generator for boolean values.\n","image":null,"permalink":"/node/commons/random/random_boolean/","subtitle":null,"tags":null,"title":"RandomBoolean"},{"content":"Description The RandomBoolean class allows you to generate random boolean values.\nStatic methods chance Calculates \u0026ldquo;chance\u0026rdquo; out of \u0026ldquo;max chances\u0026rdquo;. Example: 1 chance out of 3 chances (or 33.3%)\n static chance(chance: float, maxChances: float): bool\n  chance: float - a chance proportional to maxChances. maxChances: float - a maximum number of chances returns: bool - true or false for settled chance  next_boolean Generates a random boolean value.\n static next_boolean(): bool\n  returns: bool - a random boolean.  Examples value1 = RandomBoolean.next_boolean() # Possible result: True value2 = RandomBoolean.chance(1,3) # Possible result: False ","description":"Random generator for boolean values.\n","image":null,"permalink":"/python/commons/random/random_boolean/","subtitle":null,"tags":null,"title":"RandomBoolean"},{"content":"Description The RandomDateTime class allows you to generate random dates.\nImportant points:\n Month must be in 1..12 format.  Methods NextDate Generates a random Date in the range [\u0026lsquo;minYear\u0026rsquo;, \u0026lsquo;maxYear\u0026rsquo;]. This method generate dates without time (or time set to 00:00:00)\n (c *TRandomDateTime) NextDate(min time.Time, max time.Time) time.Time\n  min: time.Time - (optional) minimum range value max: time.Time - max range value returns: time.Time - random Date value.  NextDateTime Generates a random Date and time in the range [\u0026lsquo;minYear\u0026rsquo;, \u0026lsquo;maxYear\u0026rsquo;]. This method generate dates without time (or time set to 00:00:00)\n (c *TRandomDateTime) NextDateTime(min time.Time, max time.Time) time.Time\n  min: time.Time - (optional) minimum range value max: time.Time - max range value returns: time.Time - random Date and time value.  UpdateDateTime Updates (drifts) a Date value within specified range defined\n (c *TRandomDateTime) UpdateDateTime(value time.Time, interval int64) time.Time\n  value: time.Time - Date value to drift. range: int64 - (optional) range in milliseconds. Default: 10 days returns: time.Time - updated DateTime  Examples value1 := RandomDateTime.nextDate(time.Parse(shortForm, \u0026#34;2007-Jan-01\u0026#34;), time.Parse(shortForm, \u0026#34;2010-Jan-01\u0026#34;)); // Possible result: 2008-01-03 value2 := RandomDateTime.nextDateTime(time.Parse(shortForm, \u0026#34;2006-Jan-01\u0026#34;), time.Parse(shortForm, \u0026#34;2017-Jan-01\u0026#34;)); // Possible result: 2007-03-11 11:20:32 value3 := RandomDateTime.updateDateTime(time.Parse(shortForm, \u0026#34;2010-Jan-01\u0026#34;), ); // Possible result: 2010-02-05 11:33:23  ","description":"Random generator for Date time values.\n","image":null,"permalink":"/golang/commons/random/random_date_time/","subtitle":null,"tags":null,"title":"RandomDateTime"},{"content":"Description The RandomDateTime class allows you to generate random dates.\nImportant points:\n Month must be in 1..12 format.  Static methods NextDate Generates a random DateTime in the range [\u0026lsquo;2000, 1, 1\u0026rsquo;, \u0026lsquo;maxYear\u0026rsquo;]. This method generates dates without time(or time set to 00:00:00)\n public static DateTime NextDate(DateTime max)\n  max: DateTime - max range value returns: DateTime - random DateTime value.  NextDate Generates a random DateTime in the range [\u0026lsquo;minYear\u0026rsquo;, \u0026lsquo;maxYear\u0026rsquo;]. This method generate dates without time(or time set to 00:00:00)\n public static DateTime NextDate(DateTime min, DateTime max)\n  min: DateTime - (optional) minimum range value max: DateTime - max range value returns: DateTime - random DateTime value.  NextDateTime Generates a random DateTime and time in the range [\u0026lsquo;2000, 1, 1\u0026rsquo;, \u0026lsquo;maxYear\u0026rsquo;]. This method generate dates without time(or time set to 00:00:00)\n public static DateTime NextDateTime(DateTime max)\n  max: DateTime - max range value returns: DateTime - random DateTime and time value.  NextDateTime Generates a random DateTime and time in the range [\u0026lsquo;minYear\u0026rsquo;, \u0026lsquo;maxYear\u0026rsquo;]. This method generate dates without time(or time set to 00:00:00)\n public static DateTime NextDateTime(DateTime min, DateTime max)\n  min: DateTime - (optional) minimum range value max: DateTime - max range value returns: DateTime - random DateTime and time value.  NextTime Generates a random TimeSpan in the range [\u0026lsquo;0\u0026rsquo;, \u0026lsquo;maxTime\u0026rsquo;].\n public static TimeSpan NextTime(long max)\n  max: long - max range value returns: TimeSpan - random TimeSpan value.  NextTime Generates a random TimeSpan in the range [\u0026lsquo;minTime\u0026rsquo;, \u0026lsquo;maxTime\u0026rsquo;].\n public static TimeSpan NextTime(long min, long max)\n  min: long - minimum range value max: long - max range value returns: TimeSpan - random TimeSpan value.  UpdateDateTime Updates (drifts) a DateTime value.\n public static DateTime UpdateDateTime(DateTime value)\n  value: DateTime - DateTime value to drift. returns: DateTime - updated ZonedDateTime and time value.  UpdateDateTime Updates (drifts) a ZonedDateTime value within a specified range.\n public static DateTime UpdateDateTime(DateTime value, long range)\n  value: DateTime - DateTime value to drift. range: long - (optional) range in milliseconds. Default: 10 days returns: DateTime - updated DateTime and time value.  Examples var value1 = RandomDateTime.NextDate(2010, 0); // Possible result: 2008-01-03 var value2 = RandomDateTime.NextDateTime(2017, 0);// Possible result: 20017-03-11 11:20:32  ","description":"Random generator for DateTime time values.\n","image":null,"permalink":"/net/commons/random/random_date_time/","subtitle":null,"tags":null,"title":"RandomDateTime"},{"content":"Description The RandomDateTime class allows you to generate random dates.\nImportant points:\n Month must be in 1..12 format.  Static methods nextDate Generates a random Date in the range [\u0026lsquo;minYear\u0026rsquo;, \u0026lsquo;maxYear\u0026rsquo;]. This method generates dates without time (or time set to 00:00:00)\n public static nextDate(min: Date, max: Date = null): Date\n  min: Date - (optional) minimum range value. max: Date - max range value. returns: Date - random Date value.  nextDateTime Generates a random Date and time in the range [\u0026lsquo;minYear\u0026rsquo;, \u0026lsquo;maxYear\u0026rsquo;]. This method generates dates without time (or time set to 00:00:00)\n public static nextDateTime(min: Date, max: Date = null): Date\n  min: Date - (optional) minimum range value max: Date - max range value returns: Date - random Date and time value.  updateDateTime Updates (drifts) a Date value within specified range.\n public static updateDateTime(value: Date, range: number = null): Date\n  value: Date - Date value to drift. range: number - (optional) range in milliseconds. Default: 10 days returns: Date - updated DateTime  Examples let value1 = RandomDateTime.nextDate(new Date(2010,0,1)); // Possible result: 2008-01-03 let value2 = RandomDateTime.nextDateTime(new Date(2017,0.1));// Possible result: 2007-03-11 11:20:32 let value3 = RandomDateTime.updateDateTime(new Date(2010,1,2));// Possible result: 2010-02-05 11:33:23  ","description":"Random generator for Date time values.\n","image":null,"permalink":"/node/commons/random/random_date_time/","subtitle":null,"tags":null,"title":"RandomDateTime"},{"content":"Description The RandomDateTime class allows you to generate random dates.\nImportant points:\n Month must be in 1..12 format.  Static methods next_date Generates a random Date in the range [\u0026lsquo;minYear\u0026rsquo;, \u0026lsquo;maxYear\u0026rsquo;]. This method generate dates without time (or time set to 00:00:00)\n static next_date(min_year: datetime, max_year: datetime = None): datetime\n  min_year: datetime - (optional) minimum range value max_year: datetime - max range value returns: datetime - a random Date value.  next_date_time Generates a random Date and time in the range [\u0026lsquo;minYear\u0026rsquo;, \u0026lsquo;maxYear\u0026rsquo;]. This method generate dates without time (or time set to 00:00:00)\n static next_datetime(min_year: datetime, max_year: datetime = None): datetime\n  min_year: datetime - (optional) minimum range value max_year: datetime = None - max range value returns: datetime - a random Date and time value.  update_datetime Updates (drifts) a Date value within specified range defined\n static update_datetime(value: datetime, range: Union[int, float] = None): datetime\n  value: datetime - a Date value to drift. range: Union[int, float] = None - (optional) a range in milliseconds. Default: 10 days returns: datetime - an updated DateTime  Examples import datetime value1 = RandomDateTime.next_date(datetime.datetime(2010,1,1)) # Possible result: 2008-01-03 value2 = RandomDateTime.next_datetime(datetime.datetime(2017,1,1)) # Possible result: 2007-03-11 11:20:32 value3 = RandomDateTime.update_datetime(datetime.datetime(2010,1,2)) # Possible result: 2010-02-05 11:33:23 ","description":"Random generator for Date time values.\n","image":null,"permalink":"/python/commons/random/random_date_time/","subtitle":null,"tags":null,"title":"RandomDateTime"},{"content":"Description The RandomDouble class allows you to generate random double values.\nMethods NextDouble Generates a random double value in the range [\u0026lsquo;minYear\u0026rsquo;, \u0026lsquo;maxYear\u0026rsquo;].\n (c *TRandomDouble) NextDouble(min float64, max float64) float64\n  min: float64 - (optional) minimum range value max: float64 - max range value returns: float64 - random double value.  UpdateDouble Updates (drifts) a double value within specified range defined\n (c *TRandomDouble) UpdateDouble(value float64, interval float64) float64\n  value: float64 - double value to drift. interval: float64 - (optional) range. Default: 10% of the value returns: float64 - updated double value.  Examples value1 := RandomDouble.nextDouble(5, 10); // Possible result: 7.3 value2 := RandomDouble.nextDouble(10); // Possible result: 3.7 value3 := RandomDouble.updateDouble(10, 3); // Possible result: 9.2  ","description":"Random generator for double values.\n","image":null,"permalink":"/golang/commons/random/random_double/","subtitle":null,"tags":null,"title":"RandomDouble"},{"content":"Description The RandomDouble class allows you to generate random double values.\nStatic methods NextDouble Generates a random double value in the range to \u0026ldquo;max\u0026rdquo;.\n public static double NextDouble(double maxValue)\n  maxValue: double - max range value returns: double - random double value.  NextDouble Generates a random double value in the range [\u0026lsquo;minYear\u0026rsquo;, \u0026lsquo;maxYear\u0026rsquo;].\n public static double NextDouble(double minValue, double maxValue)\n  minValue: double - (optional) minimum range value maxValue: double - max range value returns: double - random double value.  UpdateDouble Updates (drifts) a double value without a defined range.\n public static double UpdateDouble(double value)\n  value: double - double value to drift. returns: double - updated double value.  UpdateDouble Updates (drifts) a double value within specified range defined.\n public static double UpdateDouble(double value, double range)\n  value: double - double value to drift. range: double - (optional) range. Default: 10% of the value returns: double - updated double value.  Examples var value1 = RandomDouble.NextDouble(5, 10); // Possible result: 7.3 var value2 = RandomDouble.NextDouble(10); // Possible result: 3.7 var value3 = RandomDouble.UpdateDouble(10, 3); // Possible result: 9.2  ","description":"Random generator for double values.\n","image":null,"permalink":"/net/commons/random/random_double/","subtitle":null,"tags":null,"title":"RandomDouble"},{"content":"Description The RandomDouble class allows you to generate random double values.\nStatic methods nextDouble Generates a random double value in the range [\u0026lsquo;minYear\u0026rsquo;, \u0026lsquo;maxYear\u0026rsquo;].\n public static nextDouble(min: number, max: number = null): number\n  min: number - (optional) minimum range value max: number - max range value returns: number - random double value.  updateDouble Updates (drifts) a double value within specified range.\n public static updateDouble(value: number, range: number = null): number\n  value: number - double value to drift. range: number - (optional) range. Default: 10% of the value. returns: number - updated double value.  Examples let value1 = RandomDouble.nextDouble(5, 10); // Possible result: 7.3 let value2 = RandomDouble.nextDouble(10); // Possible result: 3.7 let value3 = RandomDouble.updateDouble(10, 3); // Possible result: 9.2  ","description":"Random generator for double values.\n","image":null,"permalink":"/node/commons/random/random_double/","subtitle":null,"tags":null,"title":"RandomDouble"},{"content":"Description The RandomDouble class allows you to generate random double values.\nStatic methods next_double Generates a random double value in the range [\u0026lsquo;min_year\u0026rsquo;, \u0026lsquo;max_year\u0026rsquo;].\n static next_double(mmin: float, mmax: float = None): float\n  mmin: float - (optional) minimum range value mmax: float = None - max range value returns: float - a random double value.  update_double Updates (drifts) a double value within specified range defined\n static update_double(value: float, rrange: float = None): float\n  value: float - a double value to drift. rrange: float = None - (optional) a range. Default: 10% of the value returns: float - updated float value.  Examples value1 = RandomDouble.next_double(5, 10) # Possible result: 8.276012024925908 value2 = RandomDouble.next_double(10) # Possible result: 4.558593480049594 ","description":"Random generator for double values.\n","image":null,"permalink":"/python/commons/random/random_double/","subtitle":null,"tags":null,"title":"RandomDouble"},{"content":"Description The RandomFloat class allows you to generate random float values.\nMethods NextFloat Generates a float in the range [\u0026lsquo;min\u0026rsquo;, \u0026lsquo;max\u0026rsquo;]. If \u0026lsquo;max\u0026rsquo; is omitted, then the range will be set to [0, \u0026lsquo;min\u0026rsquo;].\n (c *TRandomFloat) NextFloat(min float32, max float32) float32\n  min: float32 - (minimum value of the float that will be generated. If \u0026lsquo;max\u0026rsquo; is omitted, then \u0026lsquo;max\u0026rsquo; is set to \u0026lsquo;min\u0026rsquo; and \u0026lsquo;min\u0026rsquo; is set to 0. max: float32 - (optional) maximum value of the float that will be generated. Defaults to \u0026lsquo;min\u0026rsquo; if omitted. returns: float32 - generated random float value.  UpdateFloat Updates (drifts) a float value within specified range defined\n (c *TRandomFloat) UpdateFloat(value float32, interval float32) float32\n  value: float32 - float value to drift. range: float32 - (optional) range. Default: 10% of the value returns: float32 - updated float value.  Examples value1 := RandomFloat.nextFloat(5, 10); // Possible result: 7.3 value2 := RandomFloat.nextFloat(10); // Possible result: 3.7 value3 := RandomFloat.updateFloat(10, 3); // Possible result: 9.2  ","description":"Random generator for float values.\n","image":null,"permalink":"/golang/commons/random/random_float/","subtitle":null,"tags":null,"title":"RandomFloat"},{"content":"Description The RandomFloat class allows you to generate random float values.\nStatic methods NextFloat Generates a random float value in the range to \u0026ldquo;max\u0026rdquo;.\n public static float NextFloat(float maxValue)\n  max: float - max range value returns: float - generated random float value.  NextFloat Generates a float in the range [\u0026lsquo;min\u0026rsquo;, \u0026lsquo;max\u0026rsquo;]. If \u0026lsquo;max\u0026rsquo; is omitted, then the range will be set to [0, \u0026lsquo;min\u0026rsquo;].\n public static float NextFloat(float minValue, float maxValue)\n  min: float - (minimum value of the float that will be generated. If \u0026lsquo;max\u0026rsquo; is omitted, then \u0026lsquo;max\u0026rsquo; is set to \u0026lsquo;min\u0026rsquo; and \u0026lsquo;min\u0026rsquo; is set to 0. max: float - (optional) maximum value of the float that will be generated. Defaults to \u0026lsquo;min\u0026rsquo; if omitted. returns: float - generated random float value.  UpdateFloat Updates (drifts) a float value without specified range defined\n public static float UpdateFloat(float value)\n  value: float - float value to drift. returns: float - updated random float value.  UpdateFloat Updates (drifts) a float value within specified range defined\n public static float UpdateFloat(float value, float range)\n  value: float - float value to drift. range: float - (optional) range. Default: 10% of the value returns: float - updated float value.  Examples var value1 = RandomFloat.NextFloat(5, 10); // Possible result: 7.3 var value2 = RandomFloat.NextFloat(10); // Possible result: 3.7 var value3 = RandomFloat.UpdateFloat(10, 3); // Possible result: 9.2  ","description":"Random generator for float values.\n","image":null,"permalink":"/net/commons/random/random_float/","subtitle":null,"tags":null,"title":"RandomFloat"},{"content":"Description The RandomFloat class allows you to generate random float values.\nStatic methods nextFloat Generates a float in the range [\u0026lsquo;min\u0026rsquo;, \u0026lsquo;max\u0026rsquo;]. If \u0026lsquo;max\u0026rsquo; is omitted, then the range will be set to [0, \u0026lsquo;min\u0026rsquo;].\n public static nextFloat(min: number, max: number = null): number\n  min: number - (minimum value of the float that will be generated.\nIf \u0026lsquo;max\u0026rsquo; is omitted, then \u0026lsquo;max\u0026rsquo; is set to \u0026lsquo;min\u0026rsquo; and \u0026lsquo;min\u0026rsquo; is set to 0. max: number - (optional) maximum value of the float that will be generated. Defaults to \u0026lsquo;min\u0026rsquo; if omitted. returns: number - generated random float value.  updateFloat Updates (drifts) a float value within specified range.\n public static updateFloat(value: number, range: number = null): number\n  value: number - float value to drift. range: number - (optional) range. Default: 10% of the value. returns: number - updated float value.  Examples let value1 = RandomFloat.nextFloat(5, 10); // Possible result: 7.3 let value2 = RandomFloat.nextFloat(10); // Possible result: 3.7 let value3 = RandomFloat.updateFloat(10, 3); // Possible result: 9.2  ","description":"Random generator for float values.\n","image":null,"permalink":"/node/commons/random/random_float/","subtitle":null,"tags":null,"title":"RandomFloat"},{"content":"Description The RandomFloat class allows you to generate random float values.\nStatic methods next_float Generates a float in the range [\u0026lsquo;min\u0026rsquo;, \u0026lsquo;max\u0026rsquo;]. If \u0026lsquo;max\u0026rsquo; is omitted, then the range will be set to [0, \u0026lsquo;min\u0026rsquo;].\n static next_float(min: float, max: float = None): float\n  min: float - (minimum value of the float that will be generated. If \u0026lsquo;max\u0026rsquo; is omitted, then \u0026lsquo;max\u0026rsquo; is set to \u0026lsquo;min\u0026rsquo; and \u0026lsquo;min\u0026rsquo; is set to 0. max: float = None - (optional) maximum value of the float that will be generated. Defaults to \u0026lsquo;min\u0026rsquo; if omitted. returns: float - generated random float value.  update_float Updates (drifts) a float value within specified range defined\n static update_float(value: float, range: float = None): float\n  value: float - a float value to drift. range: float = None - (optional) a range. Default: 10% of the value returns: float - updated float value.  Examples value1 = RandomFloat.next_float(5, 10) # Possible result: 8.109282778264653 value2 = RandomFloat.next_float(10) # Possible result: 5.281760648272185 value3 = RandomFloat.update_float(10, 3) # Possible result: 7.731874405844179 ","description":"Random generator for float values.\n","image":null,"permalink":"/python/commons/random/random_float/","subtitle":null,"tags":null,"title":"RandomFloat"},{"content":"Description The RandomInteger class allows you to generate random integer values.\nMethods NextInteger Generates a integer in the range [\u0026lsquo;min\u0026rsquo;, \u0026lsquo;max\u0026rsquo;]. If \u0026lsquo;max\u0026rsquo; is omitted, then the range will be set to [0, \u0026lsquo;min\u0026rsquo;].\n (c *TRandomInteger) NextInteger(min int, max int) int\n  min: int - minimum value of the integer that will be generated. If \u0026lsquo;max\u0026rsquo; is omitted, then \u0026lsquo;max\u0026rsquo; is set to \u0026lsquo;min\u0026rsquo; and \u0026lsquo;min\u0026rsquo; is set to 0. max: int - (optional) maximum value of the float that will be generated. Defaults to \u0026lsquo;min\u0026rsquo; if omitted. returns: int - generated random integer value.  UpdateInteger Updates (drifts) an integer value within specified range defined\n (c *TRandomInteger) UpdateInteger(value int, interval int) int\n  value: int - integer value to drift. interval: int - (optional) range. Default: 10% of the value returns: int - updated integer value.  Examples value1 := RandomInteger.nextInteger(5, 10); // Possible result: 7 value2 := RandomInteger.nextInteger(10); // Possible result: 3 value3 := RandomInteger.updateInteger(10, 3); // Possible result: 9  ","description":"Random generator for integer values.\n","image":null,"permalink":"/golang/commons/random/random_integer/","subtitle":null,"tags":null,"title":"RandomInteger"},{"content":"Description The RandomInteger class allows you to generate random integer values.\nMethods NextLong Generates a integer in the range [\u0026lsquo;min\u0026rsquo;, \u0026lsquo;max\u0026rsquo;]. If \u0026lsquo;max\u0026rsquo; is omitted, then the range will be set to [0, \u0026lsquo;min\u0026rsquo;].\n (c *TRandomLong) NextLong(min int64, max int64) int64\n  min: int64 - minimum value of the integer that will be generated. If \u0026lsquo;max\u0026rsquo; is omitted, then \u0026lsquo;max\u0026rsquo; is set to \u0026lsquo;min\u0026rsquo; and \u0026lsquo;min\u0026rsquo; is set to 0. max: int64 - maximum value of the int that will be generated. Defaults to \u0026lsquo;min\u0026rsquo; if omitted. returns: int64 - generated random integer value.  UpdateInteger Updates (drifts) a integer value within specified range defined\n (c *TRandomLong) UpdateLong(value int64, interval int64) int64\n  value: int64 - a integer value to drift. interval: int64 - (optional) a range. Default: 10% of the value returns: int64 - updated integer value.  Examples value1 := RandomLong.nextLong(5, 10); // Possible result: 7 value2 := RandomLong.nextLong(10); // Possible result: 3 value3 := RandomLong.updateLong(10, 3); // Possible result: 9  ","description":"Random generator for integer values.\n","image":null,"permalink":"/golang/commons/random/random_long/","subtitle":null,"tags":null,"title":"RandomInteger"},{"content":"Description The RandomInteger class allows you to generate random integer values.\nStatic methods NextInteger Generates a random integer value in the range to \u0026ldquo;max\u0026rdquo;.\n public static int NextInteger(int maxValue)\n  maxValue: int -max range value returns: int - generated random integer value.  NextInteger Generates a integer in the range [\u0026lsquo;min\u0026rsquo;, \u0026lsquo;max\u0026rsquo;]. If \u0026lsquo;max\u0026rsquo; is omitted, then the range will be set to [0, \u0026lsquo;min\u0026rsquo;].\n public static int NextInteger(int minValue, int maxValue)\n  min: int - minimum value of the integer that will be generated. If \u0026lsquo;max\u0026rsquo; is omitted, then \u0026lsquo;max\u0026rsquo; is set to \u0026lsquo;min\u0026rsquo; and \u0026lsquo;min\u0026rsquo; is set to 0. max: int - (optional) maximum value of the float that will be generated. Defaults to \u0026lsquo;min\u0026rsquo; if omitted. returns: int - generated random integer value.  Sequence Generates a random sequence of integers starting from 0 like: [0,1,2,3\u0026hellip;??]\n public static List\u0026lt;int\u0026gt; Sequence(int size)\n  size: int - size of sequence returns: List\u0026lt;int\u0026gt; - generated array of integers.  Sequence Generates a random sequence of integers starting from 0 like: [0,1,2,3\u0026hellip;??]\n public static List/ Sequence(int min, int max)\n  min: int - minimum value of the integer that will be generated. If \u0026lsquo;max\u0026rsquo; is omitted, then \u0026lsquo;max\u0026rsquo; is set to \u0026lsquo;min\u0026rsquo; and \u0026lsquo;min\u0026rsquo; is set to 0. max: int - (optional) maximum value of the integer that will be generated. Defaults to \u0026lsquo;min\u0026rsquo; if omitted. returns: List\u0026lt;int\u0026gt; - generated array of integers.  UpdateInteger Updates (drifts) an integer value without a defined range.\n public static int UpdateInteger(int value)\n  value: int - integer value to drift. returns: int - updated integer value.  UpdateInteger Updates (drifts) an integer value within specified range defined.\n public static int UpdateInteger(int value, int range)\n  value: int - integer value to drift. range: int - (optional) range. Default: 10% of the value returns: int - updated integer value.  Examples var value1 = RandomInteger.NextInteger(5, 10); // Possible result: 7 var value2 = RandomInteger.NextInteger(10); // Possible result: 3 var value3 = RandomInteger.UpdateInteger(10, 3); // Possible result: 9  ","description":"Random generator for integer values.\n","image":null,"permalink":"/net/commons/random/random_integer/","subtitle":null,"tags":null,"title":"RandomInteger"},{"content":"Description The RandomInteger class allows you to generate random long values.\nStatic methods NextLong Generates a random long value in the range to \u0026ldquo;max\u0026rdquo;.\n public static long NextLong(long maxValue)\n  maxValue: long -max range value returns: long - generated random long value.  NextLong Generates a random long value in the range [\u0026ldquo;min\u0026rdquo;, \u0026ldquo;max\u0026rdquo;].\n public static long NextInteger(long minValue, long maxValue)\n  min: long - minimum value of the long that will be generated. If \u0026lsquo;max\u0026rsquo; is omitted, then \u0026lsquo;max\u0026rsquo; is set to \u0026lsquo;min\u0026rsquo; and \u0026lsquo;min\u0026rsquo; is set to 0. max: long - (optional) maximum value of the float that will be generated. Defaults to \u0026lsquo;min\u0026rsquo; if omitted. returns: long - generated random long value.  Sequence Generates a random sequence of longs starting from 0, like: [0,1,2,3\u0026hellip;??]\n public static List\u0026lt;long\u0026gt; Sequence(long size)\n  size: long - size of the sequence returns: List\u0026lt;long\u0026gt; - generated array of longs.  Sequence Generates a random sequence of longs starting from 0, like: [0,1,2,3\u0026hellip;??]\n public static List/ Sequence(long min, long max)\n  min: long - minimum value of the long that will be generated. If \u0026lsquo;max\u0026rsquo; is omitted, then \u0026lsquo;max\u0026rsquo; is set to \u0026lsquo;min\u0026rsquo; and \u0026lsquo;min\u0026rsquo; is set to 0. max: long - (optional) maximum value of the long that will be generated. Defaults to \u0026lsquo;min\u0026rsquo; if omitted. returns: List\u0026lt;long\u0026gt; - generated array of longs.  UpdateInteger Updates (drifts) a long value without a defined range.\n public static long UpdateInteger(long value)\n  value: long - long value to drift. returns: long - updated long value.  UpdateInteger Updates (drifts) a long value within a specified range.\n public static long UpdateInteger(long value, long range)\n  value: long - long value to drift. range: long - (optional) range. Default: 10% of the value returns: long - updated long value.  Examples var value1 = RandomLong.NextLong(5, 10); // Possible result: 7 var value2 = RandomLong.NextLong(10); // Possible result: 3 var value3 = RandomLong.UpdateLong(10, 3); // Possible result: 9  ","description":"Random generator for long values.\n","image":null,"permalink":"/net/commons/random/random_long/","subtitle":null,"tags":null,"title":"RandomInteger"},{"content":"Description The RandomInteger class allows you to generate random integer values.\nStatic methods nextInteger Generates an integer in the range [\u0026lsquo;min\u0026rsquo;, \u0026lsquo;max\u0026rsquo;]. If \u0026lsquo;max\u0026rsquo; is omitted, then the range will be set to [0, \u0026lsquo;min\u0026rsquo;].\n public static nextInteger(min: number, max: number = null): number\n  min: number - minimum value of the integer that will be generated. If \u0026lsquo;max\u0026rsquo; is omitted, then \u0026lsquo;max\u0026rsquo; is set to \u0026lsquo;min\u0026rsquo; and \u0026lsquo;min\u0026rsquo; is set to 0. max: number - (optional) maximum value of the float that will be generated. Defaults to \u0026lsquo;min\u0026rsquo; if omitted. returns: number - generated random integer value.  updateInteger Updates (drifts) a integer value within specified range.\n public static updateInteger(value: number, range: number = null): number\n  value: number - integer value to drift. range: number - (optional) range. Default: 10% of the value returns: number - updated integer value.  Examples let value1 = RandomInteger.nextInteger(5, 10); // Possible result: 7 let value2 = RandomInteger.nextInteger(10); // Possible result: 3 let value3 = RandomInteger.updateInteger(10, 3); // Possible result: 9  ","description":"Random generator for integer values.\n","image":null,"permalink":"/node/commons/random/random_integer/","subtitle":null,"tags":null,"title":"RandomInteger"},{"content":"Description The RandomInteger class allows you to generate random integer values.\nStatic methods next_integer Generates a integer in the range [\u0026lsquo;min\u0026rsquo;, \u0026lsquo;max\u0026rsquo;]. If \u0026lsquo;max\u0026rsquo; is omitted, then the range will be set to [0, \u0026lsquo;min\u0026rsquo;].\n static next_integer(min: int, max: int = None): int\n  min: int - minimum value of the integer that will be generated. If \u0026lsquo;max\u0026rsquo; is omitted, then \u0026lsquo;max\u0026rsquo; is set to \u0026lsquo;min\u0026rsquo; and \u0026lsquo;min\u0026rsquo; is set to 0. max: int = None - (optional) maximum value of the float that will be generated. Defaults to \u0026lsquo;min\u0026rsquo; if omitted. returns: int - generated random integer value.  update_integer Updates (drifts) a integer value within specified range defined\n static update_integer(value: int, range: int = None): int\n  value: int - a integer value to drift. range: int = None - (optional) a range. Default: 10% of the value returns: int - updated integer value.  Examples value1 = RandomInteger.next_integer(5, 10) # Possible result: 5 value2 = RandomInteger.next_integer(10) # Possible result: 4 value3 = RandomInteger.update_integer(10, 3) # Possible result: 12 ","description":"Random generator for integer values.\n","image":null,"permalink":"/python/commons/random/random_integer/","subtitle":null,"tags":null,"title":"RandomInteger"},{"content":"Description The class RandomString allows you to generate random strings.\nMethods Distort Distorts a string by randomly replacing characters in it.\n (c *TRandomString) Distort(value string) string\n  value: string - string to distort. returns: string - distored string.  NextAlphaChar Generates random alpha characted [A-Za-z]\n (c *TRandomString) NextAlphaChar() byte\n  returns: byte - random characted.  NextString Generates a random string, consisting of upper and lower case letters (of the English alphabet), digits (0-9), and symbols (\u0026quot;_,.:-/.[].{},#-!,$=%.+^.\u0026amp;*-() \u0026ldquo;).\n (c *TRandomString) NextString(minLength int, maxLength int) string\n  minLength: int - (optional) minimum string length. maxLength: int - maximum string length. returns: string - random string.  Pick Picks a random string from an array of strings.\n (c *TRandomString) Pick(values []string) string\n  values: []string - Picks a random character from an array of strings. returns: string - randomly picked char.  PickChar Picks a random character from a string.\n (c *TRandomString) PickChar(values string) byte\n  values: string - string to pick a char from returns: byte - randomly picked char.  Examples value1 := RandomString.pickChar(\u0026#34;ABC\u0026#34;); // Possible result: \u0026#34;C\u0026#34; value2 := RandomString.pick([\u0026#34;A\u0026#34;,\u0026#34;B\u0026#34;,\u0026#34;C\u0026#34;]); // Possible result: \u0026#34;gBW\u0026#34;  ","description":"Random generator for string values.\n","image":null,"permalink":"/golang/commons/random/random_string/","subtitle":null,"tags":null,"title":"RandomString"},{"content":"Description The class RandomString allows you to generate random strings.\nStatic methods Distort Distorts a string by randomly replacing characters in it.\n public static string Distort(string value)\n  value: string - string to distort. returns: string - distored string.  NextAlphaChar Generates random alpha characted [A-Za-z]\n public static string NextAlphaChar()\n  returns: string - random characted.  NextString Generates a random string, consisting of upper and lower case letters (of the English alphabet), digits (0-9), and symbols (\u0026quot;_,.:-/.[].{},#-!,$=%.+^.\u0026amp;*-() \u0026ldquo;).\n public static string NextString(int minLength, int maxLength)\n  minLength: int - (optional) minimum string length. maxLength: int - maximum string length. returns: string - random string.  Pick Picks a random character from a strings.\n public static string Pick(string values)\n   values: string - string to pick a char from string\n  returns: string - randomly picked char.\n  Pick Picks a random character from an array of strings.\n public static string Pick(string[] values)\n  values: string - string to pick from array strings returns: string - randomly picked string.  Examples var value1 = RandomString.Pick(\u0026#34;ABC\u0026#34;); // Possible result: \u0026#34;C\u0026#34; var value2 = RandomString.Pick(new String {\u0026#34;A\u0026#34;,\u0026#34;B\u0026#34;,\u0026#34;C\u0026#34;}); // Possible result: \u0026#34;B\u0026#34;  ","description":"Random generator for string values.\n","image":null,"permalink":"/net/commons/random/random_string/","subtitle":null,"tags":null,"title":"RandomString"},{"content":"Description The class RandomString allows you to generate random strings.\nStatic methods distort Distorts a string by randomly replacing characters in it.\n public static distort(value: string): string\n  value: string - string to distort. returns: string - distorted string.  nextAlphaChar Generates a random alpha characted [A-Za-z]\n public static nextAlphaChar(): string\n  returns: string - random characted.  nextString Generates a random string, consisting of upper and lower case letters (of the English alphabet), digits (0-9), and symbols (\u0026quot;_,.:-/.[].{},#-!,$=%.+^.\u0026amp;*-() \u0026ldquo;).\n public static nextString(minLength: number, maxLength: number): string\n  minLength: number - (optional) minimum string length. maxLength: number - maximum string length. returns: string - random string.  pick Picks a random string from an array of strings.\n public static pick(values: string[]): string\n  values: string[] - Picks a random character from an array of strings. returns: string - randomly picked char.  pickChar Picks a random character from a string.\n public static pickChar(values: string): string\n  values: string - string to pick a char from. returns: string - randomly picked char.  Examples let value1 = RandomString.pickChar(\u0026#34;ABC\u0026#34;); // Possible result: \u0026#34;C\u0026#34; let value2 = RandomString.pick([\u0026#34;A\u0026#34;,\u0026#34;B\u0026#34;,\u0026#34;C\u0026#34;]); // Possible result: \u0026#34;gBW\u0026#34;  ","description":"Random generator for string values.\n","image":null,"permalink":"/node/commons/random/random_string/","subtitle":null,"tags":null,"title":"RandomString"},{"content":"Description The class RandomString allows you to generate random strings.\nStatic methods distort Distorts a string by randomly replacing characters in it.\n static distort(value: str): str\n  value: str - a string to distort. returns: str - a distored string.  next_alpha_char Generates random alpha characted [A-Za-z]\n static next_alpha_char(): str\n  returns: str - a random characted.  next_string Generates a random string, consisting of upper and lower case letters (of the English alphabet), digits (0-9), and symbols (\u0026quot;_,.:-/.[].{},#-!,$=%.+^.\u0026amp;*-() \u0026ldquo;).\n static next_string(min_size: int, min_size: int): str\n  min_size: int - (optional) minimum string length. min_size: int - maximum string length. returns: str - a random string.  pick Picks a random string from an array of string.\n static pick(values: List[str]): str\n  values: List[str] - Picks a random character from an array of string. returns: str - a randomly picked char.  pick_char Picks a random character from a string.\n static pick_char(values: str): str\n  values: str - picks a random character from a string. returns: str - a randomly picked char.  Examples value1 = RandomString.pick([\u0026#34;A\u0026#34;,\u0026#34;B\u0026#34;,\u0026#34;C\u0026#34;]) # Possible result: \u0026#34;A\u0026#34; ","description":"Random generator for string values.\n","image":null,"permalink":"/python/commons/random/random_string/","subtitle":null,"tags":null,"title":"RandomString"},{"content":"Description The RandomText class allows you to generate different types of randomt texts. The options included are colors, names, nouns, adjectives, verbs, phrases, full names, words, phone numbers, email addresses, and texts.\nMethods Adjective Generates a random adjective. The result value is capitalized.\n (c *TRandomText) Adjective() string\n  returns: string - random adjective.  Color Generates a random color name. The result value is capitalized.\n (c *TRandomText) Color() string\n  returns: string - random color name.  Email Generates a random email address.\n (c *TRandomText) Email() string\n  returns: string - random email address.  FullName Generates a random person\u0026rsquo;s name which has the following structure \u0026lt;optional prefix\u0026gt; \u0026lt;first name\u0026gt; \u0026lt;second name\u0026gt; \u0026lt;optional suffix\u0026gt;\n (c *TRandomText) FullName() string\n  returns: string - random name.  Phone Generates a random phone number. The phone number has the format: (XXX) XXX-YYYY\n (c *TRandomText) Phone() string\n  returns: string - a random phone number.  Phrase Generates a random phrase which consists of few words separated by spaces. The first word is capitalized, others are not.\n (c *TRandomText) Phrase(min int, max int) string\n  minLength: int - (optional) minimum string length. maxLength: int - maximum string length. returns: string - random phrase.  Text Generates a random text, consisting of first names, last names, colors, stuffs, adjectives, verbs, and punctuation marks.\n (c *TRandomText) Text(min int, max int) string\n  minLength: int - minimum amount of words to generate. The text will contain \u0026lsquo;minSize\u0026rsquo; words if \u0026lsquo;maxSize\u0026rsquo; is omitted. maxLength: int - (optional) maximum amount of words to generate. returns: string - random text.  Verb Generates a random verb. The result value is capitalized.\n (c *TRandomText) Verb() string\n  returns: string - random verb.  Word Generates a random word from available first names, last names, colors, stuffs, adjectives, or verbs.\n (c *TRandomText) Word() string\n  returns: string - random word.  Words Generates a random word from available first names, last names, colors, stuffs, adjectives, or verbs.\n (c *TRandomText) Words(min int, max int) string\n  min: int - (optional) minimum number of words. max: int - maximum number of words. returns: string - random text.  Examples value1 := RandomText.FullName(); // Possible result: \u0026#34;Segio\u0026#34; value2 := RandomText.Verb(); // Possible result: \u0026#34;Run\u0026#34; value3 := RandomText.Text(50); // Possible result: \u0026#34;Run jorge. Red high scream?\u0026#34;  ","description":"Random generator for various text types such as names, addresses or phone numbers.\n","image":null,"permalink":"/golang/commons/random/random_text/","subtitle":null,"tags":null,"title":"RandomText"},{"content":"Description The RandomText class allows you to generate different types of random texts. The options included are colors, names, nouns, adjectives, verbs, phrases, full names, words, phone numbers, email addresses, and texts.\nStatic methods Adjective Generates a random adjective. The result value is capitalized.\n public static string Adjective()\n  returns: string - random adjective.  Color Generates a random color name. The result value is capitalized.\n public static string Color()\n  returns: string - random color name.  Email Generates a random email address.\n public static string Email()\n  returns: string - random email address.  Name Generates a random person\u0026rsquo;s name, which has the following structure \u0026lt;optional prefix\u0026gt; \u0026lt;first name\u0026gt; \u0026lt;second name\u0026gt; \u0026lt;optional suffix\u0026gt;\n public static string Name()\n  returns: string - random name.  Phone Generates a random phone number. The phone number has the format: (XXX) XXX-YYYY\n public static string Phone()\n  returns: string - random phone number.  Phrase Generates a random phrase which consists of a few words separated by spaces. The first word is capitalized, the others are not.\n public static string Phrase(int size)\n  size: int - (optional) minimum string length. returns: string - random phrase.  Phrase Generates a random phrase which consists of few words separated by spaces. The first word is capitalized, the others are not.\n public static string Phrase(int minSize, int maxSize)\n  minSize: int - (optional) minimum string length. maxSize: int - maximum string length. returns: string - random phrase.  Stuff Generates a random noun. The result value is capitalized.\n public static string Stuff()\n  returns: string - random noun.  Text Generates a random text, consisting of first names, last names, colors, stuffs, adjectives, verbs, and punctuation marks.\n public static string Text(int size)\n  size: int - size of text. returns: string - random text.  Text Generates a random text, consisting of first names, last names, colors, stuffs, adjectives, verbs, and punctuation marks.\n public static string Text(int minSize, int maxSize)\n  minSize: int - minimum amount of words to generate. Text will contain \u0026lsquo;minSize\u0026rsquo; words if \u0026lsquo;maxSize\u0026rsquo; is omitted. maxSize: int - (optional) maximum amount of words to generate. returns: string - random text.  Verb Generates a random verb. The result value is capitalized.\n public static string Verb()\n  returns: string - random verb.  Word Generates a random word from available first names, last names, colors, stuffs, adjectives, or verbs.\n public static string Word()\n  returns: string - random word.  Words Generates a random word from available first names, last names, colors, stuffs, adjectives, or verbs.\n public static string Words(int min, int max)\n  min: int - (optional) minimum number of words. max: int - maximum number of words. returns: string - random text.  Examples var value1 = RandomText.Name(); // Possible result: \u0026#34;Sergio\u0026#34; var value2 = RandomText.Verb(); // Possible result: \u0026#34;Run\u0026#34; var value3 = RandomText.Text(50); // Possible result: \u0026#34;Run jorge. Red high scream?\u0026#34;  ","description":"Random generator for various text types such as names, addresses or phone numbers.\n","image":null,"permalink":"/net/commons/random/random_text/","subtitle":null,"tags":null,"title":"RandomText"},{"content":"Description The RandomText class allows you to generate different types of randomt texts. The options included are colors, names, nouns, adjectives, verbs, phrases, full names, words, phone numbers, email addresses, and texts.\nStatic methods adjective Generates a random adjective. The result value is capitalized.\n public static adjective(): string\n  returns: string - random adjective.  color Generates a random color name. The result value is capitalized.\n public static color(): string\n  returns: string - random color name.  email Generates a random email address.\n public static email(): string\n  returns: string - random email address.  fullName Generates a random person\u0026rsquo;s name, which has the following structure \u0026lt;optional prefix\u0026gt; \u0026lt;first name\u0026gt; \u0026lt;second name\u0026gt; \u0026lt;optional suffix\u0026gt;\n public static fullName(): string\n  returns: string - random name.  noun Generates a random noun. The result value is capitalized.\n public static noun(): string\n  returns: string - random noun.  phone Generates a random phone number. The phone number has the format: (XXX) XXX-YYYY\n public static phone(): string\n  returns: string - random phone number.  phrase Generates a random phrase which consists of few words separated by spaces. The first word is capitalized, others are not.\n public static phrase(minLength: number, maxLength: number = null): string\n  minLength: number - (optional) minimum string length. maxLength: number - maximum string length. returns: string - random phrase.  text Generates a random text, consisting of first names, last names, colors, stuffs, adjectives, verbs, and punctuation marks.\n public static text(minLength: number, maxLength: number = null): string\n  minLength: number - minimum amount of words to generate. The text will contain \u0026lsquo;minSize\u0026rsquo; words if \u0026lsquo;maxSize\u0026rsquo; is omitted. maxLength: number - (optional) maximum amount of words to generate. returns: string - random text.  verb Generates a random verb. The result value is capitalized.\n public static verb(): string\n  returns: string - random verb.  word Generates a random word from available first names, last names, colors, stuffs, adjectives, or verbs.\n public static word(): string\n  returns: string - random word.  words Generates a random word from available first names, last names, colors, stuffs, adjectives, or verbs.\n public static words(min: number, max: number = null): string\n  min: number - (optional) minimum number of words. max: number - maximum number of words. returns: string - random text.  Examples let value1 = RandomText.name(); // Possible result: \u0026#34;Segio\u0026#34; let value2 = RandomText.verb(); // Possible result: \u0026#34;Run\u0026#34; let value3 = RandomText.Text(50); // Possible result: \u0026#34;Run jorge. Red high scream?\u0026#34;  ","description":"Random generator for various text types such as names, addresses or phone numbers.\n","image":null,"permalink":"/node/commons/random/random_text/","subtitle":null,"tags":null,"title":"RandomText"},{"content":"Description The RandomText class allows you to generate different types of randomt texts. The options included are colors, names, nouns, adjectives, verbs, phrases, full names, words, phone numbers, email addresses, and texts.\nStatic methods adjective Generates a random adjective. The result value is capitalized.\n static adjective(): str\n  returns: str - a random adjective.  color Generates a random color name. The result value is capitalized.\n static color(): str\n  returns: str - a random color name.  email Generates a random email address.\n static email(): str\n  returns: str - a random email address.  full_name Generates a random person\u0026rsquo;s name which has the following structure \u0026lt;optional prefix\u0026gt; \u0026lt;first name\u0026gt; \u0026lt;second name\u0026gt; \u0026lt;optional suffix\u0026gt;\n static full_name(): str\n  returns: str - a random name.  noun Generates a random noun. The result value is capitalized.\n static noun(): str\n  returns: str - a random noun.  phone Generates a random phone number. The phone number has the format: (XXX) XXX-YYYY\n static phone(): str\n  returns: str - a random phone number.  phrase Generates a random phrase which consists of few words separated by spaces. The first word is capitalized, others are not.\n static phrase(min_size: int, max_size: int = None): str\n  min_size: int - (optional) minimum string length. max_size: int - maximum string length. returns: str - a random phrase.  text Generates a random text, consisting of first names, last names, colors, stuffs, adjectives, verbs, and punctuation marks.\n static text(min_size: int, max_size: int = None): str\n  min_size: int - minimum amount of words to generate. Text will contain \u0026lsquo;minSize\u0026rsquo; words if \u0026lsquo;maxSize\u0026rsquo; is omitted. max_size: int - (optional) maximum amount of words to generate. returns: str - a random text.  verb Generates a random verb. The result value is capitalized.\n static verb(): str\n  returns: str - a random verb.  word Generates a random word from available first names, last names, colors, stuffs, adjectives, or verbs.\n static word(): str\n  returns: str - a random word.  words Generates a random word from available first names, last names, colors, stuffs, adjectives, or verbs.\n static words(min_size: int, max_size: int = None): str\n  min_size: int - (optional) a minimum number of words. max_size: int - a maximum number of words. returns: str - a random text.  Examples value1 = RandomText.name() # Possible result: \u0026#34;Sergio\u0026#34; value2 = RandomText.verb() # Possible result: \u0026#34;Run\u0026#34; value3 = RandomText.text(5,20) # Possible result: \u0026#34;Due bela\u0026#34; ","description":"Random generator for various text types such as names, addresses or phone numbers.\n","image":null,"permalink":"/python/commons/random/random_text/","subtitle":null,"tags":null,"title":"RandomText"},{"content":"Description The RecursiveMapConverter class allows you to convert arbitrary values into map objects using extended conversion rules.\nImportant points:\n This class is similar to MapConverter. The difference is that it recursively converts all values stored in objects and arrays.  Instance methods ToMap Converts value into a map object or returns an empty map when the conversion is not possible\n public static IDictionary\u0026lt;string, object\u0026gt; ToMap(object value)\n  value: object - value to convert. returns: IDictionary\u0026lt;string, object\u0026gt; - map object or empty map when the conversion is not supported.  ToMapWithDefault Converts value into map object or returns a given default value when the conversion is not possible\n public static IDictionary\u0026lt;string, object\u0026gt; ToMapWithDefault(object value, IDictionary\u0026lt;string, object\u0026gt; defaultValue)\n  value: object - value to convert. defaultValue: IDictionary\u0026lt;string, object\u0026gt; - default value. returns: IDictionary\u0026lt;string, object\u0026gt; - map object or empty map when the conversion is not supported.  ToNullableMap Converts value into map object or returns null when the conversion is not possible.\n public static IDictionary\u0026lt;string, object\u0026gt; ToNullableMap(object value)\n  value: object - value to convert. returns: IDictionary\u0026lt;string, object\u0026gt; - map object or null when the conversion is not supported.  Examples var value1 = RecursiveMapConverted.ToNullableMap(\u0026#34;ABC\u0026#34;); // Result: null var value2 = RecursiveMapConverted.ToNullableMap({ key: 123 }); // Result: { key: 123 } var result = new List\u0026lt;Object\u0026gt;(); result.Add(1); result.Add(new int[]{2, 3}); var value3 = RecursiveMapConverted.ToNullableMap(result); // Result: { \u0026#34;0\u0026#34;: 1, { \u0026#34;0\u0026#34;: 2, \u0026#34;1\u0026#34;: 3 } } ","description":"The RecursiveMapConverter class allows you to convert arbitrary values into map objects using extended conversion rules.\n","image":null,"permalink":"/net/commons/convert/recursive_map_converter/","subtitle":null,"tags":null,"title":"RecursiveMapConverter"},{"content":"Description The RecursiveMapConverter class allows you to convert arbitrary values into map objects using extended conversion rules.\nImportant points:\n This class is similar to MapConverter. The difference is that it recursively converts all values stored in objects and arrays.  Instance methods toMap Converts a value into a map object or returns an empty map when the conversion is not possible.\n public static toMap(value: any): any\n  value: any - value to convert. returns: any - map object or empty map when the conversion is not supported.  toMapWithDefault Converts a value into a map object or returns default when the conversion is not possible.\n public static toMapWithDefault(value: any, defaultValue: any): any\n  value: any - value to convert. defaultValue: any - default value. returns: any - map object or empty map when the conversion is not supported.  toNullableMap Converts a value into a map object or returns null when the conversion is not possible.\n public static toNullableMap(value: any): any\n  value: any - value to convert. returns: any - map object or null when the conversion is not supported.  Examples let value1 = RecursiveMapConverted.toNullableMap(\u0026#34;ABC\u0026#34;); // Result: null let value2 = RecursiveMapConverted.toNullableMap({ key: 123 }); // Result: { key: 123 } let value3 = RecursiveMapConverted.toNullableMap([1,[2,3]); // Result: { \u0026#34;0\u0026#34;: 1, { \u0026#34;0\u0026#34;: 2, \u0026#34;1\u0026#34;: 3 } } ","description":"The RecursiveMapConverter class allows you to convert arbitrary values into map objects using extended conversion rules.\n","image":null,"permalink":"/node/commons/convert/recursive_map_converter/","subtitle":null,"tags":null,"title":"RecursiveMapConverter"},{"content":"Description The RecursiveMapConverter class allows you to convert arbitrary values into map objects using extended conversion rules.\nImportant points:\n This class is similar to MapConverter. The difference is that it recursively converts all values stored in objects and arrays.  Instance methods to_map Converts value into map object or returns empty map when conversion is not possible\n static to_map(value: Any): Any\n  value: Any - the value to convert. returns: Any - map object or empty map when conversion is not supported.  to_map_with_default Converts value into map object or returns default when conversion is not possible\n static to_map_with_default(value: Any, default_value: Any): Any\n  value: Any - the value to convert. default_value: Any - the default value. returns: Any - map object or empty map when conversion is not supported.  to_nullable_map Converts value into map object or returns None when conversion is not possible.\n static to_nullable_map(value: Any): Any\n  value: Any - the value to convert. returns: Any - map object or None when conversion is not supported.  Examples value1 = RecursiveMapConverter.to_nullable_map({ \u0026#39;key\u0026#39;: 123 }) # Returns {\u0026#39;key\u0026#39;: 123} value2 = RecursiveMapConverter.to_nullable_map([1,[2,3]]) # Returns {0: 1, 1: {0: 2, 1: 3}} ","description":"The RecursiveMapConverter class allows you to convert arbitrary values into map objects using extended conversion rules.\n","image":null,"permalink":"/python/commons/convert/recursive_map_converter/","subtitle":null,"tags":null,"title":"RecursiveMapConverter"},{"content":"Note: please note that this is not implemented for this language yet\n","description":"The RecursiveMapConverter class allows you to convert arbitrary values into map objects using extended conversion rules.\n","image":null,"permalink":"/golang/commons/convert/recursive_map_converter/","subtitle":null,"tags":null,"title":"RecursiveMapConverter!"},{"content":"Description The RecursiveObjectReader class allows you to examine the properties of an object (property instrospection) and to dynamically read them recursively using \u0026ldquo;dot\u0026rdquo; notation (e.g property.property.method).\nImportant points\n It is similar to ObjectReader but reads properties recursively through the entire object graph. Nested property names are defined using dot notation as \u0026ldquo;object.subobject.property\u0026rdquo;.  Methods GetProperties Get values of all properties in specified object and its subobjects and returns them as a map.\nThe object can be a user defined object, map or array. Returned properties correspondently are object properties, map key-pairs or array elements with their indexes.\n (c *TRecursiveObjectReader) GetProperties(obj interface{}) map[string]interface{}\n  obj: interface{} - object to get properties from. returns: map[string]interface{} - map, containing the names of the object\u0026rsquo;s properties and their values.  GetProperty Recursively gets value of an object\u0026rsquo;s or its subobjects' property specified by its name.\nThe object can be a user defined object, map or array. The property name correspondently must be an object\u0026rsquo;s property, map key or array index.\n (c *TRecursiveObjectReader) GetProperty(obj interface{}, name string) interface{}\n  obj: interface{} - object to read a property from. name: string - name of the property to get. returns: interface{} - property value or nil if property doesn\u0026rsquo;t exist or introspection failed.  GetPropertyNames Recursively gets the names of all properties implemented in specified object and its subobjects.\nThe object can be a user defined object, map or array. Returned property\u0026rsquo;s names correspondently are object properties, map keys or array indexes.\n (c *TRecursiveObjectReader) GetPropertyNames(obj interface{}) []string\n  obj: interface{} - objec to introspect. returns: []string - list with property names.  HasProperty  (c *TRecursiveObjectReader) HasProperty(obj interface{}, name string) bool\n  obj: interface{} - object to introspect. name: string - name of the property to check. returns: bool - true if the object has the property and false if it doesn\u0026rsquo;t.  See also   PropertyReflector   ObjectReader   ","description":"Helper class that allows you to examine the properties of an object (property instrospection) and to dynamically read them recursively using \"dot\" notation.\n","image":null,"permalink":"/golang/commons/reflect/recursive_object_reader/","subtitle":null,"tags":null,"title":"RecursiveObjectReader"},{"content":"Description The RecursiveObjectReader class allows you to examine the properties of an object (property instrospection) and to dynamically read them recursively using \u0026ldquo;dot\u0026rdquo; notation (e.g property.property.method).\nImportant points\n It is similar to ObjectReader but reads properties recursively through the entire object graph. Nested property names are defined using dot notation as \u0026ldquo;object.subobject.property\u0026rdquo;.  Static methods GetProperties Get values of all properties in specified object and its subobjects and returns them as a map.\nThe object can be a user defined object, map or array. Returned properties correspondently are object properties, map key-pairs or array elements with their indexes.\n public static IDictionary\u0026lt;string, object\u0026gt; GetProperties(object obj)\n  obj: object - an object to get properties from. returns: IDictionary\u0026lt;string, object\u0026gt; - a map, containing the names of the object\u0026rsquo;s properties and their values.  GetProperty Recursively gets value of object or its subobjects property specified by its name.\nThe object can be a user defined object, map or array. The property name correspondently must be object property, map key or array index.\n public static object GetProperty(object obj, string name)\n  obj: object - an object to read property from. name: string - a name of the property to get. returns: object - the property value or null if property doesn\u0026rsquo;t exist or introspection failed.  GetPropertyNames Recursively gets names of all properties implemented in specified object and its subobjects.\nThe object can be a user defined object, map or array. Returned property name correspondently are object properties, map keys or array indexes.\n public static IList\u0026lt;string\u0026gt; GetPropertyNames(object obj)\n  obj: object - an objec to introspect. returns: IList\u0026lt;string\u0026gt; - a list with property names.  HasProperty  public static bool HasProperty(object obj, string name)\n  obj: object - an object to introspect. name: string - a name of the property to check. returns: bool - true if the object has the property and false if it doesn\u0026rsquo;t.  See also   PropertyReflector   ObjectReader   ","description":"Helper class that allows you to examine the properties of an object (property instrospection) and to dynamically read them recursively using \"dot\" notation.\n","image":null,"permalink":"/net/commons/reflect/recursive_object_reader/","subtitle":null,"tags":null,"title":"RecursiveObjectReader"},{"content":"Description The RecursiveObjectReader class allows you to examine the properties of an object (property instrospection) and to dynamically read them recursively using \u0026ldquo;dot\u0026rdquo; notation (e.g property.property.method).\nImportant points\n It is similar to ObjectReader but reads properties recursively through the entire object graph. Nested property names are defined using dot notation as \u0026ldquo;object.subobject.property\u0026rdquo;.  Static methods getProperties Gets the values of all properties in a specified object and its subobjects and returns them as a map.\nThe object can be a user defined object, map or array. Returned properties correspondently are object\u0026rsquo;s properties, map key-pairs or array elements with their indexes.\n public static getProperties(obj: any): any\n  obj: any - object to get properties from. returns: any - map containing the names of the object\u0026rsquo;s properties and their values.  getProperty Recursively gets the value of an object\u0026rsquo;s or its subobjects' property specified by its name.\nThe object can be a user defined object, map or array. The property name correspondently must be an object\u0026rsquo;s property, map key or array index.\n public static getProperty(obj: any, name: string): any\n  obj: any - object to read the property from. name: string - name of the property to get. returns: any - property value or null if the property doesn\u0026rsquo;t exist or introspection failed.  getPropertyNames Recursively gets the names of all properties implemented in a specified object and its subobjects.\nThe object can be a user defined object, map or array. Returned property name correspondently are object\u0026rsquo;s properties, map keys or array indexes.\n public static getPropertyNames(obj: any): string[]\n  obj: any - objec to introspect. returns: string[] - list with property names.  hasProperty  public static hasProperty(obj: any, name: string): boolean\n  obj: any - object to introspect. name: string - name of the property to check. returns: boolean - true if the object has the property and false if it doesn\u0026rsquo;t.  See also   PropertyReflector   ObjectReader   ","description":"Helper class that allows you to examine the properties of an object (property instrospection) and to dynamically read them recursively using \"dot\" notation.\n","image":null,"permalink":"/node/commons/reflect/recursive_object_reader/","subtitle":null,"tags":null,"title":"RecursiveObjectReader"},{"content":"Description The RecursiveObjectReader class allows you to examine the properties of an object (property instrospection) and to dynamically read them recursively using \u0026ldquo;dot\u0026rdquo; notation (e.g property.property.method).\nImportant points\n It is similar to ObjectReader but reads properties recursively through the entire object graph. Nested property names are defined using dot notation as \u0026ldquo;object.subobject.property\u0026rdquo;.  Static methods get_properties Gets values of all properties in specified object and its subobjects and returns them as a map.\nThe object can be a user defined object, map or array. Returned properties correspondently are object properties, map key-pairs or array elements with their indexes.\n static get_properties(obj: Any): Any\n  obj: Any - an object to get properties from. returns: Any - a map, containing the names of the object\u0026rsquo;s properties and their values.  get_property Recursively gets value of object or its subobjects property specified by its name.\nThe object can be a user defined object, map or array. The property name correspondently must be object property, map key or array index.\n static get_property(obj: Any, name: str): Any\n  obj: Any - an object to read property from. name: str - a name of the property to get. returns: Any - the property value or None if property doesn\u0026rsquo;t exist or introspection failed.  get_property_names Recursively gets names of all properties implemented in specified object and its subobjects.\nThe object can be a user defined object, map or array. Returned property name correspondently are object properties, map keys or array indexes.\n static get_property_names(obj: Any): List[str]\n  obj: Any - an objec to introspect. returns: List[str] - a list with property names.  has_property  static has_property(obj: Any, name: str): bool\n  obj: Any - an object to introspect. name: str - a name of the property to check. returns: bool - true if the object has the property and false if it doesn\u0026rsquo;t.  See also   PropertyReflector   ObjectReader   ","description":"Helper class that allows you to examine the properties of an object (property instrospection) and to dynamically read them recursively using \"dot\" notation.\n","image":null,"permalink":"/python/commons/reflect/recursive_object_reader/","subtitle":null,"tags":null,"title":"RecursiveObjectReader"},{"content":"Description The RecursiveObjectWriter class allows you to dynamically set the properties of an object and to copy them to another object recursively using dot notation.\nImportant points\n It is similar to ObjectWriter but writes properties recursively through the entire object graph. Nested property names are defined using dot notation as \u0026ldquo;object.subobject.property\u0026rdquo;  Methods CopyProperties Copies content of one object to another object by recursively reading all properties from a source object and then recursively writing them to a destination object.\n (c *TRecursiveObjectWriter) CopyProperties(dest interface{}, src interface{})\n  dest: interface{} - destination object to write properties to. src: interface{} - source object to read properties from  SetProperties Recursively sets values of some (all) object\u0026rsquo;s and its subobjects' properties.\nThe object can be a user defined object, map or array. Property values correspondently are object properties, map key-pairs or array elements with their indexes.\nIf some properties do not exist or introspection fails they are just silently skipped and no errors thrown.\n (c *TRecursiveObjectWriter) SetProperties(obj interface{}, values map[string]interface{})\n  obj: interface{} - object to write properties to. values: map[string]interface{} - map containing property names and their values.  SetProperty Recursively sets value of an object\u0026rsquo;s and its subobjects' property specified by its name.\nThe object can be a user defined object, map or array. The property name correspondently must be an object property, map key or array index.\nIf the property does not exist or introspection fails this method doesn\u0026rsquo;t do anything and doesn\u0026rsquo;t throw any errors.\n (c *TRecursiveObjectWriter) SetProperty(obj interface{}, name string, value interface{})\n  obj: interface{} - object to write a property to. name: string - name of the property to set. value: interface{} - new value for the property to set.  See also   PropertyReflector   ObjectWriter   ","description":"Helper class that allows you to dynamically set the properties of an object recursively using \"dot\" notation.\n","image":null,"permalink":"/golang/commons/reflect/recursive_object_writer/","subtitle":null,"tags":null,"title":"RecursiveObjectWriter"},{"content":"Description The RecursiveObjectWriter class allows you to dynamically set the properties of an object and to copy them to another object recursively using dot notation.\nImportant points\n It is similar to ObjectWriter but writes properties recursively through the entire object graph. Nested property names are defined using dot notation as \u0026ldquo;object.subobject.property\u0026rdquo;  Static methods CopyProperties Copies the content of one object to another object by recursively reading all properties from source object and then recursively writing them to the destination object.\n public static void CopyProperties(object dest, object src)\n  dest: object - destination object to write properties to. src: object - source object to read properties from  SetProperties Recursively sets values of some (all) object\u0026rsquo;s and its subobjects' properties.\nThe object can be a user a defined object, a map or an array. Property values correspondently are object properties, map key-pairs or array elements with their indexes.\nIf some properties do not exist or introspection fails they are just silently skipped and no errors thrown.\n public static void SetProperties(object obj, IDictionary\u0026lt;string, object\u0026gt; values)\n  obj: object - object to write properties to. values: IDictionary\u0026lt;string, object\u0026gt; - map containing property names and their values.  SetProperty Recursively sets the value of an object\u0026rsquo;s and its subobjects' property specified by its name.\nThe object can be a user a defined object, a map or an array. The property name correspondently must be an object\u0026rsquo;s property, a map key or an array index.\nIf the property does not exist or introspection fails this method doesn\u0026rsquo;t do anything and doesn\u0026rsquo;t any throw errors.\n public static void SetProperty(object obj, string name, object value)\n  obj: object - object to write property to. name: string - name of the property to set. value: object - new value for the property to set.  See also   PropertyReflector   ObjectWriter   ","description":"Helper class that allows you to dynamically set the properties of an object recursively using \"dot\" notation.\n","image":null,"permalink":"/net/commons/reflect/recursive_object_writer/","subtitle":null,"tags":null,"title":"RecursiveObjectWriter"},{"content":"Description The RecursiveObjectWriter class allows you to dynamically set the properties of an object and to copy them to another object recursively using dot notation.\nImportant points\n It is similar to ObjectWriter but writes properties recursively through the entire object graph. Nested property names are defined using dot notation as \u0026ldquo;object.subobject.property\u0026rdquo;  Static methods copyProperties Copies content of one object to another object by recursively reading all properties from a source object and then recursively writing them to a destination object.\n public static copyProperties(dest: any, src: any): void\n  dest: any - destination object to write properties to. src: any - source object to read properties from  setProperties Recursively sets values of some (all) object and its subobjects properties.\nThe object can be a user defined object, map or array. Property values correspondently are object\u0026rsquo;s properties, map key-pairs or array elements with their indexes.\nIf some properties do not exist or introspection fails, they are just silently skipped and no errors thrown.\n public static setProperties(obj: any, values: any): void\n  obj: any - object to write properties to. values: any - map containing property names and their values.  setProperty Recursively sets the value of an object\u0026rsquo;s and its subobjects' property specified by its name.\nThe object can be a user defined object, map or array. The property name correspondently must be object\u0026rsquo;s property, map key or array index.\nIf the property does not exist or introspection fails, this method doesn\u0026rsquo;t do anything and doesn\u0026rsquo;t any throw errors.\n public static setProperty(obj: any, name: string, value: any): void\n  obj: any - object to write property to. name: string - name of the property to set. value: any - new value for the property to set.  See also   PropertyReflector   ObjectWriter   ","description":"Helper class that allows you to dynamically set the properties of an object recursively using \"dot\" notation.\n","image":null,"permalink":"/node/commons/reflect/recursive_object_writer/","subtitle":null,"tags":null,"title":"RecursiveObjectWriter"},{"content":"Description The RecursiveObjectWriter class allows you to dynamically set the properties of an object and to copy them to another object recursively using dot notation.\nImportant points\n It is similar to ObjectWriter but writes properties recursively through the entire object graph. Nested property names are defined using dot notation as \u0026ldquo;object.subobject.property\u0026rdquo;  Static methods copy_properties Copies content of one object to another object by recursively reading all properties from source object and then recursively writing them to destination object.\n static copy_properties(dest: Any, src: Any)\n  dest: Any - a destination object to write properties to. src: Any - a source object to read properties from  set_properties Recursively sets values of some (all) object and its subobjects properties.\nThe object can be a user defined object, map or array. Property values correspondently are object properties, map key-pairs or array elements with their indexes.\nIf some properties do not exist or introspection fails, they are just silently skipped and no errors thrown.\n static set_properties(obj: Any, values: Any)\n  obj: Any - an object to write properties to. values: Any - a map, containing property names and their values.  set_property Recursively sets value of object and its subobjects property specified by its name.\nThe object can be a user defined object, map or array. The property name correspondently must be object property, map key or array index.\nIf the property does not exist or introspection fails this method doesn\u0026rsquo;t do anything and doesn\u0026rsquo;t throw any errors.\n static setProperty(obj: Any, name: str, value: Any)\n  obj: Any - an object to write property to. name: str - name of the property to set. value: Any - new value for the property to set.  See also   PropertyReflector   ObjectWriter   ","description":"Helper class that allows you to dynamically set the properties of an object recursively using \"dot\" notation.\n","image":null,"permalink":"/python/commons/reflect/recursive_object_writer/","subtitle":null,"tags":null,"title":"RecursiveObjectWriter"},{"content":"Implements: ICache, IReferenceable, IConfigurable, IOpenable\nDescription TODO: add description\nConfiguration parameters  connection(s):  discovery_key: (optional) a key to retrieve the connection from IDiscovery host: host name or IP address port: port number uri: resource URI or connection string with all parameters in it   credential(s):  store_key: key to retrieve parameters from ICredentialStore username: user name (currently is not used) password: user password   options:  retries: number of retries (default: 3) timeout: default caching timeout in milliseconds (default: 1 minute) max_size: maximum number of values stored in this cache (default: 1000)    References  *:discovery:*:*:1.0 - (optional) IDiscovery services *:credential-store:*:*:1.0 - (optional) ICredentialStore stores to resolve credentials  Fields _connectionResolver The connection resolver\n protected _connectionResolver: ConnectionResolver\n _credentialResolver The credential resolver\n protected _credentialResolver: CredentialResolver\n  Constructors Creates a new instance of this cache.\n public constructor()\n Instance methods close Configures components by passing configuration parameters.\n public close(correlationId: string): Promise\u0026lt;void\u0026gt;\n  correlationId: string - (optional) transaction id to trace execution through call chain.  configure Configures components by passing configuration parameters.\n public configure(config: ConfigParams): void\n  config: ConfigParams - configuration parameters to be set.  isOpen Checks if the component is opened.\n public isOpen(): boolean\n  returns: boolean - true if the component has been opened and false otherwise.  open Opens the component.\n public open(correlationId: string): Promise\u0026lt;void\u0026gt;\n  correlationId: string - (optional) transaction id to trace execution through call chain.  remove Removes a value from the cache by its key.\n public remove(correlationId: string, key: string): Promise\u0026lt;any\u0026gt;\n  correlationId: string - (optional) transaction id to trace execution through call chain. key: string - a unique value key. returns: Promise\u0026lt;any\u0026gt; - the removed value.  retrieve Retrieves cached value from the cache using its key. If value is missing in the cache or expired it returns null.\n public retrieve(correlationId: string, key: string): Promise\u0026lt;any\u0026gt;\n  correlationId: string - (optional) transaction id to trace execution through call chain. key: string - a unique value key. returns: Promise\u0026lt;any\u0026gt; - a retrieve cached value or null if nothing was found.  setReferences Sets references to dependent components.\n public setReferences(references: IReferences): void\n  references: IReferences - references to locate the component dependencies.  store Stores value in the cache with expiration time.\n public store(correlationId: string, key: string, value: any, timeout: number): Promise\u0026lt;any\u0026gt;\n  correlationId: string - (optional) transaction id to trace execution through call chain. key: string - a unique value key. value: any - a value to store. timeout: number - expiration timeout in milliseconds. returns: Promise\u0026lt;any\u0026gt; - the stored value.  Examples let cache = new RedisCache(); cache.configure(ConfigParams.fromTuples( \u0026#34;host\u0026#34;, \u0026#34;localhost\u0026#34;, \u0026#34;port\u0026#34;, 6379 )); await cache.open(\u0026#34;123\u0026#34;); await cache.store(\u0026#34;123\u0026#34;, \u0026#34;key1\u0026#34;, \u0026#34;ABC\u0026#34;); let value = await cache.store(\u0026#34;123\u0026#34;, \u0026#34;key1\u0026#34;); // Result: \u0026#34;ABC\u0026#34;  ","description":"Distributed cache that stores values in Redis in-memory database.\n","image":null,"permalink":"/node/redis/cache/redis_cache/","subtitle":null,"tags":null,"title":"RedisCache"},{"content":"Extends: Lock\nImplements: IReferenceable, IConfigurable, IOpenable\nDescription TODO: add description\nConfiguration parameters  connection(s):  discovery_key: (optional) a key to retrieve the connection from IDiscovery host: host name or IP address port: port number uri: resource URI or connection string with all parameters in it   credential(s):  store_key: key to retrieve parameters from credential store username: user name (currently is not used) password: user password   options:  retry_timeout: timeout in milliseconds to retry lock acquisition. (Default: 100) retries: number of retries (default: 3)    References  *:discovery:*:*:1.0 - (optional) IDiscovery services *:credential-store:*:*:1.0 - (optional) ICredentialStore to resolve credentials  Instance methods close Configures components by passing configuration parameters.\n public close(correlationId: string): Promise\u0026lt;void\u0026gt;\n  correlationId: string - (optional) transaction id to trace execution through call chain.  configure Configures components by passing configuration parameters.\n public configure(config: ConfigParams): void\n  config: ConfigParams - configuration parameters to be set.  isOpen Checks if the component is opened.\n public isOpen(): boolean\n  returns: boolean - true if the component has been opened and false otherwise.  open Opens the component.\n public open(correlationId: string): Promise\u0026lt;void\u0026gt;\n  correlationId: string - (optional) transaction id to trace execution through call chain.  releaseLock Releases prevously acquired lock by its key.\n public releaseLock(correlationId: string, key: string): Promise\u0026lt;void\u0026gt;\n  correlationId: string - (optional) transaction id to trace execution through call chain. key: string - a unique lock key to release.  setReferences Sets references to dependent components.\n public setReferences(references: IReferences): void\n  references: IReferences - references to locate the component dependencies.  tryAcquireLock Makes a single attempt to acquire a lock by its key. It returns immediately a positive or negative result.\n public tryAcquireLock(correlationId: string, key: string, ttl: number): Promise\u0026lt;boolean\u0026gt;\n  correlationId: string - (optional) transaction id to trace execution through call chain. key: string - a unique lock key to acquire. ttl: number - a lock timeout (time to live) in milliseconds. returns: Promise\u0026lt;boolean\u0026gt; - true if lock was successfully acquired and false otherwise.  Examples let lock = new RedisRedis(); lock.configure(ConfigParams.fromTuples( \u0026#34;host\u0026#34;, \u0026#34;localhost\u0026#34;, \u0026#34;port\u0026#34;, 6379 )); lock.open(\u0026#34;123\u0026#34;); await lock.acquire(\u0026#34;123\u0026#34;, \u0026#34;key1\u0026#34;); try { // Processing... } finally { await lock.releaseLock(\u0026#34;123\u0026#34;, \u0026#34;key1\u0026#34;); } ","description":"Distributed lock that is implemented based on Redis in-memory database.\n","image":null,"permalink":"/node/redis/lock/redis_lock/","subtitle":null,"tags":null,"title":"RedisLock"},{"content":"Description The Reference class allows you to store a reference to a component and a locator to find it.\nImportant points\n It is used by References to store registered component references.  Constructors NewReference Create a new instance of the reference object and assigns its values.\n NewReference(locator interface{}, component interface{}) *Reference\n  locator: interface{} - locator to find the reference. component: interface{} - reference to a component.  Methods Component Gets the stored component reference.\n (c *Reference) Component() interface{}\n  returns: interface{} - component\u0026rsquo;s references.  Locator Gets the stored component locator.\n (c *Reference) Locator() interface{}\n  returns: interface{} - component\u0026rsquo;s locator.  Match Matches locator to this reference locator. Descriptors are matched using equal method. All other locator types are matched using direct comparison.\n (c *Reference) Match(locator interface{}) bool\n  locator: interface{} - the locator to match. returns: bool - true if locators are matching and false it they don\u0026rsquo;t.  ","description":"Contains a reference to a component and a locator to find it.\n","image":null,"permalink":"/golang/commons/refer/reference/","subtitle":null,"tags":null,"title":"Reference"},{"content":"Description The Reference class allows you to store a reference to a component and a locator to find it.\nImportant points\n It is used by References to store registered component references.  Constructors Create a new instance of the reference object and assigns its values.\n public Reference(object locator, object component)\n  locator: object - a locator to find the reference. component: object - a reference to component.  Instance methods GetComponent Gets the stored component reference.\n public object GetComponent()\n  returns: object - the component\u0026rsquo;s references.  GetLocator Gets the stored component locator.\n public object GetLocator()\n  returns: object - the component\u0026rsquo;s locator.  Match Matches locator to this reference locator. Descriptors are matched using equal method. All other locator types are matched using direct comparison.\n public bool Match(object locator)\n  locator: object - the locator to match. returns: bool - true if locators are matching and false it they don\u0026rsquo;t.  ","description":"Contains a reference to a component and a locator to find it.\n","image":null,"permalink":"/net/commons/refer/reference/","subtitle":null,"tags":null,"title":"Reference"},{"content":"Description The Reference class allows you to store a reference to a component and a locator to find it.\nImportant points\n It is used by References to store registered component references.  Constructors Creates a new instance of the reference object and assigns its values.\n public constructor(locator: any, component: any)\n  locator: any - locator to find the reference. component: any - reference to component.  Instance methods getComponent Gets the stored component reference.\n public getComponent(): any\n  returns: any - component\u0026rsquo;s references.  getLocator Gets the stored component locator.\n public getLocator(): any\n  returns: any - component\u0026rsquo;s locator.  match Matches locator to this reference locator. Descriptors are matched using the equal method. All other locator types are matched using direct comparison.\n public match(locator: any): boolean\n  locator: any - locator to match. returns: boolean - true if locators are matching and false it they don\u0026rsquo;t.  ","description":"Contains a reference to a component and a locator to find it.\n","image":null,"permalink":"/node/commons/refer/reference/","subtitle":null,"tags":null,"title":"Reference"},{"content":"Description The Reference class allows you to store a reference to a component and a locator to find it.\nImportant points\n It is used by References to store registered component references.  Constructors Create a new instance of the reference object and assigns its values.\n Reference(locator: Any, component: Any)\n  locator: Any - a locator to find the reference. component: Any - a reference to component.  Instance methods get_component Gets the stored component reference.\n get_component(): Any\n  returns: Any - the component\u0026rsquo;s references.  get_locator Gets the stored component locator.\n get_locator(): Any\n  returns: Any - the component\u0026rsquo;s locator.  match Matches locator to this reference locator. Descriptors are matched using equal method. All other locator types are matched using direct comparison.\n match(locator: Any): bool\n  locator: Any - the locator to match. returns: bool - true if locators are matching and false it they don\u0026rsquo;t.  ","description":"Contains a reference to a component and a locator to find it.\n","image":null,"permalink":"/python/commons/refer/reference/","subtitle":null,"tags":null,"title":"Reference"},{"content":"Description The ReferenceError` class provides a Reference error type, which can be used to create an error instance when a required component dependency cannot be found.\nConstructors NewReferenceError Creates an error instance and assigns its values.\n NewReferenceError(correlationId string, locator interface{}) *errors.ApplicationError\n  correlationId: string - (optional) unique transaction id used to trace execution through the call chain. locator: interface{} - locator to find reference to dependent component.  ","description":"Error created when a required component dependency cannot be found.\n","image":null,"permalink":"/golang/commons/refer/reference_error/","subtitle":null,"tags":null,"title":"ReferenceError"},{"content":"Description The ReferenceException class provides a Reference error type, which can be used to create an error instance when a required component dependency cannot be found.\nConstructors Creates an error instance and assigns its values.\n public ReferenceException(string correlationId, object locator)\n  correlationId: string - (optional) unique transaction id used to trace execution through the call chain. locator: object - locator used to find reference to a dependent component.  Creates an error instance and assigns its values.\n public ReferenceException(string correlationId, string message)\n  correlationId: string - (optional) unique transaction id used to trace execution through the call chain. message: string - (optional) human-readable description of the error.  Creates an error instance and assigns its values.\n public ReferenceException (string correlationId, string code, string message)\n  correlationId: string - (optional) unique transaction id used to trace execution through the call chain. message: string - (optional) human-readable description of the error. code: string - unique error code.  Creates an error instance and assigns its values.\n public ReferenceException(object locator)\n  locator: object - locator used to find a reference to a dependent component.  Creates an error instance and assigns its values.\n public ReferenceException()\n Creates an error instance by processing native C# Exceptions.\n protected ReferenceException(SerializationInfo info, StreamingContext context)\n  info: SerializationInfo - serialized information containing the serialized object data about the exception being thrown. context: StreamingContext - streaming context containing contextual information about the source or destination.  ","description":"Error created when a required component dependency cannot be found.\n","image":null,"permalink":"/net/commons/refer/reference_exception/","subtitle":null,"tags":null,"title":"ReferenceException"},{"content":"Description The ReferenceException class provides a Reference error type, which can be used to create an error instance when a required component dependency cannot be found.\nConstructors Creates an error instance and assigns its values.\n public constructor(correlationId: string, locator: any)\n  correlationId: string - (optional) unique transaction id used to trace execution through a call chain. locator: any - locator to find reference to dependent component.  ","description":"Error created when a required component dependency cannot be found.\n","image":null,"permalink":"/node/commons/refer/reference_exception/","subtitle":null,"tags":null,"title":"ReferenceException"},{"content":"Description The ReferenceException class provides a Reference error type, which can be used to create an error instance when a required component dependency cannot be found.\nConstructors Creates an error instance and assigns its values.\n ReferenceException(correlation_id: Optional[str], locator: Any)\n  correlation_id: Optional[str] - (optional) a unique transaction id to trace execution through call chain. locator: Any - the locator to find reference to dependent component.  ","description":"Error created when a required component dependency cannot be found.\n","image":null,"permalink":"/python/commons/refer/reference_exception/","subtitle":null,"tags":null,"title":"ReferenceException"},{"content":"Description The Referencer class allows you to set and unset references to components.\nMethods SetReferences Sets references to multiple components.\nTo set references components must implement IReferenceable interface. If they don\u0026rsquo;t the call to this method has no effect.\n (c *TReferencer) SetReferences(references IReferences, components []interface{})\n  references: IReferences - references to be set. component: []interface{} - list of components to set the references to.  SetReferencesForOne Sets references to specific component.\nTo set references components must implement IReferenceable interface. If they don\u0026rsquo;t the call to this method has no effect.\n (c *TReferencer) SetReferencesForOne(references IReferences, component interface{})\n  references: IReferences - references to be set. component: interface{} - component to set references to.  UnsetReferences Unsets references in multiple components. To unset references components must implement IUnreferenceable interface. If they don\u0026rsquo;t the call to this method has no effect.\n (c *TReferencer) UnsetReferences(components []interface{})\n  components: []interface{} - list of components, whose references must be cleared.  UnsetReferencesForOne Unsets references in specific component.\nTo unset references components must implement IUnreferenceable interface. If they don\u0026rsquo;t, the call to this method has no effect.\n (c *TReferencer) UnsetReferencesForOne(component interface{})\n  component: interface{} - component to unset references.  See also   IReferenceable   IUnreferenceable   ","description":"Helper class that allows you to set and unset references to components.\n","image":null,"permalink":"/golang/commons/refer/referencer/","subtitle":null,"tags":null,"title":"Referencer"},{"content":"Description The Referencer class allows you to set and unset references to components.\nStatic methods SetReferences Sets references to multiple components.\nTo set references, components must implement the IReferenceable interface. If they don\u0026rsquo;t, the call to this method has no effect.\n public static void SetReferences(IReferenceable references, IEnumerable components = null)\n  references: IReferences - references to be set. component: IEnumerable - list of components to set the references to.  SetReferencesForOne Sets references to a specific component.\nTo set references, components must implement the IReferenceable interface. If they don\u0026rsquo;t the call to this method has no effect.\n public static void SetReferencesForOne(IReferences references, object component)\n  references: IReferences - references to be set. component: object - component to set references to.  UnsetReferences Unsets references in multiple components. To unset references, components must implement the IUnreferenceable interface. If they don\u0026rsquo;t, the call to this method has no effect.\n public static void UnsetReferences(IEnumerable components)\n  components: IEnumerable - list of components whose references must be cleared.  UnsetReferences Unsets references in multiple components. To unset references, components must implement the IUnreferenceable interface. If they don\u0026rsquo;t, the call to this method has no effect.\n public static void UnsetReferences(IReferences components)\n  components: IReferences - list of components whose references must be cleared.  UnsetReferencesForOne Unsets references in a specific component.\nTo unset references, components must implement the IUnreferenceable interface. If they don\u0026rsquo;t, the call to this method has no effect.\n public static void UnsetReferencesForOne(object component)\n  component: object - component to unset references.  See also   IReferenceable   IUnreferenceable   ","description":"Helper class that allows you to set and unset references to components.\n","image":null,"permalink":"/net/commons/refer/referencer/","subtitle":null,"tags":null,"title":"Referencer"},{"content":"Description The Referencer class allows you to set and unset references to components.\nStatic methods setReferences Sets references to multiple components.\nTo set references, components must implement the IReferenceable interface. If they don\u0026rsquo;t, the call to this method has no effect.\n public static setReferences(references: IReferenceable, components: any[]): void\n  references: IReferences - references to be set. component: any[] - list of components to set the references to.  setReferencesForOne Sets references to specific component.\nTo set references, components must implement the IReferenceable interface. If they don\u0026rsquo;t, the call to this method has no effect.\n public static setReferencesForOne(references: IReferences, component: any): void\n  references: IReferences - references to be set. component: any - component to set references to.  unsetReferences Unsets references in multiple components. To unset references, components must implement the IUnreferenceable interface. If they don\u0026rsquo;t, the call to this method has no effect.\n public static unsetReferences(components: any[]): void\n  components: any[] - list of components, whose references must be cleared.  unsetReferencesForOne Unsets references in a specific component.\nTo unset references, components must implement the IUnreferenceable interface. If they don\u0026rsquo;t, the call to this method has no effect.\n public static unsetReferencesForOne(component: any): void\n  component: any - component to unset references.  See also   IReferenceable   IUnreferenceable   ","description":"Helper class that allows you to set and unset references to components.\n","image":null,"permalink":"/node/commons/refer/referencer/","subtitle":null,"tags":null,"title":"Referencer"},{"content":"Description The Referencer class allows you to set and unset references to components.\nStatic methods set_references Sets references to multiple components.\nTo set references components must implement IReferenceable interface. If they don\u0026rsquo;t, the call to this method has no effect.\n static set_references(references: IReferenceable, components: List[Any])\n  references: IReferences - the references to be set. component: List[Any] - a list of components to set the references to.  set_references_for_one Sets references to specific component.\nTo set references components must implement IReferenceable interface. If they don\u0026rsquo;t, the call to this method has no effect.\n static set_references_for_one(references: IReferences, component: Any)\n  references: IReferences - the references to be set. component: Any - the component to set references to.  unset_references Unsets references in multiple components. To unset references components must implement IUnreferenceable interface. If they don\u0026rsquo;t the call to this method has no effect.\n static unset_references(components: List[Any])\n  components: List[Any] - the list of components, whose references must be cleared.  unset_references_for_one Unsets references in specific component.\nTo unset references components must implement IUnreferenceable interface. If they don\u0026rsquo;t, the call to this method has no effect.\nSee IUnreferenceable\n static unset_references_for_one(component: Any)\n  component: Any - the component to unset references.  See also   IReferenceable   IUnreferenceable   ","description":"Helper class that allows you to set and unset references to components.\n","image":null,"permalink":"/python/commons/refer/referencer/","subtitle":null,"tags":null,"title":"Referencer"},{"content":"Description The References class allows you to store and locate component references.\nConstructors NewReferences Creates a new instance of references and initializes it with references.\n NewReferences(tuples []interface{}) *References\n NewReferencesFromTuples Creates a new References from a list of key-value pairs called tuples.\n NewReferencesFromTuples(tuples \u0026hellip;interface{}) *References\n  tuples: \u0026hellip;interface{} - list of values where odd elements are locators and the following even elements are component references  NewEmptyReferences Creates a new instance of references and initializes it with references.\n NewEmptyReferences() *References\n  tuples: []interface{} - (optional) list of values where odd elements are locators and the following even elements are component references  Fields references List of values where odd elements are locators and the following even elements are component references.\n references: []*Reference\n  Methods Find Gets all component references that match specified locator.\nThrows a ReferenceError when required is set to true but no references found.\n (c *References) Find(locator interface{}, required bool) ([]interface{}, error)\n  locator: interface{} - locator to find a reference by. required: bool - forces to raise an exception if no reference is found. returns: ([]interface{}, error) - list with matching component references.  GetAll Gets all component references registered in this reference map.\n (c *References) GetAll() []interface{}\n  returns: []interface{} - list with component references.  GetAllLocators Gets locators for all registered component references in this reference map.\n (c *References) GetAllLocators() []interface{}\n  returns: []interface{} - list with component locators.  GetOneOptional Gets an optional component reference that matches specified locator.\n (c *References) GetOneOptional(locator interface{}) interface{}\n  locator: interface{} - locator to find references by. returns: interface{} - matching component reference or nil if nothing was found.  GetOneRequired Gets a required component reference that matches specified locator.\nthrows a ReferenceError when no references found.\n (c *References) GetOneRequired(locator interface{}) (interface{}, error)\n  locator: interface{} - locator to find a reference by. returns: (interface{}, error) - matching component reference.  GetOptional Gets all component references that match specified locator.\n (c *References) GetOptional(locator interface{}) []interface{}\n  locator: interface{} - locator to find references by. returns: []interface{} - list with matching component references or empty list if nothing was found.  GetRequired Gets all component references that match specified locator. At least one component reference must be present. If it doesn\u0026rsquo;t the method throws an error. Throws a ReferenceError when no references found.\n (c *References) GetRequired(locator interface{}) ([]interface{}, error)\n  locator: interface{} - locator to find references by. returns: ([]interface{}, error) - list with matching component references.  Put Puts a new reference into this reference map.\n (c *References) Put(locator interface{}, component interface{})\n  locator: interface{} - locator to find the reference by. component: interface{} - component reference to be added.  Remove Removes a previously added reference that matches a specified locator. If many references match the locator, it removes only the first one. When all references shall be removed, use RemoveAll method instead.\n (c *References) Remove(locator interface{}) interface{}\n  locator: interface{} - locator used to remove a reference returns: interface{} - removed component\u0026rsquo;s reference.  RemoveAll Removes all component references that match the specified locator.\n (c *References) RemoveAll(locator interface{}) []interface{}\n  locator: interface{} - locator to remove references by. returns: []interface{} - list, containing all removed references.  Examples type MyController { _persistence IMyPersistence; } func (mc *MyController) SetReferences(references IReferences) { mc._persistence = references.GetOneRequired( NewDescriptor(\u0026#34;mygroup\u0026#34;, \u0026#34;persistence\u0026#34;, \u0026#34;*\u0026#34;, \u0026#34;*\u0026#34;, \u0026#34;1.0\u0026#34;) ); } persistence := NewMyMongoDbPersistence(); controller := MyController(); references := NewReferencesFromTuples( new Descriptor(\u0026#34;mygroup\u0026#34;, \u0026#34;persistence\u0026#34;, \u0026#34;mongodb\u0026#34;, \u0026#34;default\u0026#34;, \u0026#34;1.0\u0026#34;), persistence, new Descriptor(\u0026#34;mygroup\u0026#34;, \u0026#34;controller\u0026#34;, \u0026#34;default\u0026#34;, \u0026#34;default\u0026#34;, \u0026#34;1.0\u0026#34;), controller ); controller.SetReferences(references); See also   IReferences   ","description":"An implementation of [IReferences](../ireferences) that allows you to store and locate component references.\n","image":null,"permalink":"/golang/commons/refer/references/","subtitle":null,"tags":null,"title":"References"},{"content":"Inherits: IReferences\nDescription The References class allows you to store and locate a component\u0026rsquo;s references.\nConstructors Creates a new instance of the References class and initializes it with references.\n public References(object[] tuples)\n  tuples: object[] - (optional) list of values where odd elements are locators and the following even elements are component references.  Fields _references A list of values where odd elements are locators and the following even elements are component references.\n protected _references: List\u0026lt;Reference\u0026gt;\n  Instance methods Clear Clears this instance.\n public void Clear()\n Find Gets all component references that match a specified locator. Throws a ReferenceException when required is set to true but no references were found. T - class type\n public virtual List\u0026lt;object\u0026gt; Find(object locator, bool required)\n  locator: object - locator used to find a reference by. required: bool - if set to true, it forces to raise an exception if no reference is found. returns: List\u0026lt;object\u0026gt; - list with matching component references.  Find Gets all component references that match a specified locator and matching to the specified type. Throws a ReferenceException when required is set to true but no references were found. T - class type\n public virtual List\u0026lt;T\u0026gt; Find\u0026lt;T\u0026gt;(object locator, bool required)\n  locator: object - locator used to find a reference by. required: bool - if set to true, it forces to raise an exception if no reference is found. returns: List\u0026lt;T\u0026gt; - list with matching component references.  GetAll Gets all component\u0026rsquo;s references registered in this reference map.\n public virtual List\u0026lt;object\u0026gt; GetAll()\n  returns: List\u0026lt;object\u0026gt; - list with the component\u0026rsquo;s references.  GetAllLocators Gets locators for all registered component\u0026rsquo;s references in this reference map.\n public virtual List\u0026lt;object\u0026gt; GetAllLocators()\n  returns: List\u0026lt;object\u0026gt; - list with component locators.  GetOneOptional Gets an optional component\u0026rsquo;s reference that matches a specified locator.\n public virtual object GetOneOptional(object locator)\n  locator: object - locator used to find references by. returns: object - matching component reference or null if nothing was found.  GetOneOptional Gets an optional component\u0026rsquo;s reference that matches a specified locator and matching to the specified type. T - the class type\n public virtual T GetOneOptional\u0026lt;T\u0026gt;(object locator)\n  locator: object - locator used to find references by. returns: T - matching component reference or null if nothing was found.  GetOneRequired Gets a required component\u0026rsquo;s reference that matches specified locator. throws a ReferenceException when no references found.\n public virtual object GetOneRequired(object locator)\n  locator: object - locator used to find a reference by. returns: object - matching component reference.  GetOneRequired Gets a required component\u0026rsquo;s reference that matches a specified locator and matching to the specified type. throws a ReferenceException when no references found.\n public virtual T GetOneRequired\u0026lt;T\u0026gt;(object locator)\n  locator: object - locator used to find a reference by. returns: T - matching component reference.  GetOptional Gets all component\u0026rsquo;s references that match specified locator.\n public virtual List\u0026lt;object\u0026gt; GetOptional(object locator)\n  locator: object - locator used to find references by. returns: List\u0026lt;object\u0026gt; - list with matching component references or empty list if nothing was found.  GetOptional Gets all component\u0026rsquo;s references that match specified locator and matching to the specified type. T - class type\n public virtual List\u0026lt;T\u0026gt; GetOptional\u0026lt;T\u0026gt;(object locator)\n  locator: object - locator used to find references by. returns: List\u0026lt;T\u0026gt; - list with matching component references or empty list if nothing was found.  GetRequired Gets all component references that match a specified locator. At least one component\u0026rsquo;s reference must be present. If it doesn\u0026rsquo;t, the method throws an error. Throws a ReferenceException when no references were found.\n public virtual List\u0026lt;object\u0026gt; GetRequired(object locator)\n  locator: object - locator used to find references by. returns: List\u0026lt;object\u0026gt; - list with matching component references.  GetRequired Gets all component\u0026rsquo;s references that match specified locator. At least one component\u0026rsquo;s reference must be present and matching to the specified type. If it doesn\u0026rsquo;t, the method throws an error. Throws a ReferenceException when no references were found. T - the class type\n public virtual List\u0026lt;T\u0026gt; GetRequired\u0026lt;T\u0026gt;(object locator)\n  locator: object - locator used to find references by. returns: List\u0026lt;T\u0026gt; - list with matching component references.  Put Puts a new reference into this reference map.\n public virtual void Put(object locator, object component)\n  locator: object - locator used to find the reference by. component: object - component\u0026rsquo;s reference to be added.  Remove Removes a previously added reference that matches a specified locator. If many references match the locator, it removes only the first one. When all references shall be removed, use RemoveAll method instead.\n public virtual object Remove(object locator)\n  locator: object - locator used to remove a reference returns: object - removed component\u0026rsquo;s reference.  removeAll Removes all component references that match the specified locator.\n public virtual List\u0026lt;object\u0026gt; removeAll(object locator)\n  locator: object - locator used to remove references by. returns: List\u0026lt;object\u0026gt; - list containing all removed references.  Static methods FromTuples Creates a new References from a list of key-value pairs called tuples.\n public static References FromTuples(params object[] tuples)\n  tuples: object[] - list of values where odd elements are locators and the following even elements are component references. returns: References - newly created References object.  Examples public class MyController: IReferenceable { public IMyPersistence _persistence; ... public void SetReferences(IReferences references) { this._persistence = references.getOneRequired\u0026lt;IMyPersistence\u0026gt;( new Descriptor(\u0026#34;mygroup\u0026#34;, \u0026#34;persistence\u0026#34;, \u0026#34;*\u0026#34;, \u0026#34;*\u0026#34;, \u0026#34;1.0\u0026#34;) ); } ... } var persistence = new MyMongoDbPersistence(); var controller = new MyController(); var references = References.FromTuples( new Descriptor(\u0026#34;mygroup\u0026#34;, \u0026#34;persistence\u0026#34;, \u0026#34;mongodb\u0026#34;, \u0026#34;default\u0026#34;, \u0026#34;1.0\u0026#34;), persistence, new Descriptor(\u0026#34;mygroup\u0026#34;, \u0026#34;controller\u0026#34;, \u0026#34;default\u0026#34;, \u0026#34;default\u0026#34;, \u0026#34;1.0\u0026#34;), controller); controller.SetReferences(references); See also   IReferences   ","description":"An implementation of [IReferences](../ireferences) that allows you to store and locate component references.\n","image":null,"permalink":"/net/commons/refer/references/","subtitle":null,"tags":null,"title":"References"},{"content":"Implements: IReferences\nDescription The References class allows you to store and locate component references.\nConstructors Creates a new instance of References and initializes it with references.\n public constructor(tuples: any[] = null)\n  tuples: any[] - (optional) list of values where odd elements are locators and the following even elements are component references.  Fields _references A list of values where odd elements are locators and the following even elements are component references.\n protected _references: Reference[]\n  Instance methods find Gets all component references that match a specified locator.\nThrows a ReferenceException when required is set to true but no references were found.\n public find\u0026lt;T\u0026gt;(locator: any, required: boolean): T[]\n  locator: any - locator to find a reference by. required: boolean - forces to raise an exception if no reference is found. returns: T[] - list with matching component references.  getAll Gets all component references registered in this reference map.\n public getAll(): any[]\n  returns: any[] - list with component references.  getAllLocators Gets locators for all registered component references in this reference map.\n public getAllLocators(): any[]\n  returns: any[] - list with component locators.  getOneOptional Gets an optional component reference that matches a specified locator.\n public getOneOptional\u0026lt;T\u0026gt;(locator: any): T\n  locator: any - locator to find references by. returns: T - matching component reference or null if nothing was found.  getOneRequired Gets a required component reference that matches specified locator.\nthrows a ReferenceException when no references found.\n public getOneRequired\u0026lt;T\u0026gt;(locator: any): T\n  locator: any - locator to find a reference by. returns: T - matching component reference.  getOptional Gets all component references that match a specified locator.\n public getOptional\u0026lt;T\u0026gt;(locator: any): T[]\n  locator: any - locator to find references by. returns: T[] - list with matching component references or empty list if nothing was found.  getRequired Gets all component references that match a specified locator. At least one component reference must be present. If it doesn\u0026rsquo;t the method throws an error. Throws a ReferenceException when no references found.\n public getRequired\u0026lt;T\u0026gt;(locator: any): T[]\n  locator: any - locator to find references by. returns: T[] - list with matching component references.  put Puts a new reference into this reference map.\n public put(locator: any, component: any): void\n  locator: any - locator to find the reference by. component: any - component reference to be added.  remove Removes a previously added reference that matches specified locator. If many references match the locator, it removes only the first one. When all references shall be removed, use removeAll method instead.\n public remove(locator: any): any\n  locator: any - locator to remove reference returns: any - removed component reference.  removeAll Removes all component references that match the specified locator.\n public removeAll(locator: any): any[]\n  locator: any - locator to remove references by. returns: any[] - list containing all removed references.  Static methods fromTuples Creates a new References from a list of key-value pairs called tuples.\n public static fromTuples(\u0026hellip;tuples: any[]): References\n  tuples: any[] - list of values where odd elements are locators and the following even elements are component references returns: References - newly created References.  Examples export class MyController implements IReferenceable { public _persistence: IMyPersistence; ... public setReferences(references: IReferences): void { this._persistence = references.getOneRequired\u0026lt;IMyPersistence\u0026gt;( new Descriptor(\u0026#34;mygroup\u0026#34;, \u0026#34;persistence\u0026#34;, \u0026#34;*\u0026#34;, \u0026#34;*\u0026#34;, \u0026#34;1.0\u0026#34;) ); } ... } let persistence = new MyMongoDbPersistence(); let controller = new MyController(); let references = References.fromTuples( new Descriptor(\u0026#34;mygroup\u0026#34;, \u0026#34;persistence\u0026#34;, \u0026#34;mongodb\u0026#34;, \u0026#34;default\u0026#34;, \u0026#34;1.0\u0026#34;), persistence, new Descriptor(\u0026#34;mygroup\u0026#34;, \u0026#34;controller\u0026#34;, \u0026#34;default\u0026#34;, \u0026#34;default\u0026#34;, \u0026#34;1.0\u0026#34;), controller ); controller.setReferences(references); See also   IReferences   ","description":"An implementation of [IReferences](../ireferences) that allows you to store and locate component references.\n","image":null,"permalink":"/node/commons/refer/references/","subtitle":null,"tags":null,"title":"References"},{"content":"Implements: IReferences\nDescription The References class allows you to store and locate component references.\nConstructors Creates a new instance of references and initializes it with references.\n References(tuples: Sequence[Any] = None)\n  tuples: Sequence[Any] - (optional) a list of values where odd elements are locators and the following even elements are component references  Fields _references A list of values where odd elements are locators and the following even elements are component references.\n _references: List[Reference]\n  Instance methods find Gets all component references that match specified locator.\nThrows a ReferenceException when required is set to true but no references found.\n find(locator: Any, required: bool): List[Any]\n  locator: Any - the locator to find a reference by. required: bool - forces to raise an exception if no reference is found. returns: List[Any] - a list with matching component references.  get_all Gets all component references registered in this reference map.\n get_all(): List[Any]\n  returns: List[Any] - a list with component references.  get_all_locators Gets locators for all registered component references in this reference map.\n get_all_locators(): List[Any]\n  returns: List[Any] - a list with component locators.  get_one_optional Gets an optional component reference that matches a specified locator.\n get_one_optional(locator: Any): Any\n  locator: Any - the locator to find references by. returns: Any - a matching component reference or None if nothing was found.  get_one_required Gets a required component reference that matches a specified locator.\nthrows a ReferenceException when no references found.\n get_one_required(locator: Any): Any\n  locator: Any - the locator to find a reference by. returns: Any - a matching component reference.  get_optional Gets all component references that match a specified locator.\n get_optional(locator: Any): List[Any]\n  locator: Any - the locator to find references by. returns: List[Any] - a list with matching component references or empty list if nothing was found.  get_required Gets all component references that match a specified locator. At least one component reference must be present. If it doesn\u0026rsquo;t the method throws an error. Throws a ReferenceException when no references found.\n get_required(locator: Any): List[Any]\n  locator: Any - the locator to find references by. returns: List[Any] - a list with matching component references.  put Puts a new reference into this reference map.\n put(locator: Any, component: Any)\n  locator: Any - a locator to find the reference by. component: Any - a component reference to be added.  remove Removes a previously added reference that matches specified locator. If many references match the locator, it removes only the first one. When all references shall be removed, use removeAll method instead.\n remove(locator: Any): Any\n  locator: Any - a locator to remove reference returns: Any - the removed component reference.  remove_all Removes all component references that match the specified locator.\n remove_all(locator: Any): List[Any]\n  locator: Any - the locator to remove references by. returns: List[Any] - a list, containing all removed references.  Static methods from_tuples Creates a new References from a list of key-value pairs called tuples.\n static from_tuples(*tuples: Any): References\n  tuples: Any - a list of values where odd elements are locators and the following even elements are component references returns: References - a newly created References.  Examples class MyController(IReferenceable): _persistence = None def set_references(self, references): self._persistence = references.getOneRequired(Descriptor(\u0026#34;mygroup\u0026#34;, \u0026#34;persistence\u0026#34;, \u0026#34;*\u0026#34;, \u0026#34;*\u0026#34;, \u0026#34;1.0\u0026#34;)) persistence = MyMongoDbPersistence() references = References.from_tuples( Descriptor(\u0026#34;mygroup\u0026#34;, \u0026#34;persistence\u0026#34;, \u0026#34;mongodb\u0026#34;, \u0026#34;default\u0026#34;, \u0026#34;1.0\u0026#34;), persistence, Descriptor(\u0026#34;mygroup\u0026#34;, \u0026#34;controller\u0026#34;, \u0026#34;default\u0026#34;, \u0026#34;default\u0026#34;, \u0026#34;1.0\u0026#34;), controller ) controller.set_references(references) See also   IReferences   ","description":"An implementation of [IReferences](../ireferences) that allows you to store and locate component references.\n","image":null,"permalink":"/python/commons/refer/references/","subtitle":null,"tags":null,"title":"References"},{"content":"Implements: IReferences\nDescription The ReferencesDecorator class allows you to create chainable decorators for IReferences that allow to inject addtional capabilities, such as automatic component creation, automatic registration and opening.\nConstructors NewReferencesDecorator Creates a new instance of the decorator.\n NewReferencesDecorator(nextReferences IReferences, topReferences IReferences) *ReferencesDecorator\n  nextReferences: IReferences - next references or decorator in the chain. topReferences: IReferences - decorator at the top of the chain.  Fields NextReferences Next references or decorator in the chain.\n NextReferences: IReferences\n TopReferences Decorator at the top of the chain.\n TopReferences: IReferences\n  Methods Find Gets all component references that match the specified locator. Throws a ReferenceException when required is set to True but no references were found.\n (c *ReferencesDecorator) Find(locator interface{}, required bool) ([]interface{}, error)\n  locator: interface{} - locator to find a reference by. required: bool - if True, it forces to raise an exception when no reference is found. returns: ([]interface{}, error) - list with matching component references.  GetAll Gets all component references registered in this reference map.\n (c *ReferencesDecorator) GetAll() []interface{}\n  returns: []interface{} - list with component references.  GetAllLocators Gets locators for all registered component references in the reference map.\n (c *ReferencesDecorator) GetAllLocators() []interface{}\n  returns: []interface{} - list with component locators.  GetOneOptional Gets an optional component reference that matches the specified locator.\n (c *ReferencesDecorator) GetOneOptional(locator interface{}) interface{}\n  locator: interface{} - locator to find references by. returns: interface{} - matching component reference or nil if nothing was found.  GetOneRequired Gets a required component reference that matches the specified locator. Throws a ReferenceException when no references were found.\n (c *ReferencesDecorator) GetOneRequired(locator interface{}) (interface{}, error)\n  locator: interface{} - locator to find a reference by. returns: (interface{}, error) - matching component reference.  GetOptional Gets all component references that match the specified locator.\n (c *ReferencesDecorator) GetOptional(locator interface{}) []interface{}\n  locator: interface{} - locator to find references by. returns: []interface{} - list with matching component references or empty list if nothing was found.  GetRequired Gets all component references that match the specified locator. At least one component reference must be present. Throws a ReferenceException when no references were found.\n (c *ReferencesDecorator) GetRequired(locator interface{}) ([]interface{}, error)\n  locator: interface{} - locator to find references by. returns: ([]interface{}, error) - list with matching component references.  Put Puts a new reference into the reference map.\n (c *ReferencesDecorator) Put(locator interface{}, component interface{})\n  locator: interface{} - locator to find the reference by. reference: interface{} - component reference to be added.  Remove Removes a previously added component that matches the specified locator. If many references match the locator, it removes only the first one. When all references shall be removed, use RemoveAll method instead.\n (c *ReferencesDecorator) Remove(locator interface{}) interface{}\n  locator: interface{} - locator to remove component returns: interface{} - removed component.  RemoveAll Removes all component references that match the specified locator.\n (c *ReferencesDecorator) RemoveAll(locator interface{}) []interface{}\n  locator: interface{} - locator to remove references by. returns: []interface{} - list containing all removed references.  See also   IReferences   ","description":"Chainable decorator for IReferences that allows to inject additional capabilities such as automatic component creation, automatic registration and opening.\n","image":null,"permalink":"/golang/container/refer/references_decorator/","subtitle":null,"tags":null,"title":"ReferencesDecorator"},{"content":"Inherits: IReferences\nDescription The ReferencesDecorator class allows you to create chainable decorators for IReferences that allow to inject addtional capabilities, such as automatic component creation, automatic registration and opening.\nConstructors Creates a new instance of the decorator.\n public ReferencesDecorator(IReferences baseReferences = null, IReferences parentReferences = null)\n  baseReferences: IReferences - next references or decorator in the chain. parentReferences: IReferences - decorator at the top of the chain.  Properties BaseReferences Next references or decorator in the chain.\n public IReferences BaseReferences { get; set; }\n ParentReferences Decorator at the top of the chain.\n public IReferences ParentReferences { get; set; }\n Instance methods Find Gets all component references that match the specified locator. Throws a ReferenceException when required is set to True but no references were found.\n public virtual List\u0026lt;object\u0026gt; Find(object locator, bool required)\n  locator: object - locator to find a reference by. required: bool - if True, it forces to raise an exception when no reference is found. returns: List\u0026lt;object\u0026gt; - list with matching component references.  GetAll Gets all component references registered in this reference map.\n public virtual List\u0026lt;object\u0026gt; GetAll()\n  returns: List\u0026lt;object\u0026gt; - list with component references.  GetAllLocators Gets locators for all registered component references in the reference map.\n public virtual List\u0026lt;object\u0026gt; GetAllLocators()\n  returns: List\u0026lt;object\u0026gt; - list with component locators.  GetOneOptional Gets an optional component reference that matches the specified locator.\n public virtual object GetOneOptional(object locator)\n  locator: object - locator to find references by. returns: object - matching component reference or null if nothing was found.   public virtual T GetOneOptional\u0026lt;T\u0026gt;(object locator)\n  locator: object - the locator to find references by. returns: T - a matching component reference or null if nothing was found.  GetOneRequired Gets a required component reference that matches the specified locator. Throws a ReferenceException when no references were found.\n public virtual object GetOneRequired(object locator)\n  locator: object - locator to find a reference by. returns: object - matching component reference.  Gets a required component reference that matches specified locator.\n public virtual T GetOneRequired\u0026lt;T\u0026gt;(object locator)\n  locator: object - the locator to find a reference by. returns: T - matching component reference.  GetOptional Gets all component references that match the specified locator.\n public virtual List\u0026lt;object\u0026gt; GetOptional(object locator)\n  locator: List\u0026lt;object\u0026gt; - locator to find references by. returns: object - list with matching component references or empty list if nothing was found.  GetRequired Gets all component references that match the specified locator. At least one component reference must be present. Throws a ReferenceException when no references were found.\n public virtual List\u0026lt;object\u0026gt; GetRequired(object locator)\n  locator: object - locator to find references by. returns: List\u0026lt;object\u0026gt; - list with matching component references.  Put Puts a new reference into the reference map.\n public virtual void Put(object locator, object component)\n  locator: object - locator to find the reference by. reference: object - component reference to be added.  Remove Removes a previously added component that matches the specified locator. If many references match the locator, it removes only the first one. When all references shall be removed, use RemoveAll method instead.\n public virtual object Remove(object locator)\n  locator: object - locator to remove component returns: object - removed component.  removeAll Removes all component references that match the specified locator.\n public virtual List\u0026lt;object\u0026gt; RemoveAll(object locator)\n  locator: object - locator to remove references by. returns: List\u0026lt;object\u0026gt; - list containing all removed references.  See also   IReferences   ","description":"Chainable decorator for IReferences that allows to inject additional capabilities such as automatic component creation, automatic registration and opening.\n","image":null,"permalink":"/net/container/refer/references_decorator/","subtitle":null,"tags":null,"title":"ReferencesDecorator"},{"content":"Implements: IReferences\nDescription The ReferencesDecorator class allows you to create chainable decorators for IReferences that allow to inject addtional capabilities, such as automatic component creation, automatic registration and opening.\nConstructors Creates a new instance of the decorator.\n public constructor(nextReferences: IReferences, topReferences: IReferences)\n  nextReferences: IReferences - next references or decorator in the chain. topReferences: IReferences - decorator at the top of the chain.  Fields nextReferences Next references or decorator in the chain.\n public nextReferences: IReferences\n topReferences Decorator at the top of the chain.\n public topReferences: IReferences\n  Instance methods find Gets all component references that match the specified locator. Throws a ReferenceException when required is set to True but no references were found.\n public find\u0026lt;T\u0026gt;(locator: any, required: boolean): T[]\n  locator: any - locator to find a reference by. required: boolean - if True, it forces to raise an exception when no reference is found. returns: T[] - list with matching component references.  getAll Gets all component references registered in this reference map.\n public getAll(): any[]\n  returns: any[] - list with component references.  getAllLocators Gets locators for all registered component references in the reference map.\n public getAllLocators(): any[]\n  returns: any[] - list with component locators.  getOneOptional Gets an optional component reference that matches the specified locator.\n public getOneOptional\u0026lt;T\u0026gt;(locator: any): T\n  locator: any - locator to find references by. returns: T - matching component reference or null if nothing was found.  getOneRequired Gets a required component reference that matches the specified locator. Throws a ReferenceException when no references were found.\n public getOneRequired\u0026lt;T\u0026gt;(locator: any): T\n  locator: any - locator to find a reference by. returns: any - matching component reference.  getOptional Gets all component references that match the specified locator.\n public getOptional\u0026lt;T\u0026gt;(locator: any): T[]\n  locator: any - locator to find references by. returns: T[] - list with matching component references or empty list if nothing was found.  getRequired Gets all component references that match the specified locator. At least one component reference must be present. Throws a ReferenceException when no references were found.\n public getRequired\u0026lt;T\u0026gt;(locator: any): T[]\n  locator: any - locator to find references by. returns: T[] - list with matching component references.  put Puts a new reference into the reference map.\n public put(locator: any, component: any): any\n  locator: any - locator to find the reference by. reference: any - component reference to be added.  remove Removes a previously added component that matches the specified locator. If many references match the locator, it removes only the first one. When all references shall be removed, use removeAll method instead.\n public remove(locator: any): any\n  locator: any - locator to remove component returns: any - removed component.  removeAll Removes all component references that match the specified locator.\n public removeAll(locator: any): any[]\n  locator: any - locator to remove references by. returns: any[] - list containing all removed references.  See also   IReferences   ","description":"Chainable decorator for IReferences that allows to inject additional capabilities such as automatic component creation, automatic registration and opening.\n","image":null,"permalink":"/node/container/refer/references_decorator/","subtitle":null,"tags":null,"title":"ReferencesDecorator"},{"content":"Implements: IReferences\nDescription The ReferencesDecorator class allows you to create chainable decorators for IReferences that allow to inject addtional capabilities, such as automatic component creation, automatic registration and opening.\nConstructors Creates a new instance of the decorator.\n ReferencesDecorator(next_references: Optional[IReferences], top_references: Optional[IReferences])\n  next_references: Optional[IReferences] - next references or decorator in the chain. top_references: Optional[IReferences] - decorator at the top of the chain.  Fields next_references Next references or decorator in the chain.\n next_references: Optional[IReferences]\n top_references Decorator at the top of the chain.\n top_references: Optional[IReferences]\n  Instance methods find Gets all component references that match the specified locator. Throws a ReferenceException when required is set to True but no references were found.\n find(locator: Any, required: bool): List[Any]\n  locator: Any - locator to find a reference by. required: bool - if True, it forces to raise an exception when no reference is found. returns: List[Any] - list with matching component references.  get_all Gets all component references registered in this reference map.\n get_all(): List[Any]\n  returns: List[Any] - list with component references.  get_all_locators Gets locators for all registered component references in the reference map.\n get_all_locators(): List[Any]\n  returns: List[Any] - list with component locators.  get_one_optional Gets an optional component reference that matches the specified locator.\n get_one_optional(locator: Any): Any\n  locator: Any - locator to find references by. returns: Any - matching component reference or None if nothing was found.  get_one_required Gets a required component reference that matches the specified locator. Throws a ReferenceException when no references were found.\n get_one_required(locator: Any): Any\n  locator: Any - locator to find a reference by. returns: Any - matching component reference.  get_optional Gets all component references that match the specified locator.\n get_optional(locator: Any): List[Any]\n  locator: Any - locator to find references by. returns: List[Any] - list with matching component references or empty list if nothing was found.  get_required Gets all component references that match the specified locator. At least one component reference must be present. Throws a ReferenceException when no references were found.\n get_required(locator: Any): List[Any]\n  locator: Any - locator to find references by. returns: List[Any] - list with matching component references.  put Puts a new reference into the reference map.\n put(locator: Any = None, reference: Any = None)\n  locator: Any - locator to find the reference by. reference: Any - component reference to be added.  remove Removes a previously added component that matches the specified locator. If many references match the locator, it removes only the first one. When all references shall be removed, use remove_all method instead.\n remove(locator: Any): Any\n  locator: Any - locator to remove component returns: Any - removed component.  remove_all Removes all component references that match the specified locator.\n remove_all(locator: Any): List[Any]\n  locator: Any - locator to remove references by. returns: List[Any] - list containing all removed references.  See also   IReferences   ","description":"Chainable decorator for IReferences that allows to inject additional capabilities such as automatic component creation, automatic registration and opening.\n","image":null,"permalink":"/python/container/refer/references_decorator/","subtitle":null,"tags":null,"title":"ReferencesDecorator"},{"content":"Description TODO: add description\nProperties Name TODO: add description\n public string Name { get; set; }\n StatusCode TODO: add description\n public int StatusCode { get; set; }\n Description TODO: add description\n public string Description { get; set; }\n Schema TODO: add description\n public object Schema { get; set; }\n ","description":"TODO: add description\n","image":null,"permalink":"/net/rpc/data/response_data/","subtitle":null,"tags":null,"title":"ResponseData"},{"content":"Description The RestClient class allows you to create clients that call remote endpoints using the HTTP/REST protocol.\nConfiguration parameters  base_route: base route for a remote URI connection(s):  discovery_key: (optional) key to retrieve the connection from IDiscovery protocol: connection protocol (http or https) host: host name or IP address port: port number uri: resource URI or connection string with all parameters in it   options:  retries: number of retries (default: 3) connect_timeout: connection timeout in milliseconds (default: 10 sec) timeout: invocation timeout in milliseconds (default: 10 sec) correlationId: place for adding correalationId, query - in query string, headers - in headers, both - in query and headers (default: query)    References  *:logger:*:*:1.0 - (optional) ILogger components to pass log messages *:counters:*:*:1.0 - (optional) ICounters components to pass collected measurements *:traces:*:*:1.0 - (optional) ITracer components to record traces *:discovery:*:*:1.0 - (optional) IDiscovery services to resolve a connection  Constructors NewRestClient NewRestClient creates new instance of RestClient\n NewRestClient() *RestClient\n Fields Counters A list of counters.\n Counters: ICounters[]\n Client The HTTP client.\n Client: *http.Client\n Uri The remote service uri which is defined on openning.\n Uri: string\n Timeout The invocation timeout in milliseconds.\n Timeout: int\n ConnectionResolver The connection resolver.\n ConnectionResolver: HttpConnectionResolver\n Logger The logger.\n Logger: *CompositeLogger\n Counters The performance counters.\n Counters: *CompositeCounters\n Tracer  Tracer: *CompositeTracer\n Options The configuration options.\n Options: ConfigParams\n BaseRoute The base route.\n BaseRoute: string\n Retries The number of retries.\n Retries: int\n Headers The default headers to be added to every request.\n Headers: StringValueMap\n ConnectTimeout The connection timeout in milliseconds.\n ConnectTimeout: int\n passCorrelationId Add correlation id to headers\n passCorrelationId: string\n  Methods AddCorrelationId Adds a correlation id (correlationId) to the invocation parameter map.\n (c *RestClient) AddCorrelationId(params *StringValueMap, correlationId string) *StringValueMap\n  params: *StringValueMap - invocation parameters. correlationId: string - (optional) transaction id used to trace execution through the call chain. returns: *StringValueMap - invocation parameters with added correlation id.  AddFilterParams Adds filter parameters (with the same name as they defined) to the invocation parameter map.\n (c *RestClient) AddFilterParams(params *cdata.StringValueMap, filter *cdata.FilterParams) *cdata.StringValueMap\n  params: *cdata.StringValueMap - invocation parameters. filter: *cdata.FilterParams - (optional) filter parameters returns: *cdata.StringValueMap - invocation parameters with added filter parameters.  AddPagingParams Adds paging parameters (skip, take, total) to invocation parameter map.\n (c *RestClient) AddPagingParams(params *cdata.StringValueMap, paging *cdata.PagingParams) *cdata.StringValueMap\n  params: *cdata.StringValueMap - invocation parameters. paging: *cdata.PagingParams - (optional) paging parameters returns: *cdata.StringValueMap - invocation parameters with added paging parameters.  Call Calls a remote method via HTTP/REST protocol.\n (c *RestClient) Call(prototype reflect.Type, method string, route string, correlationId string, params *cdata.StringValueMap, data interface{}) (result interface{}, err error)\n  prototype: reflect.Type - type for convert JSON result. Set nil for return raw JSON string method: string - HTTP method: \u0026ldquo;get\u0026rdquo;, \u0026ldquo;head\u0026rdquo;, \u0026ldquo;post\u0026rdquo;, \u0026ldquo;put\u0026rdquo;, \u0026ldquo;delete\u0026rdquo; route: string - a command route. Base route will be added to this route correlationId: string - (optional) transaction id used to trace execution through a call chain. params: *cdata.StringValueMap - (optional) query parameters. data: interface{} - (optional) body object. returns: (result interface{}, err error) - result object  Close Closes a component and frees used resources.\n (c *RestClient) Close(correlationId string) error\n  correlationId: string - (optional) transaction id used to trace execution through a call chain. returns: error - returns error if not closed  Configure Configures a component by passing configuration parameters.\n (c *RestClient) Configure(config *cconf.ConfigParams)\n  config: ConfigParams - configuration parameters to be set.  Instrument Adds instrumentation to log calls and measures call time. It returns a Timing object that is used to end the time measurement.\n (c *RestClient) Instrument(correlationId string, name string) *service.InstrumentTiming\n  correlationId: string - (optional) transaction id used to trace execution through a call chain. name: string - method name. returns: *service.InstrumentTiming - Instrument Timing object used to end the time measurement.  IsOpen Checks if the component is open.\n (c *RestClient) IsOpen() bool\n  returns: bool - True if the component is open and False otherwise.  Open Opens the component.\n (c *RestClient) Open(correlationId string) error\n  correlationId: string - (optional) transaction id used to trace execution through a call chain. returns: error - returns error if not opened  SetReferences Sets references to dependent components.\n (c *RestClient) SetReferences(references crefer.IReferences)\n  references: IReferences - references used to locate the component dependencies.  Examples type MyRestClient struct { *RestClient } ... func (c *MyRestClient) GetData(correlationId string, id string) (result *tdata.MyDataPage, err error) { params := cdata.NewEmptyStringValueMap() params.Set(\u0026#34;id\u0026#34;, id) calValue, calErr := c.Call(MyDataPageType, \u0026#34;get\u0026#34;, \u0026#34;/data\u0026#34;, correlationId, params, nil) if calErr != nil { return nil, calErr } result, _ = calValue.(*tdata.MyDataPage) c.Instrument(correlationId, \u0026#34;myData.get_page_by_filter\u0026#34;) return result, nil } client := NewMyRestClient(); client.Configure(cconf.NewConfigParamsFromTuples( \u0026#34;connection.protocol\u0026#34;, \u0026#34;http\u0026#34;, \u0026#34;connection.host\u0026#34;, \u0026#34;localhost\u0026#34;, \u0026#34;connection.port\u0026#34;, 8080, )); result, err := client.GetData(\u0026#34;123\u0026#34;, \u0026#34;1\u0026#34;) ... See also   RestService   CommandableHttpService   ","description":"Abstract client that calls remote endpoints using the HTTP/REST protocol.\n","image":null,"permalink":"/golang/rpc/clients/rest_client/","subtitle":null,"tags":null,"title":"RestClient"},{"content":"Inherits: IConfigurable, IReferenceable, IOpenable\nDescription The RestClient class allows you to create clients that call remote endpoints using the HTTP/REST protocol.\nConfiguration parameters  base_route: base route for a remote URI connection(s):  discovery_key: (optional) key to retrieve the connection from IDiscovery protocol: connection protocol (http or https) host: host name or IP address port: port number uri: resource URI or connection string with all parameters in it   options:  retries: number of retries (default: 3) connect_timeout: connection timeout in milliseconds (default: 10 sec) timeout: invocation timeout in milliseconds (default: 10 sec) correlationId: place for adding correalationId, query - in query string, headers - in headers, both - in query and headers (default: query)    References  *:logger:*:*:1.0 - (optional) ILogger components to pass log messages *:counters:*:*:1.0 - (optional) ICounters components to pass collected measurements *:traces:*:*:1.0 - (optional) ITracer components to record traces *:discovery:*:*:1.0 - (optional) IDiscovery services to resolve a connection  Fields _counters A list of counters.\n protected _counters: ICounters[] = []\n _client The HTTP client.\n protected _client: HttpClient\n _address The remote service uri which is defined on openning.\n protected _address: string\n _timeout The invocation timeout in milliseconds.\n protected _timeout: int = 1000\n _connectionResolver The connection resolver.\n protected _connectionResolver: HttpConnectionResolver = HttpConnectionResolver()\n _logger The logger.\n protected _logger: CompositeLogger = CompositeLogger()\n _counters The performance counters.\n protected _counters: CompositeCounters = CompositeCounters()\n _options The configuration options.\n protected _options: ConfigParams = ConfigParams()\n _baseRoute The base route.\n protected _baseRoute: string\n _retries The number of retries.\n protected _retries: int = 1\n _headers The default headers to be added to every request.\n protected _headers: StringValueMap\n _correlationIdPlace Defines where to add the correlation id.\n protected _correlationIdPlace: string = \u0026ldquo;query\u0026rdquo;\n  Instance methods AddCorrelationId Adds a correlation id (correlationId) to the invocation parameter map.\n protected string AddCorrelationId(string route, string correlationId)\n  route: string - invocation parameters. correlationId: string - (optional) transaction id used to trace execution through the call chain. returns: string - invocation parameters with added correlation id.  AddFilterParams Adds filter parameters (with the same name as they defined) to the invocation parameter map.\n protected string AddFilterParams(string route, FilterParams filter)\n  route: string - invocation parameters. filters: FilterParams - (optional) filter parameters. returns: string - invocation parameters with added filter parameters.  AddPagingParams Adds paging parameters (skip, take, total) to invocation parameter map.\n protected string AddPagingParams(string route, PagingParams paging)\n  params: string - invocation parameters. paging: PagingParams - (optional) paging parameters returns: string - invocation parameters with added paging parameters.  CallAsync Calls a remote method via HTTP/REST protocol.\n protected Task CallAsync(string correlationId, HttpMethod method, string route)\n  correlationId: string - (optional) transaction id used to trace execution through a call chain. method: HttpMethod - HTTP method: \u0026ldquo;get\u0026rdquo;, \u0026ldquo;head\u0026rdquo;, \u0026ldquo;post\u0026rdquo;, \u0026ldquo;put\u0026rdquo;, \u0026ldquo;delete\u0026rdquo; route: string - a command route. Base route will be added to this route   protected Task CallAsync(string correlationId, HttpMethod method, string route, object requestEntity)\n  correlationId: string - (optional) transaction id used to trace execution through a call chain. method: HttpMethod - HTTP method: \u0026ldquo;get\u0026rdquo;, \u0026ldquo;head\u0026rdquo;, \u0026ldquo;post\u0026rdquo;, \u0026ldquo;put\u0026rdquo;, \u0026ldquo;delete\u0026rdquo; route: string - a command route. Base route will be added to this route requestEntity: object - request body object.   protected Task\u0026lt;T\u0026gt; CallAsync\u0026lt;T\u0026gt;(string correlationId, HttpMethod method, string route)\n  correlationId: string - (optional) transaction id used to trace execution through a call chain. method: HttpMethod - HTTP method: \u0026ldquo;get\u0026rdquo;, \u0026ldquo;head\u0026rdquo;, \u0026ldquo;post\u0026rdquo;, \u0026ldquo;put\u0026rdquo;, \u0026ldquo;delete\u0026rdquo; route: string - a command route. Base route will be added to this route returns: Task\u0026lt;T\u0026gt; - result object   protected Task\u0026lt;T\u0026gt; CallAsync\u0026lt;T\u0026gt;(string correlationId, HttpMethod method, string route, object requestEntity)\n  correlationId: string - (optional) transaction id used to trace execution through a call chain. method: HttpMethod - HTTP method: \u0026ldquo;get\u0026rdquo;, \u0026ldquo;head\u0026rdquo;, \u0026ldquo;post\u0026rdquo;, \u0026ldquo;put\u0026rdquo;, \u0026ldquo;delete\u0026rdquo; route: string - a command route. Base route will be added to this route requestEntity: object - request body object. returns: Task\u0026lt;T\u0026gt; - result object  CloseAsync Closes a component and frees used resources.\n public virtual Task CloseAsync(string correlationId)\n  correlationId: string - (optional) transaction id used to trace execution through a call chain.  Configure Configures a component by passing configuration parameters.\n public virtual void Configure(ConfigParams config)\n  config: ConfigParams - configuration parameters to be set.  ExecuteAsync Executes a remote method via HTTP/REST protocol.\n protected Task ExecuteAsync(string correlationId, HttpMethod method, string route, object requestEntity)\n  correlationId: string - (optional) transaction id to trace execution through call chain. method: HttpMethod - HTTP method: \u0026ldquo;get\u0026rdquo;, \u0026ldquo;head\u0026rdquo;, \u0026ldquo;post\u0026rdquo;, \u0026ldquo;put\u0026rdquo;, \u0026ldquo;delete\u0026rdquo; route: string - a command route. Base route will be added to this route requestEntity: object - request body object.   protected async Task\u0026lt;T\u0026gt; ExecuteAsync\u0026lt;T\u0026gt;(string correlationId, HttpMethod method, string route)\n  correlationId: string - (optional) transaction id to trace execution through call chain. method: HttpMethod - HTTP method: \u0026ldquo;get\u0026rdquo;, \u0026ldquo;head\u0026rdquo;, \u0026ldquo;post\u0026rdquo;, \u0026ldquo;put\u0026rdquo;, \u0026ldquo;delete\u0026rdquo; route: string - a command route. Base route will be added to this route requestEntity: object - request body object. returns: Task\u0026lt;T\u0026gt; - result object.   protected Task\u0026lt;T\u0026gt; ExecuteAsync\u0026lt;T\u0026gt;(string correlationId, HttpMethod method, string route, object requestEntity)\n  correlationId: string - (optional) transaction id to trace execution through call chain. method: HttpMethod - HTTP method: \u0026ldquo;get\u0026rdquo;, \u0026ldquo;head\u0026rdquo;, \u0026ldquo;post\u0026rdquo;, \u0026ldquo;put\u0026rdquo;, \u0026ldquo;delete\u0026rdquo; route: string - a command route. Base route will be added to this route requestEntity: object - request body object. returns: Task\u0026lt;T\u0026gt; - result object.  Instrument Adds instrumentation to log calls and measures call time. It returns a Timing object that is used to end the time measurement.\n protected CounterTiming Instrument(string correlationId, [CallerMemberName]string methodName = null)\n  correlationId: string - (optional) transaction id used to trace execution through a call chain. methodName: [CallerMemberName]string - method name. returns: CounterTiming - CounterTiming object used to end the time measurement.  InstrumentError Adds instrumentation to error handling.\n protected void InstrumentError(string correlationId, [CallerMemberName]string methodName = null, Exception ex = null, bool rethrow = false)\n  correlationId: string - (optional) transaction id used to trace execution through a call chain. methodName: [CallerMemberName]string - method name. ex: Exception - Error that occured during the method call. rethrow: bool - True to throw the exception.  IsOpen Checks if the component is open.\n public virtual bool IsOpen()\n  returns: bool - True if the component is open and False otherwise.  OpenAsync Opens the component.\n public virtual Task OpenAsync(string correlationId)\n  correlationId: string - (optional) transaction id used to trace execution through a call chain.  SetReferences Sets references to dependent components.\n public virtual void SetReferences(IReferences references)\n  references: IReferences - references used to locate the component dependencies.  SafeExecuteAsync Safely executes a remote method via HTTP/REST protocol and logs execution time.\n protected Task\u0026lt;T\u0026gt; SafeExecuteAsync\u0026lt;T\u0026gt;(string correlationId, HttpMethod method, string route, object requestEntity)\n  correlationId: string - (optional) transaction id to trace execution through call chain. method: HttpMethod - HTTP method: \u0026ldquo;get\u0026rdquo;, \u0026ldquo;head\u0026rdquo;, \u0026ldquo;post\u0026rdquo;, \u0026ldquo;put\u0026rdquo;, \u0026ldquo;delete\u0026rdquo; route: string - a command route. Base route will be added to this route requestEntity: object - request body object. returns: Task\u0026lt;T\u0026gt; - result object.   protected async Task\u0026lt;T\u0026gt; SafeExecuteAsync\u0026lt;T\u0026gt;(string correlationId, HttpMethod method, string route)\n  correlationId: string - (optional) transaction id to trace execution through call chain. method: HttpMethod - HTTP method: \u0026ldquo;get\u0026rdquo;, \u0026ldquo;head\u0026rdquo;, \u0026ldquo;post\u0026rdquo;, \u0026ldquo;put\u0026rdquo;, \u0026ldquo;delete\u0026rdquo; route: string - a command route. Base route will be added to this route returns: Task\u0026lt;T\u0026gt; - result object.  SafeCallAsync Safely calls a remote method via HTTP/REST protocol and logs execution time.\n protected Task\u0026lt;T\u0026gt; SafeCallAsync\u0026lt;T\u0026gt;(string correlationId, HttpMethod method, string route, object requestEntity)\n  correlationId: string - (optional) transaction id used to trace execution through a call chain. method: HttpMethod - HTTP method: \u0026ldquo;post\u0026rdquo;, \u0026ldquo;put\u0026rdquo;, \u0026ldquo;patch\u0026rdquo;. route: string - a command route. Base route will be added to this route requestEntity: object - request body object. returns: Task\u0026lt;T\u0026gt; - result object.   protected Task\u0026lt;T\u0026gt; SafeCallAsync\u0026lt;T\u0026gt;(string correlationId, HttpMethod method, string route)\n  correlationId: string - (optional) transaction id used to trace execution through a call chain. method: HttpMethod - HTTP method: \u0026ldquo;post\u0026rdquo;, \u0026ldquo;put\u0026rdquo;, \u0026ldquo;patch\u0026rdquo;. route: string - a command route. Base route will be added to this route returns: Task\u0026lt;T\u0026gt; - result object.  Examples class MyRestClient: RestClient, IMyClient { ... public MyData GetData(string correlationId, string id) { var timing = this.Instrument(correlationId, \u0026#39;myclient.get_data\u0026#39;); try { var result = this.ExecuteAsync\u0026lt;MyData\u0026gt;(correlationId, HttpMethod.Post, \u0026#34;/get_data\u0026#34;, new MyData(id)); } catch (Exception ex) { this.InstrumentError(correlationId, \u0026#34;myclient.get_data\u0026#34;, ex, true); } finally { timing.EndTiming(); } return result; } ... } var client = new MyRestClient(); client.Configure(ConfigParams.FromTuples( \u0026#34;connection.protocol\u0026#34;, \u0026#34;http\u0026#34;, \u0026#34;connection.host\u0026#34;, \u0026#34;localhost\u0026#34;, \u0026#34;connection.port\u0026#34;, 8080 )); var data = client.GetData(\u0026#34;123\u0026#34;, \u0026#34;1\u0026#34;); ... See also   RestService   CommandableHttpService   ","description":"Abstract client that calls remote endpoints using the HTTP/REST protocol.\n","image":null,"permalink":"/net/rpc/clients/rest_client/","subtitle":null,"tags":null,"title":"RestClient"},{"content":"Implements: IConfigurable, IReferenceable, IOpenable\nDescription The RestClient class allows you to create clients that call remote endpoints using the HTTP/REST protocol.\nConfiguration parameters  base_route: base route for a remote URI connection(s):  discovery_key: (optional) key to retrieve the connection from IDiscovery protocol: connection protocol (http or https) host: host name or IP address port: port number uri: resource URI or connection string with all parameters in it   options:  retries: number of retries (default: 3) connect_timeout: connection timeout in milliseconds (default: 10 sec) timeout: invocation timeout in milliseconds (default: 10 sec) correlationId: place for adding correalationId, query - in query string, headers - in headers, both - in query and headers (default: query)    References  *:logger:*:*:1.0 - (optional) ILogger components to pass log messages *:counters:*:*:1.0 - (optional) ICounters components to pass collected measurements *:traces:*:*:1.0 - (optional) ITracer components to record traces *:discovery:*:*:1.0 - (optional) IDiscovery services to resolve a connection  Fields _counters A list of counters.\n protected _counters: ICounters[] = []\n _client The HTTP client.\n protected _client: any\n _uri The remote service uri which is defined on openning.\n protected _uri: string\n _timeout The invocation timeout in milliseconds.\n protected _timeout: number = 1000\n _connectionResolver The connection resolver.\n protected _connectionResolver: HttpConnectionResolver = HttpConnectionResolver()\n _logger The logger.\n protected _logger: CompositeLogger = CompositeLogger()\n _counters The performance counters.\n protected _counters: CompositeCounters = CompositeCounters()\n _tracer The tracer.\n protected _tracer: CompositeTracer = CompositeTracer()\n _options The configuration options.\n protected _options: ConfigParams = ConfigParams()\n _baseRoute The base route.\n protected _baseRoute: string\n _retries The number of retries.\n protected _retries = 1\n _headers The default headers to be added to every request.\n protected _headers: any = {}\n _connectTimeout The connection timeout in milliseconds.\n protected _connectTimeout: number = 1000\n _correlationIdLocation Defines where to add the correlation id.\n protected _correlationIdLocation: string = \u0026ldquo;query\u0026rdquo;\n  Instance methods addCorrelationId Adds a correlation id (correlationId) to the invocation parameter map.\n protected addCorrelationId(params: any, correlationId: string): any\n  params: any - invocation parameters. correlationId: string - (optional) transaction id used to trace execution through the call chain. returns: any - invocation parameters with added correlation id.  addFilterParams Adds filter parameters (with the same name as they defined) to the invocation parameter map.\n protected addFilterParams(params: any, filters: any): any\n  params: any - invocation parameters. filters: any - (optional) filter parameters returns: any - invocation parameters with added filter parameters.  addPagingParams Adds paging parameters (skip, take, total) to invocation parameter map.\n protected addPagingParams(params: any, paging: any): any\n  params: any - invocation parameters. paging: any - (optional) paging parameters returns: any - invocation parameters with added paging parameters.  call Calls a remote method via HTTP/REST protocol.\n protected call\u0026lt;T\u0026gt;(method: string, route: string, correlationId?: string, params: any = {}, data?: any): Promise\u0026lt;T\u0026gt;\n  method: string - HTTP method: \u0026ldquo;get\u0026rdquo;, \u0026ldquo;head\u0026rdquo;, \u0026ldquo;post\u0026rdquo;, \u0026ldquo;put\u0026rdquo;, \u0026ldquo;delete\u0026rdquo; route: string - a command route. Base route will be added to this route correlationId: string - (optional) transaction id used to trace execution through a call chain. params: any - (optional) query parameters. data: any - (optional) body object. returns: Promise\u0026lt;T\u0026gt; - result object  close Closes a component and frees used resources.\n public close(correlationId: string): Promise\u0026lt;void\u0026gt;\n  correlationId: string - (optional) transaction id used to trace execution through a call chain.  configure Configures a component by passing configuration parameters.\n public configure(config: ConfigParams): void\n  config: ConfigParams - configuration parameters to be set.  instrument Adds instrumentation to log calls and measures call time. It returns a Timing object that is used to end the time measurement.\n protected instrument(correlationId: string, name: string): InstrumentTiming\n  correlationId: string - (optional) transaction id used to trace execution through a call chain. name: string - method name. returns: InstrumentTiming - InstrumentTiming object used to end the time measurement.  isOpen Checks if the component is open.\n public isOpen(): boolean\n  returns: boolean - True if the component is open and False otherwise.  open Opens the component.\n public open(correlationId: string): Promise\u0026lt;void\u0026gt;\n  correlationId: string - (optional) transaction id used to trace execution through a call chain.  setReferences Sets references to dependent components.\n public setReferences(references: IReferences): void\n  references: IReferences - references used to locate the component dependencies.  Examples class MyRestClient extends RestClient implements IMyClient { ... public async getData(correlationId: string, id: string): Promise\u0026lt;MyData\u0026gt; { let timing = this.instrument(correlationId, \u0026#39;myclient.get_data\u0026#39;); try { return await this.call(\u0026#34;get\u0026#34;, \u0026#34;/get_data\u0026#34; correlationId, { id: id }, null); } catch (ex) { timing.endFailure(ex); } finally { timing.endTiming(); } } ... } let client = new MyRestClient(); client.configure(ConfigParams.fromTuples( \u0026#34;connection.protocol\u0026#34;, \u0026#34;http\u0026#34;, \u0026#34;connection.host\u0026#34;, \u0026#34;localhost\u0026#34;, \u0026#34;connection.port\u0026#34;, 8080 )); let result = await client.getData(\u0026#34;123\u0026#34;, \u0026#34;1\u0026#34;); See also   RestService   CommandableHttpService   ","description":"Abstract client that calls remote endpoints using the HTTP/REST protocol.\n","image":null,"permalink":"/node/rpc/clients/rest_client/","subtitle":null,"tags":null,"title":"RestClient"},{"content":"Implements: IConfigurable, IReferenceable, IOpenable\nDescription The RestClient class allows you to create clients that call remote endpoints using the HTTP/REST protocol.\nConfiguration parameters  base_route: base route for a remote URI connection(s):  discovery_key: (optional) key to retrieve the connection from IDiscovery protocol: connection protocol (http or https) host: host name or IP address port: port number uri: resource URI or connection string with all parameters in it   options:  retries: number of retries (default: 3) connect_timeout: connection timeout in milliseconds (default: 10 sec) timeout: invocation timeout in milliseconds (default: 10 sec) correlation_id: place for adding correalationId, query - in query string, headers - in headers, both - in query and headers (default: query)    References  *:logger:*:*:1.0 - (optional) ILogger components to pass log messages *:counters:*:*:1.0 - (optional) ICounters components to pass collected measurements *:traces:*:*:1.0 - (optional) ITracer components to record traces *:discovery:*:*:1.0 - (optional) IDiscovery services to resolve a connection  Fields _counters A list of counters.\n _counters: List[ICounters] = []\n _client The HTTP client.\n _client: Any\n _uri The remote service uri which is defined on openning.\n _uri: str\n _timeout The invocation timeout in milliseconds.\n _timeout = 1000\n _connection_resolver The connection resolver.\n _connection_resolver: HttpConnectionResolver = HttpConnectionResolver()\n _logger The logger.\n _logger: CompositeLogger = CompositeLogger()\n _counters The performance counters.\n _counters: CompositeCounters = CompositeCounters()\n _tracer The tracer.\n _tracer: CompositeTracer = CompositeTracer()\n _options The configuration options.\n _options: ConfigParams = ConfigParams()\n _base_route The base route.\n _base_route: str\n _retries The number of retries.\n _retries = 1\n _headers The default headers to be added to every request.\n _headers: dict = {}\n _connect_timeout The connection timeout in milliseconds.\n _connect_timeout = 1000\n _correlation_id_location Defines where to add the correlation id.\n _correlation_id_location: str = \u0026ldquo;query\u0026rdquo;\n  Instance methods add_correlation_id Adds a correlation id (correlation_id) to the invocation parameter map.\n add_correlation_id(params: Any = None, correlation_id: Optional[str] = None): Any\n  params: Any - invocation parameters. correlation_id: Optional[str] - (optional) transaction id used to trace execution through the call chain. returns: Any - invocation parameters with added correlation id.  add_filter_params Adds filter parameters (with the same name as they defined) to the invocation parameter map.\n add_filter_params(params: Any = None, filters: Any = None): dict\n  params: Any - invocation parameters. filters: Any - (optional) filter parameters returns: dict - invocation parameters with added filter parameters.  add_paging_params Adds paging parameters (skip, take, total) to invocation parameter map.\n add_paging_params(params: Any = None, paging: Any = None): dict\n  params: Any - invocation parameters. paging: Any - (optional) paging parameters returns: dict - invocation parameters with added paging parameters.  call Calls a remote method via HTTP/REST protocol.\n call(method: str, route: str, correlation_id: Optional[str] = None, params: Any = None, data: Any = None): Any\n  method: str - HTTP method: \u0026ldquo;get\u0026rdquo;, \u0026ldquo;head\u0026rdquo;, \u0026ldquo;post\u0026rdquo;, \u0026ldquo;put\u0026rdquo;, \u0026ldquo;delete\u0026rdquo; route: str - a command route. Base route will be added to this route correlation_id: Optional[str] - (optional) transaction id used to trace execution through a call chain. params: Any - (optional) query parameters. data: Any - (optional) body object. returns: Any - result object  close Closes a component and frees used resources.\n close(correlation_id: Optional[str])\n  correlation_id: Optional[str] - (optional) transaction id used to trace execution through a call chain.  configure Configures a component by passing configuration parameters.\n configure(config: ConfigParams)\n  config: ConfigParams - configuration parameters to be set.  _instrument Adds instrumentation to log calls and measures call time. It returns a Timing object that is used to end the time measurement.\n _instrument(correlation_id: Optional[str], name: str): InstrumentTiming\n  correlation_id: Optional[str] - (optional) transaction id used to trace execution through a call chain. name: str - method name. returns: InstrumentTiming - InstrumentTiming object used to end the time measurement.  is_open Checks if the component is open.\n is_open(): bool\n  returns: bool - True if the component is open and False otherwise.  open Opens the component.\n open(correlation_id: Optional[str])\n  correlation_id: Optional[str] - (optional) transaction id used to trace execution through a call chain.  set_references Sets references to dependent components.\n set_references(references: IReferences)\n  references: IReferences - references used to locate the component dependencies.  Examples class MyRestClient(RestClient, IMyClient): def get_data(self, correlation_id, id): timing = self.instrument(correlationId, \u0026#39;myclient.get_data\u0026#39;) result = self._controller.get_data(correlationId, id) timing.end_timing() return result # ... client = MyRestClient() client.configure(ConfigParams.fromTuples(\u0026#34;connection.protocol\u0026#34;, \u0026#34;http\u0026#34;, \u0026#34;connection.host\u0026#34;, \u0026#34;localhost\u0026#34;, \u0026#34;connection.port\u0026#34;, 8080)) data = client.getData(\u0026#34;123\u0026#34;, \u0026#34;1\u0026#34;) # ... See also   RestService   CommandableHttpService   ","description":"Abstract client that calls remote endpoints using the HTTP/REST protocol.\n","image":null,"permalink":"/python/rpc/clients/rest_client/","subtitle":null,"tags":null,"title":"RestClient"},{"content":"Description The RestOperations class allows you to handle REST services' operations.\nConstructors NewRestOperations NewRestOperations creates new instance of RestOperations\n NewRestOperations() *RestOperations\n Fields Logger Composite logger component\n Logger: CompositeLogger\n Counters Counter component\n Counters: CompositeCounters\n DependencyResolver Dependency resolver component\n DependencyResolver: DependencyResolver\n  Methods Configure Configures a component by passing its configuration parameters.\n (c *RestOperations) Configure(config *cconf.ConfigParams)\n  config: *cconf.ConfigParams - configuration parameters to be set.  GetCorrelationId Returns a correlationId from a request\n (c *RestOperations) GetCorrelationId(req *http.Request) string\n  req: *http.Request - an HTTP request returns: string - correlationId from a request  GetFilterParams Gets the filter parameters.\n (c *RestOperations) GetFilterParams(req *http.Request) *cdata.FilterParams\n  req: *http.Request - an HTTP request returns: *cdata.FilterParams - filter paramters  getPagingParams Gets the paging parameters.\n (c *RestOperations) GetPagingParams(req *http.Request) *cdata.PagingParams\n  req: *http.Request - an HTTP request returns: *cdata.PagingParams - paging paramters  SendBadRequest Sends a bad request error message.\n (c *RestOperations) SendBadRequest(res http.ResponseWriter, req *http.Request, message string)\n  res: http.ResponseWriter - an HTTP request req: *http.Request - an HTTP response message: string - message  SendConflict Sends a conflict error messge\n (c *RestOperations) SendConflict(res http.ResponseWriter, req *http.Request, message string)\n  res: http.ResponseWriter - an HTTP request req: *http.Request - an HTTP response message: string - message  SendCreatedResult Sends a JSON object with the created result.\n (c *RestOperations) SendCreatedResult(res http.ResponseWriter, req *http.Request, result interface{}, err error)\n  res: http.ResponseWriter - an HTTP request req: *http.Request - an HTTP response result: interface{} - result to be sent error: error - (optional) error objrct to send  SendDeletedResult Sends the deleted result in JSON format.\n (c *RestOperations) SendDeletedResult(res http.ResponseWriter, req *http.Request, result interface{}, err error)\n  res: http.ResponseWriter - an HTTP request req: *http.Request - an HTTP response result: interface{} - result to be sent error: error - (optional) error objrct to send  SendEmptyResult Send an empty result with 204 status code.\n (c *RestOperations) SendEmptyResult(res http.ResponseWriter, req *http.Request, err error)\n  res: http.ResponseWriter - an HTTP request req: *http.Request - an HTTP response  SendError Sends an error serialized as ErrorDescription object and appropriate HTTP status code.\n (c *RestOperations) SendError(res http.ResponseWriter, req *http.Request, err error)\n  res: http.ResponseWriter - an HTTP request req: *http.Request - an HTTP response error: error - (optional) error objrct to send  SendInternalError Sends an internal error message\n (c *RestOperations) SendInternalError(res http.ResponseWriter, req *http.Request, message string)\n  res: http.ResponseWriter - an HTTP request req: *http.Request - an HTTP response message: string - message  SendNotFound Sends a not found error message.\n (c *RestOperations) SendNotFound(res http.ResponseWriter, req *http.Request, message string)\n  res: http.ResponseWriter - an HTTP request req: *http.Request - an HTTP response message: string - message  SendResult Sends a result as a JSON object.\n (c *RestOperations) SendResult(res http.ResponseWriter, req *http.Request, result interface{}, err error)\n  res: http.ResponseWriter - an HTTP request req: *http.Request - an HTTP response result: interface{} - result error: error - (optional) error objrct to send  SendServerUnavailable Sends a server unavailable error message (Status code 503).\n (c *RestOperations) SendServerUnavailable(res http.ResponseWriter, req *http.Request, message string)\n  res: http.ResponseWriter - an HTTP request req: *http.Request - an HTTP response message: string - message  SendSessionExpired Sends a session expired error message (Status code 440).\n (c *RestOperations) SendSessionExpired(res http.ResponseWriter, req *http.Request, message string)\n  res: http.ResponseWriter - an HTTP request req: *http.Request - an HTTP response message: string - message  SendUnauthorized Sends an unauthorized error message.\n (c *RestOperations) SendUnauthorized(res http.ResponseWriter, req *http.Request, message string)\n  res: http.ResponseWriter - an HTTP request req: *http.Request - an HTTP response message: string - message  SetReferences Sets the specified references.\n (c *RestOperations) SetReferences(references crefer.IReferences)\n  references: crefer.IReferences - specified references  ","description":"Handles REST services' operations.\n","image":null,"permalink":"/golang/rpc/services/rest_operations/","subtitle":null,"tags":null,"title":"RestOperations"},{"content":"Inherits: IConfigurable, IReferenceable\nDescription The RestOperations class allows you to handle REST services' operations.\nFields _logger Composite logger component\n protected _logger: CompositeLogger = CompositeLogger()\n _counters Counter component\n protected _counters: CompositeCounters = CompositeCounters()\n _dependencyResolver Dependency resolver component\n protected _dependencyResolver: DependencyResolver = DependencyResolver()\n  Instance methods Configure Configures a component by passing its configuration parameters.\n public virtual void Configure(ConfigParams config)\n  config: ConfigParams - configuration parameters to be set.  GetCorrelationId Returns a correlationId from a request\n protected string GetCorrelationId(HttpRequest request)\n  request: HttpRequest - an HTTP request returns: string - correlationId from a request  GetFilterParams Gets the filter parameters.\n protected FilterParams GetFilterParams(HttpRequest request)\n  request: HttpRequest - an HTTP request returns: FilterParams - filter paramters  GetPagingParams Gets the paging parameters.\n protected PagingParams GetPagingParams(HttpRequest request)\n  request: HttpRequest - an HTTP request returns: PagingParams - paging paramters  InvokeAsync Invokes an operation.\n public Task InvokeAsync(string operation, object[] parameters)\n  operation: string - operation to be invoked. parameters: object[] - TODO: add description.  InvokeWithResponseAsync Invokes an operation with returning response.\n public Task\u0026lt;dynamic\u0026gt; InvokeWithResponseAsync(string operation, object[] parameters)\n  operation: string - operation to be invoked. parameters: object[] - TODO: add description. returns: Task\u0026lt;dynamic\u0026gt; - operation.  SendBadRequestAsync Sends a bad request error message.\n protected Task SendBadRequestAsync(HttpRequest request, HttpResponse response, string message)\n  request: HttpRequest - an HTTP request. response: HttpResponse - an HTTP request. message: string - message  SendConflictAsync Sends a conflict error messge\n protected Task SendConflictAsync(HttpRequest request, HttpResponse response, string message)\n  request: HttpRequest - an HTTP request. response: HttpResponse - an HTTP request. message: string - message  SendCreatedResultAsync Sends a JSON object with the created result.\n protected Task SendCreatedResultAsync(HttpResponse response, object result)\n  request: HttpRequest - an HTTP request. response: HttpResponse - an HTTP request. message: string - message  SendDeletedResultAsync Sends the deleted result in JSON format.\n protected Task SendDeletedResultAsync(HttpResponse response, object result)\n  request: HttpRequest - an HTTP request. response: HttpResponse - an HTTP request.  SendEmptyResultAsync Send an empty result with 204 status code.\n protected Task SendEmptyResultAsync(HttpResponse response)\n  request: HttpRequest - an HTTP request. response: HttpResponse - an HTTP request.  SendErrorAsync Sends an error serialized as ErrorDescription object and appropriate HTTP status code.\n protected Task SendErrorAsync(HttpResponse response, Exception error)\n  request: HttpRequest - an HTTP request. response: HttpResponse - an HTTP request. error: Exception - error  SendInternalErrorAsync Sends an internal error message\n protected Task SendInternalErrorAsync(HttpRequest request, HttpResponse response, string message)\n  request: HttpRequest - an HTTP request. response: HttpResponse - an HTTP request. message: string - message  SendNotFoundAsync Sends a not found error message.\n protected Task SendNotFoundAsync(HttpRequest request, HttpResponse response, string message)\n  request: HttpRequest - an HTTP request. response: HttpResponse - an HTTP request. message: string - message  SendResultAsync Sends a result as a JSON object.\n protected Task SendResultAsync(HttpResponse response, object result)\n  request: HttpRequest - an HTTP request. response: HttpResponse - an HTTP request. result: object - result.  SendServerUnavailable Sends a server unavailable error message (Status code 503).\n protected Task SendServerUnavailableAsync(HttpRequest request, HttpResponse response, string message)\n  request: HttpRequest - an HTTP request. response: HttpResponse - an HTTP request. message: string - message  SendSessionExpiredASync Sends a session expired error message (Status code 440).\n protected Task SendSessionExpiredASync(HttpRequest request, HttpResponse response, string message)\n  request: HttpRequest - an HTTP request. response: HttpResponse - an HTTP request. message: string - message  SendUnauthorizedAsync Sends an unauthorized error message.\n protected Task SendUnauthorizedAsync(HttpRequest request, HttpResponse response, string message)\n  request: HttpRequest - an HTTP request. response: HttpResponse - an HTTP request. message: string - message  SetReferences Sets the specified references.\n public virtual void SetReferences(IReferences references)\n  references: IReferences - specified references  ","description":"Handles REST services' operations.\n","image":null,"permalink":"/net/rpc/services/rest_operations/","subtitle":null,"tags":null,"title":"RestOperations"},{"content":"Implements: IConfigurable, IReferenceable\nDescription The RestOperations class allows you to handle REST services' operations.\nFields _logger Composite logger component\n protected _logger: CompositeLogger = CompositeLogger()\n _counters Counter component\n protected _counters: CompositeCounters = CompositeCounters()\n _dependencyResolver Dependency resolver component\n protected _dependencyResolver: DependencyResolver = DependencyResolver()\n  Instance methods configure Configures a component by passing its configuration parameters.\n public configure(config: ConfigParams): void\n  config: ConfigParams - configuration parameters to be set.  getCorrelationId Returns a correlationId from a request\n protected getCorrelationId(req: any): any\n  req: any - an HTTP request returns: any - correlationId from a request  getFilterParams Gets the filter parameters.\n protected getFilterParams(req: any): FilterParams\n  req: any - an HTTP request returns: FilterParams - filter paramters  getPagingParams Gets the paging parameters.\n protected getPagingParams(req: any): PagingParams\n  req: any - an HTTP request returns: PagingParams - paging paramters  invoke Invokes an operation.\n public invoke(operation: string): (req: any, res: any) =\u0026gt; void\n  operation: string - operation to be invoked returns: (req: any, res: any) =\u0026gt; void - operation  sendBadRequest Sends a bad request error message.\n protected sendBadRequest(req: any, res: any, message: string): void\n  req: any - an HTTP request res: any - an HTTP response message: string - message  sendConflict Sends a conflict error messge\n protected sendConflict(req: any, res: any, message: string): void\n  req: any - an HTTP request res: any - an HTTP response message: string - message  sendCreatedResult Sends a JSON object with the created result.\n protected sendCreatedResult(req: any, res: any, result: any): void\n  req: any - an HTTP request res: any - an HTTP response result: any - result to be sent.  sendDeletedResult Sends the deleted result in JSON format.\n protected sendDeletedResult(req: any, res: any, result: any): void\n  req: any - an HTTP request res: any - an HTTP response result: any - execution result or a promise with execution result.  sendEmptyResult Send an empty result with 204 status code.\n protected sendEmptyResult(req: any, res: any): void\n  req: any - an HTTP request res: any - an HTTP response  sendError Sends an error serialized as ErrorDescription object and appropriate HTTP status code.\n protected sendError(req: any, res: any, error: any): void\n  req: any - an HTTP request res: any - an HTTP response error: any - error  sendInternalError Sends an internal error message\n protected sendInternalError(req: any, res: any, message: string): void\n  req: any - an HTTP request res: any - an HTTP response message: any - message  sendNotFound Sends a not found error message.\n protected sendNotFound(req: any, res: any, message: string): void\n  req: any - an HTTP request res: any - an HTTP response message: any - message  sendResult Sends a result as a JSON object.\n protected sendResult(req: any, res: any, result: any): void\n  req: any - an HTTP request res: any - an HTTP response result: any - result  sendServerUnavailable Sends a server unavailable error message (Status code 503).\n protected sendServerUnavailable(req: any, res: any, message: string): void\n  req: any - an HTTP request res: any - an HTTP response message: string - message  sendSessionExpired Sends a session expired error message (Status code 440).\n protected sendSessionExpired(req: any, res: any, message: string): void\n  req: any - an HTTP request res: any - an HTTP response message: string - message  sendUnauthorized Sends an unauthorized error message.\n protected sendUnauthorized(req: any, res: any, message: string): void\n  req: any - an HTTP request res: any - an HTTP response message: string - message  setReferences Sets the specified references.\n public setReferences(references: IReferences): void\n  references: IReferences - specified references  ","description":"Handles REST services' operations.\n","image":null,"permalink":"/node/rpc/services/rest_operations/","subtitle":null,"tags":null,"title":"RestOperations"},{"content":"Implements: IConfigurable, IReferenceable\nDescription The RestOperations class allows you to handle REST services' operations.\nFields _logger Composite logger component\n _logger: CompositeLogger = CompositeLogger()\n _counters Counter component\n _counters: CompositeCounters = CompositeCounters()\n _dependency_resolver Dependency resolver component\n _dependency_resolver: DependencyResolver = DependencyResolver()\n  Instance methods configure Configures a component by passing its configuration parameters.\n configure(config: ConfigParams)\n  config: ConfigParams - configuration parameters to be set.  _get_correlation_id Returns a correlationId from a request\n _get_correlation_id(): Optional[str]\n  returns: Optional[str] - correlationId from a request  _get_filter_params Gets the filter parameters.\n _get_filter_params(): FilterParams\n  returns: FilterParams - filter paramters  _get_paging_params Gets the paging parameters.\n _get_paging_params(): PagingParams\n  returns: PagingParams - paging paramters  invoke Invokes an operation.\n invoke(operation: str): Callable\n  operation: str - operation to be invoked returns: Callable - operation  _send_bad_request Sends a bad request error message.\n _send_bad_request(message: str): str\n  message: str - message returns: str - bad request error message  _send_conflict Sends a conflict error messge\n _send_conflict(message: str): str\n  message: str - message returns: str - conflict error message.  _send_created_result Sends a JSON object with the created result.\n _send_created_result(result: Any = None): Optional[str]\n  result: Any - result to be sent. returns: Optional[str] - JSON object with the created result.  _send_deleted_result Sends the deleted result in JSON format.\n _send_deleted_result(): Optional[str]\n  result: Any - execution result or a promise with execution result. returns: JSON object with the deleted result.  _send_empty_result Send an empty result with 204 status code.\n _send_empty_result(result: Any = None): Optional[str]\n  result: Any - Optional[str] returns: Optional[str] - empty result with 204 status code.  _send_error Sends an error serialized as ErrorDescription object and appropriate HTTP status code.\n _send_error(error: Any = None): str\n  error: Any - error returns: Optional[str] - error serialized as ErrorDescription object and appropriate HTTP status code.  _send_internal_error Sends an internal error message\n _send_internal_error(message: str): str\n  message: Any - message returns: Optional[str] - internal error message  _send_not_found Sends a not found error message.\n _send_not_found(message: str): str\n  message: Any - message returns: Optional[str] - not found error message.  _send_result Sends a result as a JSON object.\n _send_result(result: Any = None): Optional[str]\n  result: Any - result returns: Optional[str] - result as a JSON object.  _send_server_unavailable Sends a server unavailable error message (Status code 503).\n _send_server_unavailable(message: str): str\n  message: str - message returns: str - server unavailable error message (Status code 503).  _send_session_expired Sends a session expired error message (Status code 440).\n _send_session_expired(message: str): str\n  message: str - message returns: str - session expired error message (Status code 440).  _send_unauthorized Sends an unauthorized error message.\n _send_unauthorized(message: str): str\n  message: str - message returns: str - unauthorized error message.  set_references Sets the specified references.\n set_references(references: IReferences)\n  references: IReferences - specified references  ","description":"Handles REST services' operations.\n","image":null,"permalink":"/python/rpc/services/rest_operations/","subtitle":null,"tags":null,"title":"RestOperations"},{"content":"Description TODO: add description\nProperties Method TODO: add description\n public string Method { get; set; }\n Route TODO: add description\n public string Route { get; set; }\n Tags TODO: add description\n public string[] Tags { get; set; }\n QueryParams TODO: add description\n public List\u0026lt;QueryParam\u0026gt; QueryParams { get; set; } = new List\u0026lt;QueryParam\u0026gt;()\n BodySchema TODO: add description\n public ObjectSchema BodySchema { get; set; }\n NeedsFile TODO: add description\n public bool NeedsFile { get; set; }\n Responses TODO: add description\n public List\u0026lt;ResponseData\u0026gt; Responses { get; set; } = new List\u0026lt;ResponseData\u0026gt;()\n Authentication TODO: add description\n public string Authentication { get; set; }\n Instance methods RestRouteMetadata TODO: add description\n public RestRouteMetadata SetsMethodAndRoute(string method, string route)\n  method: string - TODO: add description route: string - TODO: add description returns: RestRouteMetadata - TODO: add description  SetsTags TODO: add description\n public RestRouteMetadata SetsTags(params string[] tags)\n  tags: params string[] - TODO: add description returns: RestRouteMetadata - TODO: add description  ExpectsHeader TODO: add description\n public RestRouteMetadata ExpectsHeader()\n  returns: RestRouteMetadata - TODO: add description  ReceivesQueryParam TODO: add description\n public RestRouteMetadata ReceivesQueryParam(string name, TypeCode typeCode, bool required = false, object defaultValue = null, string description = null)\n  name: string - TODO: add description typeCode: TypeCode - TODO: add description required: bool - TODO: add description defaultValue: object - TODO: add description description: string - TODO: add description returns: RestRouteMetadata - TODO: add description  ReceivesOptionalQueryParam TODO: add description\n public RestRouteMetadata ReceivesOptionalQueryParam(string name, TypeCode typeCode, object defaultValue = null, string description = null)\n  name: string - TODO: add description typeCode: TypeCode - TODO: add description defaultValue: object - TODO: add description description: string - TODO: add description returns: RestRouteMetadata - TODO: add description  ReceivesRequiredQueryParam TODO: add description\n public RestRouteMetadata ReceivesRequiredQueryParam(string name, TypeCode typeCode, object defaultValue = null, string description = null)\n  name: string - TODO: add description typeCode: TypeCode - TODO: add description defaultValue: object - TODO: add description description: string - TODO: add description returns: RestRouteMetadata - TODO: add description  ReceivesCorrelationIdParam TODO: add description\n public RestRouteMetadata ReceivesCorrelationIdParam()\n  returns: RestRouteMetadata - TODO: add description  ReceivesBodyFromSchema TODO: add description\n public RestRouteMetadata ReceivesBodyFromSchema(ObjectSchema schema)\n  schema: ObjectSchema - TODO: add description returns: RestRouteMetadata - TODO: add description  ReceivesFile TODO: add description\n public RestRouteMetadata ReceivesFile()\n  returns: RestRouteMetadata - TODO: add description  SendsData TODO: add description\n public RestRouteMetadata SendsData(int statusCode, string description, object schema = null)\n  statusCode: int - TODO: add description description: string - TODO: add description schema: object - TODO: add description returns: RestRouteMetadata - TODO: add description  SendsData200 TODO: add description\n public RestRouteMetadata SendsData200(object schema = null)\n  schema: object - TODO: add description returns: RestRouteMetadata - TODO: add description  SendsDataPage200 TODO: add description\n public RestRouteMetadata SendsDataPage200(object schema)\n  schema: object - TODO: add description returns: RestRouteMetadata - TODO: add description  SendsData400 TODO: add description\n public RestRouteMetadata SendsData400(object schema = null)\n  schema: object - TODO: add description returns: RestRouteMetadata - TODO: add description  UsesBasicAuthentication TODO: add description\n public RestRouteMetadata UsesBasicAuthentication()\n  returns: RestRouteMetadata - TODO: add description  UsesBearerAuthentication TODO: add description\n public RestRouteMetadata UsesBearerAuthentication()\n  returns: RestRouteMetadata - TODO: add description  ","description":"TODO: add description\n","image":null,"permalink":"/net/rpc/data/rest_route_metadata/","subtitle":null,"tags":null,"title":"RestRouteMetadata"},{"content":"Implements: IRegisterable\nDescription The RestService class allows you to create REST services that receive remote calls via the HTTP/REST protocol.\nConfiguration parameters  base_route: base route for remote URI dependencies:  endpoint: override for HTTP Endpoint dependency controller: override for Controller dependency   connection(s):  discovery_key: (optional) key to retrieve the connection from IDiscovery protocol: connection protocol (http or https) host: host name or IP address port: port number uri: resource URI or connection string with all parameters in it   credential: the HTTPS credentials:  ssl_key_file: SSL private key in PEM ssl_crt_file: SSL certificate in PEM ssl_ca_file: certificate authorities (root cerfiticates) in PEM    References  *:logger:*:*:1.0 - (optional) ILogger components to pass log messages *:counters:*:*:1.0 - (optional) ICounters components to pass collected measurements *:traces:*:*:1.0 - (optional) ITracer components to record traces *:discovery:*:*:1.0 - (optional) IDiscovery services to resolve connection *:endpoint:http:*:1.0 - (optional) HttpEndpoint reference  Constructors InheritRestService InheritRestService is create new instance of RestService\n InheritRestService(overrides IRestServiceOverrides) *RestService\n  overrides: IRestServiceOverrides - ingerited rest service  Fields DependencyResolver Dependency resolver.\n DependencyResolver: DependencyResolver\n Logger Logger.\n Logger: CompositeLogger\n Counters Performance counters.\n Counters: CompositeCounters\n BaseRoute Base route.\n BaseRoute: string\n Tracer Tracer.\n Tracer: *CompositeTracer\n Endpoint HTTP endpoint that exposes this service.\n Endpoint: HttpEndpoint\n config Service\u0026rsquo;s configuration paramters.\n config: ConfigParams\n SwaggerService Swagger service.\n SwaggerService: ISwaggerService\n SwaggerEnable Boolean that defines if the Swagger sevice is enabled or not.\n SwaggerEnable: bool = false\n SwaggerRoute Swagger\u0026rsquo;s route.\n SwaggerRoute: string = \u0026lsquo;swagger\u0026rsquo;\n  Methods Close Closes a component and frees used resources.\n (c *RestService) Close(correlationId string) error\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. returns: error - returns error if not closed.  Configure Configures a component by passing its configuration parameters.\n (c *RestService) Configure(config *cconf.ConfigParams)\n  config: *cconf.ConfigParams - configuration parameters, containing a \u0026ldquo;connection(s)\u0026rdquo; section.  Instrument Adds instrumentation to log calls and measure call time. It returns a Timing object that is used to end the time measurement.\n (c *RestService) Instrument(correlationId string, name string) *InstrumentTiming\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. name: string - method name. returns: *InstrumentTiming - instrument Timing object to end the time measurement.  GetCorrelationId GetCorrelationId method returns CorrelationId from request\n (c *RestService) GetCorrelationId(req *http.Request) string\n  req: *http.Request - an HTTP request returns: string - correlation_id or empty string  IsOpen Checks if the component is open.\n (c *RestService) IsOpen() bool\n  returns: bool - True if the component has been opened and False otherwise.  Open Opens the component.\n (c *RestService) Open(correlationId string) error\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. returns: error - error or nil no errors occured.  RegisterInterceptor Registers a middleware for a given route in HTTP endpoint.\n (c *RestService) RegisterInterceptor(route string, action func(res http.ResponseWriter, req *http.Request, next http.HandlerFunc))\n  route: string - command route. Base route will be added to this route action: func(res http.ResponseWriter, req *http.Request, next http.HandlerFunc) - action function that is called when middleware is invoked.  RegisterOpenApiSpec Registers the open api spec.\n (c *RestService) RegisterOpenApiSpec(content string)\n  content: string - response header content  RegisterOpenApiSpecFromFile Registers the open api spec from a file.\n (c *RestService) RegisterOpenApiSpecFromFile(path string)\n  path: string - path to the file  RegisterRoute Registers a route in HTTP endpoint.\n (c *RestService) RegisterRoute(method string, route string, schema *cvalid.Schema, action func(res http.ResponseWriter, req *http.Request))\n  method: string - HTTP method: \u0026ldquo;get\u0026rdquo;, \u0026ldquo;head\u0026rdquo;, \u0026ldquo;post\u0026rdquo;, \u0026ldquo;put\u0026rdquo;, \u0026ldquo;delete\u0026rdquo; route: string - command route. The base route will be added to this route schema: *cvalid.Schema - validation schema to validate received parameters. action: func(res http.ResponseWriter, req *http.Request) - action function that is called when an operation is invoked.  RegisterRouteWithAuth Registers a route with authorization in HTTP endpoint.\n (c *RestService) RegisterRouteWithAuth(method string, route string, schema *cvalid.Schema, authorize func(res http.ResponseWriter, req *http.Request, next http.HandlerFunc), action func(res http.ResponseWriter, req *http.Request))\n  method: string - HTTP method: \u0026ldquo;get\u0026rdquo;, \u0026ldquo;head\u0026rdquo;, \u0026ldquo;post\u0026rdquo;, \u0026ldquo;put\u0026rdquo;, \u0026ldquo;delete\u0026rdquo; route: string - command route. The base route will be added to this route schema: *cvalid.Schema - validation schema to validate received parameters. authorize: func(res http.ResponseWriter, req *http.Request, next http.HandlerFunc) - authorization interceptor action: func(res http.ResponseWriter, req *http.Request) - action function that is called when an operation is invoked.  Register Register method are registers all service routes in HTTP endpoint.\n (c *RestService) Register()\n SendCreatedResult Creates a callback function that sends a newly created object as JSON. The callack function call be called directly or passed as a parameter to business logic components.\nIf the object is not nil, it returns 200 status code. For nil results it returns 204 status code. If an error occurs, it sends ErrorDescription with the approproate status code.\n (c *RestService) SendCreatedResult(res http.ResponseWriter, req *http.Request, result interface{}, err error)\n  res: http.ResponseWriter - an HTTP request req: *http.Request - an HTTP response result: interface{} - an IReferences object, containing references to a logger, counters, and a connection resolver. error: error - (optional) error objrct to send  SendDeletedResult Creates a callback function that sends deleted object as JSON. That callack function call be called directly or passed as a parameter to business logic components.\nIf object is not nil it returns 200 status code. For nil results it returns 204 status code. If error occur it sends ErrorDescription with approproate status code.\n (c *RestService) SendDeletedResult(res http.ResponseWriter, req *http.Request, result interface{}, err error)\n  res: http.ResponseWriter - an HTTP request req: *http.Request - an HTTP response result: interface{} - body object to result error: error - (optional) error objrct to send.  SendError Sends an error serialized as ErrorDescription object and the appropriate HTTP status code. If status code is not defined, it uses 500 status code.\n (c *RestService) SendError(res http.ResponseWriter, req *http.Request, err error)\n  res: http.ResponseWriter - an HTTP request req: *http.Request - an HTTP response error: error - error object to be sent.  SendResult Creates a callback function that sends a result as a JSON object. The callack function call be called directly or passed as a parameter to business logic components.\nIf the object is not nil it returns 200 status code. For nil results, it returns 204 status code. If an error occurs, it sends ErrorDescription with the approproate status code.\n (c *RestService) SendResult(res http.ResponseWriter, req *http.Request, result interface{}, err error)\n  res: http.ResponseWriter - an HTTP request req: *http.Request - an HTTP response result: interface{} - body object to result error: error - error object to be sent.  SetReferences Sets references to dependent components.\n (c *RestService) SetReferences(references crefer.IReferences)\n  references: crefer.IReferences - references to locate the component dependencies.  UnsetReferences Unsets (clears) previously set references to dependent components.\n (c *RestService) UnsetReferences()\n Examples type MyRestService struct { *RestService controller IMyController } ... func NewMyRestService() *MyRestService { c := MyRestService{} c.RestService = services.NewRestService() c.RestService.IRegisterable = \u0026amp;c c.numberOfCalls = 0 c.DependencyResolver.Put(\u0026#34;controller\u0026#34;, crefer.NewDescriptor(\u0026#34;mygroup\u0026#34;, \u0026#34;controller\u0026#34;, \u0026#34;*\u0026#34;, \u0026#34;*\u0026#34;, \u0026#34;1.0\u0026#34;)) return \u0026amp;c } func (c * MyRestService) SetReferences(references IReferences) { c.RestService.SetReferences(references); resolv := c.DependencyResolver.GetRequired(\u0026#34;controller\u0026#34;); if resolv != nil { c.controller, _ = resolv.(IMyController) } } func (c *MyRestService) getOneById(res http.ResponseWriter, req *http.Request) { params := req.URL.Query() vars := mux.Vars(req) mydataId := params.Get(\u0026#34;mydata_id\u0026#34;) if mydataId == \u0026#34;\u0026#34; { mydataId = vars[\u0026#34;mydatay_id\u0026#34;] } result, err := c.controller.GetOneById( params.Get(\u0026#34;correlation_id\u0026#34;), mydataId) c.SendResult(res, req, result, err) } func (c * MyRestService) Register() { c.RegisterRoute( \u0026#34;get\u0026#34;, \u0026#34;get_mydata/{mydata_id}\u0026#34;, \u0026amp;cvalid.NewObjectSchema(). WithRequiredProperty(\u0026#34;mydata_id\u0026#34;, cconv.String).Schema, c.getOneById) ... } service := NewMyRestService(); service.Configure(cconf.NewConfigParamsFromTuples( \u0026#34;connection.protocol\u0026#34;, \u0026#34;http\u0026#34;, \u0026#34;connection.host\u0026#34;, \u0026#34;localhost\u0026#34;, \u0026#34;connection.port\u0026#34;, 8080, )); service.SetReferences(cref.NewReferencesFromTuples( cref.NewDescriptor(\u0026#34;mygroup\u0026#34;,\u0026#34;controller\u0026#34;,\u0026#34;default\u0026#34;,\u0026#34;default\u0026#34;,\u0026#34;1.0\u0026#34;), controller )); opnRes := service.Open(\u0026#34;123\u0026#34;) if opnErr == nil { fmt.Println(\u0026#34;The REST service is running on port 8080\u0026#34;); } See also   RestClient   ","description":"Abstract service that receives remove calls via HTTP/REST protocol.\n","image":null,"permalink":"/golang/rpc/services/rest_service/","subtitle":null,"tags":null,"title":"RestService"},{"content":"Inherits: IConfigurable, IReferenceable, IOpenable, IUnreferenceable, IRegisterable\nDescription The RestService class allows you to create REST services that receive remote calls via the HTTP/REST protocol.\nConfiguration parameters  base_route: base route for remote URI dependencies:  endpoint: override for HTTP Endpoint dependency controller: override for Controller dependency   connection(s):  discovery_key: (optional) key to retrieve the connection from IDiscovery protocol: connection protocol (http or https) host: host name or IP address port: port number uri: resource URI or connection string with all parameters in it   credential: the HTTPS credentials:  ssl_key_file: SSL private key in PEM ssl_crt_file: SSL certificate in PEM ssl_ca_file: certificate authorities (root cerfiticates) in PEM    References  *:logger:*:*:1.0 - (optional) ILogger components to pass log messages *:counters:*:*:1.0 - (optional) ICounters components to pass collected measurements *:traces:*:*:1.0 - (optional) ITracer components to record traces *:discovery:*:*:1.0 - (optional) IDiscovery services to resolve connection *:endpoint:http:*:1.0 - (optional) HttpEndpoint reference  Fields _dependencyResolver Dependency resolver.\n protected _dependencyResolver: DependencyResolver\n _logger Logger.\n protected _logger: CompositeLogger = CompositeLogger()\n _counters Performance counters.\n protected _counters: CompositeCounters = CompositeCounters()\n _debug Boolean that set debugging to True or False.\n protected _debug: boolean = false\n _baseRoute Base route.\n protected _baseRoute: string\n _endpoint HTTP endpoint that exposes this service.\n protected _endpoint: HttpEndpoint\n _config Service\u0026rsquo;s configuration paramters.\n protected _config: ConfigParams\n _swaggerService Swagger service.\n protected _swaggerService: ISwaggerService\n _swaggerEnable Boolean that defines if the Swagger sevice is enabled or not.\n protected _swaggerEnable: bool = false\n _swaggerRoute Swagger\u0026rsquo;s route.\n protected _swaggerRoute: string = \u0026lsquo;swagger\u0026rsquo;\n  Instance methods CloseAsync Closes a component and frees used resources.\n public virtual Task CloseAsync(string correlationId)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain.  Configure Configures a component by passing its configuration parameters.\n public virtual void Configure(ConfigParams config)\n  config: ConfigParams - configuration parameters, containing a \u0026ldquo;connection(s)\u0026rdquo; section.  GetCorrelationId Returns correlationId from a request\n protected string GetCorrelationId(HttpRequest request)\n  request: HttpRequest - an HTTP request returns: string - the correlation id from request.  Instrument Adds instrumentation to log calls and measure call time. It returns a Timing object that is used to end the time measurement.\n protected CounterTiming Instrument(string correlationId, string methodName)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. methodName: string - method name. returns: CounterTiming - InstrumentTiming object to end the time measurement.  IsOpen Checks if the component is open.\n public bool IsOpen()\n  returns: bool - True if the component has been opened and False otherwise.  OpenAsync Opens the component.\n public virtual Task OpenAsync(string correlationId)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain.  Register Registers all service routes in a HTTP endpoint.\nThis method is called by the service and must be overriden in child classes.\n public virtual void Register()\n RegisterInterceptor Registers a middleware for a given route in HTTP endpoint.\n public void RegisterInterceptor(string route, Func\u0026lt;HttpRequest, HttpResponse, ClaimsPrincipal, RouteData, Func\u0026lt;HttpRequest, HttpResponse, ClaimsPrincipal, RouteData, Task\u0026gt;, Task\u0026gt; action)\n  route: string - command route. Base route will be added to this route action: Func\u0026lt;HttpRequest, HttpResponse, ClaimsPrincipal, RouteData, Func\u0026lt;HttpRequest, HttpResponse, ClaimsPrincipal, RouteData, Task\u0026gt; - action function that is called when middleware is invoked.  RegisterOpenApiSpec Registers the open api spec.\n protected virtual void RegisterOpenApiSpec(string content)\n  content: string - response header content  RegisterOpenApiSpecFromFile Registers the open api spec from a file.\n protected virtual void RegisterOpenApiSpecFromFile(string path)\n  path: string - path to the file  RegisterOpenApiSpecFromResource Registers the open api spec from resource.\n protected virtual void RegisterOpenApiSpecFromResource(string name)\n  name: string - resource name.  RegisterOpenApiSpecFromMetadata Registers the open api spec from metadata.\n protected virtual void RegisterOpenApiSpecFromMetadata()\n RegisterRoute Registers a route in HTTP endpoint.\n protected virtual void RegisterRoute(string method, string route, Func\u0026lt;HttpRequest, HttpResponse, RouteData, Task\u0026gt; action)\n  method: string - HTTP method: \u0026ldquo;get\u0026rdquo;, \u0026ldquo;head\u0026rdquo;, \u0026ldquo;post\u0026rdquo;, \u0026ldquo;put\u0026rdquo;, \u0026ldquo;delete\u0026rdquo; route: string - command route. The base route will be added to this route action: Func\u0026lt;HttpRequest, HttpResponse, RouteData, Task\u0026gt; - action function that is called when an operation is invoked.  RegisterRouteWithAuth Registers a route with authorization in HTTP endpoint.\n protected virtual void RegisterRouteWithAuth(string method, string route, Func\u0026lt;HttpRequest, HttpResponse, ClaimsPrincipal, RouteData, Func\u0026lt;Task\u0026gt;, Task\u0026gt; autorize, Func\u0026lt;HttpRequest, HttpResponse, ClaimsPrincipal, RouteData, Task\u0026gt; action)\n  method: string - HTTP method: \u0026ldquo;get\u0026rdquo;, \u0026ldquo;head\u0026rdquo;, \u0026ldquo;post\u0026rdquo;, \u0026ldquo;put\u0026rdquo;, \u0026ldquo;delete\u0026rdquo; route: string - command route. The base route will be added to this route authorize: Func\u0026lt;HttpRequest, HttpResponse, ClaimsPrincipal, RouteData, Func\u0026lt;Task\u0026gt;, Task\u0026gt; - authorization interceptor action: Func\u0026lt;HttpRequest, HttpResponse, ClaimsPrincipal, RouteData, Task\u0026gt; - action function that is called when an operation is invoked.  SendCreatedResult Creates a callback function that sends a newly created object as JSON. The callack function call be called directly or passed as a parameter to business logic components.\nIf the object is not null, it returns 200 status code. For null results it returns 204 status code. If an error occurs, it sends ErrorDescription with the approproate status code.\n protected Task SendCreatedResultAsync(HttpResponse response, object result)\n  res: HttpResponse - an HTTP response result: object - an IReferences object, containing references to a logger, counters, and a connection resolver.  SendDeletedAsync Creates a callback function that sends deleted object as JSON. That callack function call be called directly or passed as a parameter to business logic components.\nIf object is not null it returns 200 status code. For null results it returns 204 status code. If error occur it sends ErrorDescription with approproate status code.\n protected Task SendDeletedAsync(HttpResponse response, object result)\n  response: HttpResponse - an HTTP response result: object - body object to result.  SendErrorAsync Sends an error serialized as ErrorDescription object and the appropriate HTTP status code. If status code is not defined, it uses 500 status code.\n protected Task SendErrorAsync(HttpResponse response, Exception ex)\n  response: HttpResponse - an HTTP response ex: Exception - error object to be sent.  SendResultAsync Creates a callback function that sends a result as a JSON object. The callack function call be called directly or passed as a parameter to business logic components.\nIf the object is not null it returns 200 status code. For null results, it returns 204 status code. If an error occurs, it sends ErrorDescription with the approproate status code.\n protected Task SendResultAsync(HttpResponse response, object result)\n  response: HttpResponse - an HTTP response result: object - body object to result.  SetReferences Sets references to dependent components.\n public virtual void SetReferences(IReferences references)\n  references: IReferences - references to locate the component dependencies.  UnsetReferences Unsets (clears) previously set references to dependent components.\n public virtual void UnsetReferences()\n Examples class MyRestService: RestService { private IMyController _controller; ... public MyRestService() { base(); this._dependencyResolver.put( \u0026#34;controller\u0026#34;, new Descriptor(\u0026#34;mygroup\u0026#34;, \u0026#34;controller\u0026#34;, \u0026#34;*\u0026#34;, \u0026#34;*\u0026#34;, \u0026#34;1.0\u0026#34;)); } public void SetReferences(IReferences references) { base.SetReferences(references); this._controller = this._dependencyResolver.getRequired\u0026lt;IMyController\u0026gt;(\u0026#34;controller\u0026#34;); } public void register() { ... } } var service = new MyRestService(); service.Configure(ConfigParams.fromTuples( \u0026#34;connection.protocol\u0026#34;, \u0026#34;http\u0026#34;, \u0026#34;connection.host\u0026#34;, \u0026#34;localhost\u0026#34;, \u0026#34;connection.port\u0026#34;, 8080 )); service.SetReferences(References.fromTuples( new Descriptor(\u0026#34;mygroup\u0026#34;,\u0026#34;controller\u0026#34;,\u0026#34;default\u0026#34;,\u0026#34;default\u0026#34;,\u0026#34;1.0\u0026#34;), controller )); service.Open(\u0026#34;123\u0026#34;); Console.Out.WriteLine(\u0026#34;The REST service is running on port 8080\u0026#34;); See also   RestClient   ","description":"Abstract service that receives remove calls via HTTP/REST protocol.\n","image":null,"permalink":"/net/rpc/services/rest_service/","subtitle":null,"tags":null,"title":"RestService"},{"content":"Implements: IConfigurable, IReferenceable, IOpenable, IUnreferenceable, IRegisterable\nDescription The RestService class allows you to create REST services that receive remote calls via the HTTP/REST protocol.\nConfiguration parameters  base_route: base route for remote URI dependencies:  endpoint: override for HTTP Endpoint dependency controller: override for Controller dependency   connection(s):  discovery_key: (optional) key to retrieve the connection from IDiscovery protocol: connection protocol (http or https) host: host name or IP address port: port number uri: resource URI or connection string with all parameters in it   credential: the HTTPS credentials:  ssl_key_file: SSL private key in PEM ssl_crt_file: SSL certificate in PEM ssl_ca_file: certificate authorities (root cerfiticates) in PEM    References  *:logger:*:*:1.0 - (optional) ILogger components to pass log messages *:counters:*:*:1.0 - (optional) ICounters components to pass collected measurements *:traces:*:*:1.0 - (optional) ITracer components to record traces *:discovery:*:*:1.0 - (optional) IDiscovery services to resolve connection *:endpoint:http:*:1.0 - (optional) HttpEndpoint reference  Fields _dependencyResolver Dependency resolver.\n protected _dependencyResolver: DependencyResolver\n _logger Logger.\n protected _logger: CompositeLogger = CompositeLogger()\n _counters Performance counters.\n protected _counters: CompositeCounters = CompositeCounters()\n _debug Boolean that set debugging to True or False.\n protected _debug: boolean = false\n _baseRoute Base route.\n protected _baseRoute: string\n _endpoint HTTP endpoint that exposes this service.\n protected _endpoint: HttpEndpoint\n _tracer Tracer.\n protected _tracer: CompositeTracer = CompositeTracer()\n _config Service\u0026rsquo;s configuration paramters.\n protected _config: ConfigParams\n _swaggerService Swagger service.\n protected _swaggerService: ISwaggerService\n _swaggerEnable Boolean that defines if the Swagger sevice is enabled or not.\n protected _swaggerEnable: boolean = false\n _swaggerRoute Swagger\u0026rsquo;s route.\n protected _swaggerRoute: string = \u0026lsquo;swagger\u0026rsquo;\n  Instance methods close Closes a component and frees used resources.\n public close(correlationId: string): Promise\u0026lt;void\u0026gt;\n  correlationId: string - (optional) transaction id used to trace execution through the call chain.  configure Configures a component by passing its configuration parameters.\n public configure(config: ConfigParams): void\n  config: ConfigParams - configuration parameters, containing a \u0026ldquo;connection(s)\u0026rdquo; section.  getCorrelationId Returns correlationId from a request\n protected getCorrelationId(req: any): string\n  req: any - an HTTP request returns: string - the correlation id from request.  instrument Adds instrumentation to log calls and measure call time. It returns a Timing object that is used to end the time measurement.\n protected instrument(correlationId: string, name: string): InstrumentTiming\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. name: string - method name. returns: InstrumentTiming - InstrumentTiming object to end the time measurement.  isOpen Checks if the component is open.\n public isOpen(): boolean\n  returns: boolean - True if the component has been opened and False otherwise.  open Opens the component.\n public open(correlationId: string): Promise\u0026lt;void\u0026gt;\n  correlationId: string - (optional) transaction id used to trace execution through the call chain.  registerInterceptor Registers a middleware for a given route in HTTP endpoint.\n protected registerInterceptor(route: string, action: (req: any, res: any, next: () =\u0026gt; void) =\u0026gt; void): void\n  route: string - command route. Base route will be added to this route action: (req: any, res: any, next: () =\u0026gt; void) =\u0026gt; void - action function that is called when middleware is invoked.  registerOpenApiSpec Registers the open api spec.\n protected registerOpenApiSpec(content: string)\n  content: string - response header content  registerOpenApiSpecFromFile Registers the open api spec from a file.\n protected registerOpenApiSpecFromFile(path: string)\n  path: string - path to the file  registerRoute Registers a route in HTTP endpoint.\n protected registerRoute(method: string, route: string, schema: Schema, action: (req: any, res: any) =\u0026gt; void): void\n  method: string - HTTP method: \u0026ldquo;get\u0026rdquo;, \u0026ldquo;head\u0026rdquo;, \u0026ldquo;post\u0026rdquo;, \u0026ldquo;put\u0026rdquo;, \u0026ldquo;delete\u0026rdquo; route: string - command route. The base route will be added to this route schema: Schema - validation schema to validate received parameters. action: (req: any, res: any) =\u0026gt; void - action function that is called when an operation is invoked.  registerRouteWithAuth Registers a route with authorization in HTTP endpoint.\n protected registerRouteWithAuth(method: string, route: string, schema: Schema, authorize: (req: any, res: any, next: () =\u0026gt; void) =\u0026gt; void, action: (req: any, res: any) =\u0026gt; void): void\n  method: string - HTTP method: \u0026ldquo;get\u0026rdquo;, \u0026ldquo;head\u0026rdquo;, \u0026ldquo;post\u0026rdquo;, \u0026ldquo;put\u0026rdquo;, \u0026ldquo;delete\u0026rdquo; route: string - command route. The base route will be added to this route schema: Schema - validation schema to validate received parameters. authorize: (req: any, res: any, next: () =\u0026gt; void) =\u0026gt; void - authorization interceptor action: (req: any, res: any) =\u0026gt; void - action function that is called when an operation is invoked.  sendCreatedResult Creates a callback function that sends a newly created object as JSON. The callack function call be called directly or passed as a parameter to business logic components.\nIf the object is not null, it returns 200 status code. For null results it returns 204 status code. If an error occurs, it sends ErrorDescription with the approproate status code.\n protected sendCreatedResult(req: any, res: any, result: any): void\n  req: any - an HTTP request res: any - an HTTP response result: any - an IReferences object, containing references to a logger, counters, and a connection resolver.  sendDeletedResult Creates a callback function that sends deleted object as JSON. That callack function call be called directly or passed as a parameter to business logic components.\nIf object is not null it returns 200 status code. For null results it returns 204 status code. If error occur it sends ErrorDescription with approproate status code.\n protected sendDeletedResult(req: any, res: any, result: any): void\n  req: any - an HTTP request res: any - an HTTP response result: any - body object to result.  sendError Sends an error serialized as ErrorDescription object and the appropriate HTTP status code. If status code is not defined, it uses 500 status code.\n protected sendError(req: any, res: any, error: any): void\n  req: any - an HTTP request res: any - an HTTP response error: any - error object to be sent.  sendResult Creates a callback function that sends a result as a JSON object. The callack function call be called directly or passed as a parameter to business logic components.\nIf the object is not null it returns 200 status code. For null results, it returns 204 status code. If an error occurs, it sends ErrorDescription with the approproate status code.\n protected sendResult(req: any, res: any, result: any): void\n  req: any - an HTTP request res: any - an HTTP response result: any - body object to result.  setReferences Sets references to dependent components.\n public setReferences(references: IReferences): void\n  references: IReferences - references to locate the component dependencies.  unsetReferences Unsets (clears) previously set references to dependent components.\n public unsetReferences(): void\n Abstract methods register Registers all service routes in a HTTP endpoint.\nThis method is called by the service and must be overriden in child classes.\n public abstract register(): void\n Examples class MyRestService extends RestService { private _controller: IMyController; ... public constructor() { base(); this._dependencyResolver.put( \u0026#34;controller\u0026#34;, new Descriptor(\u0026#34;mygroup\u0026#34;,\u0026#34;controller\u0026#34;,\u0026#34;*\u0026#34;,\u0026#34;*\u0026#34;,\u0026#34;1.0\u0026#34;) ); } public setReferences(references: IReferences): void { base.setReferences(references); this._controller = this._dependencyResolver.getRequired\u0026lt;IMyController\u0026gt;(\u0026#34;controller\u0026#34;); } public register(): void { registerRoute(\u0026#34;get\u0026#34;, \u0026#34;get_mydata\u0026#34;, null, (req, res) =\u0026gt; { let correlationId = req.param(\u0026#34;correlation_id\u0026#34;); let id = req.param(\u0026#34;id\u0026#34;); let promise = this._controller.getMyData(correlationId, id); this.sendResult(req, res, promise); }); ... } } let service = new MyRestService(); service.configure(ConfigParams.fromTuples( \u0026#34;connection.protocol\u0026#34;, \u0026#34;http\u0026#34;, \u0026#34;connection.host\u0026#34;, \u0026#34;localhost\u0026#34;, \u0026#34;connection.port\u0026#34;, 8080 )); service.setReferences(References.fromTuples( new Descriptor(\u0026#34;mygroup\u0026#34;,\u0026#34;controller\u0026#34;,\u0026#34;default\u0026#34;,\u0026#34;default\u0026#34;,\u0026#34;1.0\u0026#34;), controller )); await service.open(\u0026#34;123\u0026#34;); console.log(\u0026#34;The REST service is running on port 8080\u0026#34;); See also   RestClient   ","description":"Abstract service that receives remove calls via HTTP/REST protocol.\n","image":null,"permalink":"/node/rpc/services/rest_service/","subtitle":null,"tags":null,"title":"RestService"},{"content":"Implements: IConfigurable, IReferenceable, IOpenable, IUnreferenceable, IRegisterable\nDescription The RestService class allows you to create REST services that receive remote calls via the HTTP/REST protocol.\nConfiguration parameters  base_route: base route for remote URI dependencies:  endpoint: override for HTTP Endpoint dependency controller: override for Controller dependency   connection(s):  discovery_key: (optional) key to retrieve the connection from IDiscovery protocol: connection protocol (http or https) host: host name or IP address port: port number uri: resource URI or connection string with all parameters in it   credential: the HTTPS credentials:  ssl_key_file: SSL private key in PEM ssl_crt_file: SSL certificate in PEM ssl_ca_file: certificate authorities (root cerfiticates) in PEM    References  *:logger:*:*:1.0 - (optional) ILogger components to pass log messages *:counters:*:*:1.0 - (optional) ICounters components to pass collected measurements *:traces:*:*:1.0 - (optional) ITracer components to record traces *:discovery:*:*:1.0 - (optional) IDiscovery services to resolve connection *:endpoint:http:*:1.0 - (optional) HttpEndpoint reference  Fields _dependency_resolver Dependency resolver.\n _dependency_resolver: DependencyResolver\n _logger Logger.\n _logger: CompositeLogger = CompositeLogger()\n _counters Performance counters.\n _counters: CompositeCounters = CompositeCounters()\n _debug Boolean that set debugging to True or False.\n _debug = False\n _base_route Base route.\n _base_route: str\n _endpoint HTTP endpoint that exposes this service.\n _endpoint: HttpEndpoint\n _tracer Tracer.\n _tracer: CompositeTracer = CompositeTracer()\n _config Service\u0026rsquo;s configuration paramters.\n _config: ConfigParams\n _swagger_service Swagger service.\n _swagger_service: ISwaggerService\n _swagger_enabled Boolean that defines if the Swagger sevice is enabled or not.\n _swagger_enabled = False\n _swagger_route Swagger\u0026rsquo;s route.\n _swagger_route = \u0026lsquo;swagger\u0026rsquo;\n  Instance methods close Closes a component and frees used resources.\n close(correlation_id: Optional[str])\n  correlation_id: Optional[str] - (optional) transaction id used to trace execution through the call chain.  configure Configures a component by passing its configuration parameters.\n configure(config: ConfigParams)\n  config: ConfigParams - configuration parameters, containing a \u0026ldquo;connection(s)\u0026rdquo; section.  _get_correlation_id Returns correlationId from a request\n _get_correlation_id(self): Optional[str]\n  returns: Optional[str] - the correlation id from request.  _instrument Adds instrumentation to log calls and measure call time. It returns a Timing object that is used to end the time measurement.\n _instrument(correlation_id: Optional[str], name: str): InstrumentTiming\n  correlation_id: Optional[str] - (optional) transaction id used to trace execution through the call chain. name: str - method name. returns: InstrumentTiming - InstrumentTiming object to end the time measurement.  is_open Checks if the component is open.\n is_open(): bool\n  returns: bool - True if the component has been opened and False otherwise.  open Opens the component.\n open(correlation_id: Optional[str])\n  correlation_id: Optional[str] - (optional) transaction id used to trace execution through the call chain.  register_interceptor Registers a middleware for a given route in HTTP endpoint.\n register_interceptor(route: str, action: Callable)\n  route: str - command route. Base route will be added to this route action: Callable - action function that is called when middleware is invoked.  _register_open_api_spec Registers the open api spec.\n _register_open_api_spec(content: str)\n  content: str - response header content  _register_open_api_spec_from_file Registers the open api spec from a file.\n _register_open_api_spec_from_file(path: str)\n  path: str - path to the file  register_route Registers a route in HTTP endpoint.\n register_route(method: str, route: str, schema: Schema, handler: Callable)\n  method: str - HTTP method: \u0026ldquo;get\u0026rdquo;, \u0026ldquo;head\u0026rdquo;, \u0026ldquo;post\u0026rdquo;, \u0026ldquo;put\u0026rdquo;, \u0026ldquo;delete\u0026rdquo; route: str - command route. The base route will be added to this route schema: Schema - validation schema to validate received parameters. handler: Callable - action function that is called when an operation is invoked.  register_route_with_auth Registers a route with authorization in HTTP endpoint.\n register_route_with_auth(method: str, route: str, schema: Schema, authorize: Callable, action: Callable)\n  method: str - HTTP method: \u0026ldquo;get\u0026rdquo;, \u0026ldquo;head\u0026rdquo;, \u0026ldquo;post\u0026rdquo;, \u0026ldquo;put\u0026rdquo;, \u0026ldquo;delete\u0026rdquo; route: str - command route. The base route will be added to this route schema: Schema - validation schema to validate received parameters. authorize: Callable - authorization interceptor action: Callable - action function that is called when an operation is invoked.  send_created_result Creates a callback function that sends newly created object as JSON. That callack function call be called directly or passed as a parameter to business logic components. If object is not null it returns 201 status code. For null results it returns 204 status code. If error occur it sends ErrorDescription with approproate status code.\n send_created_result(result: Any): Optional[str]\n  result: Any - an IReferences object, containing references to a logger, counters, and a connection resolver. returns: Optional[str] - JSON response text  send_deleted_result Creates a callback function that sends a newly deleted object as JSON. The callack function call be called directly or passed as a parameter to business logic components. If the object is not None, it returns 200 status code. For None results it returns 204 status code. If an error occurs, it sends ErrorDescription with the approproate status code.\n send_deleted_result(result: Any = None): Optional[str]\n  result: Any - body object to result. returns: Optional[str] - JSON response text  send_error Sends an error serialized as ErrorDescription object and the appropriate HTTP status code. If status code is not defined, it uses 500 status code.\n send_error(error: Any): str\n  error: Any - error object to be sent. returns: str - JSON response text  send_result Creates a callback function that sends a result as a JSON object. The callack function call be called directly or passed as a parameter to business logic components.\nIf the object is not None it returns 200 status code. For None results, it returns 204 status code. If an error occurs, it sends ErrorDescription with the approproate status code.\n send_result(result: Any): Optional[str]\n  result: Any - body object to result. returns: Optional[str] - JSON response text  set_references Sets references to dependent components.\n set_references(references: IReferences)\n  references: IReferences - references to locate the component dependencies.  unset_references Unsets (clears) previously set references to dependent components.\n unset_references()\n Abstract methods register Registers all service routes in a gRPC endpoint.\nThis method is called by the service and must be overriden in child classes.\n abstractmethod register()\n Examples class MyRestService(RestService): _controller = None # ... def __init__(self): super(MyRestService, self).__init__() self._dependencyResolver.put(\u0026#34;controller\u0026#34;, Descriptor(\u0026#34;mygroup\u0026#34;,\u0026#34;controller\u0026#34;,\u0026#34;*\u0026#34;,\u0026#34;*\u0026#34;,\u0026#34;1.0\u0026#34;)) def set_references(self, references): super(MyRestService, self).set_references(references) self._controller = self._dependencyResolver.get_required(\u0026#34;controller\u0026#34;) def register(): # ... service = MyRestService() service.configure(ConfigParams.from_tuples(\u0026#34;connection.protocol\u0026#34;, \u0026#34;http\u0026#34;, \u0026#34;connection.host\u0026#34;, \u0026#34;localhost\u0026#34;, \u0026#34;connection.port\u0026#34;, 8080)) service.set_references(References.from_tuples(Descriptor(\u0026#34;mygroup\u0026#34;,\u0026#34;controller\u0026#34;,\u0026#34;default\u0026#34;,\u0026#34;default\u0026#34;,\u0026#34;1.0\u0026#34;), controller)) service.open(\u0026#34;123\u0026#34;) See also   RestClient   ","description":"Abstract service that receives remove calls via HTTP/REST protocol.\n","image":null,"permalink":"/python/rpc/services/rest_service/","subtitle":null,"tags":null,"title":"RestService"},{"content":"Keeps a list of supported reviews that are referenced from other content microservices.\n Server implementations: NodeJS Communication protocols: Direct, Commandable HTTP, Commandable GRPC, GRPC Persistence: Memory, Flat Files, MongoDB, Couchbase Deployment options: Monolith, Process, Docker, AWS Lambda Client implementations: NodeJS  ","description":null,"image":null,"permalink":"/microservices/ecommrce/reviews/","subtitle":null,"tags":null,"title":"Reviews Microservice"},{"content":"Description The RoleAuthManager class provides methods to check on a user\u0026rsquo;s roles.\nInstance methods UserInRoles Checks on the roles a user has been assigned. Throws UnauthorizedException exception if not authorized or not owner.\n (c *RoleAuthManager) UserInRoles(roles []string) func(res http.ResponseWriter, req *http.Request, next http.HandlerFunc)\n  roles: []string - roles list. returns: func(res http.ResponseWriter, req *http.Request, next http.HandlerFunc) - returns roles handler.  UserInRole Check if the role is assigned to the user.\nThrows UnauthorizedException exception if not authorized or not owner.\n (c *RoleAuthManager) UserInRole(role string) func(res http.ResponseWriter, req *http.Request, next http.HandlerFunc)\n  role: string - the user role. returns: func(res http.ResponseWriter, req *http.Request, next http.HandlerFunc) - returns role handler.  Admin Check if the user has admin role.\nThrows UnauthorizedException exception if not authorized or not owner.\n (c *RoleAuthManager) Admin() func(res http.ResponseWriter, req *http.Request, next http.HandlerFunc)\n  returns: func(res http.ResponseWriter, req *http.Request, next http.HandlerFunc) - returns admin handler.  ","description":"Provides methods to check on a user's roles.\n","image":null,"permalink":"/golang/rpc/auth/role_auth_manager/","subtitle":null,"tags":null,"title":"RoleAuthManager"},{"content":"Description The RoleAuthorizer class provides methods to check on a user\u0026rsquo;s roles.\nInstance methods UserInRoles Checks on the roles a user has been assigned. Throws UnauthorizedException exception if not authorized or not owner.\n public Func\u0026lt;HttpRequest, HttpResponse, ClaimsPrincipal, RouteData, Func\u0026lt;Task\u0026gt;, Task\u0026gt; UserInRoles(string[] roles)\n  roles: string[] - roles list. returns: Func\u0026lt;HttpRequest, HttpResponse, ClaimsPrincipal, RouteData, Func\u0026lt;Task\u0026gt;, Task\u0026gt; - returns roles handler.  UserInRole Check if the role is assigned to the user.\nThrows UnauthorizedException exception if not authorized or not owner.\n public Func\u0026lt;HttpRequest, HttpResponse, ClaimsPrincipal, RouteData, Func\u0026lt;Task\u0026gt;, Task\u0026gt; UserInRole(string role)\n  role: string - the user role. returns: Func\u0026lt;HttpRequest, HttpResponse, ClaimsPrincipal, RouteData, Func\u0026lt;Task\u0026gt;, Task\u0026gt; - returns role handler.  Admin Check if the user has admin role.\nThrows UnauthorizedException exception if not authorized or not owner.\n public Func\u0026lt;HttpRequest, HttpResponse, ClaimsPrincipal, RouteData, Func\u0026lt;Task\u0026gt;, Task\u0026gt; Admin()\n  returns: Func\u0026lt;HttpRequest, HttpResponse, ClaimsPrincipal, RouteData, Func\u0026lt;Task\u0026gt;, Task\u0026gt; - returns admin handler.  ","description":"Provides methods to check on a user's roles.\n","image":null,"permalink":"/net/rpc/auth/role_authorizer/","subtitle":null,"tags":null,"title":"RoleAuthorizer"},{"content":"Description The RoleAuthorizer class provides methods to check on a user\u0026rsquo;s roles.\nInstance methods userInRoles Checks on the roles a user has been assigned. Throws UnauthorizedException exception if not authorized or not owner.\n public userInRoles(roles: string[]): (req: any, res: any, next: () =\u0026gt; void) =\u0026gt; void\n  roles: string[] - roles list. returns: (req: any, res: any, next: () =\u0026gt; void) =\u0026gt; void - returns roles handler.  userInRole Check if the role is assigned to the user.\nThrows UnauthorizedException exception if not authorized or not owner.\n public userInRole(role: string): (req: any, res: any, next: () =\u0026gt; void) =\u0026gt; void\n  role: string - the user role. returns: (req: any, res: any, next: () =\u0026gt; void) =\u0026gt; void - returns role handler.  admin Check if the user has admin role.\nThrows UnauthorizedException exception if not authorized or not owner.\n public admin(): (req: any, res: any, next: () =\u0026gt; void) =\u0026gt; void\n  returns: (req: any, res: any, next: () =\u0026gt; void) =\u0026gt; void - returns admin handler.  ","description":"Provides methods to check on a user's roles.\n","image":null,"permalink":"/node/rpc/auth/role_authorizer/","subtitle":null,"tags":null,"title":"RoleAuthorizer"},{"content":"Description The RoleAuthorizer class provides methods to check on user\u0026rsquo;s roles.\nInstance methods user_in_roles Checks on the roles a user has been assigned. Throws UnauthorizedException exception if not authorized or not owner.\n user_in_roles(roles: List[str]): Callable\n  roles: List[str] - roles list. returns: Callable - returns roles handler.  user_in_role Checks if the role is assigned to the user.\nThrows UnauthorizedException exception if not authorized or not owner.\n user_in_role(role: str): Callable\n  role: str - user role. returns: Callable - returns role handler.  admin Checks if the user has admin role.\nThrows UnauthorizedException exception if not authorized or not owner.\n admin(): Callable\n  returns: Callable - returns admin handler.  ","description":"Provides methods to check on a user's roles.\n","image":null,"permalink":"/python/rpc/auth/role_authorizer/","subtitle":null,"tags":null,"title":"RoleAuthorizer"},{"content":"Provides basic role-based authorization mechanism for users.\n Server implementations: NodeJS, Dart Communication protocols: Direct, Commandable HTTP, Commandable GRPC, GRPC Persistence: Memory, Flat Files, MongoDB, Couchbase Deployment options: Monolith, Process, Docker, AWS Lambda Client implementations: NodeJS, Golang, Dart  ","description":null,"image":null,"permalink":"/microservices/users/roles/","subtitle":null,"tags":null,"title":"Roles Microservice"},{"content":"Description It might be useful in rest clients for microservices built on top of rest operations.\nInstance methods AddParameter TODO: add description\n public RouteBuilder AddParameter(string name, string value)\n  name: string - TODO: add description value: string - (optional) TODO: add description returns: RouteBuilder - TODO: add description  AddFilterParams TODO: add description\n public RouteBuilder AddFilterParams(FilterParams filter)\n  filter: FilterParams - (optional) TODO: add description returns: RouteBuilder - TODO: add description  AddPagingParams TODO: add description\n public RouteBuilder AddPagingParams(PagingParams paging)\n  paging: PagingParams - (optional) TODO: add description returns: RouteBuilder - TODO: add description  AddSortParams TODO: add description\n public RouteBuilder AddSortParams(SortParams sort)\n  sort: SortParams - (optional) TODO: add description returns: RouteBuilder - TODO: add description  AddProjectionParams TODO: add description\n public RouteBuilder AddProjectionParams(ProjectionParams projection)\n  projection: ProjectionParams - (optional) TODO: add description returns: RouteBuilder - TODO: add description  Build TODO: add description\n public string Build()\n  returns: string - TODO: add description  Static methods TODO: add description\n public static RouteBuilder Route(string route)\n  route: string - TODO: add description  Examples var route = RouteBuilder .Route(\u0026#34;get_dummies\u0026#34;) .AddFilterParams(filter) .AddPagingParams(paging) .AddSortParams(sort) .Build() ... ","description":"Route builder helper class to create route based on input parameters.\n","image":null,"permalink":"/net/rpc/clients/route_builder/","subtitle":null,"tags":null,"title":"RouteBuilder"},{"content":"Implements: ReferencesDecorator\nDescription The RunReferencesDecorator class allows you to create a references decorator that automatically opens to newly added components that implement the IOpenable interface and closes removed components that implement the IClosable interface.\nConstructors NewRunReferencesDecorator Creates a new instance of the decorator.\n NewRunReferencesDecorator(nextReferences IReferences, topReferences IReferences) *RunReferencesDecorator\n  nextReferences: IReferences - next references or decorator in the chain. topReferences: IReferences - decorator at the top of the chain.  Fields opened Flag of the component state\n opened: bool = false\n  Methods Close Closes the component and frees used resources.\n (c *ManagedReferences) Close(correlationId string) error\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. retunrs: error - returns error if not closed  IsOpen Checks if the component is open.\n (c *ManagedReferences) IsOpen() bool\n  returns: bool - True if the component is open and False otherwise.  Open Opens the component.\n (c *ManagedReferences) Open(correlationId string) error\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. returns: error - return error if not opened  Put Puts a new reference into the reference map.\n (c *RunReferencesDecorator) Put(locator interface{}, component interface{})\n  locator: interface{} - locator to find the reference by. reference: interface{} - component reference to be added.  Remove Removes a previously added component that matches the specified locator. If many references match the locator, it removes only the first one. When all references shall be removed, use the RemoveAll method instead.\n (c *RunReferencesDecorator) Remove(locator interface{}) interface{}\n  locator: interface{} - locator to remove component returns: interface{} - removed component.  RemoveAll Removes all component references that match the specified locator.\n (c *RunReferencesDecorator) RemoveAll(locator interface{}) []interface{}\n  locator: interface{} - locator to remove references by. returns: []interface{} - list containing all removed references.  See also   IReferences   ","description":"References decorator that automatically opens to newly added components that implement the [IOpenable](../../../commons/run/iopenable) interface and closes removed components that implement the [IClosable](../../../commons/run/iclosable) interface.\n","image":null,"permalink":"/golang/container/refer/run_references_decorator/","subtitle":null,"tags":null,"title":"RunReferencesDecorator"},{"content":"Inherits: ReferencesDecorator, IOpenable\nDescription The RunReferencesDecorator class allows you to create a references decorator that automatically opens to newly added components that implement the IOpenable interface and closes removed components that implement the IClosable interface.\nConstructors Creates a new instance of the decorator.\n public RunReferencesDecorator(IReferences baseReferences = null, IReferences parentReferences = null)\n  baseReferences: IReferences - next references or decorator in the chain. parentReferences: IReferences - decorator at the top of the chain.  Instance methods Put Puts a new reference into the reference map.\n public override void Put(object locator, object component)\n  locator: object - locator to find the reference by. reference: object - component reference to be added.  Remove Removes a previously added component that matches the specified locator. If many references match the locator, it removes only the first one. When all references shall be removed, use the RemoveAll method instead.\n public override object Remove(object locator)\n  locator: object - locator to remove component returns: object - removed component.  RemoveAll Removes all component references that match the specified locator.\n public override List\u0026lt;object\u0026gt; RemoveAll(object locator)\n  locator: object - locator to remove references by. returns: List\u0026lt;object\u0026gt; - list containing all removed references.  See also   IReferences   ","description":"References decorator that automatically opens to newly added components that implement the [IOpenable](../../../commons/run/iopenable) interface and closes removed components that implement the [IClosable](../../../commons/run/iclosable) interface.\n","image":null,"permalink":"/net/container/refer/run_references_decorator/","subtitle":null,"tags":null,"title":"RunReferencesDecorator"},{"content":"Extends: ReferencesDecorator\nImplements: IOpenable\nDescription The RunReferencesDecorator class allows you to create a references decorator that automatically opens to newly added components that implement the IOpenable interface and closes removed components that implement the IClosable interface.\nConstructors Creates a new instance of the decorator.\n public constructor(nextReferences: IReferences, topReferences: IReferences)\n  nextReferences: IReferences - next references or decorator in the chain. topReferences: IReferences - decorator at the top of the chain.  Fields _opened Flag of the component state\n public _opened: boolean = false\n  Instance methods put Puts a new reference into the reference map.\n public put(locator: any, component: any): void\n  locator: any - locator to find the reference by. reference: any - component reference to be added.  remove Removes a previously added component that matches the specified locator. If many references match the locator, it removes only the first one. When all references shall be removed, use the removeAll method instead.\n public remove(locator: any): any\n  locator: any - locator to remove component returns: any - removed component.  removeAll Removes all component references that match the specified locator.\n public removeAll(locator: any): any[]\n  locator: any - locator to remove references by. returns: any[] - list containing all removed references.  See also   IReferences   ","description":"References decorator that automatically opens to newly added components that implement the [IOpenable](../../../commons/run/iopenable) interface and closes removed components that implement the [IClosable](../../../commons/run/iclosable) interface.\n","image":null,"permalink":"/node/container/refer/run_references_decorator/","subtitle":null,"tags":null,"title":"RunReferencesDecorator"},{"content":"Implements: ReferencesDecorator, IOpenable\nDescription The RunReferencesDecorator class allows you to create a references decorator that automatically opens to newly added components that implement the IOpenable interface and closes removed components that implement the IClosable interface.\nConstructors Creates a new instance of the decorator.\n RunReferencesDecorator(next_references: Optional[IReferences], top_references: Optional[IReferences])\n  next_references: Optional[IReferences] - next references or decorator in the chain. top_references: Optional[IReferences] - decorator at the top of the chain.  Fields _opened Flag of the component state\n _opened: boolean = false\n  Instance methods put Puts a new reference into the reference map.\n put(locator: Any = None, reference: Any = None)\n  locator: Any - locator to find the reference by. reference: Any - component reference to be added.  remove Removes a previously added component that matches the specified locator. If many references match the locator, it removes only the first one. When all references shall be removed, use the remove_all method instead.\n remove(locator: Any): Any\n  locator: Any - locator to remove component returns: Any - removed component.  remove_all Removes all component references that match the specified locator.\n remove_all(locator: Any): List[Any]\n  locator: Any - locator to remove references by. returns: List[Any] - list containing all removed references.  See also   IReferences   ","description":"References decorator that automatically opens to newly added components that implement the [IOpenable](../../../commons/run/iopenable) interface and closes removed components that implement the [IClosable](../../../commons/run/iclosable) interface.\n","image":null,"permalink":"/python/container/refer/run_references_decorator/","subtitle":null,"tags":null,"title":"RunReferencesDecorator"},{"content":"Description The Schema class provides a basic schema to validate values against a set of validation rules.\nImportant points\n This schema is used as a basis for specific schemas to validate objects, project properties, arrays and maps.  Constructors NewSchemaWithRules Creates a new instance of a validation schema and sets its values.\nSee IValidationRule\n NewSchemaWithRules(required bool, rules []IValidationRule) *Schema\n  required: bool - (optional) true to always require non-nil values. rules: []IValidationRule - (optional) list with validation rules.  InheritSchema Inherits a schema\n InheritSchema(base ISchemaBase) [*Schema]\n InheritSchemaWithRules Inherits a schema with rules\n InheritSchemaWithRules(base ISchemaBase, required bool, rules []IValidationRule) *Schema\n  base: ISchemaBase - base foe create new schema required: bool - true to always require non-nil values. rules: []IValidationRule - list with validation rules.  NewSchema Creates a new instance of validation schema and sets its values.\n NewSchema() *Schema\n Methods GetRules Gets validation rules to check values against.\n (c *Schema) Rules() []IValidationRule\n  returns: []IValidationRule - list with validation rules.  Required Gets a flag that always requires non-nil values. For nil values it raises a validation error.\n (c *Schema) Required() bool\n  returns: bool - true to always require non-nil values and false to allow nil values.  MakeOptional Makes validated values optional. Validation for nil values will be skipped. This method returns a reference to this exception to implement the Builder pattern to chain additional calls.\n (c *Schema) MakeOptional() *Schema\n  returns: Schema - validation schema  MakeRequired Makes validated values always required (non-nil). For nil values the schema will raise errors. This method returns a reference to this exception to implement the Builder pattern to chain additional calls.\n (c *Schema) MakeRequired() *Schema\n  returns: *Schema - this validation schema  PerformTypeValidation Validates a given value to match a specified type. The type can be defined as a Schema, type, a type name or TypeCode When type is a Schema, it executes validation recursively against that Schema.\n (c *Schema) PerformTypeValidation(path string, typ interface{}, value interface{}) []*ValidationResult\n  path: string - dot notation path to the value. type: interface{} - type to match the value type value: interface{} - value to be validated. results: []*ValidationResult - list with validation results to add new results.  PerformValidation Validates a given value against the schema and configured validation rules.\n (c *Schema) PerformValidation(path string, value interface{}) []*ValidationResult\n  path: string - dot notation path to the value. value: interface{} - value to be validated. results: []*ValidationResult - list with validation results to add new results.  SetRequired Sets a flag that always requires non-nil values.\n (c *Schema) SetRequired(value bool)\n  value: bool - true to always require non-nil values and false to allow nil values.  SetRules Sets validation rules to check values against.\n (c *Schema) SetRules(value []IValidationRule)\n  value: []IValidationRule - list with validation rules.  Validate Validates the given value and results validation results. See ValidationResult\n (c *Schema) Validate(value interface{}) []*IValidationRule\n  value: interface{} - value to be validated. returns: []*IValidationRule - list with validation results.  ValidateAndReturnError Validates the given value and returns a ValidationException if errors were found.\n (c *Schema) ValidateAndReturnError(correlationId string, value interface{}, strict bool) *errors.ApplicationError\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. value: interface{} - value to be validated. strict: bool - true to treat warnings as errors. returns: *errors.ApplicationError - validation exception.  ValidateAndThrowError Validates the given value and throws a ValidationException if errors were found.\nSee ValidationException.ThrowExceptionIfNeeded\n (c *Schema) ValidateAndThrowError(correlationId string, value interface{}, strict bool)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. value: interface{} - value to be validated. strict: bool - true to treat warnings as errors.  WithRule Adds validation rule to this schema. This method returns a reference to this exception to implement the Builder pattern to chain additional calls.\n (c *Schema) WithRule(rule IValidationRule) *Schema\n  rule: IValidationRule - validation rule to be added. returns: *Schema - this validation schema.  See also   ObjectSchema   PropertySchema   ArraySchema   MapSchema   ","description":"Basic schema used to validate values against a set of validation rules.\n","image":null,"permalink":"/golang/commons/validate/schema/","subtitle":null,"tags":null,"title":"Schema"},{"content":"Description The Schema class provides a basic schema to validate values against a set of validation rules.\nImportant points\n This schema is used as a basis for specific schemas to validate objects, project properties, arrays and maps.  Constructors Creates a new instance of a validation schema and sets its values.\nSee IValidationRule\n public Schema(bool required, List\u0026lt;IValidationRule\u0026gt; rules)\n  required: bool - (optional) true to always require non-null values. rules: List\u0026lt;IValidationRule\u0026gt; - (optional) list with validation rules.  Properties IsRequired Gets and sets a flag that always requires non-null values. For null values it raises a validation error.\n public bool IsRequired { get; set; }\n Rules Gets and sets validation rules to check values against.\n public List\u0026lt;IValidationRule\u0026gt; Rules { get; set; }\n Instance methods MakeOptional Makes validated values optional. Validation for null values will be skipped. This method returns a reference to this exception to implement the Builder pattern to chain additional calls.\n public Schema MakeOptional()\n  returns: Schema - validation schema  MakeRequired Makes validated values always required (non-null). For null values the schema will raise errors. This method returns a reference to this exception to implement the Builder pattern to chain additional calls.\n public Schema MakeRequired()\n  returns: Schema - validation schema  PerformTypeValidation Validates a given value to match a specified type. The type can be defined as a Schema, type, a type name or TypeCode When type is a Schema, it executes validation recursively against that Schema.\n protected void PerformTypeValidation(string path, object type, object value, List\u0026lt;ValidationResult\u0026gt; results)\n  path: string - dot notation path to the value. type: object - type to match the value type value: object - value to be validated. results: ValidationResult[] - list with validation results.  PerformValidation Validates a given value against the schema and configured validation rules.\n protected internal override void PerformValidation(string path, object value, List\u0026lt;ValidationResult\u0026gt; results)\n  path: string - dot notation path to the value. value: object - value to be validated. results: List\u0026lt;ValidationResult\u0026gt; - list with validation results.  Validate Validates the given value and returns validation results. See ValidationResult\n public List\u0026lt;ValidationResult\u0026gt; Validate(object value)\n  value: object - value to be validated. returns: List\u0026lt;ValidationResult\u0026gt; - list with validation results.  ValidateAndReturnException! Note: this method is not available for this language\nValidates the given value and returns a ValidationException if errors were found.\n public ValidationException ValidateAndReturnException(string correlationId, object value, bool strict = false)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. value: object - value to be validated. strict: bool - true to treat warnings as errors. returns: ValidationException - validation exception.  ValidateAndThrowException Validates the given value and throws a ValidationException if errors were found.\nSee ValidationException.throwExceptionIfNeeded\n public void ValidateAndThrowException(string correlationId, object value, bool strict = false)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. value: object - value to be validated. strict: bool - true to treat warnings as errors.  WithRule Adds validation rule to this schema. This method returns a reference to this exception to implement the Builder pattern to chain additional calls.\n public Schema WithRule(IValidationRule rule)\n  rule: IValidationRule - validation rule to be added. returns: Schema - validation schema.  See also   ObjectSchema   PropertySchema   ArraySchema   MapSchema   ","description":"Basic schema used to validate values against a set of validation rules.\n","image":null,"permalink":"/net/commons/validate/schema/","subtitle":null,"tags":null,"title":"Schema"},{"content":"Description The Schema class provides a basic schema to validate values against a set of validation rules.\nImportant points\n This schema is used as a basis for specific schemas to validate objects, project properties, arrays and maps.  Constructors Creates a new instance of validation schema and sets its values.\nSee IValidationRule\n public constructor(required?: boolean, rules?: IValidationRule[])\n  required: boolean - (optional) true to always require non-null values. rules: IValidationRule[] - (optional) list with validation rules.  Instance methods getRules Gets validation rules to check values against.\n public getRules(): IValidationRule[]\n  returns: IValidationRule[] - list with validation rules.  isRequired Gets a flag that always requires non-null values. For null values, it raises a validation error.\n public isRequired(): boolean\n  returns: boolean - true to always require non-null values and false to allow null values.  makeOptional Makes validated values optional. Validation for null values will be skipped. This method returns a reference to this exception to implement the Builder pattern to chain additional calls.\n public makeOptional(): Schema\n  returns: Schema - validation schema  makeRequired Makes validated values always required (non-null). For null values the schema will raise errors. This method returns a reference to this exception to implement the Builder pattern to chain additional calls.\n public makeRequired(): Schema\n  returns: Schema - validation schema  performTypeValidation Validates a given value to match a specified type. The type can be defined as a Schema, type, a type name or TypeCode When type is a Schema, it executes validation recursively against that Schema.\n protected performTypeValidation(path: string, type: any, value: any, results: ValidationResult[]): void\n  path: string - dot notation path to the value. type: any - type to match the value type value: any - value to be validated. results: ValidationResult[] - list with validation results.  performValidation Validates a given value against the schema and configured validation rules.\n protected performValidation(path: string, value: any, results: ValidationResult[]): void\n  path: string - dot notation path to the value. value: any - value to be validated. results: ValidationResult[] - list with validation results to add new results.  setRequired Sets a flag that always requires non-null values.\n public setRequired(value: boolean): void\n  value: boolean - true to always require non-null values and false to allow null values.  setRules Sets validation rules to check values against.\n public setRules(value: IValidationRule[]): void\n  value: IValidationRule[] - list with validation rules.  validate Validates the given value and returns a list with validation results. See ValidationResult\n public validate(value: any): ValidationResult[]\n  value: any - value to be validated. returns: ValidationResult[] - list with validation results.  validateAndReturnException Validates the given value and returns a ValidationException if errors were found.\n public validateAndReturnException(correlationId: string, value: any, strict: boolean = false): ValidationException\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. value: any - value to be validated. strict: boolean - true to treat warnings as errors. returns: ValidationException - validation exception.  validateAndThrowException Validates the given value and throws a ValidationException if errors were found.\nSee ValidationException.throwExceptionIfNeeded\n public validateAndThrowException(correlationId: string, value: any, strict: boolean = false): void\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. value: any - value to be validated. strict: boolean - true to treat warnings as errors.  withRule Adds validation rule to this schema. This method returns a reference to this exception to implement the Builder pattern to chain additional calls.\n public withRule(rule: IValidationRule): Schema\n  rule: IValidationRule - validation rule to be added. returns: Schema - validation schema.  See also   ObjectSchema   PropertySchema   ArraySchema   MapSchema   ","description":"Basic schema used to validate values against a set of validation rules.\n","image":null,"permalink":"/node/commons/validate/schema/","subtitle":null,"tags":null,"title":"Schema"},{"content":"Description The Schema class provides a basic schema to validate values against a set of validation rules.\nImportant points\n This schema is used as a basis for specific schemas to validate objects, project properties, arrays and maps.  Constructors Creates a new instance of validation schema and sets its values.\nSee IValidationRule\n Schema(required: bool, rules: List[IValidationRule])\n  required: bool - (optional) true to always require non-None values. rules: List[IValidationRule] - (optional) a list with validation rules.  Instance methods get_rules Gets validation rules to check values against.\n get_rules(): List[IValidationRule]\n  returns: List[IValidationRule] - a list with validation rules.  is_required Gets a flag that always requires non-None values. For None values it raises a validation error.\n is_required(): bool\n  returns: bool - true to always require non-None values and false to allow None values.  make_optional Makes validated values optional. Validation for None values will be skipped. This method returns reference to this exception to implement the Builder pattern to chain additional calls.\n make_optional(): Schema\n  returns: Schema - this validation schema  make_required Makes validated values always required (non-None). For None values the schema will raise errors. This method returns reference to this exception to implement the Builder pattern to chain additional calls.\n make_required(): Schema\n  returns: Schema - this validation schema  perform_type_validation Validates a given value to match specified type. The type can be defined as a Schema, type, a type name or TypeCode When type is a Schema, it executes validation recursively against that Schema.\n _perform_type_validation(path: str, type: Any, value: Any, results: List[ValidationResult])\n  path: str - a dot notation path to the value. type: Any - a type to match the value type value: Any - a value to be validated. results: List[ValidationResult] - a list with validation results to add new results.  perform_validation Validates a given value against the schema and configured validation rules.\n _perform_validation(path: str, value: Any, results: List[ValidationResult])\n  path: str - a dot notation path to the value. value: Any - a value to be validated. results: List[ValidationResult] - a list with validation results to add new results.  set_required Sets a flag that always requires non-None values.\n set_required(value: bool)\n  value: bool - true to always require non-None values and false to allow None values.  set_rules Sets validation rules to check values against.\n set_rules(value: List[IValidationRule])\n  value: List[IValidationRule] - a list with validation rules.  validate Validates the given value and returns a list with the validation results. See ValidationResult.\n validate(value: Any): List[IValidationRule]\n  value: Any - a value to be validated. returns: List[IValidationRule] - a list with validation results.  validate_and_return_exception Validates the given value and returns a ValidationException if errors were found.\n validate_and_return_exception(correlation_id: Optional[str], value: Any, strict: bool = False): ValidationException\n  correlation_id: Optional[str] - (optional) transaction id to trace execution through call chain. value: Any - a value to be validated. strict: boolean = false - true to treat warnings as errors. returns: ValidationException - validation exception.  validate_and_throw_exception Validates the given value and throws a ValidationException if errors were found.\nSee ValidationException.throw_exception_if_needed\n validate_and_throw_exception(correlation_id: Optional[str], value: Any, strict: boolean = false)\n  correlation_id: Optional[str] - (optional) transaction id to trace execution through call chain. value: Any - a value to be validated. strict: bool = false - true to treat warnings as errors.  with_rule Adds validation rule to this schema. This method returns reference to this exception to implement the Builder pattern to chain additional calls.\n with_rule(rule: IValidationRule): Schema\n  rule: IValidationRule - a validation rule to be added. returns: Schema - this validation schema.  See also   ObjectSchema   PropertySchema   ArraySchema   MapSchema   ","description":"Basic schema used to validate values against a set of validation rules.\n","image":null,"permalink":"/python/commons/validate/schema/","subtitle":null,"tags":null,"title":"Schema"},{"content":"Opens and closes user sessions and stores sessiond data.\n Server implementations: NodeJS, Dart Communication protocols: Direct, Commandable HTTP, Commandable GRPC, GRPC Persistence: Memory, Flat Files, MongoDB, Couchbase Deployment options: Monolith, Process, Docker, AWS Lambda Client implementations: NodeJS, Golang, Dart  ","description":null,"image":null,"permalink":"/microservices/users/sessions/","subtitle":null,"tags":null,"title":"Sessions Microservice"},{"content":"Manages system settings separated by individual sections. Each section contains multiple key-value parameter pairs.\n Server implementations: NodeJS, .NET, Dart Communication protocols: Direct, Commandable HTTP, Commandable GRPC, GRPC Persistence: Memory, Flat Files, MongoDB, Couchbase Deployment options: Monolith, Process, Docker, AWS Lambda Client implementations: NodeJS, .NET, Golang, Dart  ","description":null,"image":null,"permalink":"/microservices/infrastructure/settings/","subtitle":null,"tags":null,"title":"Settings Microservice"},{"content":"Description The Shutdown class allows you to create a random shutdown component that crashes a process using various methods.\nImportant points\n The component is usually used for testing, but it can also be used in production to randomly crash microservices. It follows the concept of \u0026ldquo;Chaos Monkey\u0026rdquo; popularized by Netflix.  Configuration parameters  mode: null - crash by NullPointer excepiton, zero - crash by dividing by zero, exception = crash by unhandled exception, exit - exit the process min_timeout: minimum crash timeout in milliseconds (default: 5 mins) max_timeout: maximum crash timeout in milliseconds (default: 15 minutes)  Constructors NewShutdown Creates new instance of Shutdown\n NewShutdown() *Shutdown\n Methods Close Closes a component and frees used resources.\n (c *Shutdown) Close(correlationId string) error\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. returns: error - returns error if not received.  Configure Configures a component by passing configuration parameters.\n (c *Shutdown) Configure(config config.ConfigParams)\n  config: config.ConfigParams - configuration parameters to be set.  IsOpen Checks if the component is opened.\n (c *Shutdown) IsOpen() bool\n  returns: bool - true if the component has been opened and false otherwise.  Open Opens the component.\n (c *Shutdown) Open(correlationId string) error\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. returns: error - returned error if not received.  Shutdown Crashes the process using the configured crash mode.\n (c *Shutdown) Shutdown()\n Examples TODO: add example ","description":"Random shutdown component that crashes a process using various methods.\n","image":null,"permalink":"/golang/components/test/shutdown/","subtitle":null,"tags":null,"title":"Shutdown"},{"content":"Inherits: IConfigurable, IOpenable\nDescription The Shutdown class allows you to create a random shutdown component that crashes a process using various methods.\nImportant points\n The component is usually used for testing, but it can also be used in production to randomly crash microservices. It follows the concept of \u0026ldquo;Chaos Monkey\u0026rdquo; popularized by Netflix.  Configuration parameters  mode: null - crash by NullPointer excepiton, zero - crash by dividing by zero, exception = crash by unhandled exception, exit - exit the process min_timeout: minimum crash timeout in milliseconds (default: 5 mins) max_timeout: maximum crash timeout in milliseconds (default: 15 minutes)  Instance methods close Closes component and frees used resources.\n public close(correlationId: string): Promise\u0026lt;void\u0026gt;\n  correlationId: string - (optional) transaction id to trace execution through call chain.  configure Configures a component by passing configuration parameters.\n public configure(config: ConfigParams): void\n  config: ConfigParams - configuration parameters to be set.  isOpen Checks if the component is opened.\n public isOpen(): bool\n  returns: bool - true if the component has been opened and false otherwise.  open Opens the component.\n public open(correlationId: string): Promise\u0026lt;void\u0026gt;\n  correlationId: string - (optional) transaction id to trace execution through call chain.  shutdown Crashes the process using the configured crash mode.\n public shutdown()\n Examples let shutdown = new Shutdown(); shutdown.configure(ConfigParams.FromTuples( \u0026#34;mode\u0026#34;: \u0026#34;exception\u0026#34; )); shutdown.shutdown(); // Result: Bang!!! the process crashes ","description":"Random shutdown component that crashes a process using various methods.\n","image":null,"permalink":"/net/components/test/shutdown/","subtitle":null,"tags":null,"title":"Shutdown"},{"content":"Implements: IConfigurable, IOpenable\nDescription The Shutdown class allows you to create a random shutdown component that crashes a process using various methods.\nImportant points\n The component is usually used for testing, but it can also be used in production to randomly crash microservices. It follows the concept of \u0026ldquo;Chaos Monkey\u0026rdquo; popularized by Netflix.  Configuration parameters  mode: null - crash by NullPointer excepiton, zero - crash by dividing by zero, exception = crash by unhandled exception, exit - exit the process min_timeout: minimum crash timeout in milliseconds (default: 5 mins) max_timeout: maximum crash timeout in milliseconds (default: 15 minutes)  Instance methods close Closes component and frees used resources.\n public close(correlationId: string): Promise\u0026lt;void\u0026gt;\n  correlationId: string - (optional) transaction id to trace execution through call chain.  configure Configures a component by passing configuration parameters.\n public configure(config: ConfigParams): void\n  config: ConfigParams - configuration parameters to be set.  isOpen Checks if the component is opened.\n public isOpen(): boolean\n  returns: boolean - true if the component has been opened and false otherwise.  open Opens the component.\n public open(correlationId: string): Promise\u0026lt;void\u0026gt;\n  correlationId: string - (optional) transaction id to trace execution through call chain.  shutdown Crashes the process using the configured crash mode.\n public shutdown()\n Examples let shutdown = new Shutdown(); shutdown.configure(ConfigParams.fromTuples( \u0026#34;mode\u0026#34;: \u0026#34;exception\u0026#34; )); shutdown.shutdown(); // Result: Bang!!! the process crashes ","description":"Random shutdown component that crashes a process using various methods.\n","image":null,"permalink":"/node/components/test/shutdown/","subtitle":null,"tags":null,"title":"Shutdown"},{"content":"Implements: IConfigurable, IOpenable\nDescription The Shutdown class allows you to create a random shutdown component that crashes a process using various methods.\nImportant points\n The component is usually used for testing, but it can also be used in production to randomly crash microservices. It follows the concept of \u0026ldquo;Chaos Monkey\u0026rdquo; popularized by Netflix.  Configuration parameters  mode: None - crash by NullPointer excepiton, zero - crash by dividing by zero, exception = crash by unhandled exception, exit - exit the process min_timeout: minimum crash timeout in milliseconds (default: 5 mins) max_timeout: maximum crash timeout in milliseconds (default: 15 minutes)  Instance methods close Closes a component and frees used resources.\n close(correlation_id: Optional[str])\n  correlation_id: Optional[str] - (optional) transaction id to trace execution through a call chain.  configure Configures a component by passing configuration parameters.\n configure(config: ConfigParams)\n  config: ConfigParams - configuration parameters to be set.  is_open Checks if the component is opened.\n is_open(): bool\n  returns: bool - true if the component has been opened and false otherwise.  open Opens the component.\n open(correlation_id: Optional[str])\n  correlation_id: Optional[str] - (optional) transaction id to trace execution through call chain.  shutdown Crashes the process using the configured crash mode.\n shutdown()\n Examples shutdown = Shutdown() shutdown.configure(ConfigParams.from_tuples( \u0026#34;mode\u0026#34;: \u0026#34;exception\u0026#34; )) shutdown.shutdown() # Result: Bang!!! the process crashes ","description":"Random shutdown component that crashes a process using various methods.\n","image":null,"permalink":"/python/components/test/shutdown/","subtitle":null,"tags":null,"title":"Shutdown"},{"content":"SMS sending microservice is intended mostly to send sms to specified recipients.\n Server implementations: NodeJS, Dart Communication protocols: Direct, Commandable HTTP, Commandable GRPC, GRPC Persistence: Memory, Flat Files, MongoDB, Couchbase Deployment options: Monolith, Process, Docker, AWS Lambda Client implementations: NodeJS, .NET, Dart  ","description":null,"image":null,"permalink":"/microservices/infrastructure/sms_delivery/","subtitle":null,"tags":null,"title":"SMS Delivery Microservice"},{"content":"Keeps settings of sms recipients.\n Server implementations: NodeJS, Dart Communication protocols: Direct, Commandable HTTP, Commandable GRPC, GRPC Persistence: Memory, Flat Files, MongoDB, Couchbase Deployment options: Monolith, Process, Docker, AWS Lambda Client implementations: NodeJS, Dart  This microservice has optional dependencies on the following microservices:\n Party Activities - to log user activities Message Templates - to get message templates SMS Delivery - to send sms messages  ","description":null,"image":null,"permalink":"/microservices/users/sms_settings/","subtitle":null,"tags":null,"title":"Sms Settings Microservice"},{"content":"Description The SortField class allows you to define a field used to sort query results. In addition, it allows you to specify the order type as ascending or descending.\nConstructors NewSortField Creates a new instance and assigns its values.\n NewSortField(name string, ascending bool) SortField\n  name: string - the name of the field to sort by. ascending: bool - true to sort in ascending order, and false to sort in descending order.  NewEmptySortField Creates a new empty instance.\n NewEmptySortField() SortField\n Fields Name Field name to sort by\n Name: string\n Ascending Flag to define sorting order. True to sort ascending, false to sort descending\n Ascending: bool\n  Examples filter := NewFilterParamsFromTuples(\u0026#34;type\u0026#34;, \u0026#34;Type1\u0026#34;); paging := NewPagingParams(0, 100); sorting := NewSortingParams(NewSortField(\u0026#34;create_time\u0026#34;, true)); err, page = myDataClient.getDataByFilter(filter, paging, sorting); See also   SortParams   ","description":"Defines a field name and the order type used to sort query results.\n","image":null,"permalink":"/golang/commons/data/sort_field/","subtitle":null,"tags":null,"title":"SortField"},{"content":"Description The SortField class allows you to define a field used to sort query results. In addition, it allows you to specify the order typer as ascending or descending.\nConstructors Creates a new instance and assigns its values.\n public SortField(string name = null, bool ascending = true)\n  name: string - name of the field to sort by. ascending: bool - true to sort in ascending order, and false to sort in descending order.  Properties Name Field name to sort by\n public string Name { get; set; }\n Ascending Flag used to define sorting order. True to sort ascending, false to sort descending\n public Ascending { get; set; }\n Examples var filter = FilterParams.FromTuples(\u0026#34;type\u0026#34;, \u0026#34;Type1\u0026#34;); var paging = new PagingParams(0, 100); var sorting = new SortingParams(new SortField(\u0026#34;create_time\u0026#34;, true)); myDataClient.GetDataByFilter(filter, paging, sorting); See also   SortParams   ","description":"Defines a field name and the order type used to sort query results.\n","image":null,"permalink":"/net/commons/data/sort_field/","subtitle":null,"tags":null,"title":"SortField"},{"content":"Description The SortField class allows you to define a field used to sort query results. In addition, it allows you to specify the order type as ascending or descending.\nConstructors Creates a new instance and assigns its values.\n public constructor(name: string = null, ascending: boolean = true)\n  name: string - name of the field to sort by. ascending: boolean - true to sort in ascending order, and false to sort in descending order.  Fields name Field name to sort by.\n public name: string\n ascending Flag used to define the sorting order. True to sort ascending, false to sort descending\n public ascending: boolean\n  Examples let filter = FilterParams.fromTuples(\u0026#34;type\u0026#34;, \u0026#34;Type1\u0026#34;); let paging = new PagingParams(0, 100); let sorting = new SortingParams(new SortField(\u0026#34;create_time\u0026#34;, true)); myDataClient.getDataByFilter(filter, paging, sorting, (err, page) =\u0026gt; {...}); See also   SortParams   ","description":"Defines a field name and the order type used to sort query results.\n","image":null,"permalink":"/node/commons/data/sort_field/","subtitle":null,"tags":null,"title":"SortField"},{"content":"Description The SortField class allows you to define a field used to sort query results. In addition, it allows you to specify the order typer as ascending or descending.\nConstructors Creates a new instance and assigns its values.\n SortField(name: str = None, ascending: bool = True)\n  name: str - the name of the field to sort by. ascending: bool - true to sort in ascending order, and false to sort in descending order.  Fields name The field name to sort by\n name: str\n ascending The flag to define sorting order. True to sort ascending, false to sort descending\n ascending: bool\n  Examples filter = FilterParams.fromTuples(\u0026#34;type\u0026#34;, \u0026#34;Type1\u0026#34;) paging = PagingParams(0, 100) sorting = SortingParams(SortField(\u0026#34;create_time\u0026#34;, true)) myDataClient.get_data_by_filter(filter, paging, sorting) See also   SortParams   ","description":"Defines a field name and the order type used to sort query results.\n","image":null,"permalink":"/python/commons/data/sort_field/","subtitle":null,"tags":null,"title":"SortField"},{"content":"Implements: []\u0026lt;SortField\u0026gt;\nDescription The SortParams class allows you to define a list of field names used to sort query results. In addition, it allows you to specify the type of order as ascending or descending.\nConstructors NewSortParams Creates a new instance and initializes it with specified sort fields.\n NewSortParams(fields []SortField) *SortField\n  fields: []SortField - list of fields to sort by.  Examples filter := NewFilterParamsFromTuples(\u0026#34;type\u0026#34;, \u0026#34;Type1\u0026#34;); paging := NewPagingParams(0, 100); sorting := NewSortingParams(NewSortField(\u0026#34;create_time\u0026#34;, true)); myDataClient.getDataByFilter(filter, paging, sorting, (err, page) =\u0026gt; {...}); See also   SortField   ","description":"Defines a list of field names used to sort query results.\n","image":null,"permalink":"/golang/commons/data/sort_params/","subtitle":null,"tags":null,"title":"SortParams"},{"content":"Inherits: List\u0026lt;SortField\u0026gt;\nDescription The SortParams class allows you to define a list of field names used to sort query results. In addition, it allows you to specify the type of order as ascending or descending.\nConstructors Creates a new instance and initializes it with specified sort fields.\n public SortParams(IEnumerable\u0026lt;SortField\u0026gt; fields = null)\n  fields: IEnumerable\u0026lt;SortField\u0026gt; - list of fields to sort by.  Creates a new instance and initializes it with specified sort fields.\n public SortParams(AnyValueArray fields)\n  fields: AnyValueArray - list of fields to sort by.  Examples var filter = FilterParams.FromTuples(\u0026#34;type\u0026#34;, \u0026#34;Type1\u0026#34;); var paging = new PagingParams(0, 100); var sorting = new SortParams(new SortField(\u0026#34;create_time\u0026#34;, true)); myDataClient.GetDataByFilter(filter, paging, sorting); See also   SortField   ","description":"Defines a list of field names used to sort query results.\n","image":null,"permalink":"/net/commons/data/sort_params/","subtitle":null,"tags":null,"title":"SortParams"},{"content":"Extends: Array\u0026lt;SortField\u0026gt;\nDescription The SortParams class allows you to define a list of field names used to sort query results. In addition, it allows you to specify the type of order as ascending or descending.\nConstructors Creates a new instance and initializes it with specified sort fields.\n public constructor(\u0026hellip;fields: SortField[])\n  fields: SortField[] - list of fields to sort by.  Examples let filter = FilterParams.fromTuples(\u0026#34;type\u0026#34;, \u0026#34;Type1\u0026#34;); let paging = new PagingParams(0, 100); let sorting = new SortingParams(new SortField(\u0026#34;create_time\u0026#34;, true)); myDataClient.getDataByFilter(filter, paging, sorting, (err, page) =\u0026gt; {...}); See also   SortField   ","description":"Defines a list of field names used to sort query results.\n","image":null,"permalink":"/node/commons/data/sort_params/","subtitle":null,"tags":null,"title":"SortParams"},{"content":"Implements: list\nDescription The SortParams class allows you to define a list of field names used to sort query results. In addition, it allows you to specify the type of order as ascending or descending.\nConstructors Creates a new instance and initializes it with specified sort fields.\n SortParams(*fields: SortField)\n  fields: SortField - a list of fields to sort by.  Examples filter = FilterParams.fromTuples(\u0026#34;type\u0026#34;, \u0026#34;Type1\u0026#34;) paging = PagingParams(0, 100) sorting = SortingParams(SortField(\u0026#34;create_time\u0026#34;, true)) myDataClient.get_data_by_filter(filter, paging, sorting) See also   SortField   ","description":"Defines a list of field names used to sort query results.\n","image":null,"permalink":"/python/commons/data/sort_params/","subtitle":null,"tags":null,"title":"SortParams"},{"content":"Inherits: IReferenceable, IConfigurable, IOpenable\nDescription The SqlServerConnection class allows you to create a connection to an SQLServer database using the official driver.\nImportant points\n By defining a connection and sharing it through multiple persistence components you can reduce number of used database connections.  Configuration parameters connection(s):\n discovery_key: (optional) key to retrieve the connection from IDiscovery host: host name or IP address port: port number (default: 27017) uri: resource URI or connection string with all parameters in it  credential(s):\n store_key: (optional) key to retrieve the credentials from ICredentialStore username: username password: user\u0026rsquo;s password  options:\n max_pool_size: (optional) maximum connection pool size (default: 2) keep_alive: (optional) enable connection keep alive (default: true) connect_timeout: (optional) connection timeout in milliseconds (default: 5 sec) auto_reconnect: (optional) enable auto reconnection (default: true) max_page_size: (optional) maximum page size (default: 100) debug: (optional) enable debug output (default: false).  References  *:logger:*:*:1.0 - (optional) ILogger components to pass log messages *:discovery:*:*:1.0 - (optional) IDiscovery services *:credential-store:*:*:1.0 (optional) credential stores to resolve credentials  Fields _connection The SQLServer connection pool object.\n protected _connection: SqlConnection\n _connectionResolver The connection resolver.\n protected _connectionResolver: SqlServerConnectionResolver\n _databaseName The SQLServer database name.\n protected _databaseName: string\n _logger The logger.\n protected _logger: CompositeLogger\n _options The configuration options.\n protected _options: ConfigParams\n  Instance methods CloseAsync Closes a component and frees used resources.\n public virtual Task CloseAsync(string correlationId)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain.  Configure Configures a component by passing configuration parameters.\n public virtual void Configure(ConfigParams config)\n  config: ConfigParams - configuration parameters to be set.  GetConnection Gets the connection to an SQLServer database.\n public SqlConnection GetConnection()\n  returns: SqlConnection - connection to an SQLServer database.  GetDatabaseName Gets the name of an SQLServer database.\n public string GetDatabaseName()\n  returns: string - database name.  ","description":"SQLServer connection using the official driver.\n","image":null,"permalink":"/net/sqlserver/connect/sqlserver_connection/","subtitle":null,"tags":null,"title":"SqlServerConnection"},{"content":"Implements: IReferenceable, IConfigurable, IOpenable\nDescription The SqlServerConnection class allows you to create a connection to an SQLServer database using the official driver.\nImportant points\n By defining a connection and sharing it through multiple persistence components you can reduce number of used database connections.  Configuration parameters connection(s):\n discovery_key: (optional) key to retrieve the connection from IDiscovery host: host name or IP address port: port number (default: 27017) uri: resource URI or connection string with all parameters in it  credential(s):\n store_key: (optional) key to retrieve the credentials from ICredentialStore username: username password: user\u0026rsquo;s password  options:\n connect_timeout: (optional) number of milliseconds to wait before timing out when connecting a new client (default: 0) idle_timeout: (optional) number of milliseconds a client must sit idle in the pool and not be checked out (default: 10000) max_pool_size: (optional) maximum number of clients the pool should contain (default: 10)  References  *:logger:*:*:1.0 - (optional) ILogger components to pass log messages *:discovery:*:*:1.0 - (optional) IDiscovery services *:credential-store:*:*:1.0 (optional) credential stores to resolve credentials  Fields _connection The SQLServer connection pool object.\n protected _connection: any\n _connectionResolver The connection resolver.\n protected _connectionResolver: SqlServerConnectionResolver\n _databaseName The SQLServer database name.\n protected _databaseName: string\n _logger The logger.\n protected _logger: CompositeLogger\n _options The configuration options.\n protected _options: ConfigParams\n  Instance methods close Closes a component and frees used resources.\n public close(correlationId: string): Promise\u0026lt;void\u0026gt;\n  correlationId: string - (optional) transaction id used to trace execution through the call chain.  configure Configures a component by passing configuration parameters.\n public configure(config: ConfigParams): void\n  config: ConfigParams - configuration parameters to be set.  getConnection Gets the connection to an SQLServer database.\n public getConnection(): any\n  returns: any - connection to an SQLServer database.  getDatabaseName Gets the name of an SQLServer database.\n public getDatabaseName(): string\n  returns: string - database name.  ","description":"SQLServer connection using the official driver.\n","image":null,"permalink":"/node/sqlserver/connect/sqlserver_connection/","subtitle":null,"tags":null,"title":"SqlServerConnection"},{"content":"Implements: IReferenceable, IConfigurable, IOpenable\nDescription The SqlServerConnection class allows you to create a connection to an SQLServer database using the official driver.\nImportant points\n By defining a connection and sharing it through multiple persistence components you can reduce number of used database connections.  Configuration parameters connection(s):\n discovery_key: (optional) key to retrieve the connection from IDiscovery host: host name or IP address port: port number (default: 27017) uri: resource URI or connection string with all parameters in it  credential(s):\n store_key: (optional) key to retrieve the credentials from ICredentialStore username: username password: user\u0026rsquo;s password  options:\n connect_timeout: (optional) number of milliseconds to wait before timing out when connecting a new client (default: 0) idle_timeout: (optional) number of milliseconds a client must sit idle in the pool and not be checked out (default: 10000) max_pool_size: (optional) maximum number of clients the pool should contain (default: 10)  References  *:logger:*:*:1.0 - (optional) ILogger components to pass log messages *:discovery:*:*:1.0 - (optional) IDiscovery services *:credential-store:*:*:1.0 (optional) credential stores to resolve credentials  Fields _connection The SQLServer connection pool object.\n _connection: Any\n _connection_resolver The connection resolver.\n _connection_resolver: SqlServerConnectionResolver\n _database_name The SQLServer database name.\n _database_name: str\n _logger The logger.\n _logger: CompositeLogger\n _options The configuration options.\n _options: ConfigParams\n  Instance methods close Closes a component and frees used resources.\n close(correlation_id: Optional[str])\n  correlation_id: Optional[str] - (optional) transaction id used to trace execution through the call chain.  configure Configures a component by passing configuration parameters.\n configure(config: ConfigParams)\n  config: ConfigParams - configuration parameters to be set.  get_connection Gets the connection to an SQLServer database.\n get_connection(): connection\n  returns: Any - connection to an SQLServer database.  get_database_name Gets the name of an SQLServer database.\n get_database_name(): str\n  returns: str - database name.  ","description":"SQLServer connection using the official driver.\n","image":null,"permalink":"/python/sqlserver/connect/sqlserver_connection/","subtitle":null,"tags":null,"title":"SqlServerConnection"},{"content":"Inherits: IReferenceable, IConfigurable\nDescription The SqlServerConnectionResolver class allows you to resolve connection and credential parameters, validates these parameters, and generate a connection URI.\nImportant points\n It is able to process multiple connections to PostgreSQL cluster nodes.  Configuration parameters connection(s):\n discovery_key: (optional) key to retrieve the connection from IDiscovery host: host name or IP address port: port number (default: 27017) database: database name uri: resource URI or connection string with all parameters in it  credential(s):\n store_key: (optional) key to retrieve the credentials from ICredentialStore username: username password: user\u0026rsquo;s password  References  *:discovery:*:*:1.0 - (optional) IDiscovery services *:credential-store:*:*:1.0 - (optional) ICredentialStore stores to resolve credentials  Constructors Creates a new instance of the connection component.\n public SqlServerConnectionResolver()\n Fields _connectionResolver The connection resolver\n protected _connectionResolver: ConnectionResolver\n _credentialResolver The credential resolver\n protected _credentialResolver: CredentialResolver\n  Instance methods Configure Configures the component by passing its configuration parameters.\n public void Configure(ConfigParams config)\n  config: ConfigParams - configuration parameters to be set.  ResolveAsync Resolves SQLServer config from connection and credential parameters.\n public Task\u0026lt;string\u0026gt; ResolveAsync(string correlationId)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. returns: Task\u0026lt;string\u0026gt; - resolved connection config or raise error  SetReferences Sets the references to dependent components.\n public void SetReferences(IReferences references)\n  references: IReferences - references to locate the component dependencies.  ","description":"Helper class that resolves SQLServer connection and credential parameters, validates them and generates a connection URI.\n","image":null,"permalink":"/net/sqlserver/connect/sqlserver_connection_resolver/","subtitle":null,"tags":null,"title":"SqlServerConnectionResolver"},{"content":"Implements: IReferenceable, IConfigurable\nDescription The SqlServerConnectionResolver class allows you to resolve connection and credential parameters, validates these parameters, and generate a connection URI.\nImportant points\n It is able to process multiple connections to PostgreSQL cluster nodes.  Configuration parameters connection(s):\n discovery_key: (optional) key to retrieve the connection from IDiscovery host: host name or IP address port: port number (default: 27017) database: database name uri: resource URI or connection string with all parameters in it  credential(s):\n store_key: (optional) key to retrieve the credentials from ICredentialStore username: username password: user\u0026rsquo;s password  References  *:discovery:*:*:1.0 - (optional) IDiscovery services *:credential-store:*:*:1.0 - (optional) ICredentialStore stores to resolve credentials  Constructors Creates a new instance of the connection component.\n public SqlServerConnectionResolver()\n Fields _connectionResolver The connection resolver\n protected _connectionResolver: ConnectionResolver\n _credentialResolver The credential resolver\n protected _credentialResolver: CredentialResolver\n  Instance methods configure Configures the component by passing its configuration parameters.\n public configure(config: ConfigParams): void\n  config: ConfigParams - configuration parameters to be set.  resolve Resolves SQLServer config from connection and credential parameters.\n public resolve(correlationId: string): Promise\u0026lt;string\u0026gt;\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. returns: Promise\u0026lt;string\u0026gt; - resolved connection config or raise error  setReferences Sets the references to dependent components.\n public setReferences(references: IReferences): void\n  references: IReferences - references to locate the component dependencies.  ","description":"Helper class that resolves SQLServer connection and credential parameters, validates them and generates a connection URI.\n","image":null,"permalink":"/node/sqlserver/connect/sqlserver_connection_resolver/","subtitle":null,"tags":null,"title":"SqlServerConnectionResolver"},{"content":"Implements: IReferenceable, IConfigurable\nDescription The SqlServerConnectionResolver class allows you to resolve connection and credential parameters, validates these parameters, and generate a connection URI.\nImportant points\n It is able to process multiple connections to PostgreSQL cluster nodes.  Configuration parameters connection(s):\n discovery_key: (optional) key to retrieve the connection from IDiscovery host: host name or IP address port: port number (default: 27017) database: database name uri: resource URI or connection string with all parameters in it  credential(s):\n store_key: (optional) key to retrieve the credentials from ICredentialStore username: username password: user\u0026rsquo;s password  References  *:discovery:*:*:1.0 - (optional) IDiscovery services *:credential-store:*:*:1.0 - (optional) ICredentialStore stores to resolve credentials  Constructors Creates a new instance of the connection component.\n SqlServerConnectionResolver()\n Fields _connection_resolver The connection resolver\n _connection_resolver: ConnectionResolver\n _credential_resolver The credential resolver\n _credential_resolver: CredentialResolver\n  Instance methods configure Configures the component by passing its configuration parameters.\n configure(config: ConfigParams)\n  config: ConfigParams - configuration parameters to be set.  resolve Resolves SQLServer config from connection and credential parameters.\n resolve(correlation_id: Optional[str]): str\n  correlation_id: Optional[str] - (optional) transaction id used to trace execution through the call chain. returns: str - resolved connection config or raise error  get_database Gets a connection to an SQLServer database\n get_database(): Any\n  return: Any - connection to an SQLServer database  set_references Sets the references to dependent components.\n set_references(references: IReferences)\n  references: IReferences - references to locate the component dependencies.  ","description":"Helper class that resolves SQLServer connection and credential parameters, validates them and generates a connection URI.\n","image":null,"permalink":"/python/sqlserver/connect/sqlserver_connection_resolver/","subtitle":null,"tags":null,"title":"SqlServerConnectionResolver"},{"content":"Inherits: IReferenceable, IUnreferenceable, IConfigurable, IOpenable, ICleanable\nDescription The SqlServerPersistence class allows you to create persistence components that store data in a SQLServer database using the official driver.\nImportant points\n This is the most basic persistence component that is able to store data items of any type. Specific CRUD operations over the data items must be implemented in child classes by accessing this._model or this._collection properties.  Configuration parameters  collection: (optional) SQLServer collection name\nconnection(s): discovery_key: (optional) key to retrieve the connection from IDiscovery host: host name or IP address port: port number (default: 27017) uri: resource URI or connection string with all parameters in it  credential(s):\n store_key: (optional) key to retrieve the credentials from ICredentialStore username: (optional) username password: (optional) user\u0026rsquo;s password  options:\n max_pool_size: (optional) maximum connection pool size (default: 2) keep_alive: (optional) enable connection keep alive (default: true) connect_timeout: (optional) connection timeout in milliseconds (default: 5 sec) max_page_size: (optional) maximum page size (default: 100) debug: (optional) enable debug output (default: false).  References  *:logger:*:*:1.0 - (optional) ILogger components to pass log messages *:discovery:*:*:1.0 - (optional) IDiscovery services *:credential-store:*:*:1.0 - (optional) ICredentialStore to resolve credentials  Constructors Creates a new instance of the persistence component.\n public SqlServerPersistence(string tableName)\n  tableName: string - (optional) table name.  Fields _tableName The SQLServer table object.\n protected _tableName: string\n _dependencyResolver The dependency resolver.\n protected _dependencyResolver: DependencyResolver\n _logger The logger.\n protected _logger: CompositeLogger\n _connection The SQLServer connection component.\n protected _connection: SqlServerConnection\n _client The SQLServer connection pool object.\n protected _client: SqlConnection\n _databaseName The SQLServer database name.\n protected _databaseName: string\n _maxPageSize The maximum number of records that can be returned from the database.\n protected _maxPageSize: int = 100\n _tableName The SqlServer table name.\n protected _tableName: string\n  Instance methods AutoCreateObject Adds an index definition to be created on opening.\n This is a deprecated method. Use EnsureSchema instead.   protected void AutoCreateObject(string schemaStatement)\n  schemaStatement: string - DML statement to autocreate database object  ClearAsync Clears component state.\n public virtual Task ClearAsync(string correlationId)\n  correlationId: string- the object to convert from the public partial format.  ClearSchema Clears all auto-created objects\n protected void ClearSchema()\n CloseAsync Closes a component and frees used resources.\n public virtual Task CloseAsync(string correlationId)\n  correlationId: string- the object to convert from the public partial format.  Configure Configures component by passing configuration parameters.\n public virtual void Configure(ConfigParams config)\n  config: ConfigParams - configuration parameters to be set.  ConvertFromPublic Converts an object value from public to internal format.\n protected virtual AnyValueMap ConvertFromPublic(T value)\n  value: T - object in public format to convert. returns: AnyValueMap - converted object in internal format.  ConvertToPublic Converts an object value from internal to public format.\n protected virtual T ConvertToPublic(AnyValueMap map)\n  map: AnyValueMap - object in internal format to convert. returns: T - converted object in public format.  CreateAsync Creates a data item.\n public virtual Task\u0026lt;T\u0026gt; CreateAsync(string correlationId, T item)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. item: T - item to be created. returns: Task\u0026lt;T\u0026gt; - created item  createSchema Creates a schema.\n protected Task CreateSchemaAsync(string correlationId)\n  correlationId: string - (optional) transaction id used to trace execution through a call chain.  DefineSchema Defines a database schema via auto create objects or convenience methods. Override in chile classes\n protected virtual void DefineSchema()\n DeleteByFilterAsync Deletes data items that match to a given filter. This method shall be called by a public DeleteByFilterAsync method from a child class that receives FilterParams and converts them into a filter function.\n public virtual Task DeleteByFilterAsync(string correlationId, string filter)\n  correlationId: string - (optional) transaction id used to trace execution through a call chain. filter: string - (optional) a filter JSON object.  EnsureIndex Adds an index definition to be created on opening.\n protected void EnsureIndex(string name, Dictionary\u0026lt;string, bool\u0026gt; keys, IndexOptions options)\n  name: string - the index name keys: Dictionary\u0026lt;string, bool\u0026gt; - index keys (fields) options: IndexOptions - index options  EnsureSchema Adds a statement to a schema definition\n protected void EnsureSchema(string dmlStatement)\n  dmlStatement: string - statement to be added to the schema  GenerateColumns Generates a list of column names to use in SQL statements like: \u0026ldquo;column1,column2,column3\u0026rdquo;\n protected string GenerateColumns(AnyValueMap map)\n  map: AnyValueMap - array with column values or a key-value map returns: string - generated list of column names  GenerateParameters Generates a list of value parameters to use in SQL statements like: \u0026quot;@Param1,@Param2,@Param3\u0026quot;.\n protected string GenerateParameters(AnyValueMap map)\n  map: AnyValueMap - array with values or a key-value map returns: string - generated list of value parameters   protected string GenerateParameters\u0026lt;K\u0026gt;(IEnumerable\u0026lt;K\u0026gt; values)\n  values: IEnumerable\u0026lt;K\u0026gt; - key-value map with columns and values returns: string - generated list of column sets  GenerateSetParameters Generates a list of value parameters to use in SQL statements like: \u0026ldquo;@Param1,@Param2,@Param3\u0026rdquo;\n protected string GenerateSetParameters(AnyValueMap map)\n  map: AnyValueMap - key-value map with columns and values returns: string - generated list of column sets   protected string GenerateSetParameters(IEnumerable\u0026lt;string\u0026gt; values)\n  values: IEnumerable\u0026lt;string\u0026gt; - key-value map with columns and values returns: string - generated list of column sets  GenerateValues Generates a list of column parameters\n protected List\u0026lt;object\u0026gt; GenerateValues(AnyValueMap map)\n  map: AnyValueMap - key-value map with columns and values returns: List\u0026lt;object\u0026gt; - generated list of column values  GetCountByFilterAsync Gets a number of data items retrieved by a given filter.\nThis method shall be called by a public GetCountByFilterAsync method from a child class that receives FilterParams and converts them into a filter function.\n protected virtual Task\u0026lt;long\u0026gt; GetCountByFilterAsync(string correlationId, string filter)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. filter: string - (optional) filter for JSON objects. returns: Task\u0026lt;long\u0026gt; - number of filtered items.  GetListByFilterAsync Gets a list of data items retrieved by a given filter and sorted according to sorting parameters.\nThis method shall be called by a public GetListByFilterAsync method from a child class that receives FilterParams and converts them into a filter function.\n protected Task\u0026lt;List\u0026lt;T\u0026gt;\u0026gt; GetListByFilterAsync(string correlationId, string filter, string sort = null, string select = null)\n  correlationId: string - (optional) transaction id used to trace execution through a call chain. filter: string - (optional) filter function used to filter items sort: string - (optional) sorting parameters select: string - (optional) projection parameters (not used yet) returns: Task\u0026lt;List\u0026lt;T\u0026gt;\u0026gt; - data list of filtered results  GetOneRandomAsync Gets a random item from items that match to a given filter.\nThis method shall be called by a public GetOneRandomAsync method from a child class that receives FilterParams and converts them into a filter function.\n protected virtual Task\u0026lt;T\u0026gt; GetOneRandomAsync(string correlationId, string filter)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. filter: string - (optional) a filter JSON object returns: Task\u0026lt;T\u0026gt; - a random item.  GetPageByFilter Gets a page of data items retrieved by a given filter and sorted according to sorting parameters.\nThis method shall be called by a public getPageByFilter method from a child class that receives FilterParams and converts them into a filter function.\n public virtual Task\u0026lt;DataPage\u0026gt; GetPageByFilterAsync(string correlationId, string filter, PagingParams paging = null, string sort = null, string select = null)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. filter: string - (optional) filter for JSON objects. paging: PagingParams - (optional) paging parameters sort: string - (optional) sorting JSON object select: string - (optional) projection JSON object returns: Task\u0026lt;DataPage\u0026gt; - a data page of result by filter  IsOpen Checks if the component is opened.\n public virtual bool IsOpen()\n  returns: bool - True if the component has been opened and False otherwise.  OpenAsync Opens the component.\n public virtual Task OpenAsync(string correlationId)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain.  QuoteIdentifier Adds single quotes to a string.\n protected string QuoteIdentifier(string value)\n  value: string - string where quotes need to be added returns: string - string with added quotes  SetReferences Sets references to dependent components.\n public virtual void SetReferences(IReferences references)\n  references: IReferences - references to locate the component dependencies.  UnsetReferences Unsets (clears) previously set references to dependent components.\n public virtual void UnsetReferences()\n Examples class MySqlServerPersistence: SqlServerPersistence\u0026lt;MyData\u0026gt; { public MySqlServerPersistence() { base(\u0026#34;mydata\u0026#34;); } public MyData getByName(string correlationId, string name) { var builder = Builders\u0026lt;BeaconV1\u0026gt;.Filter; var filter = builder.Eq(x =\u0026gt; x.Name, name); var result = await _collection.Find(filter).FirstOrDefaultAsync(); return result; } public MyData set(String correlatonId, MyData item) { var filter = Builders\u0026lt;T\u0026gt;.Filter.Eq(x =\u0026gt; x.Id, item.Id); var options = new FindOneAndReplaceOptions\u0026lt;T\u0026gt; { ReturnDocument = ReturnDocument.After, IsUpsert = true }; var result = await _collection.FindOneAndReplaceAsync(filter, item, options); return result; } } var persistence = new MySqlServerPersistence(); persistence.Configure(ConfigParams.fromTuples( \u0026#34;host\u0026#34;, \u0026#34;localhost\u0026#34;, \u0026#34;port\u0026#34;, 27017 )); persitence.Open(\u0026#34;123\u0026#34;); var mydata = new MyData(\u0026#34;ABC\u0026#34;); persistence.Set(\u0026#34;123\u0026#34;, mydata); persistence.GetByName(\u0026#34;123\u0026#34;, \u0026#34;ABC\u0026#34;); Console.Out.WriteLine(item); // Result: { name: \u0026#34;ABC\u0026#34; } ","description":"Abstract persistence component that stores data in a SQLServer database using the official driver.\n","image":null,"permalink":"/net/sqlserver/persistence/sqlserver_persistence/","subtitle":null,"tags":null,"title":"SqlServerPersistence"},{"content":"Implements: IReferenceable, IUnreferenceable, IConfigurable, IOpenable, ICleanable\nDescription The SqlServerPersistence class allows you to create persistence components that store data in a SQLServer database using the official driver.\nImportant points\n This is the most basic persistence component that is able to store data items of any type. Specific CRUD operations over the data items must be implemented in child classes by accessing this._db or this._collection properties.  Configuration parameters  collection: (optional) SQLServer collection name\nconnection(s): discovery_key: (optional) key to retrieve the connection from IDiscovery host: host name or IP address port: port number (default: 27017) uri: resource URI or connection string with all parameters in it  credential(s):\n store_key: (optional) key to retrieve the credentials from ICredentialStore username: (optional) username password: (optional) user\u0026rsquo;s password  options:\n connect_timeout: (optional) number of milliseconds to wait before timing out when connecting a new client (default: 0) idle_timeout: (optional) number of milliseconds a client must sit idle in the pool and not be checked out (default: 10000) max_pool_size: (optional) maximum number of clients the pool can contain (default: 10)  References  *:logger:*:*:1.0 - (optional) ILogger components to pass log messages *:discovery:*:*:1.0 - (optional) IDiscovery services *:credential-store:*:*:1.0 - (optional) ICredentialStore to resolve credentials  Constructors Creates a new instance of the persistence component.\n public constructor(tableName?: string)\n  tableName: string - (optional) table name.  Fields _tableName The SQLServer table object.\n protected _tableName: string\n _dependencyResolver The dependency resolver.\n protected _dependencyResolver: DependencyResolver\n _logger The logger.\n protected _logger: CompositeLogger\n _connection The SQLServer connection component.\n protected _connection: SqlServerConnection\n _client The SQLServer connection pool object.\n protected _client: any\n _databaseName The SQLServer database name.\n protected _databaseName: string\n _maxPageSize The maximum number of records that can be returned from the database.\n protected _maxPageSize: number = 100\n _requestFactory The SQL Server library\n protected _requestFactory: any\n  Instance methods autoCreateObject Adds an index definition to be created on opening.\n This is a deprecated method. Use ensureSchema instead.   protected autoCreateObject(schemaStatement: string): void\n  schemaStatement: string - DML statement to autocreate database object  clear Clears component state.\n public clear(correlationId: string) :Promise\u0026lt;void\u0026gt;\n  correlationId: string- the object to convert from the public partial format.  clearSchema Clears all auto-created objects\n protected clearSchema(): void\n close Closes a component and frees used resources.\n public close(correlationId: string): Promise\u0026lt;void\u0026gt;\n  correlationId: string- the object to convert from the public partial format.  configure Configures component by passing configuration parameters.\n public configure(config: ConfigParams): void\n  config: ConfigParams - configuration parameters to be set.  convertFromPublic Converts an object value from public to internal format.\n protected convertFromPublic(value: any): any\n  value: any - object in public format to convert. returns: any - converted object in internal format.  convertToPublic Converts an object value from internal to public format.\n protected convertToPublic(value: any): any\n  value: any - object in internal format to convert. returns: any - converted object in public format.  create Creates a data item.\n public create(correlationId: string, item: T): Promise\u0026lt;T\u0026gt;\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. item: T - item to be created. returns: Promise\u0026lt;T\u0026gt; - created item  createRequest Creates request to the database.\n protected createRequest(values: any[] = null): any\n  values: any[] - optional list of query parameters returns: any - a created request  createSchema Creates a schema.\n protected createSchema(correlationId: string): Promise\u0026lt;void\u0026gt;\n  correlationId: string - (optional) transaction id used to trace execution through a call chain.  defineSchema Defines a database schema via auto create objects or convenience methods.\n protected defineSchema(): void\n deleteByFilter Deletes data items that match to a given filter. This method shall be called by a public deleteByFilter method from a child class that receives FilterParams and converts them into a filter function.\n public deleteByFilter(correlationId: string, filter: string): Promise\u0026lt;void\u0026gt;\n  correlationId: string - (optional) transaction id used to trace execution through a call chain. filter: string - (optional) a filter JSON object.  ensureIndex Adds an index definition to be created on opening.\n protected ensureIndex(name: string, keys: any, options?: any): void\n  name: string - the index name keys: any - index keys (fields) options: any - index options  ensureSchema Adds a statement to a schema definition\n protected ensureSchema(schemaStatement: string): void\n  schemaStatement: string - statement to be added to the schema  generateColumns Generates a list of column names to use in SQL statements like: \u0026ldquo;column1,column2,column3\u0026rdquo;\n protected generateColumns(values: any): string\n  values: any - array with column values or a key-value map returns: string - generated list of column names  generateParameters Generates a list of value parameters to use in SQL statements like: \u0026quot;@1,@2,@3\u0026quot;.\n protected generateParameters(values: any): string\n  values: any - array with values or a key-value map returns: string - generated list of value parameters  generateSetParameters Generates a list of column sets to use in UPDATE statements like: \u0026quot;@1,@2,@3\u0026quot;.\n protected generateSetParameters(values: any): string\n  values: any - key-value map with columns and values returns: string - generated list of column sets  generateValues Generates a list of column parameters\n protected generateValues(values: any): any[]\n  values: any - key-value map with columns and values returns: any[] - generated list of column values  getCountByFilter Gets a number of data items retrieved by a given filter.\nThis method shall be called by a public getCountByFilter method from a child class that receives FilterParams and converts them into a filter function.\n protected getCountByFilter(correlationId: string, filter: any): Promise\u0026lt;number\u0026gt;\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. filter: any - (optional) filter for JSON objects returns: Promise\u0026lt;number\u0026gt; - number of filtered items  getListByFilter Gets a list of data items retrieved by a given filter and sorted according to sorting parameters.\nThis method shall be called by a public getListByFilter method from a child class that receives FilterParams and converts them into a filter function.\n protected getListByFilter(correlationId: string, filter: any, sort: any, select: any): Promise\u0026lt;T[]\u0026gt;\n  correlationId: string - (optional) transaction id used to trace execution through a call chain. filter: any - (optional) filter function used to filter items sort: any - (optional) sorting parameters select: any - (optional) projection parameters (not used yet) returns: Promise\u0026lt;T[]\u0026gt; - data list of filtered results  getOneRandom Gets a random item from items that match to a given filter.\nThis method shall be called by a public getOneRandom method from a child class that receives FilterParams and converts them into a filter function.\n getOneRandom(correlationId: string, filter: any): Promise\u0026lt;T\u0026gt;\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. filter: any - (optional) a filter JSON object returns: Promise\u0026lt;T\u0026gt; - a random item.  getPageByFilter Gets a page of data items retrieved by a given filter and sorted according to sorting parameters.\nThis method shall be called by a public getPageByFilter method from a child class that receives FilterParams and converts them into a filter function.\n protected getPageByFilter(correlationId: string, filter: any, paging: PagingParams, sort: any, select: any): Promise\u0026lt;DataPage\u0026gt;\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. filter: any - (optional) filter for JSON objects. paging: PagingParams - (optional) paging parameters sort: any - (optional) sorting JSON object select: any - (optional) projection JSON object returns: Promise\u0026lt;DataPage\u0026gt; - a data page of result by filter  isOpen Checks if the component is opened.\n public isOpen(): boolean\n  returns: boolean - True if the component has been opened and False otherwise.  open Opens the component.\n public open(correlationId: string): Promise\u0026lt;void\u0026gt;\n  correlationId: string - (optional) transaction id used to trace execution through the call chain.  quoteIdentifier Adds single quotes to a string.\n protected quoteIdentifier(value: string): string\n  value: string - string where quotes need to be added returns: string - string with added quotes  setReferences Sets references to dependent components.\n public setReferences(references: IReferences): void\n  references: IReferences - references to locate the component dependencies.  unsetReferences Unsets (clears) previously set references to dependent components.\n public unsetReferences(): void\n Examples class MySqlServerPersistence extends SqlServerPersistence\u0026lt;MyData\u0026gt; { public constructor() { base(\u0026#34;mydata\u0026#34;); } public getByName(correlationId: string, name: string, callback: (err, item) =\u0026gt; void): void { let criteria = { name: name }; this._model.findOne(criteria, callback); }); public set(correlatonId: string, item: MyData, callback: (err) =\u0026gt; void): void { let criteria = { name: item.name }; let options = { upsert: true, new: true }; this._model.findOneAndUpdate(criteria, item, options, callback); } } let persistence = new MySqlServerPersistence(); persistence.configure(ConfigParams.fromTuples( \u0026#34;host\u0026#34;, \u0026#34;localhost\u0026#34;, \u0026#34;port\u0026#34;, 27017 )); persitence.open(\u0026#34;123\u0026#34;, (err) =\u0026gt; { ... }); persistence.set(\u0026#34;123\u0026#34;, { name: \u0026#34;ABC\u0026#34; }, (err) =\u0026gt; { persistence.getByName(\u0026#34;123\u0026#34;, \u0026#34;ABC\u0026#34;, (err, item) =\u0026gt; { console.log(item); // Result: { name: \u0026#34;ABC\u0026#34; }  }); }); ","description":"Abstract persistence component that stores data in a SQLServer database using the official driver.\n","image":null,"permalink":"/node/sqlserver/persistence/sqlserver_persistence/","subtitle":null,"tags":null,"title":"SqlServerPersistence"},{"content":"Implements: IReferenceable, IUnreferenceable, IConfigurable, IOpenable, ICleanable\nDescription The SqlServerPersistence class allows you to create persistence components that store data in a SQLServer database using the official driver.\nImportant points\n This is the most basic persistence component that is able to store data items of any type. Specific CRUD operations over the data items must be implemented in child classes by accessing self._db or self._collection properties.  Configuration parameters  collection: (optional) SQLServer collection name\nconnection(s): discovery_key: (optional) key to retrieve the connection from IDiscovery host: host name or IP address port: port number (default: 27017) uri: resource URI or connection string with all parameters in it  credential(s):\n store_key: (optional) key to retrieve the credentials from ICredentialStore username: (optional) username password: (optional) user\u0026rsquo;s password  options:\n connect_timeout: (optional) number of milliseconds to wait before timing out when connecting a new client (default: 0) idle_timeout: (optional) number of milliseconds a client must sit idle in the pool and not be checked out (default: 10000) max_pool_size: (optional) maximum number of clients the pool can contain (default: 10)  References  *:logger:*:*:1.0 - (optional) ILogger components to pass log messages *:discovery:*:*:1.0 - (optional) IDiscovery services *:credential-store:*:*:1.0 - (optional) ICredentialStore to resolve credentials  Constructors Creates a new instance of the persistence component.\n SqlServerPersistence(table_name: str = None)\n  table_name: str - (optional) table name.  Fields _table_name The SQLServer table object.\n _table_name: str\n _dependency_resolver The dependency resolver.\n _dependency_resolver: DependencyResolver\n _logger The logger.\n _logger: CompositeLogger\n _connection The SQLServer connection component.\n _connection: SqlServerConnection\n _client The SQLServer connection pool object.\n _client: Any\n _database_name The SQLServer database name.\n _database_name: str\n _max_page_size The maximum number of records that can be returned from the database.\n _max_page_size = 100\n  Instance methods _auto_create_object Adds an index definition to be created on opening.\n This is a deprecated method. Use _ensure_schema instead.   _auto_create_object(schema_statement: str)\n  schema_statement: str - DML statement to autocreate database object  clear Clears component state.\n clear(correlation_id: Optional[str])\n  correlation_id: Optional[str]- the object to convert from the public partial format.  _clear_schema Clears all auto-created objects\n _clear_schema()\n close Closes a component and frees used resources.\n close(correlation_id: Optional[str])\n  correlation_id: Optional[str]- the object to convert from the public partial format.  configure Configures component by passing configuration parameters.\n configure(config: ConfigParams)\n  config: ConfigParams - configuration parameters to be set.  _convert_from_public Converts an object value from public to internal format.\n _convert_from_public(value: Any): Any\n  value: Any - object in public format to convert. returns: Any - converted object in internal format.  _convert_to_public Converts an object value from internal to public format.\n _convert_to_public(value: Any): Any\n  value: Any - object in internal format to convert. returns: Any - converted object in public format.  create Creates a data item.\n create(correlation_id: Optional[str], item: T): Optional[T]\n  correlation_id: Optional[str] - (optional) transaction id used to trace execution through the call chain. item: T - item to be created. returns: Optional[T] - created item  _request Performs a request to the database.\n _request(query: str, params: List[str] = None): dict\n  query: str - string with sql query to database params: List[str] - optional list of query parameters returns: dict - result of the query  _create_schema Creates a schema.\n _create_schema(correlation_id: Optional[str])\n  correlation_id: Optional[str] - (optional) transaction id used to trace execution through a call chain.  _define_schema Defines a database schema via auto create objects or convenience methods.\n _define_schema()\n delete_by_filter Deletes data items that match to a given filter. This method shall be called by a public delete_by_filter method from a child class that receives FilterParams and converts them into a filter function.\n delete_by_filter(correlation_id: Optional[str], filter: Any)\n  correlation_id: Optional[str] - (optional) transaction id used to trace execution through a call chain. filter: Any - (optional) filter function used to filter items.  _ensure_index Adds an index definition to be created on opening.\n _ensure_index(name: str, keys: Any, options: Any = None)\n  name: str - the index name keys: Any - index keys (fields) options: Any - index options  _ensure_schema Adds a statement to a schema definition\n _ensure_schema(schema_statement: str)\n  schema_statement: str - statement to be added to the schema  _generate_columns Generates a list of column names to use in SQL statements like: \u0026ldquo;column1,column2,column3\u0026rdquo;\n _generate_columns(values: Any): str\n  values: Any - array with column values or a key-value map returns: str - generated list of column names  _generate_parameters Generates a list of value parameters to use in SQL statements like: \u0026quot;?,?,?\u0026quot;\n _generate_parameters(values: Any): str\n  values: Any - array with values or a key-value map returns: str - generated list of value parameters  _generate_set_parameters Generates a list of column sets to use in UPDATE statements like: column1=?1,column2=?2\n _generate_set_parameters(values: Any): str\n  values: Any - key-value map with columns and values returns: str - generated list of column sets  _generate_values Generates a list of column parameters\n _generate_values(values: Any): List[Any]\n  values: Any - key-value map with columns and values returns: List[Any] - generated list of column values  get_count_by_filter Gets a number of data items retrieved by a given filter.\nThis method shall be called by a public get_count_by_filter method from a child class that receives FilterParams and converts them into a filter function.\n get_count_by_filter(correlation_id: Optional[str], filter: Any): int\n  correlation_id: Optional[str] - (optional) transaction id used to trace execution through the call chain. filter: Any - (optional) filter for JSON objects returns: int - number of filtered items  get_list_by_filter Gets a list of data items retrieved by a given filter and sorted according to sorting parameters.\nThis method shall be called by a public get_list_by_filter method from a child class that receives FilterParams and converts them into a filter function.\n get_list_by_filter(correlation_id: Optional[str], filter: Any, sort: Any = None, select: Any = None): List[T]\n  correlation_id: Optional[str] - (optional) transaction id used to trace execution through a call chain. filter: Any - (optional) filter function used to filter items sort: Any - (optional) sorting parameters select: Any - (optional) projection parameters (not used yet) returns: List[T] - data list of filtered results  get_one_random Gets a random item from items that match to a given filter.\nThis method shall be called by a public get_one_random method from a child class that receives FilterParams and converts them into a filter function.\n get_one_random(correlation_id: Optional[str], filter: Any): T\n  correlation_id: Optional[str] - (optional) transaction id used to trace execution through the call chain. filter: Any - (optional) a filter JSON object returns: T - a random item.  get_page_by_filter Gets a page of data items retrieved by a given filter and sorted according to sorting parameters.\nThis method shall be called by a public get_page_by_filter method from a child class that receives FilterParams and converts them into a filter function.\n get_page_by_filter(correlation_id: Optional[str], filter: Any, paging: PagingParams, sort: Any = None, select: Any = None): DataPage\n  correlation_id: Optional[str] - (optional) transaction id used to trace execution through the call chain. filter: Any - (optional) filter for JSON objects. paging: PagingParams - (optional) paging parameters sort: Any - (optional) sorting JSON object select: Any - (optional) projection JSON object returns: DataPage - a data page of result by filter  is_open Checks if the component is opened.\n is_open(): bool\n  returns: bool - True if the component has been opened and False otherwise.  open Opens the component.\n open(correlation_id: Optional[str])\n  correlation_id: Optional[str] - (optional) transaction id used to trace execution through the call chain.  _quote_identifier Adds single quotes to a string.\n _quote_identifier(value: str): Optional[str]\n  value: str - string where quotes need to be added returns: Optional[str] - string with added quotes  set_references Sets references to dependent components.\n set_references(references: IReferences)\n  references: IReferences - references to locate the component dependencies.  unset_references Unsets (clears) previously set references to dependent components.\n unset_references()\n Examples class MySqlServerPersistence(SqlServerPersistence): def __init__(self): super(MySqlServerPersistence, self).__init__(\u0026#39;mydata\u0026#39;) def get_by_name(self, correlation_id, name): criteria = {\u0026#39;name\u0026#39;:name} return self._model.find_one(criteria) def set(self,correlation_id, item): criteria = {\u0026#39;name\u0026#39;: item[\u0026#39;name\u0026#39;]} options = {\u0026#39;upsert\u0026#39;: True, \u0026#39;new\u0026#39;: True} return self._model.find_one_and_update(criteria, item, options) persistence = MySqlServerPersistence() persistence.configure(ConfigParams.from_tuples( \u0026#34;host\u0026#34;, \u0026#34;localhost\u0026#34;, \u0026#34;port\u0026#34;, 27017 )) persistence.open(\u0026#39;123\u0026#39;) persistence.set(\u0026#39;123\u0026#39;, {\u0026#39;name\u0026#39;:\u0026#39;ABC\u0026#39;}) item = persistence.get_by_name(\u0026#39;123\u0026#39;, \u0026#39;ABC\u0026#39;) print(item) # Result: { name: \u0026#34;ABC\u0026#34; } ","description":"Abstract persistence component that stores data in a SQLServer database using the official driver.\n","image":null,"permalink":"/python/sqlserver/persistence/sqlserver_persistence/","subtitle":null,"tags":null,"title":"SqlServerPersistence"},{"content":"Logs important system events like starts and stops of servers, upgrades to a new version, fatal system errors or key business transactions.\n Server implementations: NodeJS Communication protocols: Direct, Commandable HTTP, Commandable GRPC, GRPC Persistence: Memory, Flat Files, MongoDB, Couchbase Deployment options: Monolith, Process, Docker, AWS Lambda Client implementations: NodeJS, .NET  ","description":null,"image":null,"permalink":"/microservices/infrastructure/statistics/","subtitle":null,"tags":null,"title":"Statistics Microservice"},{"content":"Implements: RestOperations\nDescription The StatusOperations class allows you to handle status requests for REST operations.\nMethods GetStatusOperation Gets the status of the operation.\n (c *StatusOperations) GetStatusOperation() func(res http.ResponseWriter, req *http.Request)\n  returns: func(res http.ResponseWriter, req *http.Request) - status operation method  SetReferences Sets references to dependent components.\n (c *StatusOperations) SetReferences(references crefer.IReferences)\n  references: IReferences - references to locate the component dependencies.  Status Handles status requests.\n (c *StatusOperations) Status(res http.ResponseWriter, req *http.Request)\n  req: http.ResponseWriter - an HTTP request res: *http.Request - an HTTP response  ","description":"Handles status requests for REST operations.\n","image":null,"permalink":"/golang/rpc/services/status_operations/","subtitle":null,"tags":null,"title":"StatusOperations"},{"content":"Inherits: RestOperations\nDescription The StatusOperations class allows you to handle status requests for REST operations.\nInstance methods GetStatusOperation Gets the status of the operation.\n public Func\u0026lt;HttpRequest, HttpResponse, ClaimsPrincipal, Task\u0026gt; GetStatusOperation()\n  returns: Func\u0026lt;HttpRequest, HttpResponse, ClaimsPrincipal, Task\u0026gt; - status operation method  SetReferences Sets references to dependent components.\n public void SetReferences(IReferences references)\n  references: IReferences - references to locate the component dependencies.  StatusAsync Handles status requests.\n public Task StatusAsync(HttpRequest request, HttpResponse response, ClaimsPrincipal user)\n  request: HttpRequest - an HTTP request. response: HttpResponse - an HTTP response. user: ClaimsPrincipal - to identify current user.  ","description":"Handles status requests for REST operations.\n","image":null,"permalink":"/net/rpc/services/status_operations/","subtitle":null,"tags":null,"title":"StatusOperations"},{"content":"Extends: RestOperations\nDescription The StatusOperations class allows you to handle status requests for REST operations.\nInstance methods getStatusOperation Gets the status of the operation.\n public getStatusOperation(): function\n  returns: function - status operation method  setReferences Sets references to dependent components.\n public setReferences(references: IReferences): void\n  references: IReferences - references to locate the component dependencies.  status Handles status requests.\n public status(req, res): void\n  req: any - an HTTP request res: any - an HTTP response  ","description":"Handles status requests for REST operations.\n","image":null,"permalink":"/node/rpc/services/status_operations/","subtitle":null,"tags":null,"title":"StatusOperations"},{"content":"Implements: RestOperations\nDescription The StatusOperations class allows you to handle status requests for REST operations.\nInstance methods get_status_operation Gets the status of the operation.\n get_status_operation(): Callable\n  returns: Callable - status of the operation (JSON)  set_references Sets references to dependent components.\n set_references(references: IReferences)\n  references: IReferences - references to locate the component dependencies.  status Handles status requests.\n status(): str\n ","description":"Handles status requests for REST operations.\n","image":null,"permalink":"/python/rpc/services/status_operations/","subtitle":null,"tags":null,"title":"StatusOperations"},{"content":"Implements: RestService\nDescription The StatusRestService class allows you to create a service that returns microservice status information via the HTTP/REST protocol.\nThe service responds on /status route (can be changed) with a JSON object: { - \u0026quot;id\u0026quot;: unique container id (usually hostname) - \u0026quot;name\u0026quot;: container name (from ContextInfo) - \u0026quot;description\u0026quot;: container description (from ContextInfo) - \u0026quot;start_time\u0026quot;: time when container was started - \u0026quot;current_time\u0026quot;: current time in UTC - \u0026quot;uptime\u0026quot;: duration since container start time in milliseconds - \u0026quot;properties\u0026quot;: additional container properties (from ContextInfo) - \u0026quot;components\u0026quot;: descriptors of components registered in the container } Configuration parameters  base_route: base route for remote URI route: status route (default: \u0026ldquo;status\u0026rdquo;) dependencies:  endpoint: override for HTTP Endpoint dependency controller: override for Controller dependency   connection(s):  discovery_key: (optional) key to retrieve the connection from IDiscovery protocol: connection protocol (http or https) host: host name or IP address port: port number uri: resource URI or connection string with all parameters in it    References  *:logger:*:*:1.0 - (optional) ILogger components to pass log messages *:counters:*:*:1.0 - (optional) ICounters components to pass collected measurements *:discovery:*:*:1.0 - (optional) IDiscovery services to resolve connection *:endpoint:http:*:1.0 - (optional) HttpEndpoint reference  Constructors NewStatusRestService  NewStatusRestService() *StatusRestService\n Methods Configure Configures the component by passing its configuration parameters.\n (c *StatusRestService) Configure(config )\n  config: *cconf.ConfigParams - configuration parameters to be set.  SetReferences Sets references to dependent components.\n (c *StatusRestService) SetReferences(references crefer.IReferences)\n  references: crefer.IReferences - references to locate the component dependencies.  Register Registers all service routes in HTTP endpoint.\n (c *StatusRestService) Register()\n Examples service = NewStatusService(); service.Configure(cref.NewConfigParamsFromTuples( \u0026#34;connection.protocol\u0026#34;, \u0026#34;http\u0026#34;, \u0026#34;connection.host\u0026#34;, \u0026#34;localhost\u0026#34;, \u0026#34;connection.port\u0026#34;, 8080, )); opnErr:= service.Open(\u0026#34;123\u0026#34;) if opnErr == nil { fmt.Println(\u0026#34;The Status service is accessible at http://localhost:8080/status\u0026#34;); } See also   RestClient   RestService   ","description":"Service that returns microservice status information via HTTP/REST protocol.\n","image":null,"permalink":"/golang/rpc/services/status_rest_service/","subtitle":null,"tags":null,"title":"StatusRestService"},{"content":"Inherits: RestService\nDescription The StatusRestService class allows you to create a service that returns microservice status information via the HTTP/REST protocol.\nThe service responds on /status route (can be changed) with a JSON object: { - \u0026quot;id\u0026quot;: unique container id (usually hostname) - \u0026quot;name\u0026quot;: container name (from ContextInfo) - \u0026quot;description\u0026quot;: container description (from ContextInfo) - \u0026quot;start_time\u0026quot;: time when container was started - \u0026quot;current_time\u0026quot;: current time in UTC - \u0026quot;uptime\u0026quot;: duration since container start time in milliseconds - \u0026quot;properties\u0026quot;: additional container properties (from ContextInfo) - \u0026quot;components\u0026quot;: descriptors of components registered in the container } Configuration parameters  base_route: base route for remote URI route: status route (default: \u0026ldquo;status\u0026rdquo;) dependencies:  endpoint: override for HTTP Endpoint dependency controller: override for Controller dependency   connection(s):  discovery_key: (optional) key to retrieve the connection from IDiscovery protocol: connection protocol (http or https) host: host name or IP address port: port number uri: resource URI or connection string with all parameters in it    References  *:logger:*:*:1.0 - (optional) ILogger components to pass log messages *:counters:*:*:1.0 - (optional) ICounters components to pass collected measurements *:discovery:*:*:1.0 - (optional) IDiscovery services to resolve connection *:endpoint:http:*:1.0 - (optional) HttpEndpoint reference  Instance methods Configure Configures the component by passing its configuration parameters.\n public override void Configure(ConfigParams config)\n  config: ConfigParams - configuration parameters to be set.  SetReferences Sets references to dependent components.\n public override void SetReferences(IReferences references)\n  references: IReferences - references to locate the component dependencies.  Register Registers all service routes in HTTP endpoint.\n public override void Register()\n Examples var service = new StatusService(); service.Configure(ConfigParams.FromTuples( \u0026#34;connection.protocol\u0026#34;, \u0026#34;http\u0026#34;, \u0026#34;connection.host\u0026#34;, \u0026#34;localhost\u0026#34;, \u0026#34;connection.port\u0026#34;, 8080 )); service.Open(\u0026#34;123\u0026#34;); Console.Out.WriteLine(\u0026#34;The Status service is accessible at http://+:8080/status\u0026#34;); See also   RestClient   RestService   ","description":"Service that returns microservice status information via HTTP/REST protocol.\n","image":null,"permalink":"/net/rpc/services/status_rest_service/","subtitle":null,"tags":null,"title":"StatusRestService"},{"content":"Extends: RestService\nDescription The StatusRestService class allows you to create a service that returns microservice status information via the HTTP/REST protocol.\nThe service responds on /status route (can be changed) with a JSON object: { - \u0026quot;id\u0026quot;: unique container id (usually hostname) - \u0026quot;name\u0026quot;: container name (from ContextInfo) - \u0026quot;description\u0026quot;: container description (from ContextInfo) - \u0026quot;start_time\u0026quot;: time when container was started - \u0026quot;current_time\u0026quot;: current time in UTC - \u0026quot;uptime\u0026quot;: duration since container start time in milliseconds - \u0026quot;properties\u0026quot;: additional container properties (from ContextInfo) - \u0026quot;components\u0026quot;: descriptors of components registered in the container } Configuration parameters  base_route: base route for remote URI route: status route (default: \u0026ldquo;status\u0026rdquo;) dependencies:  endpoint: override for HTTP Endpoint dependency controller: override for Controller dependency   connection(s):  discovery_key: (optional) key to retrieve the connection from IDiscovery protocol: connection protocol (http or https) host: host name or IP address port: port number uri: resource URI or connection string with all parameters in it    References  *:logger:*:*:1.0 - (optional) ILogger components to pass log messages *:counters:*:*:1.0 - (optional) ICounters components to pass collected measurements *:discovery:*:*:1.0 - (optional) IDiscovery services to resolve connection *:endpoint:http:*:1.0 - (optional) HttpEndpoint reference  Instance methods configure Configures the component by passing its configuration parameters.\n public configure(config: ConfigParams): void\n  config: ConfigParams - configuration parameters to be set.  setReferences Sets references to dependent components.\n public setReferences(references: IReferences): void\n  references: IReferences - references to locate the component dependencies.  register Registers all service routes in HTTP endpoint.\n public register(): void\n Examples let service = new StatusService(); service.configure(ConfigParams.fromTuples( \u0026#34;connection.protocol\u0026#34;, \u0026#34;http\u0026#34;, \u0026#34;connection.host\u0026#34;, \u0026#34;localhost\u0026#34;, \u0026#34;connection.port\u0026#34;, 8080 )); await service.open(\u0026#34;123\u0026#34;); console.log(\u0026#34;The Status service is accessible at http://+:8080/status\u0026#34;); See also   RestClient   RestService   ","description":"Service that returns microservice status information via HTTP/REST protocol.\n","image":null,"permalink":"/node/rpc/services/status_rest_service/","subtitle":null,"tags":null,"title":"StatusRestService"},{"content":"Implements: RestService\nDescription The StatusRestService class allows you to create a service that returns microservice status information via the HTTP/REST protocol.\nThe service responds on /status route (can be changed) with a JSON object: { - \u0026quot;id\u0026quot;: unique container id (usually hostname) - \u0026quot;name\u0026quot;: container name (from ContextInfo) - \u0026quot;description\u0026quot;: container description (from ContextInfo) - \u0026quot;start_time\u0026quot;: time when container was started - \u0026quot;current_time\u0026quot;: current time in UTC - \u0026quot;uptime\u0026quot;: duration since container start time in milliseconds - \u0026quot;properties\u0026quot;: additional container properties (from ContextInfo) - \u0026quot;components\u0026quot;: descriptors of components registered in the container } Configuration parameters  base_route: base route for remote URI route: status route (default: \u0026ldquo;status\u0026rdquo;) dependencies:  endpoint: override for HTTP Endpoint dependency controller: override for Controller dependency   connection(s):  discovery_key: (optional) key to retrieve the connection from IDiscovery protocol: connection protocol (http or https) host: host name or IP address port: port number uri: resource URI or connection string with all parameters in it    References  *:logger:*:*:1.0 - (optional) ILogger components to pass log messages *:counters:*:*:1.0 - (optional) ICounters components to pass collected measurements *:discovery:*:*:1.0 - (optional) IDiscovery services to resolve connection *:endpoint:http:*:1.0 - (optional) HttpEndpoint reference  Instance methods configure Configures the component by passing its configuration parameters.\n configure(config: ConfigParams)\n  config: ConfigParams - configuration parameters to be set.  register Registers all service routes in HTTP endpoint.\n public register(): void\n set_references Sets references to dependent components.\n set_references(references: IReferences)\n  references: IReferences - references to locate the component dependencies.  Examples service = StatusService() service.configure(ConfigParams.from_tuples(\u0026#34;connection.protocol\u0026#34;, \u0026#34;http\u0026#34;, \u0026#34;connection.host\u0026#34;, \u0026#34;localhost\u0026#34;, \u0026#34;connection.port\u0026#34;, 8080)) service.open(\u0026#34;123\u0026#34;) # ... See also   RestClient   RestService   ","description":"Service that returns microservice status information via HTTP/REST protocol.\n","image":null,"permalink":"/python/rpc/services/status_rest_service/","subtitle":null,"tags":null,"title":"StatusRestService"},{"content":"Some of the programming languages used in the Pip.Services Toolkit require a project to be built, yielding executable files. A separate stage is used for this, which builds a special “build” Docker image. The project’s source code is copied to the image, after which the container is run and the project is compiled from inside the container. If the project compiles successfully, the generated files will be copied from the container back to the project for further use.\nTo perform the build process for a Golang project, we’ll be creating a Docker container build scenario in a file named Dockerfile.build. Copy the following into this file:\nFROMgolang:1.13# Set environment variables for GoENV GO111MODULE=on \\  CGO_ENABLED=0 \\  GOOS=linux \\  GOARCH=amd64 # Set a working directoryWORKDIR/app# Copy the package filesCOPY go.mod ./# Install all go_modulesRUN go mod download# Copy the package filesCOPY . .# Build the projectRUN go build -o /go/bin/run .This file, along with the others we will be creating, should be placed in the docker folder at the root of the project.\nLet’s have a look at what this Docker script will be doing. The standard golang image is going to be used as the base image, and set environment variables for Go on top of it. Next, /app is set as the working directory and our project’s go.mod file is copied there. This file contains a list of dependencies that are required to build the project, which are installed using the npm install command. The last steps of the script simply copies the rest of the project to the image and performs compilation using the build command.\nNote that the file go.mod is copied first, then the dependencies are installed, and only after that do we copy the rest of the source code. This is done to speed up container creation during future runs, as the steps that haven’t changed from the last run are simply taken from Docker’s cache. In other words, unless we add or remove a dependency, Docker can use the cached image with all of the dependencies already installed, and only has to perform the “copy” and “compile” steps when we change the project’s source code.\nIn our projects, we strive to make our scripts as universal as possible. Because of this, all variable values are defined in a separate file named component.json, which looks like this:\n{ \u0026#34;name\u0026#34;: \u0026#34;component-name\u0026#34;, \u0026#34;registry\u0026#34;: \u0026#34;registry-name\u0026#34;, \u0026#34;version\u0026#34;: \u0026#34;1.0.0\u0026#34;, \u0026#34;build\u0026#34;: \u0026#34;1\u0026#34; } This file contains basic information about the component we are dealing with: its name, Docker Hub registry, version, and build number.\nWe’ve developed a special script called build.ps1 for building our projects. This script is written in PowerShell - a scripting language used for creating system scripts. Since version 6.0, PowerShell is supported by most platforms that are used for development, such as Windows, Mac, and Linux. If for some reason PowerShell can’t be used, you can rewrite the script using bash or any other scripting language.\n#!/usr/bin/env pwsh Set-StrictMode -Version latest $ErrorActionPreference = \u0026#34;Stop\u0026#34; # Generate image and container names using the data in the \u0026#34;component.json\u0026#34; file $component = Get-Content -Path \u0026#34;component.json\u0026#34; | ConvertFrom-Json # Get buildnumber from github actions if ($env:GITHUB_RUN_NUMBER -ne $null) { $component.build = $env:GITHUB_RUN_NUMBER Set-Content -Path \u0026#34;component.json\u0026#34; -Value $($component | ConvertTo-Json) } $buildImage=\u0026#34;$($component.registry)/$($component.name):$($component.version)-$($component.build)-build\u0026#34; $container=$component.name # Remove build files if (Test-Path \u0026#34;./dist\u0026#34;) { $null = Remove-Item -Recurse -Force -Path \u0026#34;./dist/*\u0026#34; } else { $null = New-Item -ItemType Directory -Force -Path \u0026#34;./dist\u0026#34; } # Build docker image docker build -f docker/Dockerfile.build -t $buildImage . # Create and copy compiled files, then destroy docker create --name $container $buildImage docker cp \u0026#34;$($container):/app/run\u0026#34; ./dist/run docker rm $container if (!(Test-Path \u0026#34;./dist\u0026#34;)) { Write-Host \u0026#34;dist folder doesn\u0026#39;t exist in root dir. Build failed. Watch logs above.\u0026#34; exit 1 } This script generates a name for the image using the data in the component.json file, cleans the project of files from previous compilations, runs the Docker build scenario, and then copies the compiled files from the image back into the project. Once the files are copied, the container is deleted, and the script outputs the results of the build to the console.\nIf the build was successful, the project will have an /obj directory added, containing the newly compiled files.\nThis finishes up the build process. Continue on to Step 2 to dockerize the testing process.\nStep 2. Running automated tests.  ","description":null,"image":null,"permalink":"/golang/tutorials/microservice_dockerization/step1/","subtitle":null,"tags":null,"title":"Step 1. Build"},{"content":"Some of the programming languages used in the Pip.Services Toolkit require a project to be built, yielding executable files. A separate stage is used for this, which builds a special “build” Docker image. The project’s source code is copied to the image, after which the container is run and the project is compiled from inside the container. If the project compiles successfully, the generated files will be copied from the container back to the project for further use.\nTo perform the build process for a .NET project, we’ll be creating a Docker container build scenario in a file named Dockerfile.build. Copy the following into this file:\nFROMmcr.microsoft.com/dotnet/core/sdk:3.1# Set working directoryWORKDIR/app# RestoreCOPY src/Interface/Interface.csproj ./src/Interface/RUN dotnet restore --disable-parallel src/Interface/Interface.csprojCOPY src/Service/Service.csproj ./src/Service/RUN dotnet restore --disable-parallel src/Service/Service.csprojCOPY src/Client/Client.csproj ./src/Client/RUN dotnet restore --disable-parallel src/Client/Client.csprojCOPY src/Process/Process.csproj ./src/Process/RUN dotnet restore --disable-parallel src/Process/Process.csprojCOPY test/Service.Test/Service.Test.csproj ./test/Service.Test/RUN dotnet restore --disable-parallel test/Service.Test/Service.Test.csprojCOPY test/Client.Test/Client.Test.csproj ./test/Client.Test/RUN dotnet restore --disable-parallel test/Client.Test/Client.Test.csproj# Copy srcCOPY . .# PublishRUN dotnet build src/Process/Process.csprojRUN dotnet publish src/Process/Process.csproj -o /obj# Pack NugetRUN dotnet build src/Interface/Interface.csproj -c ReleaseRUN dotnet pack src/Interface/Interface.csproj -c Release -o ../../../distRUN dotnet build src/Service/Service.csproj -c ReleaseRUN dotnet pack src/Service/Service.csproj -c Release -o ../../../distRUN dotnet build src/Client/Client.csproj -c ReleaseRUN dotnet pack src/Client/Client.csproj -c Release -o ../../../distThis file, along with the others we will be creating, should be placed in the docker folder at the root of the project.\nLet’s have a look at what this Docker script will be doing. The standard Core SDK v3 image is going to be used as the base image. Next, /app is set as the working directory and our project’s csproj files is copied there and restore dependencies. This file contains a list of dependencies that are required to build the project, which are installed using the dotnet restore command. The last steps of the script simply copies the rest of the project to the image and performs compilation using the build command.\nNote these the csproj files is copied first, then the dependencies are installed, and only after that do we copy the rest of the source code. This is done to speed up container creation during future runs, as the steps that haven’t changed from the last run are simply taken from Docker’s cache. In other words, unless we add or remove a dependency, Docker can use the cached image with all of the dependencies already installed, and only has to perform the “copy” and “compile” steps when we change the project’s source code.\nIn our projects, we strive to make our scripts as universal as possible. Because of this, all variable values are defined in a separate file named component.json, which looks like this:\n{ \u0026#34;name\u0026#34;: \u0026#34;component-name\u0026#34;, \u0026#34;registry\u0026#34;: \u0026#34;registry-name\u0026#34;, \u0026#34;version\u0026#34;: \u0026#34;1.0.0\u0026#34;, \u0026#34;build\u0026#34;: \u0026#34;1\u0026#34; } This file contains basic information about the component we are dealing with: its name, Docker Hub registry, version, and build number.\nWe’ve developed a special script called build.ps1 for building our projects. This script is written in PowerShell - a scripting language used for creating system scripts. Since version 6.0, PowerShell is supported by most platforms that are used for development, such as Windows, Mac, and Linux. If for some reason PowerShell can’t be used, you can rewrite the script using bash or any other scripting language.\n#!/usr/bin/env pwsh Set-StrictMode -Version latest $ErrorActionPreference = \u0026#34;Stop\u0026#34; $component = Get-Content -Path \u0026#34;component.json\u0026#34; | ConvertFrom-Json # Get buildnumber from github actions if ($env:GITHUB_RUN_NUMBER -ne $null) { $component.build = $env:GITHUB_RUN_NUMBER Set-Content -Path \u0026#34;component.json\u0026#34; -Value $($component | ConvertTo-Json) } $buildImage=\u0026#34;$($component.registry)/$($component.name):$($component.version)-$($component.build)-build\u0026#34; $container=$component.name # Remove build files if (Test-Path \u0026#34;obj\u0026#34;) { Remove-Item -Recurse -Force -Path \u0026#34;obj\u0026#34; } # Build docker image docker build -f docker/Dockerfile.build -t $buildImage . # Create and copy compiled files, then destroy docker create --name $container $buildImage docker cp \u0026#34;$($container):/obj\u0026#34; ./obj docker rm $container if (!(Test-Path ./obj)) { Write-Host \u0026#34;obj folder doesn\u0026#39;t exist in root dir. Build failed. Watch logs above.\u0026#34; exit 1 } This script generates a name for the image using the data in the component.json file, cleans the project of files from previous compilations, runs the Docker build scenario, and then copies the compiled files from the image back into the project. Once the files are copied, the container is deleted, and the script outputs the results of the build to the console.\nIf the build was successful, the project will have an /obj directory added, containing the newly compiled files.\nThis finishes up the build process. Continue on to Step 2 to dockerize the testing process.\nStep 2. Running automated tests.  ","description":null,"image":null,"permalink":"/net/tutorials/microservice_dockerization/step1/","subtitle":null,"tags":null,"title":"Step 1. Build"},{"content":"Some of the programming languages used in the Pip.Services Toolkit require a project to be built, yielding executable files. A separate stage is used for this, which builds a special “build” Docker image. The project’s source code is copied to the image, after which the container is run and the project is compiled from inside the container. If the project compiles successfully, the generated files will be copied from the container back to the project for further use.\nTo perform the build process for a Node.js project, we’ll be creating a Docker container build scenario in a file named Dockerfile.build. Copy the following into this file:\nFROMnode:8‍# Install development toolsRUN npm install typescript -g‍# set working directoryWORKDIR/app‍# Copy project fileCOPY package*.json ./‍# install ALL node_modules, including \u0026#39;devDependencies\u0026#39;RUN npm install# copy all projectCOPY . .# compile source codeRUN tscThis file, along with the others we will be creating, should be placed in the docker folder at the root of the project.\nLet’s have a look at what this Docker script will be doing. The standard Node.JS v.8 image is going to be used as the base image, and TypeScript is going to be installed on top of it. Next, /app is set as the working directory and our project’s package.json file is copied there. This file contains a list of dependencies that are required to build the project, which are installed using the npm install command. The last steps of the script simply copies the rest of the project to the image and performs compilation using the tsc command.\nNote that the file package.json is copied first, then the dependencies are installed, and only after that do we copy the rest of the source code. This is done to speed up container creation during future runs, as the steps that haven’t changed from the last run are simply taken from Docker’s cache. In other words, unless we add or remove a dependency, Docker can use the cached image with all of the dependencies already installed, and only has to perform the “copy” and “compile” steps when we change the project’s source code.\nIn our projects, we strive to make our scripts as universal as possible. Because of this, all variable values are defined in a separate file named component.json, which looks like this:\n{ \u0026#34;name\u0026#34;: \u0026#34;component-name\u0026#34;, \u0026#34;registry\u0026#34;: \u0026#34;registry-name\u0026#34;, \u0026#34;version\u0026#34;: \u0026#34;1.0.0\u0026#34;, \u0026#34;build\u0026#34;: \u0026#34;1\u0026#34; } This file contains basic information about the component we are dealing with: its name, Docker Hub registry, version, and build number.\nWe’ve developed a special script called build.ps1 for building our projects. This script is written in PowerShell - a scripting language used for creating system scripts. Since version 6.0, PowerShell is supported by most platforms that are used for development, such as Windows, Mac, and Linux. If for some reason PowerShell can’t be used, you can rewrite the script using bash or any other scripting language.\n#!/usr/bin/env pwsh Set-StrictMode -Version latest $ErrorActionPreference = \u0026#34;Stop\u0026#34; # Get component data and set necessary variables $component = Get-Content -Path \u0026#34;component.json\u0026#34; | ConvertFrom-Json $buildImage=\u0026#34;$($component.registry)/$($component.name):$($component.version)-$( $component.build)-build\u0026#34; $container=$component.name # Get build number from teamcity agent $component.build = $env:BUILD_NUMBER Set-Content -Path \u0026#34;component.json\u0026#34; -Value $($component | ConvertTo-Json) # Remove build files if (Test-Path \u0026#34;obj\u0026#34;) { Remove-Item -Recurse -Force -Path \u0026#34;obj\u0026#34; } # Copy private keys to access git repo if (-not (Test-Path -Path \u0026#34;docker/id_rsa\u0026#34;)) { if ($env:GIT_PRIVATE_KEY -ne $null) { Set-Content -Path \u0026#34;docker/id_rsa\u0026#34; -Value $env:GIT_PRIVATE_KEY } else { Copy-Item -Path \u0026#34;~/.ssh/id_rsa\u0026#34; -Destination \u0026#34;docker\u0026#34; } } # Build docker image docker build -f docker/Dockerfile.build -t $buildImage . # Create and copy compiled files, then destroy docker create --name $container $buildImage docker cp \u0026#34;$($container):/app/obj\u0026#34; ./obj docker rm $container if (!(Test-Path ./obj) -and $env:RETRY -eq $true) { # if build failed and retries enabled run build again Write-Host \u0026#34;Build failed, but retries enabled, so restarting build script again...\u0026#34; ./build.ps1 } elseif (!(Test-Path ./obj)) { Write-Host \u0026#34;obj folder doesn\u0026#39;t exist in root dir. Build failed. Watch logs above.\u0026#34; exit 1 } This script generates a name for the image using the data in the component.json file, cleans the project of files from previous compilations, runs the Docker build scenario, and then copies the compiled files from the image back into the project. Once the files are copied, the container is deleted, and the script outputs the results of the build to the console.\nIf the build was successful, the project will have an /obj directory added, containing the newly compiled files.\nThis finishes up the build process. Continue on to Step 2 to dockerize the testing process.\nStep 2. Running automated tests.  ","description":null,"image":null,"permalink":"/node/tutorials/microservice_dockerization/step1/","subtitle":null,"tags":null,"title":"Step 1. Build"},{"content":"TODO rewrite this step for Python (Python is an interpreted language and not a compiled one)\nSome of the programming languages used in the Pip.Services Toolkit require a project to be built, yielding executable files. A separate stage is used for this, which builds a special “build” Docker image. The project’s source code is copied to the image, after which the container is run and the project is compiled from inside the container. If the project compiles successfully, the generated files will be copied from the container back to the project for further use.\nTo perform the build process for a Node.js project, we’ll be creating a Docker container build scenario in a file named Dockerfile.build. Copy the following into this file:\nFROM python:3 # set working directory WORKDIR /usr/src/app # copy project file COPY requirements.txt . # install dependencies RUN pip install -r requirements.txt # copy all project COPY . . This file, along with the others we will be creating, should be placed in the docker folder at the root of the project.\nLet’s have a look at what this Docker script will be doing. The standard Python v.3 image is going to be used as the base image, and Python is going to be installed on top of it. Next, /app is set as the working directory and our project’s requirements.txt file is copied there. This file contains a list of dependencies that are required to build the project, which are installed using the npm install command. The last steps of the script simply copies the rest of the project to the image.\nNote that the file requirements.txt is copied first, then the dependencies are installed, and only after that do we copy the rest of the source code. This is done to speed up container creation during future runs, as the steps that haven’t changed from the last run are simply taken from Docker’s cache. In other words, unless we add or remove a dependency, Docker can use the cached image with all of the dependencies already installed, and only has to perform the “copy” steps when we change the project’s source code.\nIn our projects, we strive to make our scripts as universal as possible. Because of this, all variable values are defined in a separate file named component.json, which looks like this:\n{ \u0026#34;name\u0026#34;: \u0026#34;component-name\u0026#34;, \u0026#34;registry\u0026#34;: \u0026#34;registry-name\u0026#34;, \u0026#34;version\u0026#34;: \u0026#34;1.0.0\u0026#34;, \u0026#34;build\u0026#34;: \u0026#34;1\u0026#34; } This file contains basic information about the component we are dealing with: its name, Docker Hub registry, version, and build number.\nWe’ve developed a special script called build.ps1 for building our projects. This script is written in PowerShell - a scripting language used for creating system scripts. Since version 6.0, PowerShell is supported by most platforms that are used for development, such as Windows, Mac, and Linux. If for some reason PowerShell can’t be used, you can rewrite the script using bash or any other scripting language.\n#!/usr/bin/env pwsh Set-StrictMode -Version latest $ErrorActionPreference = \u0026#34;Stop\u0026#34; # Get component data and set necessary variables $component = Get-Content -Path \u0026#34;component.json\u0026#34; | ConvertFrom-Json $buildImage=\u0026#34;$($component.registry)/$($component.name):$($component.version)-$( $component.build)-build\u0026#34; $container=$component.name # Get build number from teamcity agent $component.build = $env:BUILD_NUMBER Set-Content -Path \u0026#34;component.json\u0026#34; -Value $($component | ConvertTo-Json) # Remove build files if (Test-Path \u0026#34;obj\u0026#34;) { Remove-Item -Recurse -Force -Path \u0026#34;obj\u0026#34; } # Copy private keys to access git repo if (-not (Test-Path -Path \u0026#34;docker/id_rsa\u0026#34;)) { if ($env:GIT_PRIVATE_KEY -ne $null) { Set-Content -Path \u0026#34;docker/id_rsa\u0026#34; -Value $env:GIT_PRIVATE_KEY } else { Copy-Item -Path \u0026#34;~/.ssh/id_rsa\u0026#34; -Destination \u0026#34;docker\u0026#34; } } # Build docker image docker build -f docker/Dockerfile.build -t $buildImage . # Create and copy compiled files, then destroy docker create --name $container $buildImage docker rm $container This script generates a name for the image using the data in the component.json file, cleans the project of files from previous compilations, runs the Docker build scenario, and then copies the compiled files from the image back into the project. Once the files are copied, the container is deleted, and the script outputs the results of the build to the console.\nThis finishes up the build process. Continue on to Step 2 to dockerize the testing process.\nStep 2. Running automated tests.  ","description":null,"image":null,"permalink":"/python/tutorials/microservice_dockerization/step1/","subtitle":null,"tags":null,"title":"Step 1. Build"},{"content":"In this tutorial, we will be using a demo project to develop a small facade for a system that consists of a few microservices:\n Beacons - business logic microservice that performs the main operations of the system. Accounts - microservice for managing user accounts Passwords - microservice for managing user passwords Roles - microservice for managing user roles Sessions - microservice for processing user sessions  The Beacons microservice was demonstrated in the Data Microservice tutorial. The rest of the microservices are from our free Pip.Services Library.\nThe architecture of the system looks like this:\nThe facade microservice will be responsible for:\n registering new users; authorizing users and creating sessions for them; checking whether or not a session has expired when an authorized user makes another request (session restoration); providing access to the functionality of the Beacons microservice for authorized users.  Before starting, be sure to set up your environment and create a folder for the project. The directory structure of facade projects differs a bit from the structure we use when developing data microservices.\n/bin /config /docker /test └───/fixture └───/services └───/version1 /src └───/build └───/container └───/operations └───/version1 └───/services └───/version1 /package.json /tsconfig.json Create a /package.json file at the root of the project with the following content to configure dependencies and project parameters:\n/package.json\n{ \u0026#34;name\u0026#34;: \u0026#34;pip-data-microservice-node\u0026#34;, \u0026#34;version\u0026#34;: \u0026#34;1.0.0\u0026#34;, \u0026#34;main\u0026#34;: \u0026#34;./obj/src/index.js\u0026#34;, \u0026#34;typings\u0026#34;: \u0026#34;./obj/src/index.d.ts\u0026#34;, \u0026#34;scripts\u0026#34;: { \u0026#34;test\u0026#34;: \u0026#34;mocha -t 5000 -R spec -u tdd --recursive ./obj/test\u0026#34; }, \u0026#34;dependencies\u0026#34;: { \u0026#34;pip-services3-commons-node\u0026#34;: \u0026#34;^3.0.6\u0026#34;, \u0026#34;pip-services3-components-node\u0026#34;: \u0026#34;^3.0.7\u0026#34;, \u0026#34;pip-services3-container-node\u0026#34;: \u0026#34;3.0.*\u0026#34;, \u0026#34;pip-services3-data-node\u0026#34;: \u0026#34;^3.1.0\u0026#34;, \u0026#34;pip-services3-mongodb-node\u0026#34;: \u0026#34;^3.3.0\u0026#34;, \u0026#34;pip-services3-rpc-node\u0026#34;: \u0026#34;^3.2.4\u0026#34; }, \u0026#34;devDependencies\u0026#34;: { \u0026#34;@types/async\u0026#34;: \u0026#34;^2.0.49\u0026#34;, \u0026#34;@types/chai\u0026#34;: \u0026#34;^4.1.3\u0026#34;, \u0026#34;@types/lodash\u0026#34;: \u0026#34;^4.14.109\u0026#34;, \u0026#34;@types/mocha\u0026#34;: \u0026#34;^5.2.1\u0026#34;, \u0026#34;@types/node\u0026#34;: \u0026#34;^10.3.0\u0026#34;, \u0026#34;chai\u0026#34;: \u0026#34;^4.1.2\u0026#34;, \u0026#34;mocha\u0026#34;: \u0026#34;^5.2.0\u0026#34;, \u0026#34;restify\u0026#34;: \u0026#34;^4.3.0\u0026#34;, \u0026#34;pip-data-microservice-node\u0026#34;: \u0026#34;git+https://github.com/pip-services-samples/pip-services-beacons-node.git\u0026#34; } } Install all necessary modules using the command:\nnpm install Create a TypeScript compiler configuration file with the following lines:\n/tsconfig.json\n{ \u0026#34;compilerOptions\u0026#34;: { \u0026#34;declaration\u0026#34;: true, \u0026#34;module\u0026#34;: \u0026#34;commonjs\u0026#34;, \u0026#34;target\u0026#34;: \u0026#34;es6\u0026#34;, \u0026#34;noImplicitAny\u0026#34;: false, \u0026#34;outDir\u0026#34;: \u0026#34;obj\u0026#34;, \u0026#34;rootDir\u0026#34;: \u0026#34;.\u0026#34;, \u0026#34;sourceMap\u0026#34;: true, \u0026#34;types\u0026#34;: [\u0026#34;node\u0026#34;, \u0026#34;mocha\u0026#34;, \u0026#34;chai\u0026#34;] }, \u0026#34;exclude\u0026#34;: [ \u0026#34;node_modules\u0026#34;, \u0026#34;lib\u0026#34;, \u0026#34;dist\u0026#34;, \u0026#34;obj\u0026#34;, \u0026#34;temp\u0026#34; ] } Now our project is ready for development. Continue on to Step 2 - Business operations to start implementing the facade itself.\nStep 2. Designing a Direct Client  ","description":null,"image":null,"permalink":"/node/tutorials/microservice_facade/step1/","subtitle":null,"tags":null,"title":"Step 1. Creating the Project’s Structure"},{"content":"In this tutorial, we will be using a demo project to develop a small facade for a system that consists of a few microservices:\n Beacons - business logic microservice that performs the main operations of the system. Accounts - microservice for managing user accounts Passwords - microservice for managing user passwords Roles - microservice for managing user roles Sessions - microservice for processing user sessions  The Beacons microservice was demonstrated in the Data Microservice tutorial. The rest of the microservices are from our free Pip.Services Library.\nThe architecture of the system looks like this:\nThe facade microservice will be responsible for:\n registering new users; authorizing users and creating sessions for them; checking whether or not a session has expired when an authorized user makes another request (session restoration); providing access to the functionality of the Beacons microservice for authorized users.  Before starting, be sure to set up your environment and create a folder for the project. The directory structure of facade projects differs a bit from the structure we use when developing data microservices.\n/bin /config /docker /test └───/fixture └───/services └───/version1 └───/src /pip_facades_sample_python └───/build └───/container └───/operations └───/version1 └───/services └───/version1 /requirements.txt /setup.py Create a requirements.txt file at the root of the project with the following content to configure dependencies and project parameters:\n/requirements.txt\niso8601 PyYAML pystache pytest pytz bottle requests cheroot beaker netifaces==0.10.9 pip-services3-commons pip-services3-components pip-services3-container pip-services3-rpc Install all necessary modules using the command:\npip install -r requirements.txt Now our project is ready for development. Continue on to Step 2 - Business operations to start implementing the facade itself.\nStep 2. Designing a Direct Client  ","description":null,"image":null,"permalink":"/python/tutorials/microservice_facade/step1/","subtitle":null,"tags":null,"title":"Step 1. Creating the Project’s Structure"},{"content":"Let’s do some small preparation of the project before we start writing the client library.\nFirst, create the following directory structure to keep the source code organized:\n/src └───/version1 /test └───/version1 Prepare the initial project files, as described in the tutorial on creating a data microservice, for the language of your choice and perform the initialization process.\nSince data is transferred between the client and the microservice using a specific protocol, this data must be defined for the client to work correctly. Some developers prefer to export general data structures, define external interfaces in a separate library, and use it on the client and on the server. However, to minimize the amount of libraries and simplify dependencies, we prefer to just copy the data structure from the microservice to the client library. This won’t cause any additional problems, since after changing the external interface, the client should be updated and retested anyways.\nCopy the files from the microservice’s data folder into the src/data/version1 folder of our client project. The microservice’s source code can be found at the following link\nFor “strongly typed” languages (e.g. Dart), you’ll have to import the data model files from the microservice using the import directive, instead of just copying the directory over. This will guarantee an exact type match.\nNow we’re ready to start writing our client library. When you’re ready, continue on to Step 2. Designing a Direct Client.\nStep 2. Designing a Direct Client.  ","description":null,"image":null,"permalink":"/net/tutorials/client_library/step1/","subtitle":null,"tags":null,"title":"Step 1. Setting up the project structure"},{"content":"Before we start actually writing our microservice, we need to first set up our environment and create a directory structure in the project’s folder.\nTo set up our environment, we’ll need to install all the necessary tools, as described on the Setup environment page.\nDon’t forget to select the programming language that you plan on using.\nCreate a folder for the project and, inside it, a directory structure to match the one below:\n/bin /config /docker /src └───/interface └───/data │ └───/version1 └───/process └───/logic └───/services └───/build └───/containers └───/persistence └───/services └───/version1 /test └───/logic └───/persistence └───/service └───/version1 Add a csproj files with the following lines to the next project folders:\nsrc/interface/Interface.csproj\n\u0026lt;Project Sdk=\u0026#34;Microsoft.NET.Sdk\u0026#34;\u0026gt; \u0026lt;PropertyGroup\u0026gt; \u0026lt;TargetFramework\u0026gt;netstandard2.1\u0026lt;/TargetFramework\u0026gt; \u0026lt;RootNamespace\u0026gt;Beacons\u0026lt;/RootNamespace\u0026gt; \u0026lt;AssemblyName\u0026gt;Beacons\u0026lt;/AssemblyName\u0026gt; \u0026lt;ApplicationIcon /\u0026gt; \u0026lt;Win32Resource /\u0026gt; \u0026lt;Version\u0026gt;1.0.0\u0026lt;/Version\u0026gt; \u0026lt;Authors\u0026gt;Sergey Seroukhov\u0026lt;/Authors\u0026gt; \u0026lt;Copyright\u0026gt;Conceptual Vision Consulting LLC 2018\u0026lt;/Copyright\u0026gt; \u0026lt;Description\u0026gt;Beacons microservice client\u0026lt;/Description\u0026gt; \u0026lt;Company\u0026gt;Conceptual Vision Consulting LLC\u0026lt;/Company\u0026gt; \u0026lt;Product\u0026gt;Beacons\u0026lt;/Product\u0026gt; \u0026lt;PackageLicenseUrl\u0026gt;http://opensource.org/licenses/MIT\u0026lt;/PackageLicenseUrl\u0026gt; \u0026lt;PackageProjectUrl\u0026gt;https://github.com/pip-services/pip-services\u0026lt;/PackageProjectUrl\u0026gt; \u0026lt;PackageIconUrl\u0026gt;https://github.com/pip-services/pip-services/design/Logo.png\u0026lt;/PackageIconUrl\u0026gt; \u0026lt;PackageTags\u0026gt;microservices beacons\u0026lt;/PackageTags\u0026gt; \u0026lt;GeneratePackageOnBuild\u0026gt;true\u0026lt;/GeneratePackageOnBuild\u0026gt; \u0026lt;/PropertyGroup\u0026gt; \u0026lt;ItemGroup\u0026gt; \u0026lt;PackageReference Include=\u0026#34;PipServices3.Commons\u0026#34; Version=\u0026#34;3.1.2\u0026#34; /\u0026gt; \u0026lt;/ItemGroup\u0026gt; \u0026lt;/Project\u0026gt; src/interface/Process.csproj\n\u0026lt;Project Sdk=\u0026#34;Microsoft.NET.Sdk\u0026#34;\u0026gt; \u0026lt;PropertyGroup\u0026gt; \u0026lt;OutputType\u0026gt;Exe\u0026lt;/OutputType\u0026gt; \u0026lt;TargetFramework\u0026gt;net5.0\u0026lt;/TargetFramework\u0026gt; \u0026lt;AssemblyName\u0026gt;main\u0026lt;/AssemblyName\u0026gt; \u0026lt;RootNamespace\u0026gt;Beacons\u0026lt;/RootNamespace\u0026gt; \u0026lt;/PropertyGroup\u0026gt; \u0026lt;ItemGroup\u0026gt; \u0026lt;ProjectReference Include=\u0026#34;..\\Service\\Service.csproj\u0026#34; /\u0026gt; \u0026lt;/ItemGroup\u0026gt; \u0026lt;/Project\u0026gt; src/interface/Service.csproj\n\u0026lt;Project Sdk=\u0026#34;Microsoft.NET.Sdk\u0026#34;\u0026gt; \u0026lt;PropertyGroup\u0026gt; \u0026lt;TargetFramework\u0026gt;netstandard2.1\u0026lt;/TargetFramework\u0026gt; \u0026lt;RootNamespace\u0026gt;Beacons\u0026lt;/RootNamespace\u0026gt; \u0026lt;AssemblyName\u0026gt;Beacons.Service\u0026lt;/AssemblyName\u0026gt; \u0026lt;/PropertyGroup\u0026gt; \u0026lt;ItemGroup\u0026gt; \u0026lt;PackageReference Include=\u0026#34;PipServices3.Commons\u0026#34; Version=\u0026#34;3.1.2\u0026#34; /\u0026gt; \u0026lt;PackageReference Include=\u0026#34;PipServices3.Components\u0026#34; Version=\u0026#34;3.2.1\u0026#34; /\u0026gt; \u0026lt;PackageReference Include=\u0026#34;PipServices3.Container\u0026#34; Version=\u0026#34;3.1.2\u0026#34; /\u0026gt; \u0026lt;PackageReference Include=\u0026#34;PipServices3.Data\u0026#34; Version=\u0026#34;3.2.3\u0026#34; /\u0026gt; \u0026lt;PackageReference Include=\u0026#34;PipServices3.MongoDb\u0026#34; Version=\u0026#34;3.3.0\u0026#34; /\u0026gt; \u0026lt;PackageReference Include=\u0026#34;PipServices3.Rpc\u0026#34; Version=\u0026#34;3.4.1\u0026#34; /\u0026gt; \u0026lt;PackageReference Include=\u0026#34;PipServices3.Expressions\u0026#34; Version=\u0026#34;3.1.0\u0026#34; /\u0026gt; \u0026lt;PackageReference Include=\u0026#34;PipServices3.Swagger\u0026#34; Version=\u0026#34;3.0.2\u0026#34; /\u0026gt; \u0026lt;/ItemGroup\u0026gt; \u0026lt;ItemGroup\u0026gt; \u0026lt;ProjectReference Include=\u0026#34;..\\Interface\\Interface.csproj\u0026#34; /\u0026gt; \u0026lt;/ItemGroup\u0026gt; \u0026lt;ItemGroup\u0026gt; \u0026lt;Compile Remove=\u0026#34;src\\Interface\\Data\\Version1\\BeaconTypeV1.cs\u0026#34; /\u0026gt; \u0026lt;Compile Remove=\u0026#34;test\\Service.Test\\Interface\\Data\\Version1\\TestModel.cs\u0026#34; /\u0026gt; \u0026lt;Compile Remove=\u0026#34;Persistence\\BeaconsMongoDbSchema.cs\u0026#34; /\u0026gt; \u0026lt;/ItemGroup\u0026gt; \u0026lt;/Project\u0026gt; To install all necessary dependencies, run the following command from a terminal at the root of the project’s directory:\ndotnet restore Now that we’ve got the project all set up, we can move on to Step 2. Data model development.\nStep 2. Data model development. ","description":null,"image":null,"permalink":"/net/tutorials/data_microservice/step1/","subtitle":null,"tags":null,"title":"Step 1. Project structure"},{"content":"Let’s do some small preparation of the project before we start writing the client library.\nFirst, create the following directory structure to keep the source code organized:\n/src └───/version1 /test └───/version1 Prepare the initial project files, as described in the tutorial on creating a data microservice, for the language of your choice and perform the initialization process.\nSince data is transferred between the client and the microservice using a specific protocol, this data must be defined for the client to work correctly. Some developers prefer to export general data structures, define external interfaces in a separate library, and use it on the client and on the server. However, to minimize the amount of libraries and simplify dependencies, we prefer to just copy the data structure from the microservice to the client library. This won’t cause any additional problems, since after changing the external interface, the client should be updated and retested anyways.\nCopy the files from the microservice’s data folder into the src/data/version1 folder of our client project. The microservice’s source code can be found at the following link\nFor “strongly typed” languages (e.g. Dart), you’ll have to import the data model files from the microservice using the import directive, instead of just copying the directory over. This will guarantee an exact type match.\nNow we’re ready to start writing our client library. When you’re ready, continue on to Step 2. Designing a Direct Client.\nStep 2. Designing a Direct Client.  ","description":null,"image":null,"permalink":"/node/tutorials/client_library/step1/","subtitle":null,"tags":null,"title":"Step 1. Setting up the project structure"},{"content":"Before we start actually writing our microservice, we need to first set up our environment and create a directory structure in the project’s folder.\nTo set up our environment, we’ll need to install all the necessary tools, as described on the Setup environment page.\nDon’t forget to select the programming language that you plan on using.\nCreate a folder for the project and, inside it, a directory structure to match the one below:\n/bin /config /docker /src └───/build └───/container └───/data │ └───/version1 └───/logic └───/persistence └───/service └───/version1 /test └───/logic └───/persistence └───/service └───/version1 Add a package.json file with the following lines to the root of the project’s folder:\n/package.json\n{ \u0026#34;name\u0026#34;: \u0026#34;beacons\u0026#34;, \u0026#34;version\u0026#34;: \u0026#34;1.0.0\u0026#34;, \u0026#34;main\u0026#34;: \u0026#34;./obj/src/index.js\u0026#34;, \u0026#34;typings\u0026#34;: \u0026#34;./obj/src/index.d.ts\u0026#34;, \u0026#34;scripts\u0026#34;: { \u0026#34;test\u0026#34;: \u0026#34;mocha -t 5000 -R spec -u tdd --recursive ./obj/test\u0026#34; }, \u0026#34;dependencies\u0026#34;: { \u0026#34;pip-services3-commons-node\u0026#34;: \u0026#34;^3.0.*\u0026#34;, \u0026#34;pip-services3-components-node\u0026#34;: \u0026#34;^3.0.*\u0026#34;, \u0026#34;pip-services3-container-node\u0026#34;: \u0026#34;3.0.*\u0026#34;, \u0026#34;pip-services3-data-node\u0026#34;: \u0026#34;^3.0.*\u0026#34;, \u0026#34;pip-services3-rpc-node\u0026#34;: \u0026#34;^3.0.*\u0026#34;, \u0026#34;pip-services3-mongodb-node\u0026#34;: \u0026#34;^3.0.*\u0026#34; }, \u0026#34;devDependencies\u0026#34;: { \u0026#34;@types/async\u0026#34;: \u0026#34;^2.0.49\u0026#34;, \u0026#34;@types/chai\u0026#34;: \u0026#34;^4.1.3\u0026#34;, \u0026#34;@types/lodash\u0026#34;: \u0026#34;^4.14.109\u0026#34;, \u0026#34;@types/mocha\u0026#34;: \u0026#34;^5.2.1\u0026#34;, \u0026#34;@types/node\u0026#34;: \u0026#34;^10.3.0\u0026#34;, \u0026#34;chai\u0026#34;: \u0026#34;^4.1.2\u0026#34;, \u0026#34;mocha\u0026#34;: \u0026#34;^5.2.0\u0026#34;, \u0026#34;restify\u0026#34;: \u0026#34;^4.3.0\u0026#34; } } To install all necessary dependencies, run the following command from a terminal at the root of the project’s directory:\nnpm install Now that we’ve got the project all set up, we can move on to Step 2. Data model development.\nStep 2. Data model development. ","description":null,"image":null,"permalink":"/node/tutorials/data_microservice/step1/","subtitle":null,"tags":null,"title":"Step 1. Project structure"},{"content":"Let’s do some small preparation of the project before we start writing the client library.\nFirst, create the following directory structure to keep the source code organized:\n/src └───/version1 /test └───/version1 Prepare the initial project files, as described in the tutorial on creating a data microservice, for the language of your choice and perform the initialization process.\nSince data is transferred between the client and the microservice using a specific protocol, this data must be defined for the client to work correctly. Some developers prefer to export general data structures, define external interfaces in a separate library, and use it on the client and on the server. However, to minimize the amount of libraries and simplify dependencies, we prefer to just copy the data structure from the microservice to the client library. This won’t cause any additional problems, since after changing the external interface, the client should be updated and retested anyways.\nCopy the files from the microservice’s data folder into the src/data/version1 folder of our client project. The microservice’s source code can be found at the following link\nFor “strongly typed” languages (e.g. Dart), you’ll have to import the data model files from the microservice using the import directive, instead of just copying the directory over. This will guarantee an exact type match.\nNow we’re ready to start writing our client library. When you’re ready, continue on to Step 2. Designing a Direct Client.\nStep 2. Designing a Direct Client.  ","description":null,"image":null,"permalink":"/python/tutorials/client_library/step1/","subtitle":null,"tags":null,"title":"Step 1. Setting up the project structure"},{"content":"Before we start actually writing our microservice, we need to first set up our environment and create a directory structure in the project’s folder.\nTo set up our environment, we’ll need to install all the necessary tools, as described on the Setup environment page.\nDon’t forget to select the programming language that you plan on using.\nCreate a folder for the project and, inside it, a directory structure to match the one below:\n/bin /config /docker /src └───/build └───/container └───/data │ └───/version1 └───/logic └───/persistence └───/service └───/version1 /test └───/logic └───/persistence └───/service └───/version1 Add a requirements.txt file with the following lines to the root of the project’s folder:\n/requirements.txt\niso8601 PyYAML pystache pytest pytz bottle pybars3 requests netifaces==0.10.9 pip_services3_commons pip_services3_expressions pip_services3_components pip_services3_container pip_services3_data pip_services3_mongodb pip_services3_rpc pip_services3_swagger To install all necessary dependencies, run the following command from a terminal at the root of the project’s directory:\npip install -r requirements.txt Now that we’ve got the project all set up, we can move on to Step 2. Data model development.\nStep 2. Data model development. ","description":null,"image":null,"permalink":"/python/tutorials/data_microservice/step1/","subtitle":null,"tags":null,"title":"Step 1. Project structure"},{"content":"Since facades are usually the point of entry into a system, they can contain dozens or even hundreds of REST operations. The classic microservices structure, when all the logic is contained in a single controller, becomes quite impractical in this case. Furthermore, it’s critical for a facade to support versioning. When the interface is changed, the facade must continue to provide stability for existing clients using interface versioning. Usually around 80% of the logic remains the same when an interface is changed, so duplicating the logic would just increase the amount of code and make it more difficult to support.\nTo solve these problems, the Pip.Services Toolkit offers a new pattern that breaks up logic into separate operations. The operations can be developed and tested individually, and then integrated into the RESTful service using unique routes. When implementing a new version, only the operations that require changes need to be rewritten. The remaining operations are simply imported from the old version by being reregistered in the new RESTful service.\nThe example facade in this tutorial will contain just 2 sets of operations:\n Operations that work with Beacons Operations for managing sessions and users  We’ll be creating a separate file for each set of operations and placing them in the folder operations/version1\nLet’s start with the first set of operations - the ones responsible for working with Beacons.\nCreate a file named BeaconsOperationsV1.ts and place the following code inside:\n/src/operations/version1/BeaconsOperationsV1.ts\nlet _ = require(\u0026#39;lodash\u0026#39;); let async = require(\u0026#39;async\u0026#39;); import { ConfigParams } from \u0026#39;pip-services3-commons-node\u0026#39;; import { IReferences } from \u0026#39;pip-services3-commons-node\u0026#39;; import { Descriptor } from \u0026#39;pip-services3-commons-node\u0026#39;; import { DependencyResolver } from \u0026#39;pip-services3-commons-node\u0026#39;; import { RestOperations } from \u0026#39;pip-services3-rpc-node\u0026#39;; import { IBeaconsClientV1 } from \u0026#39;../../clients/version1/IBeaconsClientV1\u0026#39;; import { BeaconV1 } from \u0026#39;../../clients/version1/BeaconV1\u0026#39;; export class BeaconsOperationsV2 extends RestOperations { private _beaconsClient: IBeaconsClientV1; public constructor() { super(); this._dependencyResolver.put(\u0026#39;beacons\u0026#39;, new Descriptor(\u0026#39;nov-services-beacons\u0026#39;, \u0026#39;client\u0026#39;, \u0026#39;*\u0026#39;, \u0026#39;*\u0026#39;, \u0026#39;1.0\u0026#39;)); } public setReferences(references: IReferences): void { super.setReferences(references); this._beaconsClient = this._dependencyResolver.getOneRequired\u0026lt;IBeaconsClientV1\u0026gt;(\u0026#39;beacons\u0026#39;); } public getBeaconsX(req: any, res: any): void { let filter = this.getFilterParams(req); let paging = this.getPagingParams(req); let siteId = req.params.site_id; filter.setAsObject(\u0026#39;site_id\u0026#39;, siteId); this._beaconsClient.getBeacons( null, filter, paging, this.sendResult(req, res) ); } public getBeaconX(req: any, res: any): void { let siteId = req.params.site_id; let beaconId = req.params.beacon_id; this._beaconsClient.getBeaconById( null, beaconId, this.sendResult(req, res) ); } public calculatePositionX(req: any, res: any): void { let siteId = req.params.site_id; let udis = req.param(\u0026#39;udis\u0026#39;); if (_.isString(udis)) udis = udis.split(\u0026#39;,\u0026#39;); this._beaconsClient.calculatePosition( null, siteId, udis, this.sendResult(req, res) ); } public createBeaconX(req: any, res: any): void { let siteId = req.params.site_id; let beacon = req.body || {}; this._beaconsClient.createBeacon( null, beacon, this.sendResult(req, res) ); } public updateBeaconX(req: any, res: any): void { let beaconId = req.params.beacon_id; let siteId = req.params.site_id; let beacon = req.body || {}; beacon.id = beaconId; this._beaconsClient.updateBeacon( null, beacon, this.sendResult(req, res) ); } public deleteBeaconX(req: any, res: any): void { let beaconId = req.params.beacon_id; let siteId = req.params.site_id; this._beaconsClient.deleteBeaconById( null, beaconId, this.sendResult(req, res) ); } public validateBeaconUdiX(req: any, res: any): void { let siteId = req.params.site_id; let udi = req.param(\u0026#39;udi\u0026#39;); this._beaconsClient.getBeaconByUdi( null, udi, (err, beacon) =\u0026gt; { if (beacon) res.json(beacon.id); else res.json(\u0026#39;\u0026#39;); } ); } } This component’s logic is based on calling the Beacons microservice via any client that implements the IBeaconsClientV1 interface. The component receives a link to the client through its SetReferences method (see The Component References recipe). The component’s business methods mainly just wrap the client’s methods to convert facade’s RESTful requests into calls to the client. Generally speaking, all of these methods perform the same set of steps: extract parameters from the request, call the corresponding method in the Beacons client, receive any results or errors, and send this information back as a response.\nIn the next (third) Step 3 - Authentication and session operations - we’ll be examining the second set of operations, which manage sessions and authenticate users.\nStep 3. Authentication and sessions  ","description":null,"image":null,"permalink":"/node/tutorials/microservice_facade/step2/","subtitle":null,"tags":null,"title":"Step 2. Business operations"},{"content":"Since facades are usually the point of entry into a system, they can contain dozens or even hundreds of REST operations. The classic microservices structure, when all the logic is contained in a single controller, becomes quite impractical in this case. Furthermore, it’s critical for a facade to support versioning. When the interface is changed, the facade must continue to provide stability for existing clients using interface versioning. Usually around 80% of the logic remains the same when an interface is changed, so duplicating the logic would just increase the amount of code and make it more difficult to support.\nTo solve these problems, the Pip.Services Toolkit offers a new pattern that breaks up logic into separate operations. The operations can be developed and tested individually, and then integrated into the RESTful service using unique routes. When implementing a new version, only the operations that require changes need to be rewritten. The remaining operations are simply imported from the old version by being reregistered in the new RESTful service.\nThe example facade in this tutorial will contain just 2 sets of operations:\n Operations that work with Beacons Operations for managing sessions and users  We’ll be creating a separate file for each set of operations and placing them in the folder operations/version1\nLet’s start with the first set of operations - the ones responsible for working with Beacons.\nCreate a file named BeaconsOperationsV1.py and place the following code inside:\n/pip_facades_sample_python/operations/version1/BeaconsOperationsV1.py\n# -*- coding: utf-8 -*- from typing import Optional import bottle from pip_services3_commons.convert import JsonConverter, TypeCode from pip_services3_commons.refer import Descriptor, IReferences from pip_services3_rpc.services import RestOperations from pip_facades_sample_python.clients.version1.BeaconV1 import BeaconV1 from pip_facades_sample_python.clients.version1.IBeaconsClientV1 import IBeaconsClientV1 class BeaconsOperationsV1(RestOperations): def __init__(self): super(BeaconsOperationsV1, self).__init__() self.__beacons_client: IBeaconsClientV1 = None self._dependency_resolver.put(\u0026#39;beacons\u0026#39;, Descriptor(\u0026#39;nov-services-beacons\u0026#39;, \u0026#39;client\u0026#39;, \u0026#39;*\u0026#39;, \u0026#39;*\u0026#39;, \u0026#39;1.0\u0026#39;)) def set_references(self, references: IReferences): super().set_references(references) self.__beacons_client = self._dependency_resolver.get_one_required(\u0026#39;beacons\u0026#39;) def get_beacons(self, site_id) -\u0026gt; Optional[str]: filter_params = self._get_filter_params() paging = self._get_paging_params() filter_params.set_as_object(\u0026#39;site_id\u0026#39;, site_id) result = self.__beacons_client.get_beacons(None, filter_params, paging) return self._send_result(result) def get_beacon(self, site_id, beacon_id) -\u0026gt; Optional[str]: result = self.__beacons_client.get_beacon_by_id(None, beacon_id) return self._send_result(result) def calculate_position(self, site_id) -\u0026gt; Optional[str]: params = bottle.request.json if isinstance(bottle.request.json, dict) else JsonConverter.from_json(TypeCode.Map, bottle.request.json) udis = params.get(\u0026#39;udis\u0026#39;) if isinstance(udis, str): udis = udis.split(\u0026#39;,\u0026#39;) result = self.__beacons_client.calculate_position(None, site_id, udis) return self._send_result(result) def create_beacon(self, site_id) -\u0026gt; Optional[str]: json_data = bottle.request.json if isinstance(bottle.request.json, dict) else JsonConverter.from_json( TypeCode.Map, bottle.request.json) beacon = BeaconV1(**json_data) result = self.__beacons_client.create_beacon(None, beacon) return self._send_result(result) def update_beacon(self, site_id, beacon_id) -\u0026gt; Optional[str]: beacon = bottle.request.json if isinstance(bottle.request.json, dict) else JsonConverter.from_json(TypeCode.Map, bottle.request.json) beacon[\u0026#39;id\u0026#39;] = beacon_id beacon = BeaconV1(**beacon) result = self.__beacons_client.update_beacon(None, beacon) return self._send_result(result) def delete_beacon(self, site_id, beacon_id) -\u0026gt; Optional[str]: result = self.__beacons_client.delete_beacon_by_id(None, beacon_id) return self._send_result(result) def validate_beacon_udi(self, site_id) -\u0026gt; Optional[str]: params = dict(bottle.request.query.decode()) udi = params.get(\u0026#39;udi\u0026#39;) beacon = self.__beacons_client.get_beacon_by_udi(None, udi) if beacon: return JsonConverter.to_json(beacon) else: return \u0026#39;\u0026#39; This component’s logic is based on calling the Beacons microservice via any client that implements the IBeaconsClientV1 interface. The component receives a link to the client through its SetReferences method (see The Component References recipe). The component’s business methods mainly just wrap the client’s methods to convert facade’s RESTful requests into calls to the client. Generally speaking, all of these methods perform the same set of steps: extract parameters from the request, call the corresponding method in the Beacons client, receive any results or errors, and send this information back as a response.\nIn the next (third) Step 3 - Authentication and session operations - we’ll be examining the second set of operations, which manage sessions and authenticate users.\nStep 3. Authentication and sessions  ","description":null,"image":null,"permalink":"/python/tutorials/microservice_facade/step2/","subtitle":null,"tags":null,"title":"Step 2. Business operations"},{"content":"We’ll start the development of our microservice with defining and implementing the data model that it is going to be working with. We’ll start by adding some folders to our project’s directory structure. In the src/interface folder, create a data folder and, inside it, a version1 folder. This is done to allow us to create new versions of the data model later on, without breaking the old one.\nNow, in the version1 folder, create a BeaconV1 class that implements IStringIdentifiable. By implementing the IStringIdentifiable interface, we can be sure that all objects of that given class have a string key by which they can be identified. Below is a listing of this class’s code:\n/src/interface/data/version1/BeaconV1.cs\nnamespace Beacons.Data.Version1 { [DataContract] public class BeaconV1 : IStringIdentifiable { [DataMember(Name = \u0026#34;id\u0026#34;)] public string Id { get; set; } [DataMember(Name = \u0026#34;site_id\u0026#34;)] public string SiteId { get; set; } [DataMember(Name = \u0026#34;type\u0026#34;)] public string Type { get; set; } [DataMember(Name = \u0026#34;udi\u0026#34;)] public string Udi { get; set; } [DataMember(Name = \u0026#34;label\u0026#34;)] public string Label { get; set; } [DataMember(Name = \u0026#34;center\u0026#34;)] public CenterObjectV1 Center { get; set; } [DataMember(Name = \u0026#34;radius\u0026#34;)] public double Radius { get; set; } } } All fields are of simple data types, and their names give us a good idea of their purpose. The only exception to this is the center field, in which we are going to be storing data of type GeoJSON. The beacon’s type will be represented by a string, but we’re going to have a separate class be responsible for managing the available types, using static fields. This class is going to be called BeaconTypeV1, and it’s going to simply contain a list of beacon types:\n/src/interface/data/version1/BeaconTypeV1.cs\nnamespace Beacons.Data.Version1 { public class BeaconTypeV1 { public static string Unknown = \u0026#34;unkown\u0026#34;; public static string AltBeacon = \u0026#34;altbeacon\u0026#34;; public static string iBeacon = \u0026#34;ibeacon\u0026#34;; public static string EddyStoneUdi = \u0026#34;eddystone-udi\u0026#34;; } } For checking the validity of the data we are going to be receiving, let’s create a data validation schema in a class called BeaconV1Schema:\n/src/interface/data/version1/BeaconV1Schema.cs\nnamespace Beacons.Data.Version1 { public class BeaconV1Schema : ObjectSchema { public BeaconV1Schema() { this.WithOptionalProperty(\u0026#34;id\u0026#34;, TypeCode.String); this.WithRequiredProperty(\u0026#34;site_id\u0026#34;, TypeCode.String); this.WithOptionalProperty(\u0026#34;type\u0026#34;, TypeCode.String); this.WithRequiredProperty(\u0026#34;udi\u0026#34;, TypeCode.String); this.WithOptionalProperty(\u0026#34;label\u0026#34;, TypeCode.String); this.WithOptionalProperty(\u0026#34;center\u0026#34;, null); this.WithOptionalProperty(\u0026#34;radius\u0026#34;, TypeCode.Double); } } } Let’s take a closer look at what’s going on in this class. First and foremost, we create a new class that extends the standard validation class Schema, implemented in the components module of the Pip.Services Toolkit. This class contains all of the functions that we need for checking the validity of the data we receive. All that we have to do is state which fields we are expecting, what their types should be, and whether or not any of them are required. All of this is done in the class’s constructor.\nSince everything we’ve done so far is quite simple and transparent, we’re not going to be writing any tests yet for the data model we’ve created.\nWith our data model defined, we can now move on to Step 3. Implementing persistence components.\nStep 3. Implementing persistence components. ","description":null,"image":null,"permalink":"/net/tutorials/data_microservice/step2/","subtitle":null,"tags":null,"title":"Step 2. Data model development"},{"content":"We’ll start the development of our microservice with defining and implementing the data model that it is going to be working with. We’ll start by adding some folders to our project’s directory structure. In the src folder, create a data folder and, inside it, a version1 folder. This is done to allow us to create new versions of the data model later on, without breaking the old one.\nNow, in the version1 folder, create a BeaconV1 class that implements IStringIdentifiable. By implementing the IStringIdentifiable interface, we can be sure that all objects of that given class have a string key by which they can be identified. Below is a listing of this class’s code:\n/src/data/version1/BeaconV1.ts\nimport { IStringIdentifiable } from \u0026#39;pip-services3-commons-node\u0026#39;; ‍ export class BeaconV1 implements IStringIdentifiable { public id: string; public site_id: string; public type?: string; public udi: string; public label?: string; public center?: any; // GeoJson  public radius?: number; } All fields are of simple data types, and their names give us a good idea of their purpose. The only exception to this is the center field, in which we are going to be storing data of type GeoJSON. The beacon’s type will be represented by a string, but we’re going to have a separate class be responsible for managing the available types, using static fields. This class is going to be called BeaconTypeV1, and it’s going to simply contain a list of beacon types:\n/src/data/version1/BeaconTypeV1.ts\nexport class BeaconTypeV1 { public static Unknown: string = \u0026#34;unknown\u0026#34;; public static AltBeacon: string = \u0026#34;altbeacon\u0026#34;; public static iBeacon: string = \u0026#34;ibeacon\u0026#34;; public static EddyStoneUdi: string = \u0026#34;eddystone-udi\u0026#34;; } For checking the validity of the data we are going to be receiving, let’s create a data validation schema in a class called BeaconV1Schema:\n/src/data/version1/BeaconV1Schema.ts\nimport { ObjectSchema } from \u0026#39;pip-services3-commons-node\u0026#39;; import { TypeCode } from \u0026#39;pip-services3-commons-node\u0026#39;; ‍ export class BeaconV1Schema extends ObjectSchema { public constructor() { super(); this.withOptionalProperty(\u0026#39;id\u0026#39;, TypeCode.String); this.withRequiredProperty(\u0026#39;site_id\u0026#39;, TypeCode.String); this.withOptionalProperty(\u0026#39;type\u0026#39;, TypeCode.String); this.withRequiredProperty(\u0026#39;udi\u0026#39;, TypeCode.String); this.withOptionalProperty(\u0026#39;label\u0026#39;, TypeCode.String); this.withOptionalProperty(\u0026#39;center\u0026#39;, null); this.withOptionalProperty(\u0026#39;radius\u0026#39;, TypeCode.Float); } } Let’s take a closer look at what’s going on in this class. First and foremost, we create a new class that extends the standard validation class Schema, implemented in the components module of the Pip.Services Toolkit. This class contains all of the functions that we need for checking the validity of the data we receive. All that we have to do is state which fields we are expecting, what their types should be, and whether or not any of them are required. All of this is done in the class’s constructor.\nSince everything we’ve done so far is quite simple and transparent, we’re not going to be writing any tests yet for the data model we’ve created.\nWith our data model defined, we can now move on to Step 3. Implementing persistence components.\nStep 3. Implementing persistence components. ","description":null,"image":null,"permalink":"/node/tutorials/data_microservice/step2/","subtitle":null,"tags":null,"title":"Step 2. Data model development"},{"content":"We’ll start the development of our microservice with defining and implementing the data model that it is going to be working with. We’ll start by adding some folders to our project’s directory structure. In the src folder, create a data folder and, inside it, a version1 folder. This is done to allow us to create new versions of the data model later on, without breaking the old one.\nNow, in the version1 folder, create a BeaconV1 class that implements IStringIdentifiable. By implementing the IStringIdentifiable interface, we can be sure that all objects of that given class have a string key by which they can be identified. Below is a listing of this class’s code:\n/src/data/version1/BeaconV1.py\nfrom pip_services3_commons.data import IStringIdentifiable class BeaconV1(IStringIdentifiable): def __init__(self, id: str = None, site_id: str = None, type: str = None, udi: str = None, label: str = None, center: Any = None, radius: float = None): super(BeaconV1, self).__init__() self.id = id self.site_id = site_id self.type = type self.udi = udi self.label = label self.center = center self.radius = radius All fields are of simple data types, and their names give us a good idea of their purpose. The only exception to this is the center field, in which we are going to be storing data of type GeoJSON. The beacon’s type will be represented by a string, but we’re going to have a separate class be responsible for managing the available types, using static fields. This class is going to be called BeaconTypeV1, and it’s going to simply contain a list of beacon types:\n/src/data/version1/BeaconTypeV1.py\nclass BeaconTypeV1: Unknown = \u0026#34;unknown\u0026#34; AltBeacon = \u0026#34;altbeacon\u0026#34; iBeacon = \u0026#34;ibeacons\u0026#34; EddyStoneUdi = \u0026#34;eddystone-udi\u0026#34; For checking the validity of the data we are going to be receiving, let’s create a data validation schema in a class called BeaconV1Schema:\n/src/data/version1/BeaconV1Schema.py\nfrom pip_services3_commons.convert.TypeCode import TypeCode from pip_services3_commons.validate.ObjectSchema import ObjectSchema class BeaconV1Schema(ObjectSchema): def __init__(self): super(ObjectSchema, self).__init__() self.with_optional_property(\u0026#34;id\u0026#34;, TypeCode.String) self.with_required_property(\u0026#34;site_id\u0026#34;, TypeCode.String) self.with_optional_property(\u0026#34;type\u0026#34;, TypeCode.String) self.with_required_property(\u0026#34;udi\u0026#34;, TypeCode.String) self.with_optional_property(\u0026#34;label\u0026#34;, TypeCode.String) self.with_optional_property(\u0026#34;center\u0026#34;, TypeCode.Map) self.with_optional_property(\u0026#34;radius\u0026#34;, TypeCode.Float) Let’s take a closer look at what’s going on in this class. First and foremost, we create a new class that extends the standard validation class Schema, implemented in the components module of the Pip.Services Toolkit. This class contains all of the functions that we need for checking the validity of the data we receive. All that we have to do is state which fields we are expecting, what their types should be, and whether or not any of them are required. All of this is done in the class’s constructor.\nSince everything we’ve done so far is quite simple and transparent, we’re not going to be writing any tests yet for the data model we’ve created.\nWith our data model defined, we can now move on to Step 3. Implementing persistence components.\nStep 3. Implementing persistence components. ","description":null,"image":null,"permalink":"/python/tutorials/data_microservice/step2/","subtitle":null,"tags":null,"title":"Step 2. Data model development"},{"content":"Oftentimes systems that are created using a microservices architecture end up being assembled and installed as monoliths. Sometimes this is required as a transitional step, when the operations department isn’t quite yet ready to install and support such a fragmented system. It’s also common for startups, who usually have to deal with limited financial resources, to use this approach. Packing a large amount of microservices into a monolith allows teams to significantly reduce the amount of containers needed to get the system up and running. Such a system can easily be broken up into microservices in the future, when the startup is ready to support an increasing number of clients.\nDirect clients are key to creating microservice-based monoliths. A direct client uses direct calls to the microservice’s controller from the shared address space, bypassing external interfaces in the process. On this step, we are going to create such a client. We’ll be placing our code in the src/version1 folder.\nFirst off, let\u0026rsquo;s define an interface for our clients to implement. This interface should contain a list of all the methods that are provided by our microservice’s API. As a result, we get the following code:\n/src/version1/IBeaconClientV1.cs\npublic interface IBeaconsClientV1 { Task\u0026lt;DataPage\u0026lt;BeaconV1\u0026gt;\u0026gt; GetBeaconsAsync(string correlationId, FilterParams filter, PagingParams paging); Task\u0026lt;BeaconV1\u0026gt; GetBeaconByIdAsync(string correlationId, string id); Task\u0026lt;BeaconV1\u0026gt; GetBeaconByUdiAsync(string correlationId, string udi); Task\u0026lt;CenterObjectV1\u0026gt; CalculatePositionAsync(string correlationId, string siteId, string[] udis); Task\u0026lt;BeaconV1\u0026gt; CreateBeaconAsync(string correlationId, BeaconV1 beacon); Task\u0026lt;BeaconV1\u0026gt; UpdateBeaconAsync(string correlationId, BeaconV1 beacon); Task\u0026lt;BeaconV1\u0026gt; DeleteBeaconByIdAsync(string correlationId, string id); } Let’s start writing our direct client. This will be a class that implements the interface we defined above, that has our controller set as a dependency in the controller, and that will call the controller’s methods when asked to. To learn more about the referencing and linking mechanisms, be sure to read The Referenceable Recipes. Ultimately, this will just be a wrapper class for the container. The direct client’s code is listed below:\nsrc/version1/BeaconsDirectClientV1.cs\npublic class BeaconsDirectClientV1 : DirectClient\u0026lt;IBeaconsController\u0026gt;, IBeaconsClientV1 { public BeaconsDirectClientV1() : base() { _dependencyResolver.Put(\u0026#34;controller\u0026#34;, new Descriptor(\u0026#34;beacons\u0026#34;, \u0026#34;controller\u0026#34;, \u0026#34;*\u0026#34;, \u0026#34;*\u0026#34;, \u0026#34;1.0\u0026#34;)); } public async Task\u0026lt;DataPage\u0026lt;BeaconV1\u0026gt;\u0026gt; GetBeaconsAsync( string correlationId, FilterParams filter, PagingParams paging) { var methodName = \u0026#34;beacons.get_beacons\u0026#34;; try { using (Instrument(correlationId, methodName)) { return await _controller.GetBeaconsAsync(correlationId, filter, paging); } } catch (Exception ex) { InstrumentError(correlationId, methodName, ex); throw ex; } } public async Task\u0026lt;BeaconV1\u0026gt; GetBeaconByIdAsync(string correlationId, string id) { var methodName = \u0026#34;beacons.get_beacon_by_id\u0026#34;; try { using (Instrument(correlationId, methodName)) { return await _controller.GetBeaconByIdAsync(correlationId, id); } } catch (Exception ex) { InstrumentError(correlationId, methodName, ex); throw ex; } } public async Task\u0026lt;BeaconV1\u0026gt; GetBeaconByUdiAsync(string correlationId, string udi) { var methodName = \u0026#34;beacons.get_beacon_by_udi\u0026#34;; try { using (Instrument(correlationId, methodName)) { return await _controller.GetBeaconByUdiAsync(correlationId, udi); } } catch (Exception ex) { InstrumentError(correlationId, methodName, ex); throw ex; } } public async Task\u0026lt;CenterObjectV1\u0026gt; CalculatePositionAsync(string correlationId, string siteId, string[] udis) { var methodName = \u0026#34;beacons.calculate_position\u0026#34;; try { using (Instrument(correlationId, methodName)) { return await _controller.CalculatePositionAsync(correlationId, siteId, udis); } } catch (Exception ex) { InstrumentError(correlationId, methodName, ex); throw ex; } } public async Task\u0026lt;BeaconV1\u0026gt; CreateBeaconAsync(string correlationId, BeaconV1 beacon) { var methodName = \u0026#34;beacons.create_beacon\u0026#34;; try { using (Instrument(correlationId, methodName)) { return await _controller.CreateBeaconAsync(correlationId, beacon); } } catch (Exception ex) { InstrumentError(correlationId, methodName, ex); throw ex; } } public async Task\u0026lt;BeaconV1\u0026gt; UpdateBeaconAsync(string correlationId, BeaconV1 beacon) { var methodName = \u0026#34;beacons.update_beacon\u0026#34;; try { using (Instrument(correlationId, methodName)) { return await _controller.UpdateBeaconAsync(correlationId, beacon); } } catch (Exception ex) { InstrumentError(correlationId, methodName, ex); throw ex; } } public async Task\u0026lt;BeaconV1\u0026gt; DeleteBeaconByIdAsync(string correlationId, string id) { var methodName = \u0026#34;beacons.delete_beacon_by_id\u0026#34;; try { using (Instrument(correlationId, methodName)) { return await _controller.DeleteBeaconByIdAsync(correlationId, id); } } catch (Exception ex) { InstrumentError(correlationId, methodName, ex); throw ex; } } } Now that we’re done writing the client, we should test it. To be sure that our code works as intended, we need to perform some functional testing. Let’s start with creating, in a separate class, a set of tests that will be common to all our clients. This will help us simplify the process of testing multiple clients, as well as make sure that they all work the same. We’ll place the code for our tests in the test/version1 folder. The code for this class can be found in the repository.\nNow, let’s test the direct client. To do this, create an instance of the direct client and pass it as a parameter to our set of tests. An example implementation of the tests can be found in the example’s repository\nRun the tests using the testing methods that are standard for the programming language you are using. All tests should pass successfully.This finishes the development of the Direct client. Move on to Step 3 to create the HTTP client.\nStep 3 to create the HTTP client  ","description":null,"image":null,"permalink":"/net/tutorials/client_library/step2/","subtitle":null,"tags":null,"title":"Step 2. Designing a Direct Client"},{"content":"Oftentimes systems that are created using a microservices architecture end up being assembled and installed as monoliths. Sometimes this is required as a transitional step, when the operations department isn’t quite yet ready to install and support such a fragmented system. It’s also common for startups, who usually have to deal with limited financial resources, to use this approach. Packing a large amount of microservices into a monolith allows teams to significantly reduce the amount of containers needed to get the system up and running. Such a system can easily be broken up into microservices in the future, when the startup is ready to support an increasing number of clients.\nDirect clients are key to creating microservice-based monoliths. A direct client uses direct calls to the microservice’s controller from the shared address space, bypassing external interfaces in the process. On this step, we are going to create such a client. We’ll be placing our code in the src/version1 folder.\nFirst off, let\u0026rsquo;s define an interface for our clients to implement. This interface should contain a list of all the methods that are provided by our microservice’s API. As a result, we get the following code:\n/src/version1/IBeaconClientV1.ts\nimport { FilterParams } from \u0026#39;pip-services3-commons-node\u0026#39;; import { PagingParams } from \u0026#39;pip-services3-commons-node\u0026#39;; import { DataPage } from \u0026#39;pip-services3-commons-node\u0026#39;; import { BeaconV1 } from \u0026#39;../../../src/data/version1/BeaconV1\u0026#39;; export interface IBeaconsClientV1 { getBeacons(correlationId: string, filter: FilterParams, paging: PagingParams, callback: (err: any, page: DataPage\u0026lt;BeaconV1\u0026gt;) =\u0026gt; void): void; getBeaconById(correlationId: string, beaconId: string, callback: (err: any, beacon: BeaconV1) =\u0026gt; void): void; getBeaconByUdi(correlationId: string, udi: string, callback: (err: any, beacon: BeaconV1) =\u0026gt; void): void; calculatePosition(correlationId: string, siteId: string, udis: string[], callback: (err: any, position: any) =\u0026gt; void): void; createBeacon(correlationId: string, beacon: BeaconV1, callback: (err: any, beacon: BeaconV1) =\u0026gt; void): void; updateBeacon(correlationId: string, beacon: BeaconV1, callback: (err: any, beacon: BeaconV1) =\u0026gt; void): void; deleteBeaconById(correlationId: string, beaconId: string, callback: (err: any, beacon: BeaconV1) =\u0026gt; void): void; } Let’s start writing our direct client. This will be a class that implements the interface we defined above, that has our controller set as a dependency in the controller, and that will call the controller’s methods when asked to. To learn more about the referencing and linking mechanisms, be sure to read The Referenceable Recipes. Ultimately, this will just be a wrapper class for the container. The direct client’s code is listed below:\nsrc/version1/BeaconsDirectClientV1.ts\nimport { FilterParams } from \u0026#39;pip-services3-commons-node\u0026#39;; import { PagingParams } from \u0026#39;pip-services3-commons-node\u0026#39;; import { DataPage } from \u0026#39;pip-services3-commons-node\u0026#39;; import { DirectClient } from \u0026#39;pip-services3-rpc-node\u0026#39;; import { Descriptor } from \u0026#39;pip-services3-commons-node\u0026#39;; import { BeaconV1 } from \u0026#39;./BeaconV1\u0026#39;; import { IBeaconsClientV1 } from \u0026#39;./IBeaconsClientV1\u0026#39;; import { IBeaconsController } from \u0026#39;pip-data-microservice-node\u0026#39;; export class BeaconsDirectClientV1 extends DirectClient\u0026lt;IBeaconsController\u0026gt; implements IBeaconsClientV1 { public constructor() { super(); this._dependencyResolver.put(\u0026#39;controller\u0026#39;, new Descriptor(\u0026#39;beacons\u0026#39;, \u0026#39;controller\u0026#39;, \u0026#39;*\u0026#39;, \u0026#39;*\u0026#39;, \u0026#39;1.0\u0026#39;)); } public getBeacons(correlationId: string, filter: FilterParams, paging: PagingParams, callback: (err: any, page: DataPage\u0026lt;BeaconV1\u0026gt;) =\u0026gt; void): void { let timing = this.instrument(correlationId, \u0026#39;beacons.get_beacons\u0026#39;); this._controller.getBeacons(correlationId, filter, paging, (err, page) =\u0026gt; { timing.endTiming(); callback(err, page); }); } public getBeaconById(correlationId: string, beaconId: string, callback: (err: any, beacon: BeaconV1) =\u0026gt; void): void { let timing = this.instrument(correlationId, \u0026#39;beacons.get_beacon_by_id\u0026#39;); this._controller.getBeaconById(correlationId, beaconId, (err, beacon) =\u0026gt; { timing.endTiming(); callback(err, beacon); }); } public getBeaconByUdi(correlationId: string, udi: string, callback: (err: any, beacon: BeaconV1) =\u0026gt; void): void { let timing = this.instrument(correlationId, \u0026#39;beacons.get_beacon_by_udi\u0026#39;); this._controller.getBeaconByUdi(correlationId, udi, (err, beacon) =\u0026gt; { timing.endTiming(); callback(err, beacon); }); } public calculatePosition(correlationId: string, siteId: string, udis: string[], callback: (err: any, position: any) =\u0026gt; void): void { let timing = this.instrument(correlationId, \u0026#39;beacons.calculate_position\u0026#39;); this._controller.calculatePosition(correlationId, siteId, udis, (err, position) =\u0026gt; { timing.endTiming(); callback(err, position); }); } public createBeacon(correlationId: string, beacon: BeaconV1, callback: (err: any, beacon: BeaconV1) =\u0026gt; void): void { let timing = this.instrument(correlationId, \u0026#39;beacons.create_beacon\u0026#39;); this._controller.createBeacon(correlationId, beacon, (err, beacon) =\u0026gt; { timing.endTiming(); callback(err, beacon); }); } public updateBeacon(correlationId: string, beacon: BeaconV1, callback: (err: any, beacon: BeaconV1) =\u0026gt; void): void { let timing = this.instrument(correlationId, \u0026#39;beacons.update_beacon\u0026#39;); this._controller.updateBeacon(correlationId, beacon, (err, beacon) =\u0026gt; { timing.endTiming(); callback(err, beacon); }); } public deleteBeaconById(correlationId: string, beaconId: string, callback: (err: any, beacon: BeaconV1) =\u0026gt; void): void { let timing = this.instrument(correlationId, \u0026#39;beacons.delete_beacon_by_id\u0026#39;); this._controller.deleteBeaconById(correlationId, beaconId, (err, beacon) =\u0026gt; { timing.endTiming(); callback(err, beacon); }); } } Now that we’re done writing the client, we should test it. To be sure that our code works as intended, we need to perform some functional testing. Let’s start with creating, in a separate class, a set of tests that will be common to all our clients. This will help us simplify the process of testing multiple clients, as well as make sure that they all work the same. We’ll place the code for our tests in the test/version1 folder. The code for this class can be found in the repository.\nNow, let’s test the direct client. To do this, create an instance of the direct client and pass it as a parameter to our set of tests. An example implementation of the tests can be found in the example’s repository\nRun the tests using the testing methods that are standard for the programming language you are using. All tests should pass successfully.This finishes the development of the Direct client. Move on to Step 3 to create the HTTP client.\nStep 3 to create the HTTP client  ","description":null,"image":null,"permalink":"/node/tutorials/client_library/step2/","subtitle":null,"tags":null,"title":"Step 2. Designing a Direct Client"},{"content":"Oftentimes systems that are created using a microservices architecture end up being assembled and installed as monoliths. Sometimes this is required as a transitional step, when the operations department isn’t quite yet ready to install and support such a fragmented system. It’s also common for startups, who usually have to deal with limited financial resources, to use this approach. Packing a large amount of microservices into a monolith allows teams to significantly reduce the amount of containers needed to get the system up and running. Such a system can easily be broken up into microservices in the future, when the startup is ready to support an increasing number of clients.\nDirect clients are key to creating microservice-based monoliths. A direct client uses direct calls to the microservice’s controller from the shared address space, bypassing external interfaces in the process. On this step, we are going to create such a client. We’ll be placing our code in the src/version1 folder.\nFirst off, let\u0026rsquo;s define an interface for our clients to implement. This interface should contain a list of all the methods that are provided by our microservice’s API. As a result, we get the following code:\n/src/version1/IBeaconClientV1.py\nfrom typing import Optional, List, Any from pip_services3_commons.data import PagingParams, DataPage, FilterParams from src.data.version1 import BeaconV1 class IBeaconsClientV1: def get_beacons_by_filter(self, correlation_id: Optional[str], filter: FilterParams, paging: PagingParams) -\u0026gt; DataPage: raise NotImplementedError(\u0026#39;Method from interface definition\u0026#39;) def get_beacon_by_id(self, correlation_id: Optional[str], id: str) -\u0026gt; dict: raise NotImplementedError(\u0026#39;Method from interface definition\u0026#39;) def get_beacon_by_udi(self, correlation_id: Optional[str], udi: str) -\u0026gt; dict: raise NotImplementedError(\u0026#39;Method from interface definition\u0026#39;) def calculate_position(self, correlation_id: Optional[str], site_id: str, udis: List[str]) -\u0026gt; Any: raise NotImplementedError(\u0026#39;Method from interface definition\u0026#39;) def create_beacon(self, correlation_id: Optional[str], entity: BeaconV1) -\u0026gt; dict: raise NotImplementedError(\u0026#39;Method from interface definition\u0026#39;) def update_beacon(self, correlation_id: Optional[str], entity: BeaconV1) -\u0026gt; dict: raise NotImplementedError(\u0026#39;Method from interface definition\u0026#39;) def delete_beacon_by_id(self, correlation_id: Optional[str], id: str) -\u0026gt; dict: raise NotImplementedError(\u0026#39;Method from interface definition\u0026#39;) Let’s start writing our direct client. This will be a class that implements the interface we defined above, that has our controller set as a dependency in the controller, and that will call the controller’s methods when asked to. To learn more about the referencing and linking mechanisms, be sure to read The Referenceable Recipes. Ultimately, this will just be a wrapper class for the container. The direct client’s code is listed below:\nsrc/version1/BeaconsDirectClientV1.py\nfrom typing import Optional, List, Any from pip_services3_commons.data import PagingParams, FilterParams from pip_services3_commons.refer import Descriptor from pip_services3_rpc.clients import DirectClient from .IBeaconsClientV1 import IBeaconsClientV1 from ...data.version1 import BeaconV1 class BeaconsDirectClientV1(DirectClient, IBeaconsClientV1): def __init__(self): super(BeaconsDirectClientV1, self).__init__() self._dependency_resolver.put(\u0026#39;controller\u0026#39;, Descriptor(\u0026#39;beacons\u0026#39;, \u0026#39;controller\u0026#39;, \u0026#39;*\u0026#39;, \u0026#39;*\u0026#39;, \u0026#39;1.0\u0026#39;)) def get_beacons_by_filter(self, correlation_id: Optional[str], filter: FilterParams, paging: PagingParams) -\u0026gt; dict: timing = self._instrument(correlation_id, \u0026#39;beacons.get_beacons\u0026#39;) result = self._controller.get_beacons_by_filter(correlation_id, filter, paging) timing.end_timing() return result def get_beacon_by_id(self, correlation_id: Optional[str], id: str) -\u0026gt; dict: timing = self._instrument(correlation_id, \u0026#39;beacons.get_beacon_by_id\u0026#39;) result = self._controller.get_beacon_by_id(correlation_id, id) timing.end_timing() return result def get_beacon_by_udi(self, correlation_id: Optional[str], udi: str) -\u0026gt; dict: timing = self._instrument(correlation_id, \u0026#39;beacons.get_beacon_by_udi\u0026#39;) result = self._controller.get_beacon_by_udi(correlation_id, udi) timing.end_timing() return result def calculate_position(self, correlation_id: Optional[str], site_id: str, udis: List[str]) -\u0026gt; Any: timing = self._instrument(correlation_id, \u0026#39;beacons.calculate_position\u0026#39;) result = self._controller.calculate_position(correlation_id, site_id, udis) timing.end_timing() return result def create_beacon(self, correlation_id: Optional[str], entity: BeaconV1) -\u0026gt; dict: timing = self._instrument(correlation_id, \u0026#39;beacons.create_beacon\u0026#39;) result = self._controller.create_beacon(correlation_id, entity) timing.end_timing() return result def update_beacon(self, correlation_id: Optional[str], entity: BeaconV1) -\u0026gt; dict: timing = self._instrument(correlation_id, \u0026#39;beacons.update_beacon\u0026#39;) result = self._controller.update_beacon(correlation_id, entity) timing.end_timing() return result def delete_beacon_by_id(self, correlation_id: Optional[str], id: str) -\u0026gt; dict: timing = self._instrument(correlation_id, \u0026#39;beacons.delete_beacon_by_id\u0026#39;) result = self._controller.delete_beacon_by_id(correlation_id, id) timing.end_timing() return result Now that we’re done writing the client, we should test it. To be sure that our code works as intended, we need to perform some functional testing. Let’s start with creating, in a separate class, a set of tests that will be common to all our clients. This will help us simplify the process of testing multiple clients, as well as make sure that they all work the same. We’ll place the code for our tests in the test/version1 folder. The code for this class can be found in the repository.\nNow, let’s test the direct client. To do this, create an instance of the direct client and pass it as a parameter to our set of tests. An example implementation of the tests can be found in the example’s repository\nRun the tests using the testing methods that are standard for the programming language you are using. All tests should pass successfully.This finishes the development of the Direct client. Move on to Step 3 to create the HTTP client.\nStep 3 to create the HTTP client  ","description":null,"image":null,"permalink":"/python/tutorials/client_library/step2/","subtitle":null,"tags":null,"title":"Step 2. Designing a Direct Client"},{"content":"Automated tests play a key role in achieving a guaranteed quality of microservices. Testing can be performed on various levels - unit tests for separate classes, end-to-end or integrated tests for microservices with dependencies, and tests that show how microservices work together within the actual system. In this tutorial however, we will only be looking at testing individual microservices, and system tests will not be covered.\nTo correctly perform testing, especially iterative testing, we need to correctly configure our environment with all of the necessary services and correct configuration parameters. Replicating and supporting testing configurations manually, especially across different operating systems, is far from being easy. Pretty much every development team knows that sometimes tests work perfectly locally, but break on the build server. And finding the cause of this inconsistency is usually quite time consuming.\nDockerizing automated tests provides you with a 100%-repeatable environment that can be replicated on any machine in just a number of minutes. This step of the tutorial contains specific instructions for each of the languages supported by the Pip.Services Toolkit.\nLet’s create a separate Docker container for running tests. This container’s build scenario will be defined in a file named Dockerfile.test:\n# Start with the golang v1.13 imageFROMgolang:1.13# set working directoryWORKDIR/app# Copy project fileCOPY go.mod go.sum ./# Install all go_modulesRUN go mod download# Copy the entire projectCOPY . .# Specify the command from running testsCMD go test -v ./test/...The scenario for testing is nearly identical to the one we wrote for the build process - the only difference being the last command, which will run the tests in this case.\nOftentimes, tests may require dependent microservices, databases, message brokers, and other infrastructure services. We can use a docker-compose file to start these services in separate containers and connect them to our test Docker container. We’ll be calling this file docker-compose.test.yml, and the configuration it should contain is listed below:\nversion: \u0026#39;3.3\u0026#39; ‍ services: test: build: context: .. dockerfile: docker/Dockerfile.test image: ${IMAGE:-pip/test} depends_on: - mongo environment: - MONGO_SERVICE_HOST=mongo - MONGO_SERVICE_PORT=27017 - MONGO_DB=test ‍ mongo: image: mongo:latest This configuration will start two containers: the first with the application being tested (who’s name is dynamically generated by ${IMAGE:-pip/test}), and the second with a MongoDB (mongo:latest). The test image has a number of environment variables being set to enable proper connectivity to the database from within the Docker Compose environment.\nTo automate the testing process, create a PowerShell script file named test.ps1 and populate it with the following code:\n#!/usr/bin/env pwsh Set-StrictMode -Version latest $ErrorActionPreference = \u0026#34;Stop\u0026#34; # Get component data and set necessary variables $component = Get-Content -Path \u0026#34;component.json\u0026#34; | ConvertFrom-Json $testImage=\u0026#34;$($component.registry)/$($component.name):$($component.version)-$($component.build)-test\u0026#34; # Set environment variables $env:IMAGE = $testImage try { # Workaround to remove dangling images docker-compose -f ./docker/docker-compose.test.yml down docker-compose -f ./docker/docker-compose.test.yml up --build --abort-on-container-exit --exit-code-from test } finally { # Workaround to remove dangling images  docker-compose -f ./docker/docker-compose.test.yml down } To run the script, simply type:\n./test.ps1 When run, this script will perform an automatic build of the test image and run it in the Docker Compose environment we’ve set up. While it runs, the testing process’s progress will be outputted to the console. When finished, the container will automatically be stopped, regardless of the test’s results.\nNow that we have automated testing all set up, we can move on to Step 3 to package our microservice into a Docker container, before we publish it.\nStep 3. Packaging a microservice into a container.  ","description":null,"image":null,"permalink":"/golang/tutorials/microservice_dockerization/step2/","subtitle":null,"tags":null,"title":"Step 2. Test"},{"content":"Automated tests play a key role in achieving a guaranteed quality of microservices. Testing can be performed on various levels - unit tests for separate classes, end-to-end or integrated tests for microservices with dependencies, and tests that show how microservices work together within the actual system. In this tutorial however, we will only be looking at testing individual microservices, and system tests will not be covered.\nTo correctly perform testing, especially iterative testing, we need to correctly configure our environment with all of the necessary services and correct configuration parameters. Replicating and supporting testing configurations manually, especially across different operating systems, is far from being easy. Pretty much every development team knows that sometimes tests work perfectly locally, but break on the build server. And finding the cause of this inconsistency is usually quite time consuming.\nDockerizing automated tests provides you with a 100%-repeatable environment that can be replicated on any machine in just a number of minutes. This step of the tutorial contains specific instructions for each of the languages supported by the Pip.Services Toolkit.\nLet’s create a separate Docker container for running tests. This container’s build scenario will be defined in a file named Dockerfile.test:\nFROMmcr.microsoft.com/dotnet/core/sdk:3.1# set working directoryWORKDIR/app# RestoreCOPY src/src.csproj ./src/RUN dotnet restore src/src.csprojCOPY test/test.csproj ./test/RUN dotnet restore test/test.csproj# Copy srcCOPY . .# TestCMD [ \u0026#34;dotnet\u0026#34;, \u0026#34;test\u0026#34;, \u0026#34;test/test.csproj\u0026#34; ]The scenario for testing is nearly identical to the one we wrote for the build process - the only difference being the last command, which will run the tests in this case.\nOftentimes, tests may require dependent microservices, databases, message brokers, and other infrastructure services. We can use a docker-compose file to start these services in separate containers and connect them to our test Docker container. We’ll be calling this file docker-compose.test.yml, and the configuration it should contain is listed below:\nversion: \u0026#39;3.3\u0026#39; ‍ services: test: build: context: .. dockerfile: docker/Dockerfile.test image: ${IMAGE:-pip/test} depends_on: - mongo environment: - MONGO_SERVICE_HOST=mongo - MONGO_SERVICE_PORT=27017 - MONGO_DB=test ‍ mongo: image: mongo:latest This configuration will start two containers: the first with the application being tested (who’s name is dynamically generated by ${IMAGE:-pip/test}), and the second with a MongoDB (mongo:latest). The test image has a number of environment variables being set to enable proper connectivity to the database from within the Docker Compose environment.\nTo automate the testing process, create a PowerShell script file named test.ps1 and populate it with the following code:\n#!/usr/bin/env pwsh Set-StrictMode -Version latest $ErrorActionPreference = \u0026#34;Stop\u0026#34; $component = Get-Content -Path \u0026#34;component.json\u0026#34; | ConvertFrom-Json $image=\u0026#34;$($component.registry)/$($component.name):$($component.version)-test\u0026#34; # Set environment variables $env:IMAGE = $image try { # Workaround to remove dangling images docker-compose -f ./docker/docker-compose.test.yml down docker-compose -f ./docker/docker-compose.test.yml up --build --abort-on-container-exit --exit-code-from test # Save the result to avoid overwriting it with the \u0026#34;down\u0026#34; command below $exitCode = $LastExitCode } finally { # Workaround to remove dangling images docker-compose -f ./docker/docker-compose.test.yml down } # Return the exit code of the \u0026#34;docker-compose.test.yml up\u0026#34; command exit $exitCode To run the script, simply type:\n./test.ps1 When run, this script will perform an automatic build of the test image and run it in the Docker Compose environment we’ve set up. While it runs, the testing process’s progress will be outputted to the console. When finished, the container will automatically be stopped, regardless of the test’s results.\nNow that we have automated testing all set up, we can move on to Step 3 to package our microservice into a Docker container, before we publish it.\nStep 3. Packaging a microservice into a container.  ","description":null,"image":null,"permalink":"/net/tutorials/microservice_dockerization/step2/","subtitle":null,"tags":null,"title":"Step 2. Test"},{"content":"Automated tests play a key role in achieving a guaranteed quality of microservices. Testing can be performed on various levels - unit tests for separate classes, end-to-end or integrated tests for microservices with dependencies, and tests that show how microservices work together within the actual system. In this tutorial however, we will only be looking at testing individual microservices, and system tests will not be covered.\nTo correctly perform testing, especially iterative testing, we need to correctly configure our environment with all of the necessary services and correct configuration parameters. Replicating and supporting testing configurations manually, especially across different operating systems, is far from being easy. Pretty much every development team knows that sometimes tests work perfectly locally, but break on the build server. And finding the cause of this inconsistency is usually quite time consuming.\nDockerizing automated tests provides you with a 100%-repeatable environment that can be replicated on any machine in just a number of minutes. This step of the tutorial contains specific instructions for each of the languages supported by the Pip.Services Toolkit.\nLet’s create a separate Docker container for running tests. This container’s build scenario will be defined in a file named Dockerfile.test:\nFROMnode:8# set working directoryWORKDIR/app# Copy project fileCOPY package*.json ./# install ALL node_modules, including \u0026#39;devDependencies\u0026#39;RUN npm install# copy all projectCOPY . . CMD [ \u0026#34;npm\u0026#34;, \u0026#34;test\u0026#34; ]The scenario for testing is nearly identical to the one we wrote for the build process - the only difference being the last command, which will run the tests in this case.\nOftentimes, tests may require dependent microservices, databases, message brokers, and other infrastructure services. We can use a docker-compose file to start these services in separate containers and connect them to our test Docker container. We’ll be calling this file docker-compose.test.yml, and the configuration it should contain is listed below:\nversion: \u0026#39;3.3\u0026#39; ‍ services: test: build: context: .. dockerfile: docker/Dockerfile.test image: ${IMAGE:-pip/test} depends_on: - mongo environment: - MONGO_SERVICE_HOST=mongo - MONGO_SERVICE_PORT=27017 - MONGO_DB=test ‍ mongo: image: mongo:latest This configuration will start two containers: the first with the application being tested (who’s name is dynamically generated by ${IMAGE:-pip/test}), and the second with a MongoDB (mongo:latest). The test image has a number of environment variables being set to enable proper connectivity to the database from within the Docker Compose environment.\nTo automate the testing process, create a PowerShell script file named test.ps1 and populate it with the following code:\n#!/usr/bin/env pwsh Set-StrictMode -Version latest $ErrorActionPreference = \u0026#34;Stop\u0026#34; # Get component data and set necessary variables $component = Get-Content -Path \u0026#34;component.json\u0026#34; | ConvertFrom-Json $testImage=\u0026#34;$($component.registry)/$($component.name):$($component.version)-$($component.build)-test\u0026#34; # Set environment variables $env:IMAGE = $testImage try { # Workaround to remove dangling images docker-compose -f ./docker/docker-compose.test.yml down docker-compose -f ./docker/docker-compose.test.yml up --build --abort-on-container-exit --exit-code-from test } finally { # Workaround to remove dangling images  docker-compose -f ./docker/docker-compose.test.yml down } To run the script, simply type:\n./test.ps1 When run, this script will perform an automatic build of the test image and run it in the Docker Compose environment we’ve set up. While it runs, the testing process’s progress will be outputted to the console. When finished, the container will automatically be stopped, regardless of the test’s results.\nNow that we have automated testing all set up, we can move on to Step 3 to package our microservice into a Docker container, before we publish it.\nStep 3. Packaging a microservice into a container.  ","description":null,"image":null,"permalink":"/node/tutorials/microservice_dockerization/step2/","subtitle":null,"tags":null,"title":"Step 2. Test"},{"content":"Automated tests play a key role in achieving a guaranteed quality of microservices. Testing can be performed on various levels - unit tests for separate classes, end-to-end or integrated tests for microservices with dependencies, and tests that show how microservices work together within the actual system. In this tutorial however, we will only be looking at testing individual microservices, and system tests will not be covered.\nTo correctly perform testing, especially iterative testing, we need to correctly configure our environment with all of the necessary services and correct configuration parameters. Replicating and supporting testing configurations manually, especially across different operating systems, is far from being easy. Pretty much every development team knows that sometimes tests work perfectly locally, but break on the build server. And finding the cause of this inconsistency is usually quite time consuming.\nDockerizing automated tests provides you with a 100%-repeatable environment that can be replicated on any machine in just a number of minutes. This step of the tutorial contains specific instructions for each of the languages supported by the Pip.Services Toolkit.\nLet’s create a separate Docker container for running tests. This container’s build scenario will be defined in a file named Dockerfile.test:\nFROMpython:3# set working directoryWORKDIR/usr/src/app# copy project fileCOPY requirements.txt .# install dependenciesRUN pip install -r requirements.txt# copy all projectCOPY . .# run testCMD [ \u0026#34;python\u0026#34;, \u0026#34;./test.py\u0026#34; ]The scenario for testing is nearly identical to the one we wrote for the build process - the only difference being the last command, which will run the tests in this case.\nOftentimes, tests may require dependent microservices, databases, message brokers, and other infrastructure services. We can use a docker-compose file to start these services in separate containers and connect them to our test Docker container. We’ll be calling this file docker-compose.test.yml, and the configuration it should contain is listed below:\nversion: \u0026#39;3.3\u0026#39; ‍ services: test: build: context: .. dockerfile: docker/Dockerfile.test image: ${IMAGE:-pip/test} depends_on: - mongo environment: - MONGO_SERVICE_HOST=mongo - MONGO_SERVICE_PORT=27017 - MONGO_DB=test ‍ mongo: image: mongo:latest This configuration will start two containers: the first with the application being tested (who’s name is dynamically generated by ${IMAGE:-pip/test}), and the second with a MongoDB (mongo:latest). The test image has a number of environment variables being set to enable proper connectivity to the database from within the Docker Compose environment.\nTo automate the testing process, create a PowerShell script file named test.ps1 and populate it with the following code:\n#!/usr/bin/env pwsh Set-StrictMode -Version latest $ErrorActionPreference = \u0026#34;Stop\u0026#34; # Get component data and set necessary variables $component = Get-Content -Path \u0026#34;component.json\u0026#34; | ConvertFrom-Json $testImage=\u0026#34;$($component.registry)/$($component.name):$($component.version)-$($component.build)-test\u0026#34; # Set environment variables $env:IMAGE = $testImage try { # Workaround to remove dangling images docker-compose -f ./docker/docker-compose.test.yml down docker-compose -f ./docker/docker-compose.test.yml up --build --abort-on-container-exit --exit-code-from test } finally { # Workaround to remove dangling images  docker-compose -f ./docker/docker-compose.test.yml down } To run the script, simply type:\n./test.ps1 When run, this script will perform an automatic build of the test image and run it in the Docker Compose environment we’ve set up. While it runs, the testing process’s progress will be outputted to the console. When finished, the container will automatically be stopped, regardless of the test’s results.\nNow that we have automated testing all set up, we can move on to Step 3 to package our microservice into a Docker container, before we publish it.\nStep 3. Packaging a microservice into a container.  ","description":null,"image":null,"permalink":"/python/tutorials/microservice_dockerization/step2/","subtitle":null,"tags":null,"title":"Step 2. Test"},{"content":"In most cases, access to an application’s (service’s) resources is granted only after users authenticate themselves in the system. Authentication is the process of checking the validity of the identifier provided by a user. A successful authentication (besides establishing a trusted relationship and generating a session key) is usually also followed up by user authorization. This second step grants the user access rights to an approved set of resources, deemed necessary for the user to perform his/her tasks.\nJust like in the previous step, we’ll be placing the files of this step in the operation/version1 folder.\nLet’s start by defining a data model for storing user information within a session. Create a new file named SessionUserV1.py with the following code:\nsrc/operations/version1/SessionUserV1.py\nexport class SessionUserV1 { /* Identification */ public id: string; public login: string; public name: string; public create_time: Date; /* User information */ public time_zone: string; public language: string; public theme: string; /* Security info **/ public roles: string[]; public change_pwd_time: Date; public sites: { id: string, name: string }; public settings: any; /* Custom fields */ public custom_hdr: any; public custom_dat: any; } This data model will contain all necessary information about the user: the session’s ID, login, username, list of rolls, etc.\nWe’ll be defining our operations for managing sessions and authenticating users in a file named SessionOperationsV1.py. A listing of this file’s code is presented below:\nsrc/operations/version1/SessionOperationsV1.py\nlet _ = require(\u0026#39;lodash\u0026#39;); let async = require(\u0026#39;async\u0026#39;); import { ConfigParams } from \u0026#39;pip-services3-commons-node\u0026#39;; import { FilterParams } from \u0026#39;pip-services3-commons-node\u0026#39;; import { IReferences } from \u0026#39;pip-services3-commons-node\u0026#39;; import { Descriptor } from \u0026#39;pip-services3-commons-node\u0026#39;; import { BadRequestException } from \u0026#39;pip-services3-commons-node\u0026#39;; import { UnauthorizedException } from \u0026#39;pip-services3-commons-node\u0026#39;; import { HttpRequestDetector } from \u0026#39;pip-services3-rpc-node\u0026#39;; import { RestOperations } from \u0026#39;pip-services3-rpc-node\u0026#39;; import { ISettingsClientV1 } from \u0026#39;../../clients/version1/ISettingsClientV1\u0026#39;; import { IAccountsClientV1 } from \u0026#39;../../clients/version1/IAccountsClientV1\u0026#39;; import { AccountV1 } from \u0026#39;../../clients/version1/AccountV1\u0026#39;; import { IPasswordsClientV1 } from \u0026#39;../../clients/version1/IPasswordsClientV1\u0026#39;; import { UserPasswordInfoV1 } from \u0026#39;../../clients/version1/UserPasswordInfoV1\u0026#39;; import { IRolesClientV1 } from \u0026#39;../../clients/version1/IRolesClientV1\u0026#39;; import { ISessionsClientV1 } from \u0026#39;../../clients/version1/ISessionsClientV1\u0026#39;; import { SessionV1 } from \u0026#39;../../clients/version1/SessionV1\u0026#39;; import { IEmailSettingsClientV1 } from \u0026#39;../../clients/version1/IEmailSettingsClientV1\u0026#39;; import { EmailSettingsV1 } from \u0026#39;../../clients/version1/EmailSettingsV1\u0026#39;; import { ISitesClientV1 } from \u0026#39;../../clients/version1/ISitesClientV1\u0026#39;; import { IInvitationsClientV1 } from \u0026#39;../../clients/version1/IInvitationsClientV1\u0026#39;; import { SiteV1 } from \u0026#39;../../clients/version1/SiteV1\u0026#39;; import { SessionUserV1 } from \u0026#39;./SessionUserV1\u0026#39;; export class SessionsOperationsV1 extends RestOperations { private static _defaultConfig1 = ConfigParams.fromTuples( \u0026#39;options.cookie_enabled\u0026#39;, true, \u0026#39;options.cookie\u0026#39;, \u0026#39;x-session-id\u0026#39;, \u0026#39;options.max_cookie_age\u0026#39;, 365 * 24 * 60 * 60 * 1000 ); private _cookie: string = \u0026#39;x-session-id\u0026#39;; private _cookieEnabled: boolean = true; private _maxCookieAge: number = 365 * 24 * 60 * 60 * 1000; private _settingsClient: ISettingsClientV1; private _accountsClient: IAccountsClientV1; private _sessionsClient: ISessionsClientV1; private _passwordsClient: IPasswordsClientV1; private _rolesClient: IRolesClientV1; private _emailSettingsClient: IEmailSettingsClientV1; private _sitesClient: ISitesClientV1; private _invitationsClient: IInvitationsClientV1; public constructor() { super(); this._dependencyResolver.put(\u0026#39;settings\u0026#39;, new Descriptor(\u0026#39;pip-services-settings\u0026#39;, \u0026#39;client\u0026#39;, \u0026#39;*\u0026#39;, \u0026#39;*\u0026#39;, \u0026#39;1.0\u0026#39;)); this._dependencyResolver.put(\u0026#39;accounts\u0026#39;, new Descriptor(\u0026#39;pip-services-accounts\u0026#39;, \u0026#39;client\u0026#39;, \u0026#39;*\u0026#39;, \u0026#39;*\u0026#39;, \u0026#39;1.0\u0026#39;)); this._dependencyResolver.put(\u0026#39;passwords\u0026#39;, new Descriptor(\u0026#39;pip-services-passwords\u0026#39;, \u0026#39;client\u0026#39;, \u0026#39;*\u0026#39;, \u0026#39;*\u0026#39;, \u0026#39;1.0\u0026#39;)); this._dependencyResolver.put(\u0026#39;roles\u0026#39;, new Descriptor(\u0026#39;pip-services-roles\u0026#39;, \u0026#39;client\u0026#39;, \u0026#39;*\u0026#39;, \u0026#39;*\u0026#39;, \u0026#39;1.0\u0026#39;)); this._dependencyResolver.put(\u0026#39;emailsettings\u0026#39;, new Descriptor(\u0026#39;pip-services-emailsettings\u0026#39;, \u0026#39;client\u0026#39;, \u0026#39;*\u0026#39;, \u0026#39;*\u0026#39;, \u0026#39;1.0\u0026#39;)); this._dependencyResolver.put(\u0026#39;sessions\u0026#39;, new Descriptor(\u0026#39;pip-services-sessions\u0026#39;, \u0026#39;client\u0026#39;, \u0026#39;*\u0026#39;, \u0026#39;*\u0026#39;, \u0026#39;1.0\u0026#39;)); this._dependencyResolver.put(\u0026#39;sites\u0026#39;, new Descriptor(\u0026#39;nov-services-sites\u0026#39;, \u0026#39;client\u0026#39;, \u0026#39;*\u0026#39;, \u0026#39;*\u0026#39;, \u0026#39;1.0\u0026#39;)); this._dependencyResolver.put(\u0026#39;invitations\u0026#39;, new Descriptor(\u0026#39;nov-services-invitations\u0026#39;, \u0026#39;client\u0026#39;, \u0026#39;*\u0026#39;, \u0026#39;*\u0026#39;, \u0026#39;1.0\u0026#39;)); } public configure(config: ConfigParams): void { config = config.setDefaults(SessionsOperationsV1._defaultConfig1); this._dependencyResolver.configure(config); this._cookieEnabled = config.getAsBooleanWithDefault(\u0026#39;options.cookie_enabled\u0026#39;, this._cookieEnabled); this._cookie = config.getAsStringWithDefault(\u0026#39;options.cookie\u0026#39;, this._cookie); this._maxCookieAge = config.getAsLongWithDefault(\u0026#39;options.max_cookie_age\u0026#39;, this._maxCookieAge); } public setReferences(references: IReferences): void { super.setReferences(references); this._settingsClient = this._dependencyResolver.getOneRequired\u0026lt;ISettingsClientV1\u0026gt;(\u0026#39;settings\u0026#39;); this._sessionsClient = this._dependencyResolver.getOneRequired\u0026lt;ISessionsClientV1\u0026gt;(\u0026#39;sessions\u0026#39;); this._accountsClient = this._dependencyResolver.getOneRequired\u0026lt;IAccountsClientV1\u0026gt;(\u0026#39;accounts\u0026#39;); this._passwordsClient = this._dependencyResolver.getOneRequired\u0026lt;IPasswordsClientV1\u0026gt;(\u0026#39;passwords\u0026#39;); this._rolesClient = this._dependencyResolver.getOneRequired\u0026lt;IRolesClientV1\u0026gt;(\u0026#39;roles\u0026#39;); this._emailSettingsClient = this._dependencyResolver.getOneOptional\u0026lt;IEmailSettingsClientV1\u0026gt;(\u0026#39;emailsettings\u0026#39;); this._sitesClient = this._dependencyResolver.getOneRequired\u0026lt;ISitesClientV1\u0026gt;(\u0026#39;sites\u0026#39;); this._invitationsClient = this._dependencyResolver.getOneRequired\u0026lt;IInvitationsClientV1\u0026gt;(\u0026#39;invitations\u0026#39;); } public loadSession(req: any, res: any, next: () =\u0026gt; void): void { // Is user really cached? If yes, then we shall reinvalidate cache when connections are changed  // if (req.user) {  // callback(null, req.user);  // return;  // }  // parse headers first, and if nothing in headers get cookie  let sessionId = req.headers[\u0026#39;x-session-id\u0026#39;];// || req.cookies[this._cookie];  if (sessionId) { this._sessionsClient.getSessionById(\u0026#39;facade\u0026#39;, sessionId, (err, session) =\u0026gt; { if (session == null \u0026amp;\u0026amp; err == null) { err = new UnauthorizedException( \u0026#39;facade\u0026#39;, \u0026#39;SESSION_NOT_FOUND\u0026#39;, \u0026#39;Session invalid or already expired.\u0026#39; ).withDetails(\u0026#39;session_id\u0026#39;, sessionId).withStatus(440); } if (err == null) { // Associate session user with the request  req.user_id = session.user_id; req.user_name = session.user_name; req.user = session.user; req.session_id = session.id; next(); } else { this.sendError(req, res, err); } }); } else { next(); } } public openSession(req: any, res: any, account: AccountV1, roles: string[]): void { let session: SessionV1; let sites: SiteV1[]; let passwordInfo: UserPasswordInfoV1; let settings: ConfigParams; async.series([ // Retrieve sites for user  (callback) =\u0026gt; { let siteRoles = _.filter(roles, r =\u0026gt; r.indexOf(\u0026#39;:\u0026#39;) \u0026gt; 0); let siteIds = _.map(siteRoles, (r) =\u0026gt; { let pos = r.indexOf(\u0026#39;:\u0026#39;); return pos \u0026gt;= 0 ? r.substring(0, pos) : r; }); if (siteIds.length \u0026gt; 0) { let filter = FilterParams.fromTuples(\u0026#39;ids\u0026#39;, siteIds); this._sitesClient.getSites(null, filter, null, (err, page) =\u0026gt; { sites = page != null ? page.data : []; callback(err); }); } else { sites = []; callback(); } }, (callback) =\u0026gt; { this._passwordsClient.getPasswordInfo( null, account.id, (err, data) =\u0026gt; { passwordInfo = data; callback(err); } ) }, (callback) =\u0026gt; { this._settingsClient.getSectionById( null, account.id, (err, data) =\u0026gt; { settings = data; callback(err); } ); }, // Open a new user session  (callback) =\u0026gt; { let user = \u0026lt;SessionUserV1\u0026gt;{ id: account.id, name: account.name, login: account.login, create_time: account.create_time, time_zone: account.time_zone, language: account.language, theme: account.theme, roles: roles, sites: _.map(sites, s =\u0026gt; { return { id: s.id, name: s.name } }), settings: settings, change_pwd_time: passwordInfo != null ? passwordInfo.change_time : null, custom_hdr: account.custom_hdr, custom_dat: account.custom_dat }; let address = HttpRequestDetector.detectAddress(req); let client = HttpRequestDetector.detectBrowser(req); let platform = HttpRequestDetector.detectPlatform(req); this._sessionsClient.openSession( null, account.id, account.name, address, client, user, null, (err, data) =\u0026gt; { session = data; callback(err); } ); }, ], (err) =\u0026gt; { if (err) this.sendError(req, res, err); else { res.json(session); } }); } public signup(req: any, res: any): void { let signupData = req.body; let account: AccountV1 = null; let invited: boolean = false; let roles: string[] = []; async.series([ // Validate password first  (callback) =\u0026gt; { callback(); }, // Create account  (callback) =\u0026gt; { let newAccount = \u0026lt;AccountV1\u0026gt;{ name: signupData.name, login: signupData.login || signupData.email, // Use email by default  language: signupData.language, theme: signupData.theme, time_zone: signupData.time_zone }; this._accountsClient.createAccount( null, newAccount, (err, data) =\u0026gt; { account = data; callback(err); } ) }, // Create password for the account  (callback) =\u0026gt; { let password = signupData.password; this._passwordsClient.setPassword( null, account.id, password, callback ); }, // Activate all pending invitations  (callback) =\u0026gt; { let email = signupData.email; this._invitationsClient.activateInvitations( null, email, account.id, (err, invitations) =\u0026gt; { if (invitations) { // Calculate user roles from activated invitations  for (let invitation of invitations) { // Was user invited with the same email?  invited = invited || email == invitation.invitee_email; if (invitation.site_id) { invitation.role = invitation.role || \u0026#39;user\u0026#39;; let role = invitation.site_id + \u0026#39;:\u0026#39; + invitation.role; roles.push(role); } } } callback(err); } ); }, // Create email settings for the account  (callback) =\u0026gt; { let email = signupData.email; let newEmailSettings = \u0026lt;EmailSettingsV1\u0026gt; { id: account.id, name: account.name, email: email, language: account.language }; if (this._emailSettingsClient != null) { if (invited) { this._emailSettingsClient.setVerifiedSettings( null, newEmailSettings, callback ); } else { this._emailSettingsClient.setSettings( null, newEmailSettings, callback ); } } else callback(); } ], (err) =\u0026gt; { if (err) this.sendError(req, res, err); else this.openSession(req, res, account, roles); }); } public signupValidate(req: any, res: any): void { let login = req.param(\u0026#39;login\u0026#39;); if (login) { this._accountsClient.getAccountByIdOrLogin( null, login, (err, account) =\u0026gt; { if (err == null \u0026amp;\u0026amp; account != null) { err = new BadRequestException( null, \u0026#39;LOGIN_ALREADY_USED\u0026#39;, \u0026#39;Login \u0026#39; + login + \u0026#39; already being used\u0026#39; ).withDetails(\u0026#39;login\u0026#39;, login); } if (err) this.sendError(req, res, err); else res.json(204); } ); } else { res.json(204); } } public signin(req: any, res: any): void { let login = req.param(\u0026#39;login\u0026#39;); let password = req.param(\u0026#39;password\u0026#39;); let account: AccountV1; let roles: string[] = []; async.series([ // Find user account  (callback) =\u0026gt; { this._accountsClient.getAccountByIdOrLogin(null, login, (err, data) =\u0026gt; { if (err == null \u0026amp;\u0026amp; data == null) { err = new BadRequestException( null, \u0026#39;WRONG_LOGIN\u0026#39;, \u0026#39;Account \u0026#39; + login + \u0026#39; was not found\u0026#39; ).withDetails(\u0026#39;login\u0026#39;, login); } account = data; callback(err); }); }, // Authenticate user  (callback) =\u0026gt; { this._passwordsClient.authenticate(null, account.id, password, (err, result) =\u0026gt; { // wrong password error is UNKNOWN when use http client  if ( (err == null \u0026amp;\u0026amp; result == false) || (err \u0026amp;\u0026amp; err.cause == \u0026#39;Invalid password\u0026#39;) ) { err = new BadRequestException( null, \u0026#39;WRONG_PASSWORD\u0026#39;, \u0026#39;Wrong password for account \u0026#39; + login ).withDetails(\u0026#39;login\u0026#39;, login); } callback(err); }); }, // Retrieve user roles  (callback) =\u0026gt; { if (this._rolesClient) { this._rolesClient.getRolesById(null, account.id, (err, data) =\u0026gt; { roles = data; callback(err); }); } else { roles = []; callback(); } } ], (err) =\u0026gt; { if (err) this.sendError(req, res, err); else this.openSession(req, res, account, roles); }); } public signout(req: any, res: any): void { // Cleanup cookie with session id  // if (this._cookieEnabled)  // res.clearCookie(this._cookie);  if (req.session_id) { this._sessionsClient.closeSession(null, req.session_id, (err, session) =\u0026gt; { if (err) this.sendError(req, res, err); else res.json(204); }); } else { res.json(204); } } public getSessions(req: any, res: any): void { let filter = this.getFilterParams(req); let paging = this.getPagingParams(req); this._sessionsClient.getSessions( null, filter, paging, this.sendResult(req, res) ); } public restoreSession(req: any, res: any): void { let sessionId = req.param(\u0026#39;session_id\u0026#39;); this._sessionsClient.getSessionById( null, sessionId, (err, session) =\u0026gt; { // If session closed then return null  if (session \u0026amp;\u0026amp; !session.active) session = null; if (err) this.sendError(req, res, err); else if (session) res.json(session); else res.json(204); } ); } public getUserSessions(req: any, res: any): void { let filter = this.getFilterParams(req); let paging = this.getPagingParams(req); let userId = req.params.user_id || req.params.account_id; filter.setAsObject(\u0026#39;user_id\u0026#39;, userId); this._sessionsClient.getSessions( null, filter, paging, this.sendResult(req, res) ); } public getCurrentSession(req: any, res: any): void { // parse headers first, and if nothing in headers get cookie  let sessionId = req.headers[\u0026#39;x-session-id\u0026#39;]; // || req.cookies[this._cookie];  this._sessionsClient.getSessionById( null, sessionId, this.sendResult(req, res) ); } public closeSession(req: any, res: any): void { let sessionId = req.params.session_id || req.param(\u0026#39;session_id\u0026#39;); this._sessionsClient.closeSession( null, sessionId, this.sendResult(req, res) ); } } This class contains the main operations for managing sessions, which allow us to load existing sessions, create new sessions, close existing sessions, and also authenticate users. This class depends on four microservices - Accounts, Passwords, Roles, and Sessions - each of which is responsible for a certain part of the class’s logic.\nThe signup and signin methods perform registration of new users and authentication of existing ones, respectively. Upon successful registration or authorization, the handlers of these operations open a new session as the finishing step of these methods.\nThe signout method closes sessions when users leave the system, or automatically when the session expires.\nThe loadSession interceptor checks a session’s validity, and whether or not it even exists. The interceptor checks the request’s header for a session ID and, if one is found, uses it to retrieve data about the session from the Sessions microservice. If the session is expired or incorrect, an error will be returned. If everything’s all right, information about the user and the session are extracted and attached to the request, and a “green light” is given for further processing.\nTo perform these operations, our microservice needs to be able to interact with the microservices it depends on. This communication is made simple using standard clients, the links to which are set in the setReferences method.\nThe authorization mechanism will be responsible for limiting access to resources, depending on the roles a user has been assigned. This part’s implementation will be discussed in Step 4 - Authorization.\nStep 4. Authorization  ","description":null,"image":null,"permalink":"/node/tutorials/microservice_facade/step3/","subtitle":null,"tags":null,"title":"Step 3. Authentication and sessions"},{"content":"In most cases, access to an application’s (service’s) resources is granted only after users authenticate themselves in the system. Authentication is the process of checking the validity of the identifier provided by a user. A successful authentication (besides establishing a trusted relationship and generating a session key) is usually also followed up by user authorization. This second step grants the user access rights to an approved set of resources, deemed necessary for the user to perform his/her tasks.\nJust like in the previous step, we’ll be placing the files of this step in the operation/version1 folder.\nLet’s start by defining a data model for storing user information within a session. Create a new file named SessionUserV1.py with the following code:\npip_facades_sample_python/operations/version1/SessionUserV1.py\n# -*- coding: utf-8 -*- import datetime from typing import List, Any class SessionUserV1: def __init__(self, id: str = None, login: str = None, name: str = None, create_time: str = None, time_zone: str = None, language: str = None, theme: str = None, roles: List[str] = None, change_pwd_time: datetime.datetime = None, sites: List[dict] = None, settings: Any = None, custom_hdr: Any = None, custom_dat: Any = None): # Identification self.id = id self.login = login self.name = name self.create_time = create_time # User information self.time_zone = time_zone self.language = language self.theme = theme # Security info self.roles = roles self.change_pwd_time = change_pwd_time self.sites = sites self.settings = settings # Custom fields self.custom_hdr = custom_hdr self.custom_dat = custom_dat This data model will contain all necessary information about the user: the session’s ID, login, username, list of rolls, etc.\nWe’ll be defining our operations for managing sessions and authenticating users in a file named SessionOperationsV1.py. A listing of this file’s code is presented below:\npip_facades_sample_python/operations/version1/SessionOperationsV1.py\n# -*- coding: utf-8 -*- from typing import List import bottle from pip_services3_commons.convert import JsonConverter, TypeCode from pip_services3_commons.data import DataPage from pip_services3_commons.refer import Descriptor, IReferences from pip_services3_rpc.services import RestOperations from pip_facades_sample_python.clients.version1.IRolesClientV1 import IRolesClientV1 from pip_facades_sample_python.clients.version1.ISessionsClientV1 import ISessionsClientV1 from pip_facades_sample_python.clients.version1.ISitesClientV1 import ISitesClientV1 from pip_facades_sample_python.clients.version1.SiteV1 import SiteV1 class SitesOperationsV1(RestOperations): def __init__(self): super().__init__() self.__roles_client: IRolesClientV1 = None self.__sessions_client: ISessionsClientV1 = None self.__sites_client: ISitesClientV1 = None self._dependency_resolver.put(\u0026#39;roles\u0026#39;, Descriptor(\u0026#39;pip-services-roles\u0026#39;, \u0026#39;client\u0026#39;, \u0026#39;*\u0026#39;, \u0026#39;*\u0026#39;, \u0026#39;1.0\u0026#39;)) self._dependency_resolver.put(\u0026#39;sessions\u0026#39;, Descriptor(\u0026#39;pip-services-sessions\u0026#39;, \u0026#39;client\u0026#39;, \u0026#39;*\u0026#39;, \u0026#39;*\u0026#39;, \u0026#39;1.0\u0026#39;)) self._dependency_resolver.put(\u0026#39;sites\u0026#39;, Descriptor(\u0026#39;nov-services-sites\u0026#39;, \u0026#39;client\u0026#39;, \u0026#39;*\u0026#39;, \u0026#39;*\u0026#39;, \u0026#39;1.0\u0026#39;)) def set_references(self, references: IReferences): super().set_references(references) self.__roles_client = self._dependency_resolver.get_one_required(\u0026#39;roles\u0026#39;) self.__sessions_client = self._dependency_resolver.get_one_required(\u0026#39;sessions\u0026#39;) self.__sites_client = self._dependency_resolver.get_one_required(\u0026#39;sites\u0026#39;) def get_sites(self): filter_params = self._get_filter_params() paging = self._get_paging_params() result = self.__sites_client.get_sites(None, filter_params, paging) return self._send_result(result) def get_authorized_sites(self): filter_params = self._get_filter_params() paging = self._get_paging_params() roles: List[str] = [] if not bottle.request.user else bottle.request.user.roles or [] site_ids: List[str] = [] # Get authorized site ids for role in roles: tokens = role.split(\u0026#39;:\u0026#39;) if len(tokens) == 2: site_ids.append(tokens[0]) # Consider ids parameter old_site_ids = filter_params.get(\u0026#39;ids\u0026#39;) if old_site_ids: site_ids = list(set(old_site_ids).intersection(set(site_ids))) # Is user has no sites then exit if len(site_ids) == 0: return self._send_result(DataPage([])) filter_params.set_as_object(\u0026#39;ids\u0026#39;, site_ids) result = self.__sites_client.get_sites(None, filter_params, paging) return self._send_result(result) def get_site(self, site_id): site = self.__sites_client.get_site_by_id(None, site_id) return self._send_result(site) def find_site_by_code(self): code = dict(bottle.request.query.decode()).get(\u0026#39;code\u0026#39;) site = self.__sites_client.get_site_by_code(None, code) return self._send_result(site) def generate_code(self, site_id): code = self.__sites_client.generate_code(None, site_id) return self._send_result(code) def create_site(self): try: data = bottle.request.json if isinstance(bottle.request.json, dict) else JsonConverter.from_json(TypeCode.Map, bottle.request.json) site: SiteV1 = SiteV1(**data) # Create a site site = self.__sites_client.create_site(None, site) # Assign permissions to the owner if self.__roles_client is not None and hasattr(bottle.request, \u0026#39;user\u0026#39;) and bottle.request.user.id is not None: self.__roles_client.grant_roles(None, bottle.request.user.id, [site.id + \u0026#39;:admin\u0026#39;]) # Update current user session if hasattr(bottle.request, \u0026#39;user\u0026#39;) and hasattr(bottle.request, \u0026#39;session_id\u0026#39;): user = bottle.request.user user.roles = user.roles or [] user.roles.append(site.id + \u0026#39;:admin\u0026#39;) user.sites = user.sites or [] user.sites.append(site) self.__sessions_client.update_session_user(None, bottle.request.session_id, user) return self._send_result(site) except Exception as err: return self._send_error(err) def update_site(self, site_id): try: data = bottle.request.json if isinstance(bottle.request.json, dict) else JsonConverter.from_json(TypeCode.Map, bottle.request.json) data[\u0026#39;id\u0026#39;] = site_id site: SiteV1 = SiteV1(**data) # Update site site = self.__sites_client.update_site(None, site) # Update current user session if hasattr(bottle.request, \u0026#39;user\u0026#39;) is not None and hasattr(bottle.request, \u0026#39;session_id\u0026#39;) is not None: user = bottle.request.user user.sites = user.sites or [] user.sites = list(filter(lambda x: x.id == site.id, user.sites)) user.sites.append(site) self.__sessions_client.update_session_user(None, bottle.request.session_id, user) return self._send_result(site) except Exception as err: self._send_error(err) def delete_site(self, site_id): site = self.__sites_client.delete_site_by_id(None, site_id) return self._send_deleted_result(site) def remove_site(self, site_id): try: # Assign permissions to the owner if self.__roles_client is not None and hasattr(bottle.request, \u0026#39;user\u0026#39;) and bottle.request.user.id is not None: self.__roles_client.revoke_roles( None, bottle.request.user.id, [ site_id + \u0026#39;:admin\u0026#39;, site_id + \u0026#39;:manager\u0026#39;, site_id + \u0026#39;:user\u0026#39; ] ) # Update current user session if bottle.request.user is not None and bottle.request.session_id is not None: user = bottle.request.user user.roles = user.roles or [] user.roles = list(filter(lambda x: x != site_id + \u0026#39;:admin\u0026#39;, user.roles)) user.roles = list(filter(lambda x: x != site_id + \u0026#39;:manager\u0026#39;, user.roles)) user.roles = list(filter(lambda x: x != site_id + \u0026#39;:user\u0026#39;, user.roles)) user.sites = user.sites or [] user.sites = list(filter(lambda x: x.id != site_id, user.sites)) self.__sessions_client.update_session_user(None, bottle.request.session_id, user) return self._send_empty_result() except Exception as err: return self._send_error(err) def validate_site_code(self): code = dict(bottle.request.query.decode()).get(\u0026#39;code\u0026#39;) site = self.__sites_client.get_site_by_code(None, code) if site: return self._send_result(site.id) return self._send_result() This class contains the main operations for managing sessions, which allow us to load existing sessions, create new sessions, close existing sessions, and also authenticate users. This class depends on four microservices - Accounts, Passwords, Roles, and Sessions - each of which is responsible for a certain part of the class’s logic.\nThe signup and signin methods perform registration of new users and authentication of existing ones, respectively. Upon successful registration or authorization, the handlers of these operations open a new session as the finishing step of these methods.\nThe signout method closes sessions when users leave the system, or automatically when the session expires.\nThe load_session interceptor checks a session’s validity, and whether or not it even exists. The interceptor checks the request’s header for a session ID and, if one is found, uses it to retrieve data about the session from the Sessions microservice. If the session is expired or incorrect, an error will be returned. If everything’s all right, information about the user and the session are extracted and attached to the request, and a “green light” is given for further processing.\nTo perform these operations, our microservice needs to be able to interact with the microservices it depends on. This communication is made simple using standard clients, the links to which are set in the setReferences method.\nThe authorization mechanism will be responsible for limiting access to resources, depending on the roles a user has been assigned. This part’s implementation will be discussed in Step 4 - Authorization.\nStep 4. Authorization  ","description":null,"image":null,"permalink":"/python/tutorials/microservice_facade/step3/","subtitle":null,"tags":null,"title":"Step 3. Authentication and sessions"},{"content":"The standard way of communicating with a microservice is via the HTTP protocol. It allows calling microservices that work on a separate server, or in their own container. Our example microservice uses a simplified version of the HTTP protocol that is automatically generated using the Commandable pattern.\nThen, creates a new class for the Commandable REST client and an implementation for each of the microservice’s methods. This is done by calling the REST API’s methods using the methods of the parent Commandable REST client, passing the necessary set of parameters, and then processing the response’s result. Since the answer from the client is returned as JSON, some programming languages will require that you first convert it to an instance with a specific type. Be sure to remember this when writing your HTTP clients.\nThe client’s resulting code is listed below:\n/src/version1/BeaconsHttpClientV1.cs\npublic class BeaconsHttpClientV1 : RestClient, IBeaconsClientV1 { public BeaconsHttpClientV1(object config = null) { _baseRoute = \u0026#34;v1/beacons\u0026#34;; if (config != null) Configure(ConfigParams.FromValue(config)); } public async Task\u0026lt;CenterObjectV1\u0026gt; CalculatePositionAsync(string correlationId, string siteId, string[] udis) { var methodName = \u0026#34;beacons.calculate_position\u0026#34;; try { using (Instrument(correlationId, methodName)) { return await ExecuteAsync\u0026lt;CenterObjectV1\u0026gt;(correlationId, HttpMethod.Post, \u0026#34;/calculate_position\u0026#34;, new { site_id = siteId, udis = udis }); } } catch (Exception ex) { InstrumentError(correlationId, methodName, ex); throw ex; } } public async Task\u0026lt;BeaconV1\u0026gt; CreateBeaconAsync(string correlationId, BeaconV1 beacon) { var methodName = \u0026#34;beacons.create_beacon\u0026#34;; try { using (Instrument(correlationId, methodName)) { return await ExecuteAsync\u0026lt;BeaconV1\u0026gt;(correlationId, HttpMethod.Post, \u0026#34;\u0026#34;, new { beacon = beacon }); } } catch (Exception ex) { InstrumentError(correlationId, methodName, ex); throw ex; } } public async Task\u0026lt;BeaconV1\u0026gt; UpdateBeaconAsync(string correlationId, BeaconV1 beacon) { var methodName = \u0026#34;beacons.update_beacon\u0026#34;; try { using (Instrument(correlationId, methodName)) { return await ExecuteAsync\u0026lt;BeaconV1\u0026gt;(correlationId, HttpMethod.Put, \u0026#34;\u0026#34;, new { beacon = beacon }); } } catch (Exception ex) { InstrumentError(correlationId, methodName, ex); throw ex; } } public async Task\u0026lt;BeaconV1\u0026gt; DeleteBeaconByIdAsync(string correlationId, string id) { var methodName = \u0026#34;beacons.delete_beacon_by_id\u0026#34;; try { using (Instrument(correlationId, methodName)) { return await ExecuteAsync\u0026lt;BeaconV1\u0026gt;(correlationId, HttpMethod.Delete, $\u0026#34;/{id}\u0026#34;, new { }); } } catch (Exception ex) { InstrumentError(correlationId, methodName, ex); throw ex; } } public async Task\u0026lt;BeaconV1\u0026gt; GetBeaconByIdAsync(string correlationId, string id) { var methodName = \u0026#34;beacons.get_beacon_by_id\u0026#34;; try { using (Instrument(correlationId, methodName)) { return await ExecuteAsync\u0026lt;BeaconV1\u0026gt;(correlationId, HttpMethod.Get, $\u0026#34;/{id}\u0026#34;, new { }); } } catch (Exception ex) { InstrumentError(correlationId, methodName, ex); throw ex; } } public async Task\u0026lt;BeaconV1\u0026gt; GetBeaconByUdiAsync(string correlationId, string udi) { var methodName = \u0026#34;beacons.get_beacon_by_udi\u0026#34;; try { using (Instrument(correlationId, methodName)) { return await ExecuteAsync\u0026lt;BeaconV1\u0026gt;(correlationId, HttpMethod.Get, $\u0026#34;/udi/{udi}\u0026#34;, new { }); } } catch (Exception ex) { InstrumentError(correlationId, methodName, ex); throw ex; } } public async Task\u0026lt;DataPage\u0026lt;BeaconV1\u0026gt;\u0026gt; GetBeaconsAsync(string correlationId, FilterParams filter, PagingParams paging) { var methodName = \u0026#34;beacons.get_beacons\u0026#34;; try { using (Instrument(correlationId, methodName)) { return await ExecuteAsync\u0026lt;DataPage\u0026lt;BeaconV1\u0026gt;\u0026gt;(correlationId, HttpMethod.Get, \u0026#34;/\u0026#34;, new { filter, paging }); } } catch (Exception ex) { InstrumentError(correlationId, methodName, ex); throw ex; } } } To be sure that our code works as intended, we should perform some functional testing. Test the Commandable HTTP REST client using the class with tests that we developed in the previous step. To do this, create an instance of the HTTP REST client and pass it as a parameter to our set of tests. An example implementation of the tests can be found in the example’s repository\nAll tests should pass successfully.This finishes the development of our clients. As a result, we ended up with 2 clients: one for working from within a monolithic application, and another for working with the microservice from a different application, when utilizing a distributed architecture.\nTo simulate the service, let\u0026rsquo;s create a test client in Step 4. Implementing Test Memory Client.\nStep 4. Implementing Test Memory Client.  ","description":null,"image":null,"permalink":"/net/tutorials/client_library/step3/","subtitle":null,"tags":null,"title":"Step 3. Designing an HTTP Client"},{"content":"The standard way of communicating with a microservice is via the HTTP protocol. It allows calling microservices that work on a separate server, or in their own container. Our example microservice uses a simplified version of the HTTP protocol that is automatically generated using the Commandable pattern. Then, creates a new class for the Commandable REST client and an implementation for each of the microservice’s methods. This is done by calling the REST API’s methods using the methods of the parent Commandable REST client, passing the necessary set of parameters, and then processing the response’s result. Since the answer from the client is returned as JSON, some programming languages will require that you first convert it to an instance with a specific type. Be sure to remember this when writing your HTTP clients.\nThe client’s resulting code is listed below:\n/src/version1/BeaconsHttpClientV1.ts\nimport { FilterParams } from \u0026#39;pip-services3-commons-node\u0026#39;; import { PagingParams } from \u0026#39;pip-services3-commons-node\u0026#39;; import { DataPage } from \u0026#39;pip-services3-commons-node\u0026#39;; import { CommandableHttpClient } from \u0026#39;pip-services3-rpc-node\u0026#39;; import { BeaconV1 } from \u0026#39;./BeaconV1\u0026#39;; import { IBeaconsClientV1 } from \u0026#39;./IBeaconsClientV1\u0026#39;; export class BeaconsHttpClientV1 extends CommandableHttpClient implements IBeaconsClientV1 { public constructor() { super(\u0026#39;v1/beacons\u0026#39;); } public getBeacons(correlationId: string, filter: FilterParams, paging: PagingParams, callback: (err: any, page: DataPage\u0026lt;BeaconV1\u0026gt;) =\u0026gt; void): void { this.callCommand( \u0026#39;get_beacons\u0026#39;, correlationId, { filter: filter, paging: paging }, callback ); } public getBeaconById(correlationId: string, beaconId: string, callback: (err: any, beacon: BeaconV1) =\u0026gt; void): void { this.callCommand( \u0026#39;get_beacon_by_id\u0026#39;, correlationId, { beacon_id: beaconId }, callback ); } public getBeaconByUdi(correlationId: string, udi: string, callback: (err: any, beacon: BeaconV1) =\u0026gt; void): void { this.callCommand( \u0026#39;get_beacon_by_udi\u0026#39;, correlationId, { udi: udi }, callback ); } public calculatePosition(correlationId: string, siteId: string, udis: string[], callback: (err: any, position: any) =\u0026gt; void): void { this.callCommand( \u0026#39;calculate_position\u0026#39;, correlationId, { site_id: siteId, udis: udis }, callback ); } public createBeacon(correlationId: string, beacon: BeaconV1, callback: (err: any, beacon: BeaconV1) =\u0026gt; void): void { this.callCommand( \u0026#39;create_beacon\u0026#39;, correlationId, { beacon: beacon }, callback ); } public updateBeacon(correlationId: string, beacon: BeaconV1, callback: (err: any, beacon: BeaconV1) =\u0026gt; void): void { this.callCommand( \u0026#39;update_beacon\u0026#39;, correlationId, { beacon: beacon }, callback ); } public deleteBeaconById(correlationId: string, beaconId: string, callback: (err: any, beacon: BeaconV1) =\u0026gt; void): void { this.callCommand( \u0026#39;delete_beacon_by_id\u0026#39;, correlationId, { beacon_id: beaconId }, callback ); } } To be sure that our code works as intended, we should perform some functional testing. Test the Commandable HTTP REST client using the class with tests that we developed in the previous step. To do this, create an instance of the HTTP REST client and pass it as a parameter to our set of tests. An example implementation of the tests can be found in the example’s repository\nAll tests should pass successfully.This finishes the development of our clients. As a result, we ended up with 2 clients: one for working from within a monolithic application, and another for working with the microservice from a different application, when utilizing a distributed architecture.\nTo simulate the service, let\u0026rsquo;s create a test client in Step 4. Implementing Test Memory Client.\nStep 4. Implementing Test Memory Client.  ","description":null,"image":null,"permalink":"/node/tutorials/client_library/step3/","subtitle":null,"tags":null,"title":"Step 3. Designing an HTTP Client"},{"content":"The standard way of communicating with a microservice is via the HTTP protocol. It allows calling microservices that work on a separate server, or in their own container. Our example microservice uses a simplified version of the HTTP protocol that is automatically generated using the Commandable pattern.\nThen, creates a new class for the Commandable REST client and an implementation for each of the microservice’s methods. This is done by calling the REST API’s methods using the methods of the parent Commandable REST client, passing the necessary set of parameters, and then processing the response’s result. Since the answer from the client is returned as JSON, some programming languages will require that you first convert it to an instance with a specific type. Be sure to remember this when writing your HTTP clients.\nThe client’s resulting code is listed below:\n/src/version1/BeaconsHttpClientV1.py\nfrom typing import Optional, List, Any from pip_services3_commons.data import DataPage, FilterParams, PagingParams from pip_services3_rpc.clients import CommandableHttpClient from .IBeaconsClientV1 import IBeaconsClientV1 from ...data.version1 import BeaconV1 class BeaconsHttpClientV1(CommandableHttpClient, IBeaconsClientV1): def __init__(self): super(BeaconsHttpClientV1, self).__init__(\u0026#34;v1/beacons\u0026#34;) def get_beacons_by_filter(self, correlation_id: Optional[str], filter: FilterParams, paging: PagingParams) -\u0026gt; DataPage: result = self.call_command( \u0026#39;get_beacons\u0026#39;, correlation_id, { \u0026#39;filter\u0026#39;: filter, \u0026#39;paging\u0026#39;: paging } ) return DataPage(result[\u0026#39;data\u0026#39;], result[\u0026#39;total\u0026#39;]) def get_beacon_by_id(self, correlation_id: Optional[str], id: str) -\u0026gt; dict: return self.call_command( \u0026#39;get_beacon_by_id\u0026#39;, correlation_id, { \u0026#39;id\u0026#39;: id } ) def get_beacon_by_udi(self, correlation_id: Optional[str], udi: str) -\u0026gt; dict: return self.call_command( \u0026#39;get_beacon_by_udi\u0026#39;, correlation_id, { \u0026#39;udi\u0026#39;: udi } ) def calculate_position(self, correlation_id: Optional[str], site_id: str, udis: List[str]) -\u0026gt; Any: return self.call_command( \u0026#39;calculate_position\u0026#39;, correlation_id, { \u0026#39;site_id\u0026#39;: site_id, \u0026#39;udis\u0026#39;: udis } ) def create_beacon(self, correlation_id: Optional[str], entity: BeaconV1) -\u0026gt; dict: return self.call_command( \u0026#39;create_beacon\u0026#39;, correlation_id, { \u0026#39;beacon\u0026#39;: entity } ) def update_beacon(self, correlation_id: Optional[str], entity: BeaconV1) -\u0026gt; dict: return self.call_command( \u0026#39;update_beacon\u0026#39;, correlation_id, { \u0026#39;beacon\u0026#39;: entity } ) def delete_beacon_by_id(self, correlation_id: Optional[str], id: str) -\u0026gt; dict: return self.call_command( \u0026#39;delete_beacon_by_id\u0026#39;, correlation_id, { \u0026#39;id\u0026#39;: id } ) To be sure that our code works as intended, we should perform some functional testing. Test the Commandable HTTP REST client using the class with tests that we developed in the previous step. To do this, create an instance of the HTTP REST client and pass it as a parameter to our set of tests. An example implementation of the tests can be found in the example’s repository\nAll tests should pass successfully.This finishes the development of our clients. As a result, we ended up with 2 clients: one for working from within a monolithic application, and another for working with the microservice from a different application, when utilizing a distributed architecture.\nTo simulate the service, let\u0026rsquo;s create a test client in Step 4. Implementing Test Memory Client.\nStep 4. Implementing Test Memory Client.  ","description":null,"image":null,"permalink":"/python/tutorials/client_library/step3/","subtitle":null,"tags":null,"title":"Step 3. Designing an HTTP Client"},{"content":"Once a microservice has successfully passed the previous “build” and “test” stages, it is ready to be published and tested as a part of the system. But before we can do this, we need to correctly package it into a Docker container.\nWhen creating containers, we follow the “Build once - run everywhere” principle. What this means is that the container is created just once. After being created, this container goes through the stages of system testing in various environments and eventually gets deployed into production - all without any modifications.\nFurthermore, a flexibly configurable container can easily be included in various systems, even those that use a wide array of system services, databases, and communication protocols. This is achieved by building and configuring microservices out of loosely coupled components using the container’s configuration. Environment variables are often used for configuration and have great support in Docker. To do this, developers need to envisage all possible configuration combinations, include the required components into the container, open up ports, and then perform configuration via environment variables.\nWe’ll be creating a separate container for packaging our microservice and defining its build instructions in a file named Dockerfile:\n#FROM docker.pkg.github.com/nov-pocs/max-devops/go-runtime:latestFROMscratch# Set a working directoryWORKDIR/app# Copy the entire projectCOPY ./dist ./binCOPY ./config ./config# Set environment variablesENV HTTP_PORT=8080 ENV GRPC_SERVICE_PORT=8090 ENV POSTGRES_SERVICE_HOST=ENV POSTGRES_SERVICE_PORT=27017 ENV POSTGRES_USER=ENV POSTGRES_PASS=ENV POSTGRES_DB=app # Expose the portEXPOSE\u0026#34;8080:8080\u0026#34;EXPOSE\u0026#34;8090:8090\u0026#34;# Specify the command to runCMD [\u0026#34;./bin/main\u0026#34;]Once again, this script is pretty similar to the ones we’ve already written. What’s new in this script is the indication of which file needs to be used to start the application, as well as what port we need to expose to make the service available from outside the container (EXPOSE \u0026ldquo;8080:8080\u0026rdquo;).\nWe checked that our microservice is functional in the previous “testing” step, but this doesn’t guarantee that the container that the microservice is running in will work as needed. To check this, we can create a special Docker Compose environment. Place the following code into a file named docker-compose.yml:\nversion: \u0026#39;3.3\u0026#39; services: app: image: ${IMAGE} ports: - \u0026#34;8080:8080\u0026#34; depends_on: - mongo environment: - HTTP_PORT=8080 - MONGO_ENABLED=true - MONGO_SERVICE_HOST=mongo - MONGO_SERVICE_PORT=27017 mongo: image: mongo:latest To automate this process, create a package.ps1 script with the following content:\n#!/usr/bin/env pwsh Set-StrictMode -Version latest $ErrorActionPreference = \u0026#34;Stop\u0026#34; # Generate image names using the data in the \u0026#34;component.json\u0026#34; file $component = Get-Content -Path \u0026#34;component.json\u0026#34; | ConvertFrom-Json $rcImage=\u0026#34;$($component.registry)/$($component.name):$($component.version)-$($component.build)-rc\u0026#34; $latestImage=\u0026#34;$($component.registry)/$($component.name):latest\u0026#34; # Build docker image docker build -f docker/Dockerfile -t $rcImage -t $latestImage . # Set environment variables $env:IMAGE = $rcImage # Set docker machine ip (on windows not localhost) if ($env:DOCKER_IP -ne $null) { $dockerMachineIp = $env:DOCKER_IP } else { $dockerMachineIp = \u0026#34;localhost\u0026#34; } try { # Workaround to remove dangling images docker-compose -f ./docker/docker-compose.yml down docker-compose -f ./docker/docker-compose.yml up -d # Give the service time to start and then check that it\u0026#39;s responding to requests Start-Sleep -Seconds 20 Invoke-WebRequest -Uri \u0026#34;http://$($dockerMachineIp):8080/heartbeat\u0026#34; Invoke-WebRequest -Uri \u0026#34;http://$($dockerMachineIp):8080/$($component.test_route)\u0026#34; -Method Post Write-Host \u0026#34;The container was successfully built.\u0026#34; } finally { docker-compose -f ./docker/docker-compose.yml down } This script performs an automatic build of the Docker image and then runs and checks it from within the Docker Compose environment. The Docker Compose environment allows us to run our microservice alongside its dependencies, while keeping them all in separate containers. The script then runs the microservice and, if all is well, the service can be checked by requesting the http://localhost:8080/heartbeat URL from a browser. This URL returns and displays the current time in the JSON format, which indicates that the application is up and running in the container. All build results will be outputted to the console. Once the container tests are done, the containers are stopped.\nThis finishes the process of preparing a microservice container for publishing. When you’re ready, continue on to Step 4 to publish the image to a Docker registry.\nStep 4. Publishing a microservice container to a registry.  ","description":null,"image":null,"permalink":"/golang/tutorials/microservice_dockerization/step3/","subtitle":null,"tags":null,"title":"Step 3. Package"},{"content":"Once a microservice has successfully passed the previous “build” and “test” stages, it is ready to be published and tested as a part of the system. But before we can do this, we need to correctly package it into a Docker container.\nWhen creating containers, we follow the “Build once - run everywhere” principle. What this means is that the container is created just once. After being created, this container goes through the stages of system testing in various environments and eventually gets deployed into production - all without any modifications.\nFurthermore, a flexibly configurable container can easily be included in various systems, even those that use a wide array of system services, databases, and communication protocols. This is achieved by building and configuring microservices out of loosely coupled components using the container’s configuration. Environment variables are often used for configuration and have great support in Docker. To do this, developers need to envisage all possible configuration combinations, include the required components into the container, open up ports, and then perform configuration via environment variables.\nWe’ll be creating a separate container for packaging our microservice and defining its build instructions in a file named Dockerfile:\nFROMmcr.microsoft.com/dotnet/core/runtime:3.1# Set working directoryWORKDIR/app# Copy compiled binariesCOPY ./obj ./bin# Copy configurationCOPY config/*.* ./config/ENV MONGO_SERVICE_URI \u0026#34;\u0026#34;ENV MONGO_SERVICE_HOST mongoENV MONGO_SERVICE_PORT 27017ENV MONGO_DB appENV MONGO_USER \u0026#34;\u0026#34;ENV MONGO_PASS \u0026#34;\u0026#34;ENV HTTP_PORT 8080ENV GRPC_PORT 8090EXPOSE8080EXPOSE8090CMD [\u0026#34;dotnet\u0026#34;, \u0026#34;./bin/main.dll\u0026#34;, \u0026#34;-c\u0026#34;, \u0026#34;./config/config.yml\u0026#34;]Once again, this script is pretty similar to the ones we’ve already written. What’s new in this script is the indication of which file needs to be used to start the application, as well as what port we need to expose to make the service available from outside the container (EXPOSE \u0026ldquo;8080:8080\u0026rdquo;).\nWe checked that our microservice is functional in the previous “testing” step, but this doesn’t guarantee that the container that the microservice is running in will work as needed. To check this, we can create a special Docker Compose environment. Place the following code into a file named docker-compose.yml:\nversion: \u0026#39;3.3\u0026#39; services: app: image: ${IMAGE} ports: - \u0026#34;8080:8080\u0026#34; depends_on: - mongo environment: - HTTP_PORT=8080 - MONGO_ENABLED=true - MONGO_SERVICE_HOST=mongo - MONGO_SERVICE_PORT=27017 mongo: image: mongo:latest To automate this process, create a package.ps1 script with the following content:\n#!/usr/bin/env pwsh ##Set-StrictMode -Version latest $ErrorActionPreference = \u0026#34;Stop\u0026#34; $component = Get-Content -Path \u0026#34;component.json\u0026#34; | ConvertFrom-Json $rcImage=\u0026#34;$($component.registry)/$($component.name):$($component.version)-$($component.build)-rc\u0026#34; $latestImage=\u0026#34;$($component.registry)/$($component.name):latest\u0026#34; # Build docker image docker build -f docker/Dockerfile -t $rcImage -t $latestImage . # Set environment variables $env:IMAGE = $rcImage # Set docker host address if ($env:DOCKER_IP -ne $null) { $dockerMachineIp = $env:DOCKER_IP } else { $dockerMachineIp = \u0026#34;localhost\u0026#34; } try { # Workaround to remove dangling images docker-compose -f ./docker/docker-compose.yml down docker-compose -f ./docker/docker-compose.yml up -d # Test using curl Start-Sleep -Seconds 10 Invoke-WebRequest -Uri http://$($dockerMachineIp):8080/heartbeat Invoke-WebRequest -Uri http://$($dockerMachineIp):8080/v1/beacons/get_beacons -Method Post Write-Host \u0026#34;The container was successfully built.\u0026#34; } finally { # Workaround to remove dangling images docker-compose -f ./docker/docker-compose.yml down } This script performs an automatic build of the Docker image and then runs and checks it from within the Docker Compose environment. The Docker Compose environment allows us to run our microservice alongside its dependencies, while keeping them all in separate containers. The script then runs the microservice and, if all is well, the service can be checked by requesting the http://localhost:8080/heartbeat URL from a browser. This URL returns and displays the current time in the JSON format, which indicates that the application is up and running in the container. All build results will be outputted to the console. Once the container tests are done, the containers are stopped.\nThis finishes the process of preparing a microservice container for publishing. When you’re ready, continue on to Step 4 to publish the image to a Docker registry.\nStep 4. Publishing a microservice container to a registry.  ","description":null,"image":null,"permalink":"/net/tutorials/microservice_dockerization/step3/","subtitle":null,"tags":null,"title":"Step 3. Package"},{"content":"Once a microservice has successfully passed the previous “build” and “test” stages, it is ready to be published and tested as a part of the system. But before we can do this, we need to correctly package it into a Docker container.\nWhen creating containers, we follow the “Build once - run everywhere” principle. What this means is that the container is created just once. After being created, this container goes through the stages of system testing in various environments and eventually gets deployed into production - all without any modifications.\nFurthermore, a flexibly configurable container can easily be included in various systems, even those that use a wide array of system services, databases, and communication protocols. This is achieved by building and configuring microservices out of loosely coupled components using the container’s configuration. Environment variables are often used for configuration and have great support in Docker. To do this, developers need to envisage all possible configuration combinations, include the required components into the container, open up ports, and then perform configuration via environment variables.\nWe’ll be creating a separate container for packaging our microservice and defining its build instructions in a file named Dockerfile:\nFROMnode:8# set working directoryWORKDIR/app# Copy project fileCOPY package*.json ./# install ALL node_modules, including \u0026#39;devDependencies\u0026#39;RUN npm install# copy all projectCOPY . . ENV HTTP_PORT=8080 ENV MONGO_SERVICE_HOST=ENV MONGO_SERVICE_PORT=27017 EXPOSE\u0026#34;8080:8080\u0026#34;CMD [ \u0026#34;node\u0026#34;, \u0026#34;bin/run.js\u0026#34; ]Once again, this script is pretty similar to the ones we’ve already written. What’s new in this script is the indication of which file needs to be used to start the application, as well as what port we need to expose to make the service available from outside the container (EXPOSE \u0026ldquo;8080:8080\u0026rdquo;).\nWe checked that our microservice is functional in the previous “testing” step, but this doesn’t guarantee that the container that the microservice is running in will work as needed. To check this, we can create a special Docker Compose environment. Place the following code into a file named docker-compose.yml:\nversion: \u0026#39;3.3\u0026#39; services: app: image: ${IMAGE} ports: - \u0026#34;8080:8080\u0026#34; depends_on: - mongo environment: - HTTP_PORT=8080 - MONGO_ENABLED=true - MONGO_SERVICE_HOST=mongo - MONGO_SERVICE_PORT=27017 mongo: image: mongo:latest To automate this process, create a package.ps1 script with the following content:\n#!/usr/bin/env pwsh ‍ Set-StrictMode -Version latest $ErrorActionPreference = \u0026#34;Stop\u0026#34; $component = Get-Content -Path \u0026#34;component.json\u0026#34; | ConvertFrom-Json $image=\u0026#34;$($component.registry)/$($component.name):$($component.version)-$($component.build)-rc\u0026#34; $latestImage=\u0026#34;$($component.registry)/$($component.name):latest\u0026#34; # Build docker image docker build -f docker/Dockerfile -t $image -t $latestImage . # Set environment variables $env:IMAGE = $image try { # Workaround to remove dangling images docker-compose -f ./docker/docker-compose.yml down docker-compose -f ./docker/docker-compose.yml up -d Start-Sleep -Seconds 15 Invoke-WebRequest -Uri http://localhost:8080/heartbeat Write-Host \u0026#34;The container was successfully built.\u0026#34; # Save the result to avoid overwriting it with the \u0026#34;down\u0026#34; command below $exitCode = $LastExitCode } finally { docker-compose -f ./docker/docker-compose.yml down } # Return the exit code of the \u0026#34;docker-compose.yml up\u0026#34; command exit $exitCode This script performs an automatic build of the Docker image and then runs and checks it from within the Docker Compose environment. The Docker Compose environment allows us to run our microservice alongside its dependencies, while keeping them all in separate containers. The script then runs the microservice and, if all is well, the service can be checked by requesting the http://localhost:8080/heartbeat URL from a browser. This URL returns and displays the current time in the JSON format, which indicates that the application is up and running in the container. All build results will be outputted to the console. Once the container tests are done, the containers are stopped.\nThis finishes the process of preparing a microservice container for publishing. When you’re ready, continue on to Step 4 to publish the image to a Docker registry.\nStep 4. Publishing a microservice container to a registry.  ","description":null,"image":null,"permalink":"/node/tutorials/microservice_dockerization/step3/","subtitle":null,"tags":null,"title":"Step 3. Package"},{"content":"Once a microservice has successfully passed the previous “build” and “test” stages, it is ready to be published and tested as a part of the system. But before we can do this, we need to correctly package it into a Docker container.\nWhen creating containers, we follow the “Build once - run everywhere” principle. What this means is that the container is created just once. After being created, this container goes through the stages of system testing in various environments and eventually gets deployed into production - all without any modifications.\nFurthermore, a flexibly configurable container can easily be included in various systems, even those that use a wide array of system services, databases, and communication protocols. This is achieved by building and configuring microservices out of loosely coupled components using the container’s configuration. Environment variables are often used for configuration and have great support in Docker. To do this, developers need to envisage all possible configuration combinations, include the required components into the container, open up ports, and then perform configuration via environment variables.\nWe’ll be creating a separate container for packaging our microservice and defining its build instructions in a file named Dockerfile:\nFROMpython:3# set working directoryWORKDIR/usr/src/app# copy project fileCOPY requirements.txt .# install dependenciesRUN pip install -r requirements.txt# copy all projectCOPY . .ENV HTTP_PORT=8080 ENV MONGO_SERVICE_HOST=mongo ENV MONGO_SERVICE_PORT=27017 EXPOSE\u0026#34;8080:8080\u0026#34;# run CMD [ \u0026#34;python\u0026#34;, \u0026#34;./bin/run.py\u0026#34; ]Once again, this script is pretty similar to the ones we’ve already written. What’s new in this script is the indication of which file needs to be used to start the application, as well as what port we need to expose to make the service available from outside the container (EXPOSE \u0026ldquo;8080:8080\u0026rdquo;).\nWe checked that our microservice is functional in the previous “testing” step, but this doesn’t guarantee that the container that the microservice is running in will work as needed. To check this, we can create a special Docker Compose environment. Place the following code into a file named docker-compose.yml:\nversion: \u0026#39;3.3\u0026#39; services: app: image: ${IMAGE} ports: - \u0026#34;8080:8080\u0026#34; depends_on: - mongo environment: - HTTP_PORT=8080 - MONGO_ENABLED=true - MONGO_SERVICE_HOST=mongo - MONGO_SERVICE_PORT=27017 mongo: image: mongo:latest To automate this process, create a package.ps1 script with the following content:\n#!/usr/bin/env pwsh ‍ Set-StrictMode -Version latest $ErrorActionPreference = \u0026#34;Stop\u0026#34; $component = Get-Content -Path \u0026#34;component.json\u0026#34; | ConvertFrom-Json $image=\u0026#34;$($component.registry)/$($component.name):$($component.version)-$($component.build)-rc\u0026#34; $latestImage=\u0026#34;$($component.registry)/$($component.name):latest\u0026#34; # Build docker image docker build -f docker/Dockerfile -t $image -t $latestImage . # Set environment variables $env:IMAGE = $image try { # Workaround to remove dangling images docker-compose -f ./docker/docker-compose.yml down docker-compose -f ./docker/docker-compose.yml up -d Start-Sleep -Seconds 15 Invoke-WebRequest -Uri http://localhost:8080/heartbeat Write-Host \u0026#34;The container was successfully built.\u0026#34; # Save the result to avoid overwriting it with the \u0026#34;down\u0026#34; command below $exitCode = $LastExitCode } finally { docker-compose -f ./docker/docker-compose.yml down } # Return the exit code of the \u0026#34;docker-compose.yml up\u0026#34; command exit $exitCode This script performs an automatic build of the Docker image and then runs and checks it from within the Docker Compose environment. The Docker Compose environment allows us to run our microservice alongside its dependencies, while keeping them all in separate containers. The script then runs the microservice and, if all is well, the service can be checked by requesting the http://localhost:8080/heartbeat URL from a browser. This URL returns and displays the current time in the JSON format, which indicates that the application is up and running in the container. All build results will be outputted to the console. Once the container tests are done, the containers are stopped.\nThis finishes the process of preparing a microservice container for publishing. When you’re ready, continue on to Step 4 to publish the image to a Docker registry.\nStep 4. Publishing a microservice container to a registry.  ","description":null,"image":null,"permalink":"/python/tutorials/microservice_dockerization/step3/","subtitle":null,"tags":null,"title":"Step 3. Package"},{"content":"In this step, we’ll be creating components for persisting the data model we defined in the previous step. In our projects, we always create at least two persistences: one for storing data in-memory (used for testing), and another for storing data in an external database (used in production). With the Beacons example, we’ll be doing the same.\nLet’s start by navigating to the src/service directory and creating a persistence directory inside it. This directory is going to contain all of the files that relate to this step of the tutorial.\nThe first thing we are going to do is define what functionality our persistent storage should have. We can define these in a form of an interface and name it IBeaconsPersistence\nsrc/interface/persistence/IBeaconsPersistence.cs\nnamespace Beacons.Persistence { public interface IBeaconsPersistence { Task\u0026lt;DataPage\u0026lt;BeaconV1\u0026gt;\u0026gt; GetPageByFilterAsync(string correlationId, FilterParams filter, PagingParams paging); Task\u0026lt;BeaconV1\u0026gt; GetOneByIdAsync(string correlationId, string id); Task\u0026lt;BeaconV1\u0026gt; GetOneByUdiAsync(string correlationId, string udi); Task\u0026lt;BeaconV1\u0026gt; CreateAsync(string correlationId, BeaconV1 item); Task\u0026lt;BeaconV1\u0026gt; UpdateAsync(string correlationId, BeaconV1 item); Task\u0026lt;BeaconV1\u0026gt; DeleteByIdAsync(string correlationId, string id); } } The first persistence to implement this interface will be the memory persistence, which we will name BeaconsMemoryPersistence. This class will need to extend the IdentifiableMemoryPersistence class from the pip-services3-data module, and have a few additional functions added to it. One of these functions will be used to create filters for the GetPageByFilterAsync method that we’re going to override from the parent class. This function will be called compose_filter, as it’s going to allow us to filter data in accordance with the received filtering parameters. The overriding GetPageByFilterAsync method then simply calls the parent’s method, passing the compose_filter function as a filter parameter. The second function that we will need to implement is the GetOneByUdiAsync method, whose purpose will be to retrieve a beacon by its udi.\nThe resulting code for this class is listed below:\nsrc/interface/persistence/BeaconsMemoryPersistence.cs\nnamespace Beacons.Persistence { public class BeaconsMemoryPersistence : IdentifiableMemoryPersistence\u0026lt;BeaconV1, string\u0026gt;, IBeaconsPersistence { public BeaconsMemoryPersistence() { _maxPageSize = 1000; } private List\u0026lt;Func\u0026lt;BeaconV1, bool\u0026gt;\u0026gt; ComposeFilter(FilterParams filter) { filter = filter ?? new FilterParams(); var id = filter.GetAsNullableString(\u0026#34;id\u0026#34;); var siteId = filter.GetAsNullableString(\u0026#34;site_id\u0026#34;); var label = filter.GetAsNullableString(\u0026#34;label\u0026#34;); var udi = filter.GetAsNullableString(\u0026#34;udi\u0026#34;); var udis = filter.GetAsNullableString(\u0026#34;udis\u0026#34;); var udiList = udis != null ? udis.Split(\u0026#39;,\u0026#39;) : null; return new List\u0026lt;Func\u0026lt;BeaconV1, bool\u0026gt;\u0026gt;() { (item) =\u0026gt; { if (id != null \u0026amp;\u0026amp; item.Id != id) return false; if (siteId != null \u0026amp;\u0026amp; item.SiteId != siteId) return false; if (label != null \u0026amp;\u0026amp; item.Label != label) return false; if (udi != null \u0026amp;\u0026amp; item.Udi != udi) return false; if (udiList != null \u0026amp;\u0026amp; !udiList.Contains(item.Udi)) return false; return true; } }; } public Task\u0026lt;DataPage\u0026lt;BeaconV1\u0026gt;\u0026gt; GetPageByFilterAsync(string correlationId, FilterParams filter, PagingParams paging) { return base.GetPageByFilterAsync(correlationId, ComposeFilter(filter), paging); } public async Task\u0026lt;BeaconV1\u0026gt; GetOneByUdiAsync(string correlationId, string udi) { BeaconV1 item = null; lock (_lock) { item = _items.Find((beacon) =\u0026gt; { return beacon.Udi == udi; }); } if (item != null) _logger.Trace(correlationId, \u0026#34;Found beacon by {0}\u0026#34;, udi); else _logger.Trace(correlationId, \u0026#34;Cannot find beacon by {0}\u0026#34;, udi); return await Task.FromResult(item); } } } And that’s pretty much it for the memory persistence.\nNow let’s move on to something a bit more sophisticated - a MongoDB persistence. Here we’re also going to use an already existing base class, IdentifiableMongoDbPersistence, from the pip-services3-mongodb module, and write a few functions, the most important of which will be compose_filter. This time around, its implementation is going to contain syntax for creating database requests. The resulting code for this class is listed below:\nsrc/interface/persistence/BeaconsMongoDbPersistence.cs\nnamespace Beacons.Persistence { public class BeaconsMongoDbPersistence : IdentifiableMongoDbPersistence\u0026lt;BeaconV1, string\u0026gt;, IBeaconsPersistence { public BeaconsMongoDbPersistence() : base(\u0026#34;beacons\u0026#34;) { } private new FilterDefinition\u0026lt;BeaconV1\u0026gt; ComposeFilter(FilterParams filterParams) { filterParams = filterParams ?? new FilterParams(); var builder = Builders\u0026lt;BeaconV1\u0026gt;.Filter; var filter = builder.Empty; var id = filterParams.GetAsNullableString(\u0026#34;id\u0026#34;); if (!string.IsNullOrEmpty(id)) filter \u0026amp;= builder.Eq(b =\u0026gt; b.Id, id); var siteId = filterParams.GetAsNullableString(\u0026#34;site_id\u0026#34;); if (!string.IsNullOrEmpty(siteId)) filter \u0026amp;= builder.Eq(b =\u0026gt; b.SiteId, siteId); var label = filterParams.GetAsNullableString(\u0026#34;label\u0026#34;); if (!string.IsNullOrEmpty(label)) filter \u0026amp;= builder.Eq(b =\u0026gt; b.Label, label); var udi = filterParams.GetAsNullableString(\u0026#34;udi\u0026#34;); if (!string.IsNullOrEmpty(udi)) filter \u0026amp;= builder.Eq(b =\u0026gt; b.Udi, udi); var udis = filterParams.GetAsNullableString(\u0026#34;udis\u0026#34;); var udiList = !string.IsNullOrEmpty(udis) ? udis.Split(\u0026#39;,\u0026#39;) : null; if (udiList != null) filter \u0026amp;= builder.In(b =\u0026gt; b.Udi, udiList); return filter; } public async Task\u0026lt;DataPage\u0026lt;BeaconV1\u0026gt;\u0026gt; GetPageByFilterAsync( string correlationId, FilterParams filter, PagingParams paging) { return await GetPageByFilterAsync(correlationId, ComposeFilter(filter), paging); } public async Task\u0026lt;BeaconV1\u0026gt; GetOneByUdiAsync(string correlationId, string udi) { var builder = Builders\u0026lt;BeaconV1\u0026gt;.Filter; var filter = builder.Eq(x =\u0026gt; x.Udi, udi); var result = await _collection.Find(filter).FirstOrDefaultAsync(); if (result != null) _logger.Trace(correlationId, \u0026#34;Retrieved from {0} with udi = {1}\u0026#34;, _collectionName, udi); else _logger.Trace(correlationId, \u0026#34;Nothing found from {0} with udi = {1}\u0026#34;, _collectionName, udi); return result; } } } Let’s take a quick look at what’s in this code. A basic set of CRUD operations are already implemented in the data module. There’s minimal code that needs to be written by us as developers for this class: just a filter function, and non-standard methods for searching by a specific data field. The rest of the methods that we defined in our interface are already implemented in the parent class.\nTo make sure that the code does just what we expect it to do, let’s add some tests. We’ll be placing the files with our tests in the test directory and organizing them into subdirectories, whose names will reflect the components they are testing.\nThanks to the modular structure of microservices, each component is easily testable with the help of simple mock tests. We’ll start with creating a class that contains a set of testable commands and checks the results we receive with the help of standard testing libraries. This class will be accepting any persistence that implements our IBeaconsPersistence interface as a parameter. This way we can use the same set of commands to test both of our persistence implementations. This set of commands should contain standard CRUD operations, which are implemented in the parent class, as well as the methods we’ve added in the child classes.\n/test/service.test/persistence/BeaconsPersistenceFixture.cs\nnamespace Beacons.Persistence { public class BeaconsPersistenceFixture { private BeaconV1 BEACON1 = new BeaconV1 { Id = \u0026#34;1\u0026#34;, Udi = \u0026#34;00001\u0026#34;, Type = BeaconTypeV1.AltBeacon, SiteId = \u0026#34;1\u0026#34;, Label = \u0026#34;TestBeacon1\u0026#34;, Center = new CenterObjectV1 { Type = \u0026#34;Point\u0026#34;, Coordinates = new double[] { 0, 0 } }, Radius = 50 }; private BeaconV1 BEACON2 = new BeaconV1 { Id = \u0026#34;2\u0026#34;, Udi = \u0026#34;00002\u0026#34;, Type = BeaconTypeV1.iBeacon, SiteId = \u0026#34;1\u0026#34;, Label = \u0026#34;TestBeacon2\u0026#34;, Center = new CenterObjectV1 { Type = \u0026#34;Point\u0026#34;, Coordinates = new double[] { 2, 2 } }, Radius = 70 }; private BeaconV1 BEACON3 = new BeaconV1 { Id = \u0026#34;3\u0026#34;, Udi = \u0026#34;00003\u0026#34;, Type = BeaconTypeV1.AltBeacon, SiteId = \u0026#34;2\u0026#34;, Label = \u0026#34;TestBeacon3\u0026#34;, Center = new CenterObjectV1 { Type = \u0026#34;Point\u0026#34;, Coordinates = new double[] { 10, 10 } }, Radius = 50 }; private IBeaconsPersistence _persistence; public BeaconsPersistenceFixture(IBeaconsPersistence persistence) { _persistence = persistence; } private async Task TestCreateBeaconsAsync() { // Create the first beacon  var beacon = await _persistence.CreateAsync(null, BEACON1); Assert.NotNull(beacon); Assert.Equal(BEACON1.Udi, beacon.Udi); Assert.Equal(BEACON1.SiteId, beacon.SiteId); Assert.Equal(BEACON1.Type, beacon.Type); Assert.Equal(BEACON1.Label, beacon.Label); Assert.NotNull(beacon.Center); // Create the second beacon  beacon = await _persistence.CreateAsync(null, BEACON2); Assert.NotNull(beacon); Assert.Equal(BEACON2.Udi, beacon.Udi); Assert.Equal(BEACON2.SiteId, beacon.SiteId); Assert.Equal(BEACON2.Type, beacon.Type); Assert.Equal(BEACON2.Label, beacon.Label); Assert.NotNull(beacon.Center); // Create the third beacon  beacon = await _persistence.CreateAsync(null, BEACON3); Assert.NotNull(beacon); Assert.Equal(BEACON3.Udi, beacon.Udi); Assert.Equal(BEACON3.SiteId, beacon.SiteId); Assert.Equal(BEACON3.Type, beacon.Type); Assert.Equal(BEACON3.Label, beacon.Label); Assert.NotNull(beacon.Center); } public async Task TestCrudOperationsAsync() { // Create items  await TestCreateBeaconsAsync(); // Get all beacons  var page = await _persistence.GetPageByFilterAsync( null, new FilterParams(), new PagingParams() ); Assert.NotNull(page); Assert.Equal(3, page.Data.Count); var beacon1 = page.Data[0]; // Update the beacon  beacon1.Label = \u0026#34;ABC\u0026#34;; var beacon = await _persistence.UpdateAsync(null, beacon1); Assert.NotNull(beacon); Assert.Equal(beacon1.Id, beacon.Id); Assert.Equal(\u0026#34;ABC\u0026#34;, beacon.Label); // Get beacon by udi  beacon = await _persistence.GetOneByUdiAsync(null, beacon1.Udi); Assert.NotNull(beacon); Assert.Equal(beacon1.Id, beacon.Id); // Delete the beacon  beacon = await _persistence.DeleteByIdAsync(null, beacon1.Id); Assert.NotNull(beacon); Assert.Equal(beacon1.Id, beacon.Id); // Try to get deleted beacon  beacon = await _persistence.GetOneByIdAsync(null, beacon1.Id); Assert.Null(beacon); } public async Task TestGetWithFiltersAsync() { // Create items  await TestCreateBeaconsAsync(); // Filter by id  var page = await _persistence.GetPageByFilterAsync( null, FilterParams.FromTuples( \u0026#34;id\u0026#34;, \u0026#34;1\u0026#34; ), new PagingParams() ); Assert.Single(page.Data); // Filter by udi  page = await _persistence.GetPageByFilterAsync( null, FilterParams.FromTuples( \u0026#34;udi\u0026#34;, \u0026#34;00002\u0026#34; ), new PagingParams() ); Assert.Single(page.Data); // Filter by udis  page = await _persistence.GetPageByFilterAsync( null, FilterParams.FromTuples( \u0026#34;udis\u0026#34;, \u0026#34;00001,00003\u0026#34; ), new PagingParams() ); Assert.Equal(2, page.Data.Count); // Filter by site_id  page = await _persistence.GetPageByFilterAsync( null, FilterParams.FromTuples( \u0026#34;site_id\u0026#34;, \u0026#34;1\u0026#34; ), new PagingParams() ); Assert.Equal(2, page.Data.Count); } } } Now that we have a set of tests, we can dive into the testing itself. To do this, we’ll create files for testing each of our persistences and run them.\n/test/service.test/persistence/BeaconMemoryPersistenceTest.cs\nnamespace Beacons.Persistence { public class MemoryBeaconsPersistenceTest: IDisposable { public BeaconsMemoryPersistence _persistence; public BeaconsPersistenceFixture _fixture; public MemoryBeaconsPersistenceTest() { _persistence = new BeaconsMemoryPersistence(); _persistence.Configure(new ConfigParams()); _fixture = new BeaconsPersistenceFixture(_persistence); _persistence.OpenAsync(null).Wait(); } public void Dispose() { _persistence.CloseAsync(null).Wait(); } [Fact] public async Task TestCrudOperationsAsync() { await _fixture.TestCrudOperationsAsync(); } [Fact] public async Task TestGetWithFiltersAsync() { await _fixture.TestGetWithFiltersAsync(); } } } To run these tests, run the command npm test from a terminal at the root of the project.\n“But where exactly is the data going to be stored when we get the service actually up and running?” you may ask. Jumping ahead, we’ll tell you that the config.yml configuration file takes care of that. It contains configurations for all of the service’s components, such as: which logger to use, where performance counter output should be, what database to connect to and using what parameters, etc. We’ll discuss this in more detail later on in this tutorial.\nNow that we can persist our data, let’s move on to Step 4. Implementing a controller.\nStep 4. Implementing a controller. ","description":null,"image":null,"permalink":"/net/tutorials/data_microservice/step3/","subtitle":null,"tags":null,"title":"Step 3. Implementing persistence components"},{"content":"In this step, we’ll be creating components for persisting the data model we defined in the previous step. In our projects, we always create at least two persistences: one for storing data in-memory (used for testing), and another for storing data in an external database (used in production). With the Beacons example, we’ll be doing the same.\nLet’s start by navigating to the src directory and creating a persistence directory inside it. This directory is going to contain all of the files that relate to this step of the tutorial.\nThe first thing we are going to do is define what functionality our persistent storage should have. We can define these in a form of an interface and name it IBeaconsPersistence\n/src/persistence/IBeaconsPersistence.ts\nimport { FilterParams } from \u0026#39;pip-services3-commons-node\u0026#39;; import { PagingParams } from \u0026#39;pip-services3-commons-node\u0026#39;; import { DataPage } from \u0026#39;pip-services3-commons-node\u0026#39;; ‍ import { BeaconV1 } from \u0026#39;../data/version1/BeaconV1\u0026#39;; ‍ export interface IBeaconsPersistence { getPageByFilter(correlationId: string, filter: FilterParams, paging: PagingParams, callback: (err: any, page: DataPage\u0026lt;BeaconV1\u0026gt;) =\u0026gt; void): void; ‍ getOneById(correlationId: string, id: string, callback: (err: any, item: BeaconV1) =\u0026gt; void): void; ‍ getOneByUdi(correlationId: string, udi: string, callback: (err: any, item: BeaconV1) =\u0026gt; void): void; ‍ create(correlationId: string, item: BeaconV1, callback: (err: any, item: BeaconV1) =\u0026gt; void): void; update(correlationId: string, item: BeaconV1, callback: (err: any, item: BeaconV1) =\u0026gt; void): void; ‍ deleteById(correlationId: string, id: string, callback: (err: any, item: BeaconV1) =\u0026gt; void): void; } The first persistence to implement this interface will be the memory persistence, which we will name BeaconsMemoryPersistence. This class will need to extend the IdentifiableMemoryPersistence class from the pip-services3-data module, and have a few additional functions added to it. One of these functions will be used to create filters for the getPageByFilter method that we’re going to override from the parent class. This function will be called composeFilter, as it’s going to allow us to filter data in accordance with the received filtering parameters. The overriding getPageByFilter method then simply calls the parent’s method, passing the composeFilter function as a filter parameter. The second function that we will need to implement is the getOneByUdi method, whose purpose will be to retrieve a beacon by its udi.\nThe resulting code for this class is listed below:\n/src/persistence/BeaconsMemoryPersistence.ts\nlet _ = require(\u0026#39;lodash\u0026#39;); ‍ import { FilterParams } from \u0026#39;pip-services3-commons-node\u0026#39;; import { PagingParams } from \u0026#39;pip-services3-commons-node\u0026#39;; import { DataPage } from \u0026#39;pip-services3-commons-node\u0026#39;; ‍ import { IdentifiableMemoryPersistence } from \u0026#39;pip-services3-data-node\u0026#39;; ‍ import { BeaconV1 } from \u0026#39;../data/version1/BeaconV1\u0026#39;; import { IBeaconsPersistence } from \u0026#39;./IBeaconsPersistence\u0026#39;; ‍ export class BeaconsMemoryPersistence extends IdentifiableMemoryPersistence\u0026lt;BeaconV1, string\u0026gt; implements IBeaconsPersistence { ‍ constructor() { super(); ‍ this._maxPageSize = 1000; } ‍ private composeFilter(filter: FilterParams): any { filter = filter || new FilterParams(); ‍ let id = filter.getAsNullableString(\u0026#39;id\u0026#39;); let siteId = filter.getAsNullableString(\u0026#39;site_id\u0026#39;); let label = filter.getAsNullableString(\u0026#39;label\u0026#39;); let udi = filter.getAsNullableString(\u0026#39;udi\u0026#39;); let udis = filter.getAsObject(\u0026#39;udis\u0026#39;); if (_.isString(udis)) udis = udis.split(\u0026#39;,\u0026#39;); if (!_.isArray(udis)) udis = null; ‍ return (item) =\u0026gt; { if (id != null \u0026amp;\u0026amp; item.id != id) return false; if (siteId != null \u0026amp;\u0026amp; item.site_id != siteId) return false; if (label != null \u0026amp;\u0026amp; item.label != label) return false; if (udi != null \u0026amp;\u0026amp; item.udi != udi) return false; if (udis != null \u0026amp;\u0026amp; _.indexOf(udis, item.udi) \u0026lt; 0) return false; return true; }; } public getPageByFilter(correlationId: string, filter: FilterParams, paging: PagingParams, callback: (err: any, page: DataPage\u0026lt;BeaconV1\u0026gt;) =\u0026gt; void): void { super.getPageByFilter(correlationId, this.composeFilter(filter), paging, null, null, callback); } public getOneByUdi(correlationId: string, udi: string, callback: (err: any, item: BeaconV1) =\u0026gt; void): void { ‍ let item = _.find(this._items, (item) =\u0026gt; item.udi == udi); ‍ if (item != null) this._logger.trace(correlationId, \u0026#34;Found beacon by %s\u0026#34;, udi); else this._logger.trace(correlationId, \u0026#34;Cannot find beacon by %s\u0026#34;, udi); ‍ callback(null, item); } } And that’s pretty much it for the memory persistence.\nNow let’s move on to something a bit more sophisticated - a MongoDB persistence. Here we’re also going to use an already existing base class, IdentifiableMongoDbPersistence, from the pip-services3-mongodb module, and write a few functions, the most important of which will be composeFilter. This time around, its implementation is going to contain syntax for creating database requests. The resulting code for this class is listed below:\n/src/persistence/BeaconsMongoDbPersistence.ts\nimport { IdentifiableMongoDbPersistence } from \u0026#39;pip-services3-mongodb-node\u0026#39;; ‍ import { BeaconV1 } from \u0026#39;../data/version1/BeaconV1\u0026#39;; import { IBeaconsPersistence } from \u0026#39;./IBeaconsPersistence\u0026#39;; import { BeaconsMongoDbSchema } from \u0026#39;./BeaconsMongoDbSchema\u0026#39;; ‍ export class BeaconsMongoDbPersistence extends IdentifiableMongoDbPersistence\u0026lt;BeaconV1, string\u0026gt; implements IBeaconsPersistence { constructor() { super(\u0026#39;beacons\u0026#39;, BeaconsMongoDbSchema()); this._maxPageSize = 1000; } ‍ private composeFilter(filter: FilterParams): any { filter = filter || new FilterParams(); let criteria = []; let id = filter.getAsNullableString(\u0026#39;id\u0026#39;); if (id != null) criteria.push({ _id: id }); ‍ let siteId = filter.getAsNullableString(\u0026#39;site_id\u0026#39;); if (siteId != null) criteria.push({ site_id: siteId }); ‍ let label = filter.getAsNullableString(\u0026#39;label\u0026#39;); if (label != null) criteria.push({ label: label }); ‍ let udi = filter.getAsNullableString(\u0026#39;udi\u0026#39;); if (udi != null) { criteria.push({ udi: udi }); } ‍ let udis = filter.getAsObject(\u0026#39;udis\u0026#39;); if (_.isString(udis)) udis = udis.split(\u0026#39;,\u0026#39;); if (_.isArray(udis)) criteria.push({ udi: { $in: udis } }); ‍ return criteria.length \u0026gt; 0 ? { $and: criteria } : null; } ‍ public getPageByFilter(correlationId: string, filter: FilterParams, paging: PagingParams, callback: (err: any, page: DataPage\u0026lt;BeaconV1\u0026gt;) =\u0026gt; void): void { super.getPageByFilter(correlationId, this.composeFilter(filter), paging, null, null, callback); } public getOneByUdi(correlationId: string, udi: string, callback: (err: any, item: BeaconV1) =\u0026gt; void): void { ‍ let criteria = { udi: udi }; ‍ this._model.findOne(criteria, (err, item) =\u0026gt; { item = this.convertFromPublic(item); if (item != null) this._logger.trace(correlationId, \u0026#34;Found beacon by %s\u0026#34;, udi); else this._logger.trace(correlationId, \u0026#34;Cannot find beacon by %s\u0026#34;, udi); ‍ callback(err, item); }); } } Let’s take a quick look at what’s in this code. A basic set of CRUD operations are already implemented in the data module. There’s minimal code that needs to be written by us as developers for this class: just a filter function, and non-standard methods for searching by a specific data field. The rest of the methods that we defined in our interface are already implemented in the parent class.\nTo make sure that the code does just what we expect it to do, let’s add some tests. We’ll be placing the files with our tests in the test directory and organizing them into subdirectories, whose names will reflect the components they are testing.\nThanks to the modular structure of microservices, each component is easily testable with the help of simple mock tests. We’ll start with creating a class that contains a set of testable commands and checks the results we receive with the help of standard testing libraries. This class will be accepting any persistence that implements our IBeaconsPersistence interface as a parameter. This way we can use the same set of commands to test both of our persistence implementations. This set of commands should contain standard CRUD operations, which are implemented in the parent class, as well as the methods we’ve added in the child classes.\n/test/persistence/BeaconsPersistenceFixture.ts\nlet _ = require(\u0026#39;lodash\u0026#39;); let async = require(\u0026#39;async\u0026#39;); let assert = require(\u0026#39;chai\u0026#39;).assert; ‍ import { FilterParams } from \u0026#39;pip-services3-commons-node\u0026#39;; import { PagingParams } from \u0026#39;pip-services3-commons-node\u0026#39;; import { BeaconV1 } from \u0026#39;../../src/data/version1/BeaconV1\u0026#39;; import { BeaconTypeV1 } from \u0026#39;../../src/data/version1/BeaconTypeV1\u0026#39;; import { IBeaconsPersistence } from \u0026#39;../../src/persistence/IBeaconsPersistence\u0026#39;; ‍ const BEACON1: BeaconV1 = { id: \u0026#39;1\u0026#39;, udi: \u0026#39;00001\u0026#39;, type: BeaconTypeV1.AltBeacon, site_id: \u0026#39;1\u0026#39;, label: \u0026#39;TestBeacon1\u0026#39;, center: { type: \u0026#39;Point\u0026#39;, coordinates: [ 0, 0 ] }, radius: 50 }; const BEACON2: BeaconV1 = { id: \u0026#39;2\u0026#39;, udi: \u0026#39;00002\u0026#39;, type: BeaconTypeV1.iBeacon, site_id: \u0026#39;1\u0026#39;, label: \u0026#39;TestBeacon2\u0026#39;, center: { type: \u0026#39;Point\u0026#39;, coordinates: [ 2, 2 ] }, radius: 70 }; const BEACON3: BeaconV1 = { id: \u0026#39;3\u0026#39;, udi: \u0026#39;00003\u0026#39;, type: BeaconTypeV1.AltBeacon, site_id: \u0026#39;2\u0026#39;, label: \u0026#39;TestBeacon3\u0026#39;, center: { type: \u0026#39;Point\u0026#39;, coordinates: [ 10, 10 ] }, radius: 50 }; export class BeaconsPersistenceFixture { private _persistence: IBeaconsPersistence; ‍ public constructor(persistence: IBeaconsPersistence) { assert.isNotNull(persistence); this._persistence = persistence; } ‍ private testCreateBeacons(done) { async.series([ // Create the first beacon  (callback) =\u0026gt; { this._persistence.create( null, BEACON1, (err, beacon) =\u0026gt; { assert.isNull(err); ‍ assert.isObject(beacon); assert.equal(BEACON1.udi, beacon.udi); assert.equal(BEACON1.site_id, beacon.site_id); assert.equal(BEACON1.type, beacon.type); assert.equal(BEACON1.label, beacon.label); assert.isNotNull(beacon.center); ‍ callback(); } ); }, // Create the second beacon  (callback) =\u0026gt; { this._persistence.create( null, BEACON2, (err, beacon) =\u0026gt; { assert.isNull(err); ‍ assert.isObject(beacon); assert.equal(BEACON2.udi, beacon.udi); assert.equal(BEACON2.site_id, beacon.site_id); assert.equal(BEACON2.type, beacon.type); assert.equal(BEACON2.label, beacon.label); assert.isNotNull(beacon.center); ‍ callback(); } ); }, // Create the third beacon  (callback) =\u0026gt; { this._persistence.create( null, BEACON3, (err, beacon) =\u0026gt; { assert.isNull(err); ‍ assert.isObject(beacon); assert.equal(BEACON3.udi, beacon.udi); assert.equal(BEACON3.site_id, beacon.site_id); assert.equal(BEACON3.type, beacon.type); assert.equal(BEACON3.label, beacon.label); assert.isNotNull(beacon.center); ‍ callback(); } ); } ], done); } ‍ public testCrudOperations(done) { let beacon1: BeaconV1; ‍ async.series([ // Create items  (callback) =\u0026gt; { this.testCreateBeacons(callback); }, // Get all beacons  (callback) =\u0026gt; { this._persistence.getPageByFilter( null, new FilterParams(), new PagingParams(), (err, page) =\u0026gt; { assert.isNull(err); ‍ assert.isObject(page); assert.lengthOf(page.data, 3); ‍ beacon1 = page.data[0]; ‍ callback(); } ) }, // Update the beacon  (callback) =\u0026gt; { beacon1.label = \u0026#39;ABC\u0026#39;; ‍ this._persistence.update( null, beacon1, (err, beacon) =\u0026gt; { assert.isNull(err); ‍ assert.isObject(beacon); assert.equal(beacon1.id, beacon.id); assert.equal(\u0026#39;ABC\u0026#39;, beacon.label); ‍ callback(); } ) }, // Get beacon by udi  (callback) =\u0026gt; { this._persistence.getOneByUdi( null, beacon1.udi, (err, beacon) =\u0026gt; { assert.isNull(err); ‍ assert.isObject(beacon); assert.equal(beacon1.id, beacon.id); ‍ callback(); } ) } , // Delete the beacon  (callback) =\u0026gt; { this._persistence.deleteById( null, beacon1.id, (err, beacon) =\u0026gt; { assert.isNull(err); ‍ assert.isObject(beacon); assert.equal(beacon1.id, beacon.id); ‍ callback(); } ) }, // Try to get deleted beacon  (callback) =\u0026gt; { this._persistence.getOneById( null, beacon1.id, (err, beacon) =\u0026gt; { assert.isNull(err); ‍ assert.isNull(beacon || null); ‍ callback(); } ) } ], done); } ‍ public testGetWithFilters(done) { async.series([ // Create items  (callback) =\u0026gt; { this.testCreateBeacons(callback); }, // Filter by id  (callback) =\u0026gt; { this._persistence.getPageByFilter( null, FilterParams.fromTuples( \u0026#39;id\u0026#39;, \u0026#39;1\u0026#39; ), new PagingParams(), (err, page) =\u0026gt; { assert.isNull(err); ‍ assert.lengthOf(page.data, 1); ‍ callback(); } ) }, // Filter by udi  (callback) =\u0026gt; { this._persistence.getPageByFilter( null, FilterParams.fromTuples( \u0026#39;udi\u0026#39;, \u0026#39;00002\u0026#39; ), new PagingParams(), (err, page) =\u0026gt; { assert.isNull(err); ‍ assert.lengthOf(page.data, 1); ‍ callback(); } ) }, // Filter by udis  (callback) =\u0026gt; { this._persistence.getPageByFilter( null, FilterParams.fromTuples( \u0026#39;udis\u0026#39;, \u0026#39;00001,00003\u0026#39; ), new PagingParams(), (err, page) =\u0026gt; { assert.isNull(err); ‍ assert.lengthOf(page.data, 2); ‍ callback(); } ) }, // Filter by site_id  (callback) =\u0026gt; { this._persistence.getPageByFilter( null, FilterParams.fromTuples( \u0026#39;site_id\u0026#39;, \u0026#39;1\u0026#39; ) , new PagingParams(), (err, page) =\u0026gt; { assert.isNull(err); ‍ assert.lengthOf(page.data, 2); ‍ callback(); } ) }, ], done); } } Now that we have a set of tests, we can dive into the testing itself. To do this, we’ll create files for testing each of our persistences and run them.\n/test/persistence/BeaconsMemoryPersistence.test.ts\nimport { ConfigParams } from \u0026#39;pip-services3-commons-node\u0026#39;; import {BeaconsMemoryPersistence} from \u0026#39;../../src/persistence/BeaconsMemoryPersistence\u0026#39;; import { BeaconsPersistenceFixture } from \u0026#39;./BeaconsPersistenceFixture\u0026#39;; ‍ suite(\u0026#39;BeaconsMemoryPersistence\u0026#39;, () =\u0026gt; { let persistence: BeaconsMemoryPersistence; let fixture: BeaconsPersistenceFixture; ‍ setup((done) =\u0026gt; { persistence = new BeaconsMemoryPersistence(); persistence.configure(new ConfigParams()); ‍ fixture = new BeaconsPersistenceFixture(persistence); ‍ persistence.open(null, done); }); ‍ teardown((done) =\u0026gt; { persistence.close(null, done); }); ‍ test(\u0026#39;CRUD Operations\u0026#39;, (done) =\u0026gt; { fixture.testCrudOperations(done); }); test(\u0026#39;Get with Filters\u0026#39;, (done) =\u0026gt; { fixture.testGetWithFilters(done); }); }); To run these tests, run the command npm test from a terminal at the root of the project.\n“But where exactly is the data going to be stored when we get the service actually up and running?” you may ask. Jumping ahead, we’ll tell you that the config.yml configuration file takes care of that. It contains configurations for all of the service’s components, such as: which logger to use, where performance counter output should be, what database to connect to and using what parameters, etc. We’ll discuss this in more detail later on in this tutorial.\nNow that we can persist our data, let’s move on to Step 4. Implementing a controller.\nStep 4. Implementing a controller. ","description":null,"image":null,"permalink":"/node/tutorials/data_microservice/step3/","subtitle":null,"tags":null,"title":"Step 3. Implementing persistence components"},{"content":"In this step, we’ll be creating components for persisting the data model we defined in the previous step. In our projects, we always create at least two persistences: one for storing data in-memory (used for testing), and another for storing data in an external database (used in production). With the Beacons example, we’ll be doing the same.\nLet’s start by navigating to the src directory and creating a persistence directory inside it. This directory is going to contain all of the files that relate to this step of the tutorial.\nThe first thing we are going to do is define what functionality our persistent storage should have. We can define these in a form of an interface and name it IBeaconsPersistence\n/src/persistence/IBeaconsPersistence.py\nfrom typing import Optional from pip_services3_commons.data import PagingParams, FilterParams, DataPage from src.data.version1 import BeaconV1 class IBeaconsPersistence: def get_page_by_filter(self, correlation_id: Optional[str], filter: FilterParams, paging: PagingParams) -\u0026gt; DataPage: raise NotImplementedError(\u0026#39;Method from interface definition\u0026#39;) def get_one_by_id(self, correlation_id: Optional[str], id: str) -\u0026gt; BeaconV1: raise NotImplementedError(\u0026#39;Method from interface definition\u0026#39;) def get_one_by_udi(self, correlation_id: Optional[str], udi: str) -\u0026gt; BeaconV1: raise NotImplementedError(\u0026#39;Method from interface definition\u0026#39;) def create(self, correlation_id: Optional[str], entity: BeaconV1) -\u0026gt; BeaconV1: raise NotImplementedError(\u0026#39;Method from interface definition\u0026#39;) def update(self, correlation_id: Optional[str], entity: BeaconV1) -\u0026gt; BeaconV1: raise NotImplementedError(\u0026#39;Method from interface definition\u0026#39;) def delete_by_id(self, correlation_id: Optional[str], id: str) -\u0026gt; BeaconV1: raise NotImplementedError(\u0026#39;Method from interface definition\u0026#39;) The first persistence to implement this interface will be the memory persistence, which we will name BeaconsMemoryPersistence. This class will need to extend the IdentifiableMemoryPersistence class from the pip-services3-data module, and have a few additional functions added to it. One of these functions will be used to create filters for the get_page_by_filter method that we’re going to override from the parent class. This function will be called __compose_filter, as it’s going to allow us to filter data in accordance with the received filtering parameters. The overriding get_page_by_filter method then simply calls the parent’s method, passing the __compose_filter function as a filter parameter. The second function that we will need to implement is the get_one_by_udi method, whose purpose will be to retrieve a beacon by its udi.\nThe resulting code for this class is listed below:\n/src/persistence/BeaconsMemoryPersistence.py\nfrom typing import Optional, Any, Callable from pip_services3_commons.data import FilterParams, DataPage, PagingParams from pip_services3_data.persistence import IdentifiableMemoryPersistence from .IBeaconsPersistence import IBeaconsPersistence from ..data.version1 import BeaconV1 class BeaconsMemoryPersistence(IdentifiableMemoryPersistence, IBeaconsPersistence): def __init__(self): super(BeaconsMemoryPersistence, self).__init__() self._max_page_size = 1000 def __compose_filter(self, filter: FilterParams) -\u0026gt; Callable: filter = filter if filter is not None else FilterParams() id = filter.get_as_nullable_string(\u0026#34;id\u0026#34;) site_id = filter.get_as_nullable_string(\u0026#34;site_id\u0026#34;) label = filter.get_as_nullable_string(\u0026#34;label\u0026#34;) udi = filter.get_as_nullable_string(\u0026#34;udi\u0026#34;) udis = filter.get_as_object(\u0026#34;udis\u0026#34;) if udis is not None and len(udis) \u0026gt; 0: udis = udis.split(\u0026#34;,\u0026#34;) def filter_beacons(item): if id is not None and item.id != id: return False if site_id is not None and item.site_id != site_id: return False if label is not None and item.label != label: return False if udi is not None and item.udi != udi: return False if udis is not None and item.udi not in udis: return False return True return filter_beacons def get_page_by_filter(self, correlation_id: Optional[str], filter: FilterParams, paging: PagingParams, sort: Any = None, select: Any = None) -\u0026gt; DataPage: return super(BeaconsMemoryPersistence, self).get_page_by_filter(correlation_id, self.__compose_filter(filter), paging=paging) def get_one_by_udi(self, correlation_id: Optional[str], udi: str) -\u0026gt; BeaconV1: if udi is None: return None for item in self._items: if udi == item.udi: return item And that’s pretty much it for the memory persistence.\nNow let’s move on to something a bit more sophisticated - a MongoDB persistence. Here we’re also going to use an already existing base class, IdentifiableMongoDbPersistence, from the pip-services3-mongodb module, and write a few functions, the most important of which will be __compose_filter. This time around, its implementation is going to contain syntax for creating database requests. The resulting code for this class is listed below:\n/src/persistence/BeaconsMongoDbPersistence.py\nfrom typing import Any, Optional from pip_services3_commons.data import FilterParams, PagingParams, DataPage from pip_services3_mongodb.persistence import IdentifiableMongoDbPersistence from .IBeaconsPersistence import IBeaconsPersistence from ..data.version1 import BeaconV1 class BeaconsMongoDbPersistence(IdentifiableMongoDbPersistence, IBeaconsPersistence): def __init__(self): super(BeaconsMongoDbPersistence, self).__init__(\u0026#34;beacons\u0026#34;) self._max_page_size = 1000 def compose_filter(self, filter: FilterParams) -\u0026gt; Any: filter = filter if filter is not None else FilterParams() criteria = [] id = filter.get_as_nullable_string(\u0026#34;id\u0026#34;) if id is not None: criteria.append({\u0026#34;id\u0026#34;: id}) site_id = filter.get_as_nullable_string(\u0026#34;site_id\u0026#34;) if site_id is not None: criteria.append({\u0026#34;site_id\u0026#34;: site_id}) label = filter.get_as_nullable_string(\u0026#34;label\u0026#34;) if label is not None: criteria.append({\u0026#34;label\u0026#34;: label}) udi = filter.get_as_nullable_string(\u0026#34;udi\u0026#34;) if udi is not None: criteria.append({\u0026#34;udi\u0026#34;: udi}) udis = filter.get_as_object(\u0026#34;udis\u0026#34;) if udis is not None and len(udis) \u0026gt; 0: udis = udis.split(\u0026#34;,\u0026#34;) criteria.append({\u0026#34;udi\u0026#34;: {\u0026#34;$in\u0026#34;: udis}}) return {\u0026#34;$and\u0026#34;: criteria} if len(criteria) \u0026gt; 0 else None def get_page_by_filter(self, correlation_id: Optional[str], filter: FilterParams, paging: PagingParams, sort: Any = None, select: Any = None) -\u0026gt; DataPage: filter = filter if filter is not None else FilterParams() return super(BeaconsMongoDbPersistence, self).get_page_by_filter(correlation_id, self.compose_filter(filter), paging, None, None) def get_one_by_udi(self, correlation_id: Optional[str], udi: str) -\u0026gt; BeaconV1: if udi is None: return None item = self._collection.find_one({\u0026#39;udi\u0026#39;: udi}) item = self._convert_to_public(item) if item is None: self._logger.trace(correlation_id, \u0026#34;Found beacon by %s\u0026#34;, udi) else: self._logger.trace(correlation_id, \u0026#34;Cannot find beacon by %s\u0026#34;, udi) return item Let’s take a quick look at what’s in this code. A basic set of CRUD operations are already implemented in the data module. There’s minimal code that needs to be written by us as developers for this class: just a filter function, and non-standard methods for searching by a specific data field. The rest of the methods that we defined in our interface are already implemented in the parent class.\nTo make sure that the code does just what we expect it to do, let’s add some tests. We’ll be placing the files with our tests in the test directory and organizing them into subdirectories, whose names will reflect the components they are testing.\nThanks to the modular structure of microservices, each component is easily testable with the help of simple mock tests. We’ll start with creating a class that contains a set of testable commands and checks the results we receive with the help of standard testing libraries. This class will be accepting any persistence that implements our IBeaconsPersistence interface as a parameter. This way we can use the same set of commands to test both of our persistence implementations. This set of commands should contain standard CRUD operations, which are implemented in the parent class, as well as the methods we’ve added in the child classes.\n/test/persistence/BeaconsPersistenceFixture.py\nfrom pip_services3_commons.data import PagingParams, FilterParams from src.data.version1 import BeaconV1, BeaconTypeV1 from src.persistence import IBeaconsPersistence BEACON1 = BeaconV1(\u0026#34;1\u0026#34;, \u0026#34;1\u0026#34;, BeaconTypeV1.AltBeacon, \u0026#34;00001\u0026#34;, \u0026#34;TestBeacon1\u0026#34;, {\u0026#34;type\u0026#34;: \u0026#39;Point\u0026#39;, \u0026#34;coordinates\u0026#34;: [0, 0]}, 50) BEACON2 = BeaconV1(\u0026#34;2\u0026#34;, \u0026#34;1\u0026#34;, BeaconTypeV1.iBeacon, \u0026#34;00002\u0026#34;, \u0026#34;TestBeacon2\u0026#34;, {\u0026#34;type\u0026#34;: \u0026#39;Point\u0026#39;, \u0026#34;coordinates\u0026#34;: [2, 2]}, 70) BEACON3 = BeaconV1(\u0026#34;3\u0026#34;, \u0026#34;2\u0026#34;, BeaconTypeV1.AltBeacon, \u0026#34;00003\u0026#34;, \u0026#34;TestBeacon3\u0026#34;, {\u0026#34;type\u0026#34;: \u0026#39;Point\u0026#39;, \u0026#34;coordinates\u0026#34;: [10, 10]}, 50) class BeaconsPersistenceFixture(): _persistence: IBeaconsPersistence = None def __init__(self, persistence: IBeaconsPersistence): self._persistence = persistence def test_create_beacons(self): #Create the first beacon beacon1 = self._persistence.create(None, BEACON1) assert beacon1 != None assert beacon1.id == BEACON1.id assert beacon1.site_id == BEACON1.site_id assert beacon1.udi == BEACON1.udi assert beacon1.type == BEACON1.type assert beacon1.label == BEACON1.label assert beacon1.center != None #Create the second beacon beacon2 = self._persistence.create(None, BEACON2) assert beacon2 != None assert beacon2.id == BEACON2.id assert beacon2.site_id == BEACON2.site_id assert beacon2.udi == BEACON2.udi assert beacon2.type == BEACON2.type assert beacon2.label == BEACON2.label assert beacon2.center != None #Create the third beacon beacon3 = self._persistence.create(None, BEACON3) assert beacon3 != None assert beacon3.id == BEACON3.id assert beacon3.site_id == BEACON3.site_id assert beacon3.udi == BEACON3.udi assert beacon3.type == BEACON3.type assert beacon3.label == BEACON3.label assert beacon3.center != None def test_crud_operations(self): #Create 3 beacons self.test_create_beacons() #Get all beacons page = self._persistence.get_page_by_filter(None, FilterParams(), PagingParams()) assert page != None assert len(page.data) == 3 beacon1 = page.data[0] #Update the beacon beacon1[\u0026#39;label\u0026#39;] = \u0026#34;ABC\u0026#34; beacon = self._persistence.update(None, beacon1) assert beacon != None assert beacon1.id == beacon.id assert \u0026#34;ABC\u0026#34; == beacon.label #Get beacon by udi beacon = self._persistence.get_one_by_udi(None, beacon1.udi) assert beacon != None assert beacon.id == beacon1.id #Delete beacon self._persistence.delete_by_id(None, beacon1.id) #Try to get deleted beacon beacon = self._persistence.get_one_by_id(None, beacon1.id) assert beacon == None def test_get_with_filter(self): #Create 3 beacons self.test_create_beacons() #Filter by id page = self._persistence.get_page_by_filter(None, FilterParams.from_tuples(\u0026#34;id\u0026#34;, \u0026#34;1\u0026#34;), PagingParams()) assert page != None assert len(page.data) == 1 #Filter by udi page = self._persistence.get_page_by_filter(None, FilterParams.from_tuples(\u0026#34;udi\u0026#34;, \u0026#34;00002\u0026#34;), PagingParams()) assert page != None assert len(page.data) == 1 #Filter by udis page = self._persistence.get_page_by_filter(None, FilterParams.from_tuples(\u0026#34;udis\u0026#34;, \u0026#39;00001,00003\u0026#39;), PagingParams()) assert page != None assert len(page.data) == 2 #Filter by udi page = self._persistence.get_page_by_filter(None, FilterParams.from_tuples(\u0026#34;site_id\u0026#34;, \u0026#34;1\u0026#34;), PagingParams()) assert page != None assert len(page.data) == 2 Now that we have a set of tests, we can dive into the testing itself. To do this, we’ll create files for testing each of our persistences and run them.\n/test/persistence/test_BeaconMemoryPersistence.py\nfrom src.persistence.BeaconsMemoryPersistence import BeaconsMemoryPersistence from .BeaconsPersistenceFixture import BeaconsPersistenceFixture class TestBeaconMemoryPersistence(): persistence: BeaconsMemoryPersistence fixture: BeaconsPersistenceFixture @classmethod def setup_class(cls): cls.persistence = BeaconsMemoryPersistence() cls.fixture = BeaconsPersistenceFixture(cls.persistence) def setup_method(self, method): self.persistence.clear(None) def test_crud_operations(self): self.fixture.test_crud_operations() def test_get_with_filter(self): self.fixture.test_get_with_filter() To run these tests, run the command npm test from a terminal at the root of the project.\n“But where exactly is the data going to be stored when we get the service actually up and running?” you may ask. Jumping ahead, we’ll tell you that the config.yml configuration file takes care of that. It contains configurations for all of the service’s components, such as: which logger to use, where performance counter output should be, what database to connect to and using what parameters, etc. We’ll discuss this in more detail later on in this tutorial.\nNow that we can persist our data, let’s move on to Step 4. Implementing a controller.\nStep 4. Implementing a controller. ","description":null,"image":null,"permalink":"/python/tutorials/data_microservice/step3/","subtitle":null,"tags":null,"title":"Step 3. Implementing persistence components"},{"content":"Once we’ve established who our user is, we need to implement some way of controlling what operations our user can perform, based on the rights he/she has been assigned. In this tutorial, we will be taking a look at how to install access limitations that are based on user roles. The roles themselves are stored in the Roles microservice and are loaded into a UserSession by the loadSession interceptor we discussed in the previous step.\nOur Authorizer class was made to provide flexible access management. We will be using this class to limit access to certain operations in our facade’s RESTful services. This class’s implementation can be found in the Authorize.ts file, located in the folder services/version1. Its code is as follows:\n/src/services/version1/Authorize.ts\nlet _ = require(\u0026#39;lodash\u0026#39;); import { UnauthorizedException } from \u0026#39;pip-services3-commons-node\u0026#39;; import { HttpResponseSender } from \u0026#39;pip-services3-rpc-node\u0026#39;; import { BasicAuthManager } from \u0026#39;pip-services3-rpc-node\u0026#39;; import { RoleAuthManager } from \u0026#39;pip-services3-rpc-node\u0026#39;; import { OwnerAuthManager } from \u0026#39;pip-services3-rpc-node\u0026#39;; export class AuthorizerV1 { private basicAuth = new BasicAuthManager(); private roleAuth = new RoleAuthManager(); private ownerAuth = new OwnerAuthManager(); public anybody(): (req: any, res: any, next: () =\u0026gt; void) =\u0026gt; void { return this.basicAuth.anybody(); } public signed(): (req: any, res: any, next: () =\u0026gt; void) =\u0026gt; void { return this.basicAuth.signed(); } public owner(idParam: string = \u0026#39;user_id\u0026#39;): (req: any, res: any, next: () =\u0026gt; void) =\u0026gt; void { return this.ownerAuth.owner(idParam); } public ownerOrAdmin(idParam: string = \u0026#39;user_id\u0026#39;): (req: any, res: any, next: () =\u0026gt; void) =\u0026gt; void { return this.ownerAuth.ownerOrAdmin(idParam); } public siteRoles(roles: string[], idParam: string = \u0026#39;site_id\u0026#39;): (req: any, res: any, next: () =\u0026gt; void) =\u0026gt; void { return (req, res, next) =\u0026gt; { let user = req.user; if (user == null) { HttpResponseSender.sendError( req, res, new UnauthorizedException( null, \u0026#39;NOT_SIGNED\u0026#39;, \u0026#39;User must be signed in to perform this operation\u0026#39; ).withStatus(401) ); } else { let siteId = req.params[idParam]; let authorized = _.includes(user.roles, \u0026#39;admin\u0026#39;); if (siteId != null \u0026amp;\u0026amp; !authorized) { for (let role of roles) authorized = authorized || _.includes(user.roles, siteId + \u0026#39;:\u0026#39; + role); } if (!authorized) { HttpResponseSender.sendError( req, res, new UnauthorizedException( null, \u0026#39;NOT_IN_SITE_ROLE\u0026#39;, \u0026#39;User must be site:\u0026#39; + roles.join(\u0026#39; or site:\u0026#39;) + \u0026#39; to perform this operation\u0026#39; ).withDetails(\u0026#39;roles\u0026#39;, roles).withStatus(403) ); } else { next(); } } }; } public admin(): (req: any, res: any, next: () =\u0026gt; void) =\u0026gt; void { return this.roleAuth.userInRole(\u0026#39;admin\u0026#39;); } public siteAdmin(idParam: string = \u0026#39;site_id\u0026#39;): (req: any, res: any, next: () =\u0026gt; void) =\u0026gt; void { return this.siteRoles([\u0026#39;admin\u0026#39;], idParam); } public siteManager(idParam: string = \u0026#39;site_id\u0026#39;): (req: any, res: any, next: () =\u0026gt; void) =\u0026gt; void { return this.siteRoles([\u0026#39;admin\u0026#39;, \u0026#39;manager\u0026#39;], idParam); } public siteUser(idParam: string = \u0026#39;site_id\u0026#39;): (req: any, res: any, next: () =\u0026gt; void) =\u0026gt; void { return this.siteRoles([\u0026#39;admin\u0026#39;, \u0026#39;manager\u0026#39;, \u0026#39;user\u0026#39;], idParam); } public siteAdminOrOwner(userIdParam: string = \u0026#39;user_id\u0026#39;, siteIdParam: string = \u0026#39;site_id\u0026#39;): (req: any, res: any, next: () =\u0026gt; void) =\u0026gt; void { return (req, res, next) =\u0026gt; { let user = req.user; if (user == null) { HttpResponseSender.sendError( req, res, new UnauthorizedException( null, \u0026#39;NOT_SIGNED\u0026#39;, \u0026#39;User must be signed in to perform this operation\u0026#39; ).withStatus(401) ); } else { let userId = req.params[userIdParam] || req.param(userIdParam); if (userId != null \u0026amp;\u0026amp; userId == user.user_id) { next(); } else { let siteId = req.params[siteIdParam]; let authorized = _.includes(user.roles, \u0026#39;admin\u0026#39;) || _.includes(user.roles, siteId + \u0026#39;:admin\u0026#39;); if (!authorized) { HttpResponseSender.sendError( req, res, new UnauthorizedException( null, \u0026#39;NOT_IN_SITE_ROLE\u0026#39;, \u0026#39;User must be site:admin to perform this operation\u0026#39; ).withDetails(\u0026#39;roles\u0026#39;, [\u0026#39;admin\u0026#39;]).withStatus(403) ); } else { next(); } } } }; } } Let’s take a closer look at each of these methods:\n anybody - allows everyone access, even unauthorized users. signed - access is granted only to authorized users. admin - access is granted only to users with the Administrator role. owner - access is granted only for the session owner.  The logic pretty much boils down to making a decision about whether we should allow further access, or send an answer with the corresponding error. In case of the latter, the error is based on the information provided by the clients and the information about the user that is embedded into the interceptor’s request for the active session.\nSetting specific access levels to certain resources is configured when registering routes in the service. The service’s implementation is described in Step 5 - REST services and versioning.\nStep 5 - REST services and versioning  ","description":null,"image":null,"permalink":"/node/tutorials/microservice_facade/step4/","subtitle":null,"tags":null,"title":"Step 4. Authorization"},{"content":"Once we’ve established who our user is, we need to implement some way of controlling what operations our user can perform, based on the rights he/she has been assigned. In this tutorial, we will be taking a look at how to install access limitations that are based on user roles. The roles themselves are stored in the Roles microservice and are loaded into a UserSession by the loadSession interceptor we discussed in the previous step.\nOur Authorizer class was made to provide flexible access management. We will be using this class to limit access to certain operations in our facade’s RESTful services. This class’s implementation can be found in the Authorize.py file, located in the folder services/version1. Its code is as follows:\n/pip_facades_sample_python/services/version1/Authorize.py\n# -*- coding: utf-8 -*- from typing import List import bottle from pip_services3_commons.convert import JsonConverter from pip_services3_commons.errors import UnauthorizedException from pip_services3_rpc.auth.BasicAuthorizer import BasicAuthorizer from pip_services3_rpc.auth.OwnerAuthorizer import OwnerAuthorizer from pip_services3_rpc.auth.RoleAuthorizer import RoleAuthorizer class AuthorizerV1: def __init__(self): self.__basic_auth = BasicAuthorizer() self.__role_auth = RoleAuthorizer() self.__owner_auth = OwnerAuthorizer() # Anybody who entered the system def anybody(self): return self.__basic_auth.anybody() # Only registered and authenticated users def signed(self): return self.__basic_auth.signed() # Only the user session owner def owner(self, id_param: str = \u0026#39;user_id\u0026#39;): return self.__owner_auth.owner(id_param) def owner_or_admin(self, id_param: str = \u0026#39;user_id\u0026#39;): return self.__owner_auth.owner_or_admin(id_param) def site_roles(self, roles: List[str], id_param: str = \u0026#39;site_id\u0026#39;): def inner(): user = getattr(bottle.request, \u0026#39;user\u0026#39;, None) if user is None: raise UnauthorizedException( None, \u0026#39;NOT_SIGNED\u0026#39;, \u0026#39;User must be signed in to perform this operation\u0026#39; ).with_status(401) else: user.roles = getattr(user, \u0026#39;roles\u0026#39;, False) or [] site_id = bottle.request.params[\u0026#39;kwargs\u0026#39;].get(id_param) authorized = \u0026#39;admin\u0026#39; in user.roles if site_id is not None and not authorized: for role in roles: authorized = authorized or (site_id + \u0026#39;:\u0026#39; + role) in user.roles if not authorized: raise UnauthorizedException( None, \u0026#39;NOT_IN_SITE_ROLE\u0026#39;, \u0026#39;User must be site:\u0026#39; + \u0026#39; or site:\u0026#39;.join(roles) + \u0026#39; to perform this operation\u0026#39; ).with_details(\u0026#39;roles\u0026#39;, roles).with_status(403) return inner def admin(self): return self.__role_auth.user_in_role(\u0026#39;admin\u0026#39;) def site_admin(self, id_param: str = \u0026#39;site_id\u0026#39;): return self.site_roles([\u0026#39;admin\u0026#39;], id_param) def site_manager(self, id_param: str = \u0026#39;site_id\u0026#39;): return self.site_roles([\u0026#39;admin\u0026#39;, \u0026#39;manager\u0026#39;], id_param) def site_user(self, id_param: str = \u0026#39;site_id\u0026#39;): return self.site_roles([\u0026#39;admin\u0026#39;, \u0026#39;manager\u0026#39;, \u0026#39;user\u0026#39;], id_param) def site_admin_or_owner(self, user_id_param: str = \u0026#39;user_id\u0026#39;, site_id_param: str = \u0026#39;site_id\u0026#39;): def inner(): user = bottle.request.user if user is None: raise UnauthorizedException( None, \u0026#39;NOT_SIGNED\u0026#39;, \u0026#39;User must be signed in to perform this operation\u0026#39; ).with_status(401) else: user_id = dict(bottle.request.query.decode()).get(user_id_param) or JsonConverter.to_json( bottle.request.json) if user_id is not None and user_id == user.user_id: return else: site_id = bottle.request.params.get(site_id_param) authorized = \u0026#39;admin\u0026#39; in user.roles or site_id + \u0026#39;:admin\u0026#39; in user.roles if not authorized: raise UnauthorizedException( None, \u0026#39;NOT_IN_SITE_ROLE\u0026#39;, \u0026#39;User must be site:admin to perform this operation\u0026#39; ).with_details(\u0026#39;roles\u0026#39;, [\u0026#39;admin\u0026#39;]).with_status(403) return inner Let’s take a closer look at each of these methods:\n anybody - allows everyone access, even unauthorized users. signed - access is granted only to authorized users. admin - access is granted only to users with the Administrator role. owner - access is granted only for the session owner.  The logic pretty much boils down to making a decision about whether we should allow further access, or send an answer with the corresponding error. In case of the latter, the error is based on the information provided by the clients and the information about the user that is embedded into the interceptor’s request for the active session.\nSetting specific access levels to certain resources is configured when registering routes in the service. The service’s implementation is described in Step 5 - REST services and versioning.\nStep 5 - REST services and versioning  ","description":null,"image":null,"permalink":"/python/tutorials/microservice_facade/step4/","subtitle":null,"tags":null,"title":"Step 4. Authorization"},{"content":"Now that we know a bit about how we are going to be storing data and how microservice configuration works, it’s time to add some logic to our service. Our microservice needs to be able to calculate a device’s position based on the beacons it “sees”, as well as initiate CRUD operations for the data it handles. Let’s create a logic folder under the src/interface directory and start by defining an interface:\n/src/interface/logic/IBeaconsController.cs\nnamespace Beacons.Logic { public interface IBeaconsController { Task\u0026lt;DataPage\u0026lt;BeaconV1\u0026gt;\u0026gt; GetBeaconsAsync(string correlationId, FilterParams filter, PagingParams paging); Task\u0026lt;BeaconV1\u0026gt; GetBeaconByIdAsync(string correlationId, string id); Task\u0026lt;BeaconV1\u0026gt; GetBeaconByUdiAsync(string correlationId, string udi); Task\u0026lt;CenterObjectV1\u0026gt; CalculatePositionAsync(string correlationId, string siteId, string[] udis); Task\u0026lt;BeaconV1\u0026gt; CreateBeaconAsync(string correlationId, BeaconV1 beacon); Task\u0026lt;BeaconV1\u0026gt; UpdateBeaconAsync(string correlationId, BeaconV1 beacon); Task\u0026lt;BeaconV1\u0026gt; DeleteBeaconByIdAsync(string correlationId, string id); } } Once our interface is ready, we can move on to implementing the actual controller. Its code is also going to be quite simple, as all we need to write is one method for calculating a device’s position, and the other methods will just be wrappers for the methods we wrote in our persistence components.\n/src/interface/logic/BeaconsController.cs\nnamespace Beacons.Logic { public class BeaconsController : IBeaconsController, IConfigurable, IReferenceable, ICommandable { private IBeaconsPersistence _persistence; private BeaconsCommandSet _commandSet; public BeaconsController() {} public void Configure(ConfigParams config) {} public void SetReferences(IReferences references) { _persistence = references.GetOneRequired\u0026lt;IBeaconsPersistence\u0026gt;( new Descriptor(\u0026#34;beacons\u0026#34;, \u0026#34;persistence\u0026#34;, \u0026#34;*\u0026#34;, \u0026#34;*\u0026#34;, \u0026#34;1.0\u0026#34;) ); } public CommandSet GetCommandSet() { if (_commandSet == null) _commandSet = new BeaconsCommandSet(this); return _commandSet; } public async Task\u0026lt;DataPage\u0026lt;BeaconV1\u0026gt;\u0026gt; GetBeaconsAsync(string correlationId, FilterParams filter, PagingParams paging) { return await _persistence.GetPageByFilterAsync(correlationId, filter, paging); } public async Task\u0026lt;BeaconV1\u0026gt; GetBeaconByIdAsync(string correlationId, string id) { return await _persistence.GetOneByIdAsync(correlationId, id); } public async Task\u0026lt;BeaconV1\u0026gt; GetBeaconByUdiAsync(string correlationId, string udi) { return await _persistence.GetOneByUdiAsync(correlationId, udi); } public async Task\u0026lt;CenterObjectV1\u0026gt; CalculatePositionAsync(string correlationId, string siteId, string[] udis) { if (udis == null || udis.Length == 0) return null; var page = await this._persistence.GetPageByFilterAsync( correlationId, FilterParams.FromTuples(\u0026#34;site_id\u0026#34;, siteId, \u0026#34;udis\u0026#34;, udis), null ); var lat = 0.0; var lng = 0.0; var count = 0; foreach (var beacon in page.Data) { if (beacon.Center != null \u0026amp;\u0026amp; beacon.Center.Type == \u0026#34;Point\u0026#34; \u0026amp;\u0026amp; beacon.Center.Coordinates.Length \u0026gt; 1) { lng += beacon.Center.Coordinates[0]; lat += beacon.Center.Coordinates[1]; count += 1; } } if (count == 0) { return null; } var point = new CenterObjectV1 { Type = \u0026#34;Point\u0026#34;, Coordinates = new double[] { lng / count, lat / count } }; return point; } public async Task\u0026lt;BeaconV1\u0026gt; CreateBeaconAsync(string correlationId, BeaconV1 beacon) { beacon.Id = beacon.Id ?? IdGenerator.NextLong(); beacon.Type = beacon.Type ?? BeaconTypeV1.Unknown; return await _persistence.CreateAsync(correlationId, beacon); } public async Task\u0026lt;BeaconV1\u0026gt; UpdateBeaconAsync(string correlationId, BeaconV1 beacon) { beacon.Type = beacon.Type ?? BeaconTypeV1.Unknown; return await _persistence.UpdateAsync(correlationId, beacon); } public async Task\u0026lt;BeaconV1\u0026gt; DeleteBeaconByIdAsync(string correlationId, string id) { return await _persistence.DeleteByIdAsync(correlationId, id); } } } Pay special attention to the following two methods in the code above:\n SetReferences GetCommandSet  The first one sets a dependency upon a persistence using the descriptor beacons:persistence:::1.0. This descriptor reads: we don’t necessarily care which persistence we are given, as long as it implements the IBeaconsPersistence interface via the Referenceable pattern. This way, our controller can be used with the memory persistence, the mongoDB one, or any other one that meets this requirement.\nThe second method is used to get a set of commands, with which we can control this controller using the Commandable pattern. In our case, it will be used by the commandable HTTP service. If you’re not yet familiar with the Commandable pattern, make sure to find some time and read about it here. To complete this pattern, lets implement a class called BeaconsCommandSet:\n/src/interfaces/logic/BeaconsCommandSet.cs\nnamespace Beacons.Logic { public class BeaconsCommandSet : CommandSet { private IBeaconsController _controller; public BeaconsCommandSet(IBeaconsController controller) { _controller = controller; AddCommand(MakeGetBeaconsCommand()); AddCommand(MakeGetBeaconByIdBeaconsCommand()); AddCommand(MakeGetBeaconByUdiCommand()); AddCommand(MakeCalculatePositionCommand()); AddCommand(MakeCreateBeaconCommand()); AddCommand(MakeUpdateBeaconCommand()); AddCommand(MakeDeleteBeaconByIdCommand()); } private ICommand MakeGetBeaconsCommand() { return new Command( \u0026#34;get_beacons\u0026#34;, new ObjectSchema() .WithOptionalProperty(\u0026#34;filter\u0026#34;, new FilterParamsSchema()) .WithOptionalProperty(\u0026#34;paging\u0026#34;, new PagingParamsSchema()), async (correlationId, parameters) =\u0026gt; { var filter = FilterParams.FromValue(parameters.Get(\u0026#34;filter\u0026#34;)); var paging = PagingParams.FromValue(parameters.Get(\u0026#34;paging\u0026#34;)); return await _controller.GetBeaconsAsync(correlationId, filter, paging); }); } private ICommand MakeGetBeaconByIdBeaconsCommand() { return new Command( \u0026#34;get_beacon_by_id\u0026#34;, new ObjectSchema() .WithRequiredProperty(\u0026#34;beacon_id\u0026#34;, TypeCode.String), async (correlationId, parameters) =\u0026gt; { var id = parameters.GetAsString(\u0026#34;beacon_id\u0026#34;); return await _controller.GetBeaconByIdAsync(correlationId, id); }); } private ICommand MakeGetBeaconByUdiCommand() { return new Command( \u0026#34;get_beacon_by_udi\u0026#34;, new ObjectSchema() .WithRequiredProperty(\u0026#34;udi\u0026#34;, TypeCode.String), async (correlationId, parameters) =\u0026gt; { var udi = parameters.GetAsString(\u0026#34;udi\u0026#34;); return await _controller.GetBeaconByUdiAsync(correlationId, udi); }); } private ICommand MakeCalculatePositionCommand() { return new Command( \u0026#34;calculate_position\u0026#34;, new ObjectSchema() .WithRequiredProperty(\u0026#34;site_id\u0026#34;, TypeCode.String) .WithRequiredProperty(\u0026#34;udis\u0026#34;, TypeCode.Array), async (correlationId, parameters) =\u0026gt; { var siteId = parameters.GetAsString(\u0026#34;site_id\u0026#34;); string[] udis = ConvertToStringList(parameters.Get(\u0026#34;udis\u0026#34;)); return await _controller.CalculatePositionAsync(correlationId, siteId, udis); }); } private ICommand MakeCreateBeaconCommand() { return new Command( \u0026#34;create_beacon\u0026#34;, new ObjectSchema() .WithRequiredProperty(\u0026#34;beacon\u0026#34;, new BeaconV1Schema()), async (correlationId, parameters) =\u0026gt; { var beacon = ConvertToBeacon(parameters.GetAsObject(\u0026#34;beacon\u0026#34;)); return await _controller.CreateBeaconAsync(correlationId, beacon); }); } private ICommand MakeUpdateBeaconCommand() { return new Command( \u0026#34;update_beacon\u0026#34;, new ObjectSchema() .WithRequiredProperty(\u0026#34;beacon\u0026#34;, new BeaconV1Schema()), async (correlationId, parameters) =\u0026gt; { var beacon = ConvertToBeacon(parameters.GetAsObject(\u0026#34;beacon\u0026#34;)); return await _controller.UpdateBeaconAsync(correlationId, beacon); }); } private ICommand MakeDeleteBeaconByIdCommand() { return new Command( \u0026#34;delete_beacon_by_id\u0026#34;, new ObjectSchema() .WithRequiredProperty(\u0026#34;beacon_id\u0026#34;, TypeCode.String), async (correlationId, parameters) =\u0026gt; { var id = parameters.GetAsString(\u0026#34;beacon_id\u0026#34;); return await _controller.DeleteBeaconByIdAsync(correlationId, id); }); } private BeaconV1 ConvertToBeacon(object value) { return JsonConverter.FromJson\u0026lt;BeaconV1\u0026gt;(JsonConverter.ToJson(value)); } private string[] ConvertToStringList(object value) { return JsonConverter.FromJson\u0026lt;string[]\u0026gt;(JsonConverter.ToJson(value)); } } } To sum up this class’s code: we’re creating commands for each of the controller’s methods, and then registering them in the constructor. To create a command, we give it a name, a validation schema (if needed), and a callback function with the following three parameters:\n correlationId: string – used to identify the operation, args: Parameters - the set of parameters received from the command being called, callback – callback function for returning the command’s result, or an error, if one occurs.  To be sure that our new methods are working correctly, let’s add some tests for the controller. The code for testing the controller is listed below:\n/test/service.test/logic/BeaconsControllerTest.cs\nnamespace Beacons.Logic { public class BeaconsControllerTest: IDisposable { private BeaconV1 BEACON1 = new BeaconV1 { Id = \u0026#34;1\u0026#34;, Udi = \u0026#34;00001\u0026#34;, Type = BeaconTypeV1.AltBeacon, SiteId = \u0026#34;1\u0026#34;, Label = \u0026#34;TestBeacon1\u0026#34;, Center = new CenterObjectV1 { Type = \u0026#34;Point\u0026#34;, Coordinates = new double[] { 0, 0 } }, Radius = 50 }; private BeaconV1 BEACON2 = new BeaconV1 { Id = \u0026#34;2\u0026#34;, Udi = \u0026#34;00002\u0026#34;, Type = BeaconTypeV1.iBeacon, SiteId = \u0026#34;1\u0026#34;, Label = \u0026#34;TestBeacon2\u0026#34;, Center = new CenterObjectV1 { Type = \u0026#34;Point\u0026#34;, Coordinates = new double[] { 2, 2 } }, Radius = 70 }; private BeaconsController _controller; private BeaconsMemoryPersistence _persistence; public BeaconsControllerTest() { _persistence = new BeaconsMemoryPersistence(); _persistence.Configure(new ConfigParams()); _controller = new BeaconsController(); var references = References.FromTuples( new Descriptor(\u0026#34;beacons\u0026#34;, \u0026#34;persistence\u0026#34;, \u0026#34;memory\u0026#34;, \u0026#34;*\u0026#34;, \u0026#34;1.0\u0026#34;), _persistence, new Descriptor(\u0026#34;beacons\u0026#34;, \u0026#34;controller\u0026#34;, \u0026#34;default\u0026#34;, \u0026#34;*\u0026#34;, \u0026#34;1.0\u0026#34;), _controller ); _controller.SetReferences(references); _persistence.OpenAsync(null).Wait(); } public void Dispose() { _persistence.CloseAsync(null).Wait(); } [Fact] public async Task TestCrudOperationsAsync() { // Create the first beacon  var beacon = await _controller.CreateBeaconAsync(null, BEACON1); Assert.NotNull(beacon); Assert.Equal(BEACON1.Udi, beacon.Udi); Assert.Equal(BEACON1.SiteId, beacon.SiteId); Assert.Equal(BEACON1.Type, beacon.Type); Assert.Equal(BEACON1.Label, beacon.Label); Assert.NotNull(beacon.Center); // Create the second beacon  beacon = await _controller.CreateBeaconAsync(null, BEACON2); Assert.NotNull(beacon); Assert.Equal(BEACON2.Udi, beacon.Udi); Assert.Equal(BEACON2.SiteId, beacon.SiteId); Assert.Equal(BEACON2.Type, beacon.Type); Assert.Equal(BEACON2.Label, beacon.Label); Assert.NotNull(beacon.Center); // Get all beacons  var page = await _controller.GetBeaconsAsync( null, new FilterParams(), new PagingParams() ); Assert.NotNull(page); Assert.Equal(2, page.Data.Count); var beacon1 = page.Data[0]; // Update the beacon  beacon1.Label = \u0026#34;ABC\u0026#34;; beacon = await _controller.UpdateBeaconAsync(null, beacon1); Assert.NotNull(beacon); Assert.Equal(beacon1.Id, beacon.Id); Assert.Equal(\u0026#34;ABC\u0026#34;, beacon.Label); // Get beacon by udi  beacon = await _controller.GetBeaconByUdiAsync(null, beacon1.Udi); Assert.NotNull(beacon); Assert.Equal(beacon1.Id, beacon.Id); // Delete the beacon  beacon = await _controller.DeleteBeaconByIdAsync(null, beacon1.Id); Assert.NotNull(beacon); Assert.Equal(beacon1.Id, beacon.Id); // Try to get deleted beacon  beacon = await _controller.GetBeaconByIdAsync(null, beacon1.Id); Assert.Null(beacon); } [Fact] public async Task TestCalculatePositionsAsync() { // Create the first beacon  var beacon = await _controller.CreateBeaconAsync(null, BEACON1); Assert.NotNull(beacon); Assert.Equal(BEACON1.Udi, beacon.Udi); Assert.Equal(BEACON1.SiteId, beacon.SiteId); Assert.Equal(BEACON1.Type, beacon.Type); Assert.Equal(BEACON1.Label, beacon.Label); Assert.NotNull(beacon.Center); // Create the second beacon  beacon = await _controller.CreateBeaconAsync(null, BEACON2); Assert.NotNull(beacon); Assert.Equal(BEACON2.Udi, beacon.Udi); Assert.Equal(BEACON2.SiteId, beacon.SiteId); Assert.Equal(BEACON2.Type, beacon.Type); Assert.Equal(BEACON2.Label, beacon.Label); Assert.NotNull(beacon.Center); // Calculate position for one beacon  var position = await _controller.CalculatePositionAsync( null, \u0026#34;1\u0026#34;, new string[] { \u0026#34;00001\u0026#34; } ); Assert.NotNull(position); Assert.Equal(\u0026#34;Point\u0026#34;, position.Type); Assert.Equal(2, position.Coordinates.Length); Assert.Equal(0, position.Coordinates[0]); Assert.Equal(0, position.Coordinates[1]); // Calculate position for two beacons  position = await _controller.CalculatePositionAsync( null, \u0026#34;1\u0026#34;, new string[] { \u0026#34;00001\u0026#34;, \u0026#34;00002\u0026#34; } ); Assert.NotNull(position); Assert.Equal(\u0026#34;Point\u0026#34;, position.Type); Assert.Equal(2, position.Coordinates.Length); Assert.Equal(1, position.Coordinates[0]); Assert.Equal(1, position.Coordinates[1]); } } } These tests can be run using the same npm test command that we used to run the persistence tests.\nOur service is now just one step away from being completed! All that we have left to write is Step 5. Implementing an HTTP service.\nStep 5. Implementing an HTTP service. ","description":null,"image":null,"permalink":"/net/tutorials/data_microservice/step4/","subtitle":null,"tags":null,"title":"Step 4. Implementing a controller"},{"content":"Now that we know a bit about how we are going to be storing data and how microservice configuration works, it’s time to add some logic to our service. Our microservice needs to be able to calculate a device’s position based on the beacons it “sees”, as well as initiate CRUD operations for the data it handles. Let’s create a logic folder under the src directory and start by defining an interface:\n/src/logic/IBeaconsController.ts\nimport { FilterParams } from \u0026#39;pip-services3-commons-node\u0026#39;; import { PagingParams } from \u0026#39;pip-services3-commons-node\u0026#39;; import { DataPage } from \u0026#39;pip-services3-commons-node\u0026#39;; import { BeaconV1 } from \u0026#39;../../src/data/version1/BeaconV1\u0026#39;; export interface IBeaconsController { getBeacons(correlationId: string, filter: FilterParams, paging: PagingParams, callback: (err: any, page: DataPage\u0026lt;BeaconV1\u0026gt;) =\u0026gt; void): void; getBeaconById(correlationId: string, beaconId: string, callback: (err: any, page: BeaconV1) =\u0026gt; void): void; getBeaconByUdi(correlationId: string, beaconId: string, callback: (err: any, page: BeaconV1) =\u0026gt; void): void; calculatePosition(correlationId: string, siteId: string, udis: string[], callback: (err: any, position: any) =\u0026gt; void): void; createBeacon(correlationId: string, beacon: BeaconV1, callback: (err: any, beacon: BeaconV1) =\u0026gt; void): void; updateBeacon(correlationId: string, beacon: BeaconV1, callback: (err: any, beacon: BeaconV1) =\u0026gt; void): void; deleteBeaconById(correlationId: string, beaconId: string, callback: (err: any, beacon: BeaconV1) =\u0026gt; void): void; } Once our interface is ready, we can move on to implementing the actual controller. Its code is also going to be quite simple, as all we need to write is one method for calculating a device’s position, and the other methods will just be wrappers for the methods we wrote in our persistence components.\n/src/logic/BeaconsController.ts\nlet _ = require(\u0026#39;lodash\u0026#39;);let async = require(\u0026#39;async\u0026#39;); ‍ import { FilterParams } from \u0026#39;pip-services3-commons-node\u0026#39;; import { PagingParams } from \u0026#39;pip-services3-commons-node\u0026#39;; import { DataPage } from \u0026#39;pip-services3-commons-node\u0026#39;; import { ConfigParams } from \u0026#39;pip-services3-commons-node\u0026#39;; import { IConfigurable } from \u0026#39;pip-services3-commons-node\u0026#39;; import { Descriptor } from \u0026#39;pip-services3-commons-node\u0026#39;; import { IReferences } from \u0026#39;pip-services3-commons-node\u0026#39;; import { IReferenceable } from \u0026#39;pip-services3-commons-node\u0026#39;; import { IdGenerator } from \u0026#39;pip-services3-commons-node\u0026#39;; import { CommandSet } from \u0026#39;pip-services3-commons-node\u0026#39;; import { ICommandable } from \u0026#39;pip-services3-commons-node\u0026#39;; import { BeaconV1 } from \u0026#39;../../src/data/version1/BeaconV1\u0026#39;; import { IBeaconsPersistence } from \u0026#39;../../src/persistence/IBeaconsPersistence\u0026#39;; import { IBeaconsController } from \u0026#39;./IBeaconsController\u0026#39;; import { BeaconTypeV1 } from \u0026#39;../../src/data/version1/BeaconTypeV1\u0026#39;; import { BeaconsCommandSet } from \u0026#39;./BeaconsCommandSet\u0026#39;; ‍ export class BeaconsController implements IBeaconsController, IConfigurable, IReferenceable, ICommandable { private _persistence: IBeaconsPersistence; private _commandSet: BeaconsCommandSet; ‍ public constructor() { } ‍ public configure(config: ConfigParams): void { ‍ } ‍ public setReferences(references: IReferences): void { this._persistence = references.getOneRequired\u0026lt;IBeaconsPersistence\u0026gt;( new Descriptor(\u0026#39;beacons\u0026#39;, \u0026#39;persistence\u0026#39;, \u0026#39;*\u0026#39;, \u0026#39;*\u0026#39;, \u0026#39;1.0\u0026#39;) ); } public getCommandSet(): CommandSet { if (this._commandSet == null) { this._commandSet = new BeaconsCommandSet(this); } ‍ return this._commandSet; } ‍ public getBeacons(correlationId: string, filter: FilterParams, paging: PagingParams, callback: (err: any, page: DataPage\u0026lt;BeaconV1\u0026gt;) =\u0026gt; void): void { this._persistence.getPageByFilter(correlationId, filter, paging, callback); } ‍ public getBeaconById(correlationId: string, beaconId: string, callback: (err: any, page: BeaconV1) =\u0026gt; void): void { this._persistence.getOneById(correlationId, beaconId, callback); } ‍ public getBeaconByUdi(correlationId: string, beaconId: string, callback: (err: any, page: BeaconV1) =\u0026gt; void): void { this._persistence.getOneByUdi(correlationId, beaconId, callback); } ‍ public calculatePosition(correlationId: string, siteId: string, udis: string[], callback: (err: any, position: any) =\u0026gt; void): void { let beacons: BeaconV1[]; let position: any = null; ‍ if (udis == null || udis.length == 0) { callback(null, null); return; } ‍ async.series([ (callback) =\u0026gt; { this._persistence.getPageByFilter( correlationId, FilterParams.fromTuples( \u0026#39;site_id\u0026#39;, siteId, \u0026#39;udis\u0026#39;, udis ), null, (err, page) =\u0026gt; { beacons = page ? page.data : []; callback(err); } ); }, (callback) =\u0026gt; { let lat = 0; let lng = 0; let count = 0; ‍ for (let beacon of beacons) { if (beacon.center != null \u0026amp;\u0026amp; beacon.center.type == \u0026#39;Point\u0026#39; \u0026amp;\u0026amp; _.isArray(beacon.center.coordinates)) { lng += beacon.center.coordinates[0]; lat += beacon.center.coordinates[1]; count += 1; } } ‍ if (count \u0026gt; 0) { position = { type: \u0026#39;Point\u0026#39;, coordinates: [lng / count, lat / count] } } ‍ callback(); } ], (err) =\u0026gt; { callback(err, err == null ? position : null); }); } ‍ public createBeacon(correlationId: string, beacon: BeaconV1, callback: (err: any, beacon: BeaconV1) =\u0026gt; void): void { beacon.id = beacon.id || IdGenerator.nextLong(); beacon.type = beacon.type || BeaconTypeV1.Unknown; ‍ this._persistence.create(correlationId, beacon, callback); } ‍ public updateBeacon(correlationId: string, beacon: BeaconV1, callback: (err: any, beacon: BeaconV1) =\u0026gt; void): void { beacon.type = beacon.type || BeaconTypeV1.Unknown; ‍ this._persistence.update(correlationId, beacon, callback); } ‍ public deleteBeaconById(correlationId: string, beaconId: string, callback: (err: any, beacon: BeaconV1) =\u0026gt; void): void { this._persistence.deleteById(correlationId, beaconId, callback); } } Pay special attention to the following two methods in the code above:\n setReferences getCommandSet  The first one sets a dependency upon a persistence using the descriptor beacons:persistence:::1.0. This descriptor reads: we don’t necessarily care which persistence we are given, as long as it implements the IBeaconsPersistence interface via the Referenceable pattern. This way, our controller can be used with the memory persistence, the mongoDB one, or any other one that meets this requirement.\nThe second method is used to get a set of commands, with which we can control this controller using the Commandable pattern. In our case, it will be used by the commandable HTTP service. If you’re not yet familiar with the Commandable pattern, make sure to find some time and read about it here. To complete this pattern, lets implement a class called BeaconsCommandSet:\n/src/logic/BeaconsCommandSet.ts\nimport { CommandSet, FilterParams, PagingParams } from \u0026#39;pip-services3-commons-node\u0026#39;; import { ICommand } from \u0026#39;pip-services3-commons-node\u0026#39;; import { Command } from \u0026#39;pip-services3-commons-node\u0026#39;; import { ObjectSchema } from \u0026#39;pip-services3-commons-node\u0026#39;; import { FilterParamsSchema } from \u0026#39;pip-services3-commons-node\u0026#39;; import { PagingParamsSchema } from \u0026#39;pip-services3-commons-node\u0026#39;; import { ArraySchema } from \u0026#39;pip-services3-commons-node\u0026#39;; import { TypeCode } from \u0026#39;pip-services3-commons-node\u0026#39;; import { Parameters } from \u0026#39;pip-services3-commons-node\u0026#39;; ‍ import { BeaconV1Schema } from \u0026#39;../../src/data/version1/BeaconV1Schema\u0026#39;; import { IBeaconsController } from \u0026#39;../../src/logic/IBeaconsController\u0026#39;; ‍ export class BeaconsCommandSet extends CommandSet { private _controller: IBeaconsController; ‍ constructor(controller: IBeaconsController) { super(); ‍ this._controller = controller; ‍ this.addCommand(this.makeGetBeaconsCommand()); this.addCommand(this.makeGetBeaconByIdCommand()); this.addCommand(this.makeGetBeaconByUdiCommand()); this.addCommand(this.makeCalculatePositionCommand()); this.addCommand(this.makeCreateBeaconCommand()); this.addCommand(this.makeUpdateBeaconCommand()); this.addCommand(this.makeDeleteBeaconByIdCommand()); } private makeGetBeaconsCommand(): ICommand { return new Command( \u0026#39;get_beacons\u0026#39;, new ObjectSchema(true) .withOptionalProperty(\u0026#39;filter\u0026#39;, new FilterParamsSchema()) .withOptionalProperty(\u0026#39;paging\u0026#39;, new PagingParamsSchema()), (correlationId: string, args: Parameters, callback: (err: any, result: any) =\u0026gt; void) =\u0026gt; { let filter = FilterParams.fromValue(args.get(\u0026#39;filter\u0026#39;)); let paging = PagingParams.fromValue(args.get(\u0026#39;paging\u0026#39;)); this._controller.getBeacons(correlationId, filter, paging, callback); } ); } ‍ private makeGetBeaconByIdCommand(): ICommand { return new Command( \u0026#39;get_beacon_by_id\u0026#39;, new ObjectSchema(true) .withRequiredProperty(\u0026#39;beacon_id\u0026#39;, TypeCode.String), (correlationId: string, args: Parameters, callback: (err: any, result: any) =\u0026gt; void) =\u0026gt; { let beaconId = args.getAsString(\u0026#39;beacon_id\u0026#39;); this._controller.getBeaconById(correlationId, beaconId, callback); } ); } ‍ private makeGetBeaconByUdiCommand(): ICommand { return new Command( \u0026#39;get_beacon_by_udi\u0026#39;, new ObjectSchema(true) .withRequiredProperty(\u0026#39;udi\u0026#39;, TypeCode.String), (correlationId: string, args: Parameters, callback: (err: any, result: any) =\u0026gt; void) =\u0026gt; { let udi = args.getAsString(\u0026#39;udi\u0026#39;); this._controller.getBeaconByUdi(correlationId, udi, callback); } ); } ‍ private makeCalculatePositionCommand(): ICommand { return new Command( \u0026#39;calculate_position\u0026#39;, new ObjectSchema(true) .withRequiredProperty(\u0026#39;site_id\u0026#39;, TypeCode.String) .withRequiredProperty(\u0026#39;udis\u0026#39;, new ArraySchema(TypeCode.String)), (correlationId: string, args: Parameters, callback: (err: any, result: any) =\u0026gt; void) =\u0026gt; { let siteId = args.getAsString(\u0026#39;site_id\u0026#39;); let udis = args.getAsObject(\u0026#39;udis\u0026#39;); this._controller.calculatePosition(correlationId, siteId, udis, callback); } ); } ‍ private makeCreateBeaconCommand(): ICommand { return new Command( \u0026#39;create_beacon\u0026#39;, new ObjectSchema(true) .withRequiredProperty(\u0026#39;beacon\u0026#39;, new BeaconV1Schema()), (correlationId: string, args: Parameters, callback: (err: any, result: any) =\u0026gt; void) =\u0026gt; { let beacon = args.getAsObject(\u0026#39;beacon\u0026#39;); this._controller.createBeacon(correlationId, beacon, callback); } ); } private makeUpdateBeaconCommand(): ICommand { return new Command( \u0026#39;update_beacon\u0026#39;, new ObjectSchema(true) .withRequiredProperty(\u0026#39;beacon\u0026#39;, new BeaconV1Schema()), (correlationId: string, args: Parameters, callback: (err: any, result: any) =\u0026gt; void) =\u0026gt; { let beacon = args.getAsObject(\u0026#39;beacon\u0026#39;); this._controller.updateBeacon(correlationId, beacon, callback); } ); } private makeDeleteBeaconByIdCommand(): ICommand { return new Command( \u0026#39;delete_beacon_by_id\u0026#39;, new ObjectSchema(true) .withRequiredProperty(\u0026#39;beacon_id\u0026#39;, TypeCode.String), (correlationId: string, args: Parameters, callback: (err: any, result: any) =\u0026gt; void) =\u0026gt; { let beaconId = args.getAsString(\u0026#39;beacon_id\u0026#39;); this._controller.deleteBeaconById(correlationId, beaconId, callback); } ); } } To sum up this class’s code: we’re creating commands for each of the controller’s methods, and then registering them in the constructor. To create a command, we give it a name, a validation schema (if needed), and a callback function with the following three parameters:\n correlationId: string – used to identify the operation, args: Parameters - the set of parameters received from the command being called, callback – callback function for returning the command’s result, or an error, if one occurs.  To be sure that our new methods are working correctly, let’s add some tests for the controller. The code for testing the controller is listed below:\n/test/logic/BeaconsController.test.ts\nlet _ = require(\u0026#39;lodash\u0026#39;); let async = require(\u0026#39;async\u0026#39;); let assert = require(\u0026#39;chai\u0026#39;).assert; ‍ import { ConfigParams } from \u0026#39;pip-services3-commons-node\u0026#39;; import { Descriptor } from \u0026#39;pip-services3-commons-node\u0026#39;; import { References } from \u0026#39;pip-services3-commons-node\u0026#39;; import { FilterParams } from \u0026#39;pip-services3-commons-node\u0026#39;; import { PagingParams } from \u0026#39;pip-services3-commons-node\u0026#39;; ‍ import { BeaconV1 } from \u0026#39;../../src/data/version1/BeaconV1\u0026#39;; import { BeaconTypeV1 } from \u0026#39;../../src/data/version1/BeaconTypeV1\u0026#39;; import { BeaconsMemoryPersistence } from \u0026#39;../../src/persistence/BeaconsMemoryPersistence\u0026#39;; import { BeaconsController } from \u0026#39;../../src/logic/BeaconsController\u0026#39;; ‍ const BEACON1: BeaconV1 = { id: \u0026#39;1\u0026#39;, udi: \u0026#39;00001\u0026#39;, type: BeaconTypeV1.AltBeacon, site_id: \u0026#39;1\u0026#39;, label: \u0026#39;TestBeacon1\u0026#39;, center: { type: \u0026#39;Point\u0026#39;, coordinates: [ 0, 0 ] }, radius: 50 }; ‍ const BEACON2: BeaconV1 = { id: \u0026#39;2\u0026#39;, udi: \u0026#39;00002\u0026#39;, type: BeaconTypeV1.iBeacon, site_id: \u0026#39;1\u0026#39;, label: \u0026#39;TestBeacon2\u0026#39;, center: { type: \u0026#39;Point\u0026#39;, coordinates: [ 2, 2 ] }, radius: 70 }; ‍ suite(\u0026#39;BeaconsController\u0026#39;, () =\u0026gt; { let persistence: BeaconsMemoryPersistence; let controller: BeaconsController; ‍ setup((done) =\u0026gt; { persistence = new BeaconsMemoryPersistence(); persistence.configure(new ConfigParams()); ‍ controller = new BeaconsController(); controller.configure(new ConfigParams()); ‍ let references = References.fromTuples( new Descriptor(\u0026#39;beacons\u0026#39;, \u0026#39;persistence\u0026#39;, \u0026#39;memory\u0026#39;, \u0026#39;default\u0026#39;, \u0026#39;1.0\u0026#39;), persistence, new Descriptor(\u0026#39;beacons\u0026#39;, \u0026#39;controller\u0026#39;, \u0026#39;default\u0026#39;, \u0026#39;default\u0026#39;, \u0026#39;1.0\u0026#39;), controller ); ‍ controller.setReferences(references); ‍ persistence.open(null, done); }); ‍ teardown((done) =\u0026gt; { persistence.close(null, done); }); ‍ test(\u0026#39;CRUD Operations\u0026#39;, (done) =\u0026gt; { let beacon1: BeaconV1; ‍ async.series([ // Create the first beacon  (callback) =\u0026gt; { controller.createBeacon( null, BEACON1, (err, beacon) =\u0026gt; { assert.isNull(err); ‍ assert.isObject(beacon); assert.equal(BEACON1.udi, beacon.udi); assert.equal(BEACON1.site_id, beacon.site_id); assert.equal(BEACON1.type, beacon.type); assert.equal(BEACON1.label, beacon.label); assert.isNotNull(beacon.center); ‍ callback(); } ); }, // Create the second beacon  (callback) =\u0026gt; { controller.createBeacon( null, BEACON2, (err, beacon) =\u0026gt; { assert.isNull(err); ‍ assert.isObject(beacon); assert.equal(BEACON2.udi, beacon.udi); assert.equal(BEACON2.site_id, beacon.site_id); assert.equal(BEACON2.type, beacon.type); assert.equal(BEACON2.label, beacon.label); assert.isNotNull(beacon.center); ‍ callback(); } ); }, // Get all beacons  (callback) =\u0026gt; { controller.getBeacons( null, new FilterParams(), new PagingParams(), (err, page) =\u0026gt; { assert.isNull(err); ‍ assert.isObject(page); assert.lengthOf(page.data, 2); ‍ beacon1 = page.data[0]; ‍ callback(); } ) }, // Update the beacon  (callback) =\u0026gt; { beacon1.label = \u0026#39;ABC\u0026#39;; ‍ controller.updateBeacon( null, beacon1, (err, beacon) =\u0026gt; { assert.isNull(err); ‍ assert.isObject(beacon); assert.equal(beacon1.id, beacon.id); assert.equal(\u0026#39;ABC\u0026#39;, beacon.label); ‍ callback(); } ) }, // Get beacon by udi  (callback) =\u0026gt; { controller.getBeaconByUdi( null, beacon1.udi, (err, beacon) =\u0026gt; { assert.isNull(err); ‍ assert.isObject(beacon); assert.equal(beacon1.id, beacon.id); ‍ callback(); } ) }, // Delete the beacon  (callback) =\u0026gt; { controller.deleteBeaconById( null, beacon1.id, (err, beacon) =\u0026gt; { assert.isNull(err); ‍ assert.isObject(beacon); assert.equal(beacon1.id, beacon.id); ‍ callback(); } ) }, // Try to get deleted beacon  (callback) =\u0026gt; { controller.getBeaconById( null, beacon1.id, (err, beacon) =\u0026gt; { assert.isNull(err); ‍ assert.isNull(beacon || null); ‍ callback(); } ) } ], done); }); test(\u0026#39;Calculate Positions\u0026#39;, (done) =\u0026gt; { async.series([ // Create the first beacon  (callback) =\u0026gt; { controller.createBeacon( null, BEACON1, (err, beacon) =\u0026gt; { assert.isNull(err); ‍ assert.isObject(beacon); assert.equal(BEACON1.udi, beacon.udi); assert.equal(BEACON1.site_id, beacon.site_id); assert.equal(BEACON1.type, beacon.type); assert.equal(BEACON1.label, beacon.label); assert.isNotNull(beacon.center); ‍ callback(); } ); }, // Create the second beacon  (callback) =\u0026gt; { controller.createBeacon( null, BEACON2, (err, beacon) =\u0026gt; { assert.isNull(err); ‍ assert.isObject(beacon); assert.equal(BEACON2.udi, beacon.udi); assert.equal(BEACON2.site_id, beacon.site_id); assert.equal(BEACON2.type, beacon.type); assert.equal(BEACON2.label, beacon.label); assert.isNotNull(beacon.center); ‍ callback(); } ); }, // Calculate position for one beacon  (callback) =\u0026gt; { controller.calculatePosition( null, \u0026#39;1\u0026#39;, [\u0026#39;00001\u0026#39;], (err, position) =\u0026gt; { assert.isNull(err); ‍ assert.isObject(position); assert.equal(\u0026#39;Point\u0026#39;, position.type); assert.lengthOf(position.coordinates, 2); assert.equal(0, position.coordinates[0]); assert.equal(0, position.coordinates[1]); ‍ callback(); } ) }, // Calculate position for two beacons  (callback) =\u0026gt; { controller.calculatePosition( null, \u0026#39;1\u0026#39;, [\u0026#39;00001\u0026#39;, \u0026#39;00002\u0026#39;], (err, position) =\u0026gt; { assert.isNull(err); ‍ assert.isObject(position); assert.equal(\u0026#39;Point\u0026#39;, position.type); assert.lengthOf(position.coordinates, 2); assert.equal(1, position.coordinates[0]); assert.equal(1, position.coordinates[1]); ‍ callback(); } ) } ], done); }); }); These tests can be run using the same npm test command that we used to run the persistence tests.\nOur service is now just one step away from being completed! All that we have left to write is Step 5. Implementing an HTTP service.\nStep 5. Implementing an HTTP service. ","description":null,"image":null,"permalink":"/node/tutorials/data_microservice/step4/","subtitle":null,"tags":null,"title":"Step 4. Implementing a controller"},{"content":"Now that we know a bit about how we are going to be storing data and how microservice configuration works, it’s time to add some logic to our service. Our microservice needs to be able to calculate a device’s position based on the beacons it “sees”, as well as initiate CRUD operations for the data it handles. Let’s create a logic folder under the src directory and start by defining an interface:\n/src/logic/IBeaconsController.py\nfrom typing import Any, List, Optional from pip_services3_commons.data import PagingParams, FilterParams, DataPage from src.data.version1 import BeaconV1 class IBeaconsController: def get_beacons_by_filter(self, correlation_id: Optional[str], filter: FilterParams, paging: PagingParams) -\u0026gt; DataPage: raise NotImplementedError(\u0026#39;Method from interface definition\u0026#39;) def get_beacon_by_id(self, correlation_id: Optional[str], id: str) -\u0026gt; BeaconV1: raise NotImplementedError(\u0026#39;Method from interface definition\u0026#39;) def get_beacon_by_udi(self, correlation_id: Optional[str], udi: str) -\u0026gt; BeaconV1: raise NotImplementedError(\u0026#39;Method from interface definition\u0026#39;) def calculate_position(self, correlation_id: Optional[str], site_id: str, udis: List[str]) -\u0026gt; Any: raise NotImplementedError(\u0026#39;Method from interface definition\u0026#39;) def create_beacon(self, correlation_id: Optional[str], entity: BeaconV1) -\u0026gt; BeaconV1: raise NotImplementedError(\u0026#39;Method from interface definition\u0026#39;) def update_beacon(self, correlation_id: Optional[str], entity: BeaconV1) -\u0026gt; BeaconV1: raise NotImplementedError(\u0026#39;Method from interface definition\u0026#39;) def delete_beacon_by_id(self, correlation_id: Optional[str], id: str) -\u0026gt; BeaconV1: raise NotImplementedError(\u0026#39;Method from interface definition\u0026#39;) Once our interface is ready, we can move on to implementing the actual controller. Its code is also going to be quite simple, as all we need to write is one method for calculating a device’s position, and the other methods will just be wrappers for the methods we wrote in our persistence components.\n/src/logic/BeaconsController.py\nfrom typing import List, Any, Optional from pip_services3_commons.commands import ICommandable, CommandSet from pip_services3_commons.config import IConfigurable, ConfigParams from pip_services3_commons.data import FilterParams, PagingParams, DataPage from pip_services3_commons.refer import IReferenceable, Descriptor, IReferences from ..data.version1 import BeaconV1 from ..logic.BeaconsCommandSet import BeaconsCommandSet from ..logic.IBeaconsController import IBeaconsController from ..persistence import IBeaconsPersistence class BeaconsController(IBeaconsController, IConfigurable, IReferenceable, ICommandable): def __init__(self): self.__persistence: IBeaconsPersistence = None self.__command_set: BeaconsCommandSet = None def configure(self, config: ConfigParams): pass def get_command_set(self) -\u0026gt; CommandSet: if self.__command_set is None: self.__command_set = BeaconsCommandSet(self) return self.__command_set def set_references(self, references: IReferences): self.__persistence = references.get_one_required(Descriptor(\u0026#34;beacons\u0026#34;, \u0026#34;persistence\u0026#34;, \u0026#34;*\u0026#34;, \u0026#34;*\u0026#34;, \u0026#34;1.0\u0026#34;)) def get_beacons_by_filter(self, correlation_id: Optional[str], filter: FilterParams, paging: PagingParams) -\u0026gt; DataPage: return self.__persistence.get_page_by_filter(correlation_id, filter, paging) def get_beacon_by_id(self, correlation_id: Optional[str], id: str) -\u0026gt; BeaconV1: return self.__persistence.get_one_by_id(correlation_id, id) def get_beacon_by_udi(self, correlation_id: Optional[str], udi: str) -\u0026gt; BeaconV1: return self.__persistence.get_one_by_udi(correlation_id, udi) def calculate_position(self, correlation_id: Optional[str], site_id: str, udis: List[str]) -\u0026gt; Any: if udis is None or len(udis) == 0: return None result = self.__persistence.get_page_by_filter(correlation_id, FilterParams.from_tuples(\u0026#34;site_id\u0026#34;, site_id, \u0026#34;udis\u0026#34;, udis), None) beacons = result.data lat = 0 lng = 0 count = 0 for beacon in beacons: if beacon.center is not None and beacon.center[\u0026#39;type\u0026#39;] == \u0026#34;Point\u0026#34; and len( beacon.center[\u0026#39;coordinates\u0026#39;]) \u0026gt; 1: lng = lng + beacon.center[\u0026#39;coordinates\u0026#39;][0] lat = lat + beacon.center[\u0026#39;coordinates\u0026#39;][1] count = count + 1 if count == 0: return None position = {\u0026#34;type\u0026#34;: \u0026#39;Point\u0026#39;, \u0026#34;coordinates\u0026#34;: [lng / count, lat / count]} return position def create_beacon(self, correlation_id: Optional[str], entity: BeaconV1) -\u0026gt; BeaconV1: return self.__persistence.create(correlation_id, entity) def update_beacon(self, correlation_id: Optional[str], entity: BeaconV1) -\u0026gt; BeaconV1: return self.__persistence.update(correlation_id, entity) def delete_beacon_by_id(self, correlation_id: Optional[str], id: str) -\u0026gt; BeaconV1: return self.__persistence.delete_by_id(correlation_id, id) Pay special attention to the following two methods in the code above:\n set_references get_command_set  The first one sets a dependency upon a persistence using the descriptor beacons:persistence:::1.0. This descriptor reads: we don’t necessarily care which persistence we are given, as long as it implements the IBeaconsPersistence interface via the Referenceable pattern. This way, our controller can be used with the memory persistence, the mongoDB one, or any other one that meets this requirement.\nThe second method is used to get a set of commands, with which we can control this controller using the Commandable pattern. In our case, it will be used by the commandable HTTP service. If you’re not yet familiar with the Commandable pattern, make sure to find some time and read about it here. To complete this pattern, lets implement a class called BeaconsCommandSet:\n/src/logic/BeaconsCommandSet.py\nfrom pip_services3_commons.commands import CommandSet, Command, ICommand from pip_services3_commons.convert import TypeCode from pip_services3_commons.data import FilterParams, PagingParams from pip_services3_commons.validate import ObjectSchema, FilterParamsSchema, PagingParamsSchema, ArraySchema from . import IBeaconsController from ..data.version1 import BeaconV1Schema class BeaconsCommandSet(CommandSet): def __init__(self, controller: IBeaconsController): super(BeaconsCommandSet, self).__init__() self.__controller: IBeaconsController = controller self.add_command(self.__make_get_beacons_command()) self.add_command(self.__make_get_beacon_by_id_command()) self.add_command(self.__make_get_beacon_by_udi_command()) self.add_command(self.__make_calculate_position_command()) self.add_command(self.__make_create_beacon_command()) self.add_command(self.__make_update_beacon_command()) self.add_command(self.__make_delete_beacon_by_id_command()) def __make_get_beacons_command(self) -\u0026gt; ICommand: def handler(correlation_id, args): filter = FilterParams.from_value(args.get(\u0026#34;filter\u0026#34;)) paging = PagingParams.from_value(args.get(\u0026#34;paging\u0026#34;)) return self.__controller.get_beacons_by_filter(correlation_id, filter, paging) return Command(\u0026#34;get_beacons\u0026#34;, ObjectSchema().with_optional_property(\u0026#34;filter\u0026#34;, FilterParamsSchema()) .with_optional_property(\u0026#34;paging\u0026#34;, PagingParamsSchema()), handler) def __make_get_beacon_by_id_command(self) -\u0026gt; ICommand: def handler(correlation_id, args): id = args.get_as_string(\u0026#34;id\u0026#34;) return self.__controller.get_beacon_by_id(correlation_id, id) return Command(\u0026#34;get_beacon_by_id\u0026#34;, ObjectSchema().with_required_property(\u0026#34;id\u0026#34;, TypeCode.String), handler) def __make_get_beacon_by_udi_command(self) -\u0026gt; ICommand: def handler(correlation_id, args): id = args.get_as_string(\u0026#34;udi\u0026#34;) return self.__controller.get_beacon_by_udi(correlation_id, id) return Command(\u0026#34;get_beacon_by_udi\u0026#34;, ObjectSchema().with_required_property(\u0026#34;udi\u0026#34;, TypeCode.String), handler) def __make_calculate_position_command(self) -\u0026gt; ICommand: def handler(correlation_id, args): site_id = args.get_as_string(\u0026#34;site_id\u0026#34;) udis = args.get_as_nullable_string(\u0026#34;udis\u0026#34;) return self.__controller.calculate_position(correlation_id, site_id, udis) return Command(\u0026#34;calculate_position\u0026#34;, ObjectSchema().with_required_property(\u0026#34;site_id\u0026#34;, TypeCode.String) .with_required_property(\u0026#34;udis\u0026#34;, ArraySchema(\u0026#34;String\u0026#34;)), handler) def __make_create_beacon_command(self) -\u0026gt; ICommand: def handler(correlation_id, args): entity = args.get(\u0026#34;beacon\u0026#34;) return self.__controller.create_beacon(correlation_id, entity) return Command(\u0026#34;create_beacon\u0026#34;, ObjectSchema().with_optional_property(\u0026#34;beacon\u0026#34;, BeaconV1Schema()), handler) def __make_update_beacon_command(self) -\u0026gt; ICommand: def handler(correlation_id, args): entity = args.get(\u0026#34;beacon\u0026#34;) return self.__controller.update_beacon(correlation_id, entity) return Command(\u0026#34;update_beacon\u0026#34;, ObjectSchema().with_optional_property(\u0026#34;beacon\u0026#34;, BeaconV1Schema()), handler) def __make_delete_beacon_by_id_command(self) -\u0026gt; ICommand: def handler(correlation_id, args): id = args.get_as_string(\u0026#34;id\u0026#34;) return self.__controller.delete_beacon_by_id(correlation_id, id) return Command(\u0026#34;delete_beacon_by_id\u0026#34;, ObjectSchema().with_required_property(\u0026#34;id\u0026#34;, TypeCode.String), handler) To sum up this class’s code: we’re creating commands for each of the controller’s methods, and then registering them in the constructor. To create a command, we give it a name, a validation schema (if needed), and a callback function with the following three parameters:\n correlationId: string – used to identify the operation, args: Parameters - the set of parameters received from the command being called, callback – callback function for returning the command’s result, or an error, if one occurs.  To be sure that our new methods are working correctly, let’s add some tests for the controller. The code for testing the controller is listed below:\n/test/logic/test_BeaconsController.py\nfrom pip_services3_commons.data import FilterParams, PagingParams from pip_services3_commons.refer import References, Descriptor from src.data.version1 import BeaconV1, BeaconTypeV1 from src.logic.BeaconsController import BeaconsController from src.persistence.BeaconsMemoryPersistence import BeaconsMemoryPersistence BEACON1 = BeaconV1(\u0026#34;1\u0026#34;, \u0026#34;1\u0026#34;, BeaconTypeV1.AltBeacon, \u0026#34;00001\u0026#34;, \u0026#34;TestBeacon1\u0026#34;, {\u0026#34;type\u0026#34;: \u0026#39;Point\u0026#39;, \u0026#34;coordinates\u0026#34;: [0, 0]}, 50) BEACON2 = BeaconV1(\u0026#34;2\u0026#34;, \u0026#34;1\u0026#34;, BeaconTypeV1.iBeacon, \u0026#34;00002\u0026#34;, \u0026#34;TestBeacon2\u0026#34;, {\u0026#34;type\u0026#34;: \u0026#39;Point\u0026#39;, \u0026#34;coordinates\u0026#34;: [2, 2]}, 70) BEACON3 = BeaconV1(\u0026#34;3\u0026#34;, \u0026#34;2\u0026#34;, BeaconTypeV1.AltBeacon, \u0026#34;00003\u0026#34;, \u0026#34;TestBeacon3\u0026#34;, {\u0026#34;type\u0026#34;: \u0026#39;Point\u0026#39;, \u0026#34;coordinates\u0026#34;: [10, 10]}, 50) class TestBeaconsController(): _persistence: BeaconsMemoryPersistence _controller: BeaconsController @classmethod def setup_class(cls): cls._persistence = BeaconsMemoryPersistence() cls._controller = BeaconsController() references = References.from_tuples(Descriptor(\u0026#39;beacons\u0026#39;, \u0026#39;persistence\u0026#39;, \u0026#39;memory\u0026#39;, \u0026#39;default\u0026#39;, \u0026#39;1.0\u0026#39;), cls._persistence, Descriptor(\u0026#39;beacons\u0026#39;, \u0026#39;controller\u0026#39;, \u0026#39;default\u0026#39;, \u0026#39;default\u0026#39;, \u0026#39;1.0\u0026#39;), cls._controller) cls._controller.set_references(references) cls._persistence.open(None) @classmethod def teardown_class(cls): cls._persistence.close(None) def test_crud_operations(self): # Create the first beacon beacon1 = self._controller.create_beacon(None, BEACON1) assert beacon1 is not None assert beacon1.id == BEACON1.id assert beacon1.site_id == BEACON1.site_id assert beacon1.udi == BEACON1.udi assert beacon1.type == BEACON1.type assert beacon1.label == BEACON1.label assert beacon1.center is not None # Create the second beacon beacon2 = self._controller.create_beacon(None, BEACON2) assert beacon2 is not None assert beacon2.id == BEACON2.id assert beacon2.site_id == BEACON2.site_id assert beacon2.udi == BEACON2.udi assert beacon2.type == BEACON2.type assert beacon2.label == BEACON2.label assert beacon2.center is not None # Get all beacons page = self._controller.get_beacons_by_filter(None, FilterParams(), PagingParams()) assert page is not None assert len(page.data) == 2 beacon1 = page.data[0] # Update the beacon beacon1.label = \u0026#34;ABC\u0026#34; beacon = self._controller.update_beacon(None, beacon1) assert beacon is not None assert beacon1.id == beacon.id assert \u0026#34;ABC\u0026#34; == beacon.label # Get beacon by udi beacon = self._controller.get_beacon_by_udi(None, beacon1.udi) assert beacon is not None assert beacon.id == beacon1.id # Delete beacon self._controller.delete_beacon_by_id(None, beacon1.id) # Try to get deleted beacon beacon = self._controller.get_beacon_by_id(None, beacon1.id) assert beacon is None def test_calculate_position(self): # Create the first beacon beacon1 = self._controller.create_beacon(None, BEACON1) assert beacon1 is not None assert beacon1.id == BEACON1.id assert beacon1.site_id == BEACON1.site_id assert beacon1.udi == BEACON1.udi assert beacon1.type == BEACON1.type assert beacon1.label == BEACON1.label assert beacon1.center is not None # Create the second beacon beacon2 = self._controller.create_beacon(None, BEACON2) assert beacon2 is not None assert beacon2.id == BEACON2.id assert beacon2.site_id == BEACON2.site_id assert beacon2.udi == BEACON2.udi assert beacon2.type == BEACON2.type assert beacon2.label == BEACON2.label assert beacon2.center is not None # Calculate position for one beacon position = self._controller.calculate_position(None, \u0026#39;1\u0026#39;, [\u0026#39;00001\u0026#39;]) assert position is not None assert \u0026#34;Point\u0026#34; == position[\u0026#34;type\u0026#34;] assert 2 == len(position[\u0026#34;coordinates\u0026#34;]) These tests can be run using the same npm test command that we used to run the persistence tests.\nOur service is now just one step away from being completed! All that we have left to write is Step 5. Implementing an HTTP service.\nStep 5. Implementing an HTTP service. ","description":null,"image":null,"permalink":"/python/tutorials/data_microservice/step4/","subtitle":null,"tags":null,"title":"Step 4. Implementing a controller"},{"content":"Complex systems usually experience difficulties when it comes to writing unit tests for a logic that calls external services. These tests are supposed to run quickly and without any additional infrastructure. The standard approach to solving this problem is to replace the calls to external services with a local approximation (a.k.a. a mock). However, writing mocks takes time and doesn’t always guarantee functionality that matches the real service.\nIn our projects, we’ve come to the conclusion that it pays off to develop mocks alongside the real clients and test them using common tests, to guarantee that their behavior is identical. This way, all users of the microservice will receive both the client and mock from the library and will be able to start coding logic and unit tests for it without delay.\nIn this step we will be demonstrating how Mock clients are developed and how they can be tested using the tests we created earlier.\nThe test client has to implement the same interface that the other clients did. However, the client’s methods are going to contain code that only imitates the microservice’s behavior.\nThe code for this client is showed below:\n/src/version1/BeaconsMockClientV1.cs\npublic class BeaconsMockClientV1 : IBeaconsClientV1 { protected int maxPageSize = 100; protected List\u0026lt;BeaconV1\u0026gt; _items = new List\u0026lt;BeaconV1\u0026gt;(); private Func\u0026lt;BeaconV1, bool\u0026gt; ComposeFilter(FilterParams filter) { filter = filter ?? new FilterParams(); var id = filter.GetAsNullableString(\u0026#34;id\u0026#34;); var siteId = filter.GetAsNullableString(\u0026#34;site_id\u0026#34;); var label = filter.GetAsNullableString(\u0026#34;label\u0026#34;); var udi = filter.GetAsNullableString(\u0026#34;udi\u0026#34;); var udis = filter.GetAsNullableString(\u0026#34;udis\u0026#34;); var udiList = udis != null ? udis.Split(\u0026#39;,\u0026#39;) : null; return (item) =\u0026gt; { if (id != null \u0026amp;\u0026amp; item.Id != id) return false; if (siteId != null \u0026amp;\u0026amp; item.SiteId != siteId) return false; if (label != null \u0026amp;\u0026amp; item.Label != label) return false; if (udi != null \u0026amp;\u0026amp; item.Udi != udi) return false; if (udiList != null \u0026amp;\u0026amp; !udiList.Contains(item.Udi)) return false; return true; }; } public async Task\u0026lt;DataPage\u0026lt;BeaconV1\u0026gt;\u0026gt; GetBeaconsAsync(string correlationId, FilterParams filter, PagingParams paging) { var filterBeacons = ComposeFilter(filter); var beacons = _items.FindAll(beacon =\u0026gt; filterBeacons(beacon)); paging = paging ?? new PagingParams(); var skip = Convert.ToInt32(paging.GetSkip(-1)); var take = Convert.ToInt32(paging.GetTake(maxPageSize)); long? total = null; if (paging.Total) total = beacons.Count(); if (skip \u0026gt; 0) beacons = beacons.Skip(skip).Take(take).ToList(); var page = await Task.FromResult(new DataPage\u0026lt;BeaconV1\u0026gt;(beacons, total)); return page; } public async Task\u0026lt;BeaconV1\u0026gt; GetBeaconByIdAsync(string correlationId, string id) { var beacons = await Task.FromResult(_items.Find(beacon =\u0026gt; beacon.Id == id)); return beacons; } public async Task\u0026lt;BeaconV1\u0026gt; GetBeaconByUdiAsync(string correlationId, string udi) { var beacons = await Task.FromResult(_items.Find(beacon =\u0026gt; beacon.Udi == udi)); return beacons; } public async Task\u0026lt;CenterObjectV1\u0026gt; CalculatePositionAsync(string correlationId, string siteId, string[] udis) { List\u0026lt;BeaconV1\u0026gt; beacons; var page = await GetBeaconsAsync(correlationId, FilterParams.FromTuples( \u0026#34;site_id\u0026#34;, siteId, \u0026#34;udis\u0026#34;, udis), null); beacons = page.Data ?? new List\u0026lt;BeaconV1\u0026gt;(); double lat = 0; double lng = 0; double count = 0; foreach (BeaconV1 beacon in beacons) { if (beacon.Center != null \u0026amp;\u0026amp; beacon.Center.Type == \u0026#34;Point\u0026#34; \u0026amp;\u0026amp; beacon.Center.Coordinates.Length \u0026gt; 1) { lng = lng + beacon.Center.Coordinates[0]; lat = lat + beacon.Center.Coordinates[1]; count = count + 1; } } if (count \u0026gt; 0) return new CenterObjectV1() { Coordinates = new double[] { lng / count, lat / count }, Type = \u0026#34;Point\u0026#34; }; return null; } public async Task\u0026lt;BeaconV1\u0026gt; CreateBeaconAsync(string correlationId, BeaconV1 beacon) { if (beacon == null) return null; beacon.Id = beacon.Id ?? IdGenerator.NextLong(); _items.Add(beacon); return await Task.FromResult(beacon); } public async Task\u0026lt;BeaconV1\u0026gt; UpdateBeaconAsync(string correlationId, BeaconV1 beacon) { var index = _items.FindIndex(el =\u0026gt; el.Id == beacon.Id); if (index \u0026lt; 0) return null; _items[index] = beacon; return await Task.FromResult(beacon); } public async Task\u0026lt;BeaconV1\u0026gt; DeleteBeaconByIdAsync(string correlationId, string id) { var index = _items.FindIndex(el =\u0026gt; el.Id == id); if (index \u0026lt; 0) return null; var deletedBeacon = _items[index]; _items.RemoveAt(index); return await Task.FromResult(deletedBeacon); } } Now let’s test the client we’ve created. We’ll be using the set of tests that we developed in one of the previous steps, and adding just one test file that will bring it all together. The source of this file is presented below:\n/test/version1/test_BeaconsMockClientV1.cs\n[Collection(\u0026#34;Sequential\u0026#34;)] public class BeaconsMockClientV1Test { private BeaconsMockClientV1 _client; private BeaconsClientV1Fixture _fixture; public BeaconsMockClientV1Test() { _client = new BeaconsMockClientV1(); _fixture = new BeaconsClientV1Fixture(_client); } [Fact] public async Task TestCrudOperationsAsync() { await _fixture.TestCrudOperationsAsync(); } [Fact] public async Task TestCalculatePositionsAsync() { await _fixture.TestCalculatePositionsAsync(); } } Create a file with the tests and run them. All the tests should pass, even though the server-side code wasn’t actually used anywhere.\nThis technique becomes very useful when developing microservices that bring together multiple microservices by means of their clients (e.g. a facade microservice). It allows us to perform functional testing without having to run the entire infrastructure.\nTo performing non-fuctional testing, we need to generate a large amount of realistic data. Users usually don’t know the entire data structure with all of its variations and exceptions. The next component we will be adding to our client library is a random data generator. This component can be used by the microservice’s users to create quality tests. The implementation is usually done in the form of static methods that either return an entire object, or just some part of its parameters. Let’s take a look at what an implementation of such a generator for the BeaconsV1 data object would look like. The generator’s code is listed below:\npublic class RandomBeaconV1 { public static BeaconV1 NextBeacon(int siteCount = 100) { return new BeaconV1() { Id = IdGenerator.NextLong(), SiteId = NextSiteId(siteCount), Udi = IdGenerator.NextShort(), Label = RandomString.NextString(10, 25), Type = NextBeaconType(), Radius = RandomFloat.NextFloat(3, 150), Center = NextPosition() }; } public static string NextSiteId(int siteCount = 100) { return RandomInteger.NextInteger(1, siteCount).ToString(); } public static string NextBeaconType() { var choice = RandomInteger.NextInteger(0, 3); switch (choice) { case 0: return BeaconTypeV1.iBeacon; case 1: return BeaconTypeV1.AltBeacon; case 2: return BeaconTypeV1.EddyStoneUdi; case 3: return BeaconTypeV1.Unknown; default: return BeaconTypeV1.Unknown; } } public static CenterObjectV1 NextPosition() { return new CenterObjectV1 { Type = \u0026#34;Point\u0026#34;, Coordinates = new double[] { RandomFloat.NextFloat(-180, 168), // Longitude  RandomFloat.NextFloat(-90, 90), // Latitude  } }; } } In this implementation, the ranges of generated values are statically set, but they can be passed as parameters to the methods and dynamically set as needed. Using this instrument, we can easily generate large volumes of realistic data. This, in turn, can be used to test, for example, how fast the system can create elements in the persistence it’s using.\nIn the Step 5. Testing the Client with a Remote Microservice, we’ll be taking a look at how to test our client using a microservice that is remotely deployed in a Docker container.\nStep 5. Testing the Client with a Remote Microservice  ","description":null,"image":null,"permalink":"/net/tutorials/client_library/step4/","subtitle":null,"tags":null,"title":"Step 4. Implementing Mock Client"},{"content":"Complex systems usually experience difficulties when it comes to writing unit tests for a logic that calls external services. These tests are supposed to run quickly and without any additional infrastructure. The standard approach to solving this problem is to replace the calls to external services with a local approximation (a.k.a. a mock). However, writing mocks takes time and doesn’t always guarantee functionality that matches the real service.\nIn our projects, we’ve come to the conclusion that it pays off to develop mocks alongside the real clients and test them using common tests, to guarantee that their behavior is identical. This way, all users of the microservice will receive both the client and mock from the library and will be able to start coding logic and unit tests for it without delay.\nIn this step we will be demonstrating how Mock clients are developed and how they can be tested using the tests we created earlier.\nThe test client has to implement the same interface that the other clients did. However, the client’s methods are going to contain code that only imitates the microservice’s behavior.\nThe code for this client is showed below:\n/src/version1/BeaconsMockClientV1.ts\nlet _ = require(\u0026#39;lodash\u0026#39;); let async = require(\u0026#39;async\u0026#39;); import { FilterParams, IdGenerator } from \u0026#39;pip-services3-commons-node\u0026#39;; import { PagingParams } from \u0026#39;pip-services3-commons-node\u0026#39;; import { DataPage } from \u0026#39;pip-services3-commons-node\u0026#39;; import { BeaconV1 } from \u0026#39;./BeaconV1\u0026#39;; import { IBeaconsClientV1 } from \u0026#39;./IBeaconsClientV1\u0026#39;; export class BeaconsMockClientV1 implements IBeaconsClientV1 { private _maxPageSize: number = 100; private _items: BeaconV1[]; public constructor(...items: BeaconV1[]) { this._items = items; } private composeFilter(filter: FilterParams): any { filter = filter || new FilterParams(); let id = filter.getAsNullableString(\u0026#39;id\u0026#39;); let siteId = filter.getAsNullableString(\u0026#39;site_id\u0026#39;); let label = filter.getAsNullableString(\u0026#39;label\u0026#39;); let udi = filter.getAsNullableString(\u0026#39;udi\u0026#39;); let udis = filter.getAsObject(\u0026#39;udis\u0026#39;); if (_.isString(udis)) udis = udis.split(\u0026#39;,\u0026#39;); if (!_.isArray(udis)) udis = null; return (item) =\u0026gt; { if (id != null \u0026amp;\u0026amp; item.id != id) return false; if (siteId != null \u0026amp;\u0026amp; item.site_id != siteId) return false; if (label != null \u0026amp;\u0026amp; item.label != label) return false; if (udi != null \u0026amp;\u0026amp; item.udi != udi) return false; if (udis != null \u0026amp;\u0026amp; _.indexOf(udis, item.udi) \u0026lt; 0) return false; return true; }; } public getBeacons(correlationId: string, filter: FilterParams, paging: PagingParams, callback: (err: any, page: DataPage\u0026lt;BeaconV1\u0026gt;) =\u0026gt; void): void { let filterBeacons = this.composeFilter(filter); let beacons = _.filter(this._items, filterBeacons); // Extract a page  paging = paging != null ? paging : new PagingParams(); let skip = paging.getSkip(-1); let take = paging.getTake(this._maxPageSize); let total = null; if (paging.total) total = beacons.length; if (skip \u0026gt; 0) beacons = _.slice(beacons, skip); beacons = _.take(beacons, take); let page = new DataPage\u0026lt;BeaconV1\u0026gt;(beacons, total); callback(null, page); } public getBeaconById(correlationId: string, beaconId: string, callback: (err: any, beacon: BeaconV1) =\u0026gt; void): void { let beacons = this._items.filter((x) =\u0026gt; { return x.id == beaconId; }); let beacon = beacons.length \u0026gt; 0 ? beacons[0] : null; callback(null, beacon); } public getBeaconByUdi(correlationId: string, udi: string, callback: (err: any, beacon: BeaconV1) =\u0026gt; void): void { let beacons = this._items.filter((x) =\u0026gt; { return x.udi == udi; }); let beacon = beacons.length \u0026gt; 0 ? beacons[0] : null; callback(null, beacon); } public calculatePosition(correlationId: string, siteId: string, udis: string[], callback: (err: any, position: any) =\u0026gt; void): void { let beacons: BeaconV1[]; let position: any = null; if (udis == null || udis.length == 0) { callback(null, null); return; } async.series([ (callback) =\u0026gt; { this.getBeacons( correlationId, FilterParams.fromTuples( \u0026#39;site_id\u0026#39;, siteId, \u0026#39;udis\u0026#39;, udis ), null, (err, page) =\u0026gt; { beacons = page ? page.data : []; callback(err); } ); }, (callback) =\u0026gt; { let lat = 0; let lng = 0; let count = 0; for (let beacon of beacons) { if (beacon.center != null \u0026amp;\u0026amp; beacon.center.type == \u0026#39;Point\u0026#39; \u0026amp;\u0026amp; _.isArray(beacon.center.coordinates)) { lng += beacon.center.coordinates[0]; lat += beacon.center.coordinates[1]; count += 1; } } if (count \u0026gt; 0) { position = { type: \u0026#39;Point\u0026#39;, coordinates: [lng / count, lat / count] } } callback(); } ], (err) =\u0026gt; { callback(err, err == null ? position : null); }); } public createBeacon(correlationId: string, beacon: BeaconV1, callback: (err: any, beacon: BeaconV1) =\u0026gt; void): void { if (beacon == null) { if (callback) callback(null, null); return; } beacon = _.clone(beacon); beacon.id = beacon.id || IdGenerator.nextLong(); this._items.push(beacon); if (callback) callback(null, beacon) } public updateBeacon(correlationId: string, beacon: BeaconV1, callback: (err: any, beacon: BeaconV1) =\u0026gt; void): void { let index = this._items.map((x) =\u0026gt; { return x.id; }).indexOf(beacon.id); if (index \u0026lt; 0) { callback(null, null); return; } beacon = _.clone(beacon); this._items[index] = beacon; if (callback) callback(null, beacon) } public deleteBeaconById(correlationId: string, beaconId: string, callback: (err: any, beacon: BeaconV1) =\u0026gt; void): void { var index = this._items.map((x) =\u0026gt; { return x.id; }).indexOf(beaconId); var item = this._items[index]; if (index \u0026lt; 0) { callback(null, null); return; } this._items.splice(index, 1); if (callback) callback(null, item) } } Now let’s test the client we’ve created. We’ll be using the set of tests that we developed in one of the previous steps, and adding just one test file that will bring it all together. The source of this file is presented below:\n/test/version1/BeaconsMockClient.test.ts\nimport { BeaconsMockClientV1 } from \u0026#39;../../src/version1/BeaconsMockClientV1\u0026#39;; import { BeaconsClientV1Fixture } from \u0026#39;./BeaconsClientV1Fixture\u0026#39;; suite(\u0026#39;BeaconsMockClientV1\u0026#39;, () =\u0026gt; { let client: BeaconsMockClientV1; let fixture: BeaconsClientV1Fixture; setup((done) =\u0026gt; { client = new BeaconsMockClientV1(); fixture = new BeaconsClientV1Fixture(client); done(); }); teardown((done) =\u0026gt; { done(); }); test(\u0026#39;CRUD Operations\u0026#39;, (done) =\u0026gt; { fixture.testCrudOperations(done); }); test(\u0026#39;Calculate Positions\u0026#39;, (done) =\u0026gt; { fixture.testCalculatePosition(done); }); }); Create a file with the tests and run them. All the tests should pass, even though the server-side code wasn’t actually used anywhere.\nThis technique becomes very useful when developing microservices that bring together multiple microservices by means of their clients (e.g. a facade microservice). It allows us to perform functional testing without having to run the entire infrastructure.\nTo performing non-fuctional testing, we need to generate a large amount of realistic data. Users usually don’t know the entire data structure with all of its variations and exceptions. The next component we will be adding to our client library is a random data generator. This component can be used by the microservice’s users to create quality tests. The implementation is usually done in the form of static methods that either return an entire object, or just some part of its parameters. Let’s take a look at what an implementation of such a generator for the BeaconsV1 data object would look like. The generator’s code is listed below:\nimport { RandomArray, RandomInteger } from \u0026#39;pip-services3-commons-node\u0026#39;; import { BeaconV1 } from \u0026#39;./BeaconV1\u0026#39; import { BeaconTypeV1 } from \u0026#39;./BeaconTypeV1\u0026#39; export class RandomBeaconV1 { public static nextBeaconType(): string { return RandomArray.pick([BeaconTypeV1.AltBeacon, BeaconTypeV1.EddyStoneUdi, BeaconTypeV1.Unknown, BeaconTypeV1.iBeacon]); } public static nextBeaconCenter(): any { return { type: \u0026#39;Point\u0026#39;, center: { coordinates: [RandomInteger.nextInteger(1, 1000), RandomInteger.nextInteger(1, 1000)] } } } public static nextBeacon(): BeaconV1 { var beacon = new BeaconV1(); beacon.type = RandomBeaconV1.nextBeaconType(); beacon.radius = RandomInteger.nextInteger(1, 1000); beacon.udi = RandomArray.pick([\u0026#39;00001\u0026#39;, \u0026#39;00002\u0026#39;, \u0026#39;00003\u0026#39;, \u0026#39;00004\u0026#39;]); beacon.center = RandomBeaconV1.nextBeaconCenter(); return beacon; } } In this implementation, the ranges of generated values are statically set, but they can be passed as parameters to the methods and dynamically set as needed. Using this instrument, we can easily generate large volumes of realistic data. This, in turn, can be used to test, for example, how fast the system can create elements in the persistence it’s using.\nIn the Step 5. Testing the Client with a Remote Microservice, we’ll be taking a look at how to test our client using a microservice that is remotely deployed in a Docker container.\nStep 5. Testing the Client with a Remote Microservice  ","description":null,"image":null,"permalink":"/node/tutorials/client_library/step4/","subtitle":null,"tags":null,"title":"Step 4. Implementing Mock Client"},{"content":"Complex systems usually experience difficulties when it comes to writing unit tests for a logic that calls external services. These tests are supposed to run quickly and without any additional infrastructure. The standard approach to solving this problem is to replace the calls to external services with a local approximation (a.k.a. a mock). However, writing mocks takes time and doesn’t always guarantee functionality that matches the real service.\nIn our projects, we’ve come to the conclusion that it pays off to develop mocks alongside the real clients and test them using common tests, to guarantee that their behavior is identical. This way, all users of the microservice will receive both the client and mock from the library and will be able to start coding logic and unit tests for it without delay.\nIn this step we will be demonstrating how Mock clients are developed and how they can be tested using the tests we created earlier.\nThe test client has to implement the same interface that the other clients did. However, the client’s methods are going to contain code that only imitates the microservice’s behavior.\nThe code for this client is showed below:\n/src/version1/BeaconsMockClientV1.py\nimport copy from typing import List, Any, Optional from pip_services3_commons.data import FilterParams, IdGenerator, PagingParams, DataPage from src.clients.version1.IBeaconsClientV1 import IBeaconsClientV1 from src.data.version1 import BeaconV1 filtered = filter class BeaconsMockClientV1(IBeaconsClientV1): _max_page_size = 100 _items: List[BeaconV1] = [] def compose_filter(self, filter: FilterParams) -\u0026gt; Any: filter = filter or FilterParams() id = filter.get_as_nullable_string(\u0026#34;id\u0026#34;) site_id = filter.get_as_nullable_string(\u0026#34;site_id\u0026#34;) label = filter.get_as_nullable_string(\u0026#39;label\u0026#39;) udi = filter.get_as_nullable_string(\u0026#39;udi\u0026#39;) udis = filter.get_as_object(\u0026#39;udis\u0026#39;) if type(udis) == str: udis = udis.split(\u0026#39;,\u0026#39;) if not (type(udis) == list): udis = None def filter_beacons(item): if id is not None and item[\u0026#39;id\u0026#39;] != id: return False if site_id is not None and item[\u0026#39;site_id\u0026#39;] != site_id: return False if label is not None and item[\u0026#39;label\u0026#39;] != label: return False if udi is not None and item[\u0026#39;udi\u0026#39;] != udi: return False if udis is not None and item[\u0026#39;udi\u0026#39;] not in udis: try: udis.index(item.udi) except Exception as e: return False return True return filter_beacons def get_beacons(self, correlation_id: Optional[str], filter: FilterParams, paging: PagingParams) -\u0026gt; DataPage: filter_beacons = self.compose_filter(filter) beacons = [item for item in self._items if filter_beacons(item) is True] # Extract a page paging = paging if paging is not None else PagingParams() skip = paging.get_skip(-1) take = paging.get_take(self._max_page_size) total = None if paging.total: total = len(beacons) if skip \u0026gt; 0: beacons = beacons[skip:] beacons = beacons[:take] page = DataPage(beacons, total) return page def get_beacon_by_id(self, correlation_id: Optional[str], id: str) -\u0026gt; dict: beacons = [item for item in self._items if item[\u0026#39;id\u0026#39;] == id] beacon = beacons[0] if len(beacons) \u0026gt; 0 else None return beacon def get_beacon_by_udi(self, correlation_id: Optional[str], udi: str) -\u0026gt; dict: beacons = [item for item in self._items if item[\u0026#39;udi\u0026#39;] == udi] beacon = beacons[0] if len(beacons) \u0026gt; 0 else None return beacon def get_beacons_by_filter(self, correlation_id: Optional[str], filter: FilterParams, paging: PagingParams, sort=None, select=None): items = list(self._items) # Filter and sort if filter is not None: items = list(filtered(filter, items)) if sort is not None: items = list(items.sort(key=sort)) # items = sorted(items, sort) # Prepare paging parameters paging = paging if not (paging is None) else PagingParams() skip = paging.get_skip(-1) take = paging.get_take(self._max_page_size) # Get a page data = items if skip \u0026gt; 0: data = data[skip:] if take \u0026gt; 0: data = data[:take + 1] # Convert values if not (select is None): data = map(select, data) # Return a page return DataPage(data, len(items)) def calculate_position(self, correlation_id: Optional[str], site_id: str, udis: List[str]) -\u0026gt; Any: beacons: List[BeaconV1] position = None if udis is None or len(udis) == 0: return page = self.get_beacons(correlation_id, FilterParams.from_tuples( \u0026#39;site_id\u0026#39;, site_id, \u0026#39;udis\u0026#39;, udis ), None) beacons = page.data if page.data else [] lat = 0 lng = 0 count = 0 for beacon in beacons: if beacon[\u0026#39;center\u0026#39;] is not None and beacon[\u0026#39;center\u0026#39;][\u0026#39;type\u0026#39;] == \u0026#34;Point\u0026#34; and len( beacon[\u0026#39;center\u0026#39;][\u0026#39;coordinates\u0026#39;]) \u0026gt; 1: lng = lng + beacon[\u0026#39;center\u0026#39;][\u0026#39;coordinates\u0026#39;][0] lat = lat + beacon[\u0026#39;center\u0026#39;][\u0026#39;coordinates\u0026#39;][1] count = count + 1 if count \u0026gt; 0: position = {\u0026#34;type\u0026#34;: \u0026#39;Point\u0026#39;, \u0026#34;coordinates\u0026#34;: [lng / count, lat / count]} return position return None def create_beacon(self, correlation_id: Optional[str], beacon: BeaconV1) -\u0026gt; dict: if beacon is None: return beacon = copy.deepcopy(beacon) beacon.id = beacon.id or IdGenerator.next_long() self._items.append(beacon) return beacon def update_beacon(self, correlation_id: Optional[str], beacon: BeaconV1) -\u0026gt; dict: try: index = list(map(lambda x: x.id, self._items)).index(beacon[\u0026#39;id\u0026#39;]) except ValueError: return beacon = copy.deepcopy(beacon) self._items[index] = beacon return beacon def delete_beacon_by_id(self, correlation_id: Optional[str], beacon_id: str) -\u0026gt; dict: try: index = list(map(lambda x: x.id, self._items)).index(beacon_id) except ValueError: return beacon = self._items[index] del self._items[index] return beacon Now let’s test the client we’ve created. We’ll be using the set of tests that we developed in one of the previous steps, and adding just one test file that will bring it all together. The source of this file is presented below:\n/test/version1/test_BeaconsMockClientV1.py\nfrom src.clients.version1.BeaconsMockClientV1 import BeaconsMockClientV1 from test.clients.version1.BeaconsClientV1Fixture import BeaconsClientV1Fixture class TestBeaconsMockClientV1: client: BeaconsMockClientV1 fixture: BeaconsClientV1Fixture @classmethod def setup_class(cls): cls.client = BeaconsMockClientV1() cls.fixture = BeaconsClientV1Fixture(cls.client) def test_crud_operations(self): self.fixture.test_crud_operations() def test_calculate_position(self): self.fixture.test_calculate_position() Create a file with the tests and run them. All the tests should pass, even though the server-side code wasn’t actually used anywhere.\nThis technique becomes very useful when developing microservices that bring together multiple microservices by means of their clients (e.g. a facade microservice). It allows us to perform functional testing without having to run the entire infrastructure.\nTo performing non-fuctional testing, we need to generate a large amount of realistic data. Users usually don’t know the entire data structure with all of its variations and exceptions. The next component we will be adding to our client library is a random data generator. This component can be used by the microservice’s users to create quality tests. The implementation is usually done in the form of static methods that either return an entire object, or just some part of its parameters. Let’s take a look at what an implementation of such a generator for the BeaconsV1 data object would look like. The generator’s code is listed below:\n# -*- coding: utf-8 -*- from pip_services3_commons.random import RandomArray, RandomInteger from src.data.version1 import BeaconTypeV1, BeaconV1 class RandomBeaconV1: @staticmethod def next_beacon_type() -\u0026gt; str: return RandomArray.pick( [ BeaconTypeV1.AltBeacon, BeaconTypeV1.EddyStoneUdi, BeaconTypeV1.Unknown, BeaconTypeV1.iBeacon ] ) @staticmethod def next_beacon() -\u0026gt; BeaconV1: return BeaconV1( id=None, site_id=None, type=RandomBeaconV1.next_beacon_type(), udi=RandomArray.pick([\u0026#39;00001\u0026#39;, \u0026#39;00002\u0026#39;, \u0026#39;00003\u0026#39;, \u0026#39;00004\u0026#39;]), label=None, center=RandomBeaconV1.next_beacon_type(), radius=RandomInteger.next_integer(1, 1000) ) In this implementation, the ranges of generated values are statically set, but they can be passed as parameters to the methods and dynamically set as needed. Using this instrument, we can easily generate large volumes of realistic data. This, in turn, can be used to test, for example, how fast the system can create elements in the persistence it’s using.\nIn the Step 5. Testing the Client with a Remote Microservice, we’ll be taking a look at how to test our client using a microservice that is remotely deployed in a Docker container.\nStep 5. Testing the Client with a Remote Microservice  ","description":null,"image":null,"permalink":"/python/tutorials/client_library/step4/","subtitle":null,"tags":null,"title":"Step 4. Implementing Mock Client"},{"content":"Now that all of the preparational work has been done, all that’s left is to publish the image of the container we’ve created with our microservice to a Docker Registry. In this tutorial, we’ll be demonstrating the process of publishing to a free registry on Docker Hub, so you’ll be needing a Docker Hub account to continue. If you don’t have a Docker ID yet, you can get one by registering on their site: https://hub.docker.com/.\nIn commercial projects, we tend to use private Docker registries instead of DockerHub. Private registries function in a similar manner to DockerHub, so with minimal modifications to the scripts you can use them as well.\nLogin to Docker Hub using your credentials and create a repository for hosting the microservice’s image that we built. For simplicity, let’s name the repository test_registry.\nIt’s worth pointing out that a version number tag is appended to the name of the image. The tagging system allows us to control the versions of images we’ve published. By changing a service’s tag, you can publish more than one version of your service to the repository. This way you can start using the new version, without breaking any other systems that are still using an older version of your service.\nSince our scripts use values from the component.json file, make sure to edit that file as needed before you package your service\nTo automate the publication process, create a publish.ps1 file with the following script inside:\nTODO: add publish for go Before running this script, be sure to initialize the DOCKER_USER and DOCKER_PASS variables in your environment, as these will be used for authorization in Docker Hub.\nRun the script using the following command:\n./publish.ps1 While running, the script will generate a name for the image using the data in the component.json file, authorize itself in the Docker Hub service, and push the image to the repository.\nPlease wait for the image to finish uploading. Once uploaded, the image will become available for use, alongside the other images in the repository.\nThe publishing stage is the last step of a microservice’s Dockerized development process. However, sometimes there occurs the need to just run a microservice for demonstration or testing purposes. Step 5 will focus on how we can use Docker to help us do that as well.\nStep 5. Running a dockerized microservice.  ","description":null,"image":null,"permalink":"/golang/tutorials/microservice_dockerization/step4/","subtitle":null,"tags":null,"title":"Step 4. Publish"},{"content":"Now that all of the preparational work has been done, all that’s left is to publish the image of the container we’ve created with our microservice to a Docker Registry. In this tutorial, we’ll be demonstrating the process of publishing to a free registry on Docker Hub, so you’ll be needing a Docker Hub account to continue. If you don’t have a Docker ID yet, you can get one by registering on their site: https://hub.docker.com/.\nIn commercial projects, we tend to use private Docker registries instead of DockerHub. Private registries function in a similar manner to DockerHub, so with minimal modifications to the scripts you can use them as well.\nLogin to Docker Hub using your credentials and create a repository for hosting the microservice’s image that we built. For simplicity, let’s name the repository test_registry.\nIt’s worth pointing out that a version number tag is appended to the name of the image. The tagging system allows us to control the versions of images we’ve published. By changing a service’s tag, you can publish more than one version of your service to the repository. This way you can start using the new version, without breaking any other systems that are still using an older version of your service.\nSince our scripts use values from the component.json file, make sure to edit that file as needed before you package your service\nTo automate the publication process, create a publish.ps1 file with the following script inside:\n#!/usr/bin/env pwsh ‍ Set-StrictMode -Version latest $ErrorActionPreference = \u0026#34;Stop\u0026#34; # Get component data and set necessary variables $component = Get-Content -Path \u0026#34;component.json\u0026#34; | ConvertFrom-Json $rcImage=\u0026#34;$($component.registry)/$($component.name):$($component.version)-$($component.build)-rc\u0026#34; # Define server name $pos = $component.registry.IndexOf(\u0026#34;/\u0026#34;) $server = \u0026#34;\u0026#34; if ($pos -gt 0) { $server = $component.registry.Substring(0, $pos) } # Automatically login to server if ($env:DOCKER_USER -ne $null -and $env:DOCKER_PASS -ne $null) { docker login $server -u $env:DOCKER_USER -p $env:DOCKER_PASS } ‍ # Push image to docker registry docker push $rcImage Before running this script, be sure to initialize the DOCKER_USER and DOCKER_PASS variables in your environment, as these will be used for authorization in Docker Hub.\nRun the script using the following command:\n./publish.ps1 While running, the script will generate a name for the image using the data in the component.json file, authorize itself in the Docker Hub service, and push the image to the repository.\nPlease wait for the image to finish uploading. Once uploaded, the image will become available for use, alongside the other images in the repository.\nThe publishing stage is the last step of a microservice’s Dockerized development process. However, sometimes there occurs the need to just run a microservice for demonstration or testing purposes. Step 5 will focus on how we can use Docker to help us do that as well.\nStep 5. Running a dockerized microservice.  ","description":null,"image":null,"permalink":"/net/tutorials/microservice_dockerization/step4/","subtitle":null,"tags":null,"title":"Step 4. Publish"},{"content":"Now that all of the preparational work has been done, all that’s left is to publish the image of the container we’ve created with our microservice to a Docker Registry. In this tutorial, we’ll be demonstrating the process of publishing to a free registry on Docker Hub, so you’ll be needing a Docker Hub account to continue. If you don’t have a Docker ID yet, you can get one by registering on their site: https://hub.docker.com/.\nIn commercial projects, we tend to use private Docker registries instead of DockerHub. Private registries function in a similar manner to DockerHub, so with minimal modifications to the scripts you can use them as well.\nLogin to Docker Hub using your credentials and create a repository for hosting the microservice’s image that we built. For simplicity, let’s name the repository test_registry.\nIt’s worth pointing out that a version number tag is appended to the name of the image. The tagging system allows us to control the versions of images we’ve published. By changing a service’s tag, you can publish more than one version of your service to the repository. This way you can start using the new version, without breaking any other systems that are still using an older version of your service.\nSince our scripts use values from the component.json file, make sure to edit that file as needed before you package your service\nTo automate the publication process, create a publish.ps1 file with the following script inside:\n#!/usr/bin/env pwsh ‍ Set-StrictMode -Version latest $ErrorActionPreference = \u0026#34;Stop\u0026#34; # Get component data and set necessary variables $component = Get-Content -Path \u0026#34;component.json\u0026#34; | ConvertFrom-Json $rcImage=\u0026#34;$($component.registry)/$($component.name):$($component.version)-$($component.build)-rc\u0026#34; # Define server name $pos = $component.registry.IndexOf(\u0026#34;/\u0026#34;) $server = \u0026#34;\u0026#34; if ($pos -gt 0) { $server = $component.registry.Substring(0, $pos) } # Automatically login to server if ($env:DOCKER_USER -ne $null -and $env:DOCKER_PASS -ne $null) { docker login $server -u $env:DOCKER_USER -p $env:DOCKER_PASS } ‍ # Push image to docker registry docker push $rcImage Before running this script, be sure to initialize the DOCKER_USER and DOCKER_PASS variables in your environment, as these will be used for authorization in Docker Hub.\nRun the script using the following command:\n./publish.ps1 While running, the script will generate a name for the image using the data in the component.json file, authorize itself in the Docker Hub service, and push the image to the repository.\nPlease wait for the image to finish uploading. Once uploaded, the image will become available for use, alongside the other images in the repository.\nThe publishing stage is the last step of a microservice’s Dockerized development process. However, sometimes there occurs the need to just run a microservice for demonstration or testing purposes. Step 5 will focus on how we can use Docker to help us do that as well.\nStep 5. Running a dockerized microservice.  ","description":null,"image":null,"permalink":"/node/tutorials/microservice_dockerization/step4/","subtitle":null,"tags":null,"title":"Step 4. Publish"},{"content":"Now that all of the preparational work has been done, all that’s left is to publish the image of the container we’ve created with our microservice to a Docker Registry. In this tutorial, we’ll be demonstrating the process of publishing to a free registry on Docker Hub, so you’ll be needing a Docker Hub account to continue. If you don’t have a Docker ID yet, you can get one by registering on their site: https://hub.docker.com/.\nIn commercial projects, we tend to use private Docker registries instead of DockerHub. Private registries function in a similar manner to DockerHub, so with minimal modifications to the scripts you can use them as well.\nLogin to Docker Hub using your credentials and create a repository for hosting the microservice’s image that we built. For simplicity, let’s name the repository test_registry.\nIt’s worth pointing out that a version number tag is appended to the name of the image. The tagging system allows us to control the versions of images we’ve published. By changing a service’s tag, you can publish more than one version of your service to the repository. This way you can start using the new version, without breaking any other systems that are still using an older version of your service.\nSince our scripts use values from the component.json file, make sure to edit that file as needed before you package your service\nTo automate the publication process, create a publish.ps1 file with the following script inside:\n#!/usr/bin/env pwsh ‍ Set-StrictMode -Version latest $ErrorActionPreference = \u0026#34;Stop\u0026#34; # Get component data and set necessary variables $component = Get-Content -Path \u0026#34;component.json\u0026#34; | ConvertFrom-Json $rcImage=\u0026#34;$($component.registry)/$($component.name):$($component.version)-$($component.build)-rc\u0026#34; # Define server name $pos = $component.registry.IndexOf(\u0026#34;/\u0026#34;) $server = \u0026#34;\u0026#34; if ($pos -gt 0) { $server = $component.registry.Substring(0, $pos) } # Automatically login to server if ($env:DOCKER_USER -ne $null -and $env:DOCKER_PASS -ne $null) { docker login $server -u $env:DOCKER_USER -p $env:DOCKER_PASS } ‍ # Push image to docker registry docker push $rcImage Before running this script, be sure to initialize the DOCKER_USER and DOCKER_PASS variables in your environment, as these will be used for authorization in Docker Hub.\nRun the script using the following command:\n./publish.ps1 While running, the script will generate a name for the image using the data in the component.json file, authorize itself in the Docker Hub service, and push the image to the repository.\nPlease wait for the image to finish uploading. Once uploaded, the image will become available for use, alongside the other images in the repository.\nThe publishing stage is the last step of a microservice’s Dockerized development process. However, sometimes there occurs the need to just run a microservice for demonstration or testing purposes. Step 5 will focus on how we can use Docker to help us do that as well.\nStep 5. Running a dockerized microservice.  ","description":null,"image":null,"permalink":"/python/tutorials/microservice_dockerization/step4/","subtitle":null,"tags":null,"title":"Step 4. Publish"},{"content":"The Pip.Services Toolkit has a dedicated component in the RPC module for processing external requests. To make use of this service, create a new class BeaconsHttpServiceV1, extending the CommandableHttpService class:\n/src/service/service/version1/BeaconsHttpServicesV1.py\nnamespace Beacons.Services.Version1 { public class BeaconsHttpServiceV1: CommandableHttpService { public BeaconsHttpServiceV1() : base(\u0026#34;v1/beacons\u0026#34;) { _dependencyResolver.Put(\u0026#34;controller\u0026#34;, new Descriptor(\u0026#34;beacons\u0026#34;, \u0026#34;controller\u0026#34;, \u0026#34;default\u0026#34;, \u0026#34;*\u0026#34;, \u0026#34;1.0\u0026#34;)); } } } The CommandableHttpService class from the pip-services3-rpc module implements all of the basic functionality needed by the service, right out of the box. All that we need to do on our side is configure it in the child class. This is done by defining a base route to the API (e.g. \u0026lsquo;v1/beacons\u0026rsquo;) and by setting references to the controller. The rest is taken care of by the parent class and the process container: a controller will be searched for and referenced, after which the service will receive a set of commands, register it, and make those commands available through the API interface. This allows us to run commands by simply posting requests to a URL of the following format:\nhttp://{ip}:{port}/v1/beacons/{command_name} Even though the BeaconsHttpServiceV1 class barely has any lines of code, there’s a large amount of code being executed in the service itself. To make sure that everything is working as it should, we should add tests for the service itself, as well as for the commands we wrote in the CommandSet. Create a file for the service’s test and paste the following code:\n/test/service.test/services/version1/BeaconsHttpServiceV1Test.py\nnamespace Beacons.Services.Version1 { public class BeaconsHttpServiceV1Test { private BeaconV1 BEACON1 = new BeaconV1 { Id = \u0026#34;1\u0026#34;, Udi = \u0026#34;00001\u0026#34;, Type = BeaconTypeV1.AltBeacon, SiteId = \u0026#34;1\u0026#34;, Label = \u0026#34;TestBeacon1\u0026#34;, Center = new CenterObjectV1 { Type = \u0026#34;Point\u0026#34;, Coordinates = new double[] { 0, 0 } }, Radius = 50 }; private BeaconV1 BEACON2 = new BeaconV1 { Id = \u0026#34;2\u0026#34;, Udi = \u0026#34;00002\u0026#34;, Type = BeaconTypeV1.iBeacon, SiteId = \u0026#34;1\u0026#34;, Label = \u0026#34;TestBeacon2\u0026#34;, Center = new CenterObjectV1 { Type = \u0026#34;Point\u0026#34;, Coordinates = new double[] { 2, 2 } }, Radius = 70 }; private static readonly ConfigParams HttpConfig = ConfigParams.FromTuples( \u0026#34;connection.protocol\u0026#34;, \u0026#34;http\u0026#34;, \u0026#34;connection.host\u0026#34;, \u0026#34;localhost\u0026#34;, \u0026#34;connection.port\u0026#34;, \u0026#34;3000\u0026#34; ); private BeaconsMemoryPersistence _persistence; private BeaconsController _controller; private BeaconsHttpServiceV1 _service; private TestCommandableHttpClient _client; public BeaconsHttpServiceV1Test() { _persistence = new BeaconsMemoryPersistence(); _controller = new BeaconsController(); _service = new BeaconsHttpServiceV1(); _client = new TestCommandableHttpClient(\u0026#34;v1/beacons\u0026#34;); IReferences references = References.FromTuples( new Descriptor(\u0026#34;beacons\u0026#34;, \u0026#34;persistence\u0026#34;, \u0026#34;memory\u0026#34;, \u0026#34;default\u0026#34;, \u0026#34;1.0\u0026#34;), _persistence, new Descriptor(\u0026#34;beacons\u0026#34;, \u0026#34;controller\u0026#34;, \u0026#34;default\u0026#34;, \u0026#34;default\u0026#34;, \u0026#34;1.0\u0026#34;), _controller, new Descriptor(\u0026#34;beacons\u0026#34;, \u0026#34;service\u0026#34;, \u0026#34;http\u0026#34;, \u0026#34;default\u0026#34;, \u0026#34;1.0\u0026#34;), _service, new Descriptor(\u0026#34;beacons\u0026#34;, \u0026#34;client\u0026#34;, \u0026#34;http\u0026#34;, \u0026#34;default\u0026#34;, \u0026#34;1.0\u0026#34;), _client ); _controller.SetReferences(references); _service.Configure(HttpConfig); _service.SetReferences(references); _client.Configure(HttpConfig); _service.OpenAsync(null).Wait(); // Todo: This is defect! Open shall not block the tread  //Task.Run(() =\u0026gt; _service.OpenAsync(null));  //Thread.Sleep(1000); // Just let service a sec to be initialized  _client.OpenAsync(null).Wait(); } [Fact] public async Task TestCrudOperationsAsync() { // Create the first beacon  var beacon = await _client.CallCommandAsync\u0026lt;BeaconV1\u0026gt;( \u0026#34;create_beacon\u0026#34;, null, new { beacon = BEACON1 }); Assert.NotNull(beacon); Assert.Equal(BEACON1.Udi, beacon.Udi); Assert.Equal(BEACON1.SiteId, beacon.SiteId); Assert.Equal(BEACON1.Type, beacon.Type); Assert.Equal(BEACON1.Label, beacon.Label); Assert.NotNull(beacon.Center); // Create the second beacon  beacon = await _client.CallCommandAsync\u0026lt;BeaconV1\u0026gt;( \u0026#34;create_beacon\u0026#34;, null, new { beacon = BEACON2 }); Assert.NotNull(beacon); Assert.Equal(BEACON2.Udi, beacon.Udi); Assert.Equal(BEACON2.SiteId, beacon.SiteId); Assert.Equal(BEACON2.Type, beacon.Type); Assert.Equal(BEACON2.Label, beacon.Label); Assert.NotNull(beacon.Center); // Get all beacons  var page = await _client.CallCommandAsync\u0026lt;DataPage\u0026lt;BeaconV1\u0026gt;\u0026gt;( \u0026#34;get_beacons\u0026#34;, null, new { filter = new FilterParams(), paging = new PagingParams() } ); Assert.NotNull(page); Assert.Equal(2, page.Data.Count); var beacon1 = page.Data[0]; // Update the beacon  beacon1.Label = \u0026#34;ABC\u0026#34;; beacon = await _client.CallCommandAsync\u0026lt;BeaconV1\u0026gt;( \u0026#34;update_beacon\u0026#34;, null, new { beacon = beacon1 }); Assert.NotNull(beacon); Assert.Equal(beacon1.Id, beacon.Id); Assert.Equal(\u0026#34;ABC\u0026#34;, beacon.Label); // Get beacon by udi  beacon = await _client.CallCommandAsync\u0026lt;BeaconV1\u0026gt;( \u0026#34;get_beacon_by_udi\u0026#34;, null, new { udi = beacon1.Udi }); Assert.NotNull(beacon); Assert.Equal(beacon1.Id, beacon.Id); // Delete the beacon  beacon = await _client.CallCommandAsync\u0026lt;BeaconV1\u0026gt;( \u0026#34;delete_beacon_by_id\u0026#34;, null, new { beacon_id = beacon1.Id }); Assert.NotNull(beacon); Assert.Equal(beacon1.Id, beacon.Id); // Try to get deleted beacon  beacon = await _client.CallCommandAsync\u0026lt;BeaconV1\u0026gt;( \u0026#34;get_beacon_by_id\u0026#34;, null, new { beacon_id = beacon1.Id }); Assert.Null(beacon); } } } Run the dotnet test command and make sure that all of the tests pass successfully.\nCongratulations! This step finishes off the development of our microservice! However, before we can start our service up as a fully fledged microservice, we’ll first need to compose all of its components using a process container. And that’s exactly what we’ll be doing in Step 6. Wrapping microservice into container.\nStep 6. Wrapping microservice into container. ","description":null,"image":null,"permalink":"/net/tutorials/data_microservice/step5/","subtitle":null,"tags":null,"title":"Step 5. Implementing an HTTP service"},{"content":"The Pip.Services Toolkit has a dedicated component in the RPC module for processing external requests. To make use of this service, create a new class BeaconsHttpServiceV1, extending the CommandableHttpService class:\n/src/service/version1/BeaconsHttpServicesV1.ts\nimport { CommandableHttpService } from \u0026#39;pip-services3-rpc-node\u0026#39;; import { Descriptor } from \u0026#39;pip-services3-commons-node\u0026#39;; ‍ export class BeaconsHttpServiceV1 extends CommandableHttpService { public constructor() { super(\u0026#39;v1/beacons\u0026#39;); this._dependencyResolver.put(\u0026#39;controller\u0026#39;, new Descriptor(\u0026#39;beacons\u0026#39;, \u0026#39;controller\u0026#39;, \u0026#39;*\u0026#39;, \u0026#39;*\u0026#39;, \u0026#39;1.0\u0026#39;)); } } The CommandableHttpService class from the pip-services3-rpc module implements all of the basic functionality needed by the service, right out of the box. All that we need to do on our side is configure it in the child class. This is done by defining a base route to the API (e.g. \u0026lsquo;v1/beacons\u0026rsquo;) and by setting references to the controller. The rest is taken care of by the parent class and the process container: a controller will be searched for and referenced, after which the service will receive a set of commands, register it, and make those commands available through the API interface. This allows us to run commands by simply posting requests to a URL of the following format:\nhttp://{ip}:{port}/v1/beacons/{command_name} Even though the BeaconsHttpServiceV1 class barely has any lines of code, there’s a large amount of code being executed in the service itself. To make sure that everything is working as it should, we should add tests for the service itself, as well as for the commands we wrote in the CommandSet. Create a file for the service’s test and paste the following code:\n/test/services/version1/BeaconsHttpServiceV1.test.ts\nlet _ = require(\u0026#39;lodash\u0026#39;); let async = require(\u0026#39;async\u0026#39;); let assert = require(\u0026#39;chai\u0026#39;).assert; let restify = require(\u0026#39;restify\u0026#39;); ‍ import { ConfigParams } from \u0026#39;pip-services3-commons-node\u0026#39;; import { Descriptor } from \u0026#39;pip-services3-commons-node\u0026#39;; import { References } from \u0026#39;pip-services3-commons-node\u0026#39;; import { FilterParams } from \u0026#39;pip-services3-commons-node\u0026#39;; import { PagingParams } from \u0026#39;pip-services3-commons-node\u0026#39;; ‍ import { BeaconV1 } from \u0026#39;../../../src/data/version1/BeaconV1\u0026#39;; import { BeaconTypeV1 } from \u0026#39;../../../src/data/version1/BeaconTypeV1\u0026#39;; import { BeaconsMemoryPersistence } from \u0026#39;../../../src/persistence/BeaconsMemoryPersistence\u0026#39;; import { BeaconsController } from \u0026#39;../../../src/logic/BeaconsController\u0026#39;; import { BeaconsHttpServiceV1 } from \u0026#39;../../../src/services/version1/BeaconsHttpServiceV1\u0026#39;; ‍ const BEACON1: BeaconV1 = { id: \u0026#39;1\u0026#39;, udi: \u0026#39;00001\u0026#39;, type: BeaconTypeV1.AltBeacon, site_id: \u0026#39;1\u0026#39;, label: \u0026#39;TestBeacon1\u0026#39;, center: { type: \u0026#39;Point\u0026#39;, coordinates: [ 0, 0 ] }, radius: 50 }; const BEACON2: BeaconV1 = { id: \u0026#39;2\u0026#39;, udi: \u0026#39;00002\u0026#39;, type: BeaconTypeV1.iBeacon, site_id: \u0026#39;1\u0026#39;, label: \u0026#39;TestBeacon2\u0026#39;, center: { type: \u0026#39;Point\u0026#39;, coordinates: [ 2, 2 ] }, radius: 70 }; ‍ suite(\u0026#39;BeaconsHttpServiceV1\u0026#39;, () =\u0026gt; { let persistence: BeaconsMemoryPersistence; let controller: BeaconsController; let service: BeaconsHttpServiceV1; let rest: any; ‍ setup((done) =\u0026gt; { let url = \u0026#34;http://localhost:3000\u0026#34;; rest = restify.createJsonClient({ url: url, version: \u0026#39;*\u0026#39;}); ‍ persistence = new BeaconsMemoryPersistence(); persistence.configure(new ConfigParams()); ‍ controller = new BeaconsController(); controller.configure(new ConfigParams()); ‍ service = new BeaconsHttpServiceV1(); service.configure(ConfigParams.fromTuples( \u0026#39;connection.protocol\u0026#39;, \u0026#39;http\u0026#39;, \u0026#39;connection.port\u0026#39;, 3000, \u0026#39;connection.host\u0026#39;, \u0026#39;localhost\u0026#39; )); ‍ let references = References.fromTuples( new Descriptor(\u0026#39;beacons\u0026#39;, \u0026#39;persistence\u0026#39;, \u0026#39;memory\u0026#39;, \u0026#39;default\u0026#39;, \u0026#39;1.0\u0026#39;), persistence, new Descriptor(\u0026#39;beacons\u0026#39;, \u0026#39;controller\u0026#39;, \u0026#39;default\u0026#39;, \u0026#39;default\u0026#39;, \u0026#39;1.0\u0026#39;), controller, new Descriptor(\u0026#39;beacons\u0026#39;, \u0026#39;service\u0026#39;, \u0026#39;http\u0026#39;, \u0026#39;default\u0026#39;, \u0026#39;1.0\u0026#39;), service ); ‍ controller.setReferences(references); service.setReferences(references); ‍ persistence.open(null, (err) =\u0026gt; { if (err) { done(err); return; } ‍ service.open(null, done); }); }); ‍ teardown((done) =\u0026gt; { service.close(null, (err) =\u0026gt; { persistence.close(null, done); }); }); ‍ test(\u0026#39;CRUD Operations\u0026#39;, (done) =\u0026gt; { let beacon1: BeaconV1; ‍ async.series([ // Create the first beacon  (callback) =\u0026gt; { rest.post(\u0026#39;/v1/beacons/create_beacon\u0026#39;, { beacon: BEACON1 }, (err, req, res, beacon) =\u0026gt; { assert.isNull(err); ‍ assert.isObject(beacon); assert.equal(BEACON1.udi, beacon.udi); assert.equal(BEACON1.site_id, beacon.site_id); assert.equal(BEACON1.type, beacon.type); assert.equal(BEACON1.label, beacon.label); assert.isNotNull(beacon.center); ‍ callback(); } ); }, // Create the second beacon  (callback) =\u0026gt; { rest.post(\u0026#39;/v1/beacons/create_beacon\u0026#39;, { beacon: BEACON2 }, (err, req, res, beacon) =\u0026gt; { assert.isNull(err); ‍ assert.isObject(beacon); assert.equal(BEACON2.udi, beacon.udi); assert.equal(BEACON2.site_id, beacon.site_id); assert.equal(BEACON2.type, beacon.type); assert.equal(BEACON2.label, beacon.label); assert.isNotNull(beacon.center); ‍ callback(); } ); }, // Get all beacons  (callback) =\u0026gt; { rest.post(\u0026#39;/v1/beacons/get_beacons\u0026#39;, { filter: new FilterParams(), paging: new PagingParams() }, (err, req, res, page) =\u0026gt; { assert.isNull(err); ‍ assert.isObject(page); assert.lengthOf(page.data, 2); ‍ beacon1 = page.data[0]; ‍ callback(); } ) }, // Update the beacon  (callback) =\u0026gt; { beacon1.label = \u0026#39;ABC\u0026#39;; ‍ rest.post(\u0026#39;/v1/beacons/update_beacon\u0026#39;, { beacon: beacon1 }, (err, req, res, beacon) =\u0026gt; { assert.isNull(err); ‍ assert.isObject(beacon); assert.equal(beacon1.id, beacon.id); assert.equal(\u0026#39;ABC\u0026#39;, beacon.label); ‍ callback(); } ) }, // Get beacon by udi  (callback) =\u0026gt; { rest.post(\u0026#39;/v1/beacons/get_beacon_by_udi\u0026#39;, { udi: beacon1.udi }, (err, req, res, beacon) =\u0026gt; { assert.isNull(err); ‍ assert.isObject(beacon); assert.equal(beacon1.id, beacon.id); ‍ callback(); } ) }, // Calculate position for one beacon  (callback) =\u0026gt; { rest.post(\u0026#39;/v1/beacons/calculate_position\u0026#39;, { site_id: \u0026#39;1\u0026#39;, udis: [\u0026#39;00001\u0026#39;] }, (err, req, res, position) =\u0026gt; { assert.isNull(err); ‍ assert.isObject(position); assert.equal(\u0026#39;Point\u0026#39;, position.type); assert.lengthOf(position.coordinates, 2); assert.equal(0, position.coordinates[0]); assert.equal(0, position.coordinates[1]); ‍ callback(); } ) }, // Delete the beacon  (callback) =\u0026gt; { rest.post(\u0026#39;/v1/beacons/delete_beacon_by_id\u0026#39;, { beacon_id: beacon1.id }, (err, req, res, beacon) =\u0026gt; { assert.isNull(err); ‍ assert.isObject(beacon); assert.equal(beacon1.id, beacon.id); ‍ callback(); } ) }, // Try to get deleted beacon  (callback) =\u0026gt; { rest.post(\u0026#39;/v1/beacons/get_beacon_by_id\u0026#39;, { beacon_id: beacon1.id }, (err, req, res, beacon) =\u0026gt; { assert.isNull(err); ‍ //assert.isEmpty(beacon || null); ‍ callback(); } ) } ], done); }); }); Run the npm test command and make sure that all of the tests pass successfully.\nCongratulations! This step finishes off the development of our microservice! However, before we can start our service up as a fully fledged microservice, we’ll first need to compose all of its components using a process container. And that’s exactly what we’ll be doing in Step 6. Wrapping microservice into container.\nStep 6. Wrapping microservice into container. ","description":null,"image":null,"permalink":"/node/tutorials/data_microservice/step5/","subtitle":null,"tags":null,"title":"Step 5. Implementing an HTTP service"},{"content":"The Pip.Services Toolkit has a dedicated component in the RPC module for processing external requests. To make use of this service, create a new class BeaconsHttpServiceV1, extending the CommandableHttpService class:\n/src/service/version1/BeaconsHttpServicesV1.py\nfrom pip_services3_commons.refer import Descriptor from pip_services3_rpc.services import CommandableHttpService class BeaconsHttpServiceV1(CommandableHttpService): def __init__(self): super(BeaconsHttpServiceV1, self).__init__(\u0026#34;v1/beacons\u0026#34;) self._dependency_resolver.put(\u0026#34;controller\u0026#34;, Descriptor(\u0026#39;beacons\u0026#39;, \u0026#39;controller\u0026#39;, \u0026#39;*\u0026#39;, \u0026#39;*\u0026#39;, \u0026#39;1.0\u0026#39;)) The CommandableHttpService class from the pip-services3-rpc module implements all of the basic functionality needed by the service, right out of the box. All that we need to do on our side is configure it in the child class. This is done by defining a base route to the API (e.g. \u0026lsquo;v1/beacons\u0026rsquo;) and by setting references to the controller. The rest is taken care of by the parent class and the process container: a controller will be searched for and referenced, after which the service will receive a set of commands, register it, and make those commands available through the API interface. This allows us to run commands by simply posting requests to a URL of the following format:\nhttp://{ip}:{port}/v1/beacons/{command_name} Even though the BeaconsHttpServiceV1 class barely has any lines of code, there’s a large amount of code being executed in the service itself. To make sure that everything is working as it should, we should add tests for the service itself, as well as for the commands we wrote in the CommandSet. Create a file for the service’s test and paste the following code:\n/test/services/version1/test_BeaconsHttpServiceV1.py\nimport json import time from json import JSONDecodeError from typing import Union import requests from pip_services3_commons.config import ConfigParams from pip_services3_commons.refer import References, Descriptor from pip_services3_commons.reflect import PropertyReflector from pip_services3_commons.run import Parameters from src.data.version1 import BeaconV1, BeaconTypeV1 from src.logic.BeaconsController import BeaconsController from src.persistence.BeaconsMemoryPersistence import BeaconsMemoryPersistence from src.services.version1.BeaconsHttpServiceV1 import BeaconsHttpServiceV1 BEACON1 = BeaconV1(\u0026#34;1\u0026#34;, \u0026#34;1\u0026#34;, BeaconTypeV1.AltBeacon, \u0026#34;00001\u0026#34;, \u0026#34;TestBeacon1\u0026#34;, {\u0026#34;type\u0026#34;: \u0026#39;Point\u0026#39;, \u0026#34;coordinates\u0026#34;: [0, 0]}, 50.0) BEACON2 = BeaconV1(\u0026#34;2\u0026#34;, \u0026#34;1\u0026#34;, BeaconTypeV1.iBeacon, \u0026#34;00002\u0026#34;, \u0026#34;TestBeacon2\u0026#34;, {\u0026#34;type\u0026#34;: \u0026#39;Point\u0026#39;, \u0026#34;coordinates\u0026#34;: [2, 2]}, 70.0) BEACON3 = BeaconV1(\u0026#34;3\u0026#34;, \u0026#34;2\u0026#34;, BeaconTypeV1.AltBeacon, \u0026#34;00003\u0026#34;, \u0026#34;TestBeacon3\u0026#34;, {\u0026#34;type\u0026#34;: \u0026#39;Point\u0026#39;, \u0026#34;coordinates\u0026#34;: [10, 10]}, 50.0) class TestBeaconsHttpServiceV1: _persistence: BeaconsMemoryPersistence _controller: BeaconsController _service: BeaconsHttpServiceV1 @classmethod def setup_class(cls): cls._persistence = BeaconsMemoryPersistence() cls._controller = BeaconsController() cls._service = BeaconsHttpServiceV1() cls._service.configure(ConfigParams.from_tuples( \u0026#39;connection.protocol\u0026#39;, \u0026#39;http\u0026#39;, \u0026#39;connection.port\u0026#39;, 3002, \u0026#39;connection.host\u0026#39;, \u0026#39;localhost\u0026#39;)) references = References.from_tuples(Descriptor(\u0026#39;beacons\u0026#39;, \u0026#39;persistence\u0026#39;, \u0026#39;memory\u0026#39;, \u0026#39;default\u0026#39;, \u0026#39;1.0\u0026#39;), cls._persistence, Descriptor(\u0026#39;beacons\u0026#39;, \u0026#39;controller\u0026#39;, \u0026#39;default\u0026#39;, \u0026#39;default\u0026#39;, \u0026#39;1.0\u0026#39;), cls._controller, Descriptor(\u0026#39;beacons\u0026#39;, \u0026#39;service\u0026#39;, \u0026#39;http\u0026#39;, \u0026#39;default\u0026#39;, \u0026#39;1.0\u0026#39;), cls._service) cls._controller.set_references(references) cls._service.set_references(references) cls._persistence.open(None) cls._service.open(None) @classmethod def teardown_class(cls): cls._persistence.close(None) cls._service.close(None) def test_crud_operations(self): time.sleep(2) # Create the first beacon beacon1 = self.invoke(\u0026#34;/v1/beacons/create_beacon\u0026#34;, Parameters.from_tuples(\u0026#34;beacon\u0026#34;, PropertyReflector.get_properties(BEACON1))) assert beacon1 is not None assert beacon1[\u0026#39;id\u0026#39;] == BEACON1.id assert beacon1[\u0026#39;site_id\u0026#39;] == BEACON1.site_id assert beacon1[\u0026#39;udi\u0026#39;] == BEACON1.udi assert beacon1[\u0026#39;type\u0026#39;] == BEACON1.type assert beacon1[\u0026#39;label\u0026#39;] == BEACON1.label assert beacon1[\u0026#39;center\u0026#39;] is not None # Create the second beacon beacon2 = self.invoke(\u0026#34;/v1/beacons/create_beacon\u0026#34;, Parameters.from_tuples(\u0026#34;beacon\u0026#34;, PropertyReflector.get_properties(BEACON2))) assert beacon2 is not None assert beacon2[\u0026#39;id\u0026#39;] == BEACON2.id assert beacon2[\u0026#39;site_id\u0026#39;] == BEACON2.site_id assert beacon2[\u0026#39;udi\u0026#39;] == BEACON2.udi assert beacon2[\u0026#39;type\u0026#39;] == BEACON2.type assert beacon2[\u0026#39;label\u0026#39;] == BEACON2.label assert beacon2[\u0026#39;center\u0026#39;] is not None # Get all beacons page = self.invoke(\u0026#34;/v1/beacons/get_beacons\u0026#34;, Parameters.from_tuples(\u0026#34;beacons\u0026#34;)) assert page is not None assert len(page[\u0026#39;data\u0026#39;]) == 2 beacon1 = page[\u0026#39;data\u0026#39;][0] # Update the beacon beacon1[\u0026#39;label\u0026#39;] = \u0026#34;ABC\u0026#34; beacon = self.invoke(\u0026#34;/v1/beacons/update_beacon\u0026#34;, Parameters.from_tuples(\u0026#34;beacon\u0026#34;, beacon1)) assert beacon is not None assert beacon1[\u0026#39;id\u0026#39;] == beacon[\u0026#39;id\u0026#39;] assert \u0026#34;ABC\u0026#34; == beacon[\u0026#39;label\u0026#39;] # Get beacon by udi beacon = self.invoke(\u0026#34;/v1/beacons/get_beacon_by_udi\u0026#34;, Parameters.from_tuples(\u0026#34;udi\u0026#34;, beacon1[\u0026#39;udi\u0026#39;])) assert beacon is not None assert beacon[\u0026#39;id\u0026#39;] == beacon1[\u0026#39;id\u0026#39;] # Calculate position for one beacon position = self.invoke(\u0026#34;/v1/beacons/calculate_position\u0026#34;, Parameters.from_tuples(\u0026#34;site_id\u0026#34;, \u0026#39;1\u0026#39;, \u0026#34;udis\u0026#34;, [\u0026#39;00001\u0026#39;])) assert position is not None assert \u0026#34;Point\u0026#34; == position[\u0026#34;type\u0026#34;] assert 2 == len(position[\u0026#34;coordinates\u0026#34;]) assert 0 == position[\u0026#34;coordinates\u0026#34;][0] assert 0 == position[\u0026#34;coordinates\u0026#34;][1] # Delete beacon self.invoke(\u0026#34;/v1/beacons/delete_beacon_by_id\u0026#34;, Parameters.from_tuples(\u0026#34;id\u0026#34;, beacon1[\u0026#39;id\u0026#39;])) # Try to get deleted beacon beacon = self.invoke(\u0026#34;/v1/beacons/get_beacon_by_id\u0026#34;, Parameters.from_tuples(\u0026#34;id\u0026#34;, beacon1[\u0026#39;id\u0026#39;])) assert beacon is False def invoke(self, route, entity) -\u0026gt; Union[bool, dict]: params = {} route = \u0026#34;http://localhost:3002\u0026#34; + route response = None timeout = 10000 # Call the service data = json.dumps(entity) try: response = requests.request(\u0026#39;POST\u0026#39;, route, params=params, json=data, timeout=timeout) return response.json() except JSONDecodeError: if response.status_code == 404: return False Run the python test.py command and make sure that all of the tests pass successfully.\nCongratulations! This step finishes off the development of our microservice! However, before we can start our service up as a fully fledged microservice, we’ll first need to compose all of its components using a process container. And that’s exactly what we’ll be doing in Step 6. Wrapping microservice into container.\nStep 6. Wrapping microservice into container. ","description":null,"image":null,"permalink":"/python/tutorials/data_microservice/step5/","subtitle":null,"tags":null,"title":"Step 5. Implementing an HTTP service"},{"content":"While developing and debugging a project, you may find the need to run and connect to a microservice, for example, using a client. Readily available Docker images, like the ones we made in the previous steps, are quite handy in such situations.\nTo run our service, we’ll be using the scenario we wrote in the third step of this tutorial in the docker-compose.yml file:\nversion: \u0026#39;3.3\u0026#39; services: app: image: ${IMAGE} ports: - \u0026#34;8080:8080\u0026#34; depends_on: - mongo environment: - HTTP_PORT=8080 - MONGO_ENABLED=true - MONGO_SERVICE_HOST=mongo - MONGO_SERVICE_PORT=27017 mongo: image: mongo:latest To automated the running process, we can create a file named run.ps1 with the following script:\n#!/usr/bin/env pwsh Set-StrictMode -Version latest $ErrorActionPreference = \u0026#34;Stop\u0026#34; # Generate an image name using the data in the \u0026#34;component.json\u0026#34; file $component = Get-Content -Path \u0026#34;component.json\u0026#34; | ConvertFrom-Json $image=\u0026#34;$($component.registry)/$($component.name):$($component.version)-$($component.build)-rc\u0026#34; # Set environment variables $env:IMAGE = $image docker-compose -f ./docker/docker-compose.yml up docker-compose -f ./docker/docker-compose.yml down To run the script, enter the following command:\n./run.ps1 While running, the script will generate a name for the image using the data in the component.json file and then run it in Docker Compose. In accordance with the scenario, Docker Compose will run two containers: one with the service, and another with a DB. The service will be made available on port 8080.\nWhen the service is stopped, both containers will automatically be stopped as well.\nCongratulations! You now know how to Dockerize your microservices! We hope this knowledge helps you avoid environment related errors and keep your development process automated and standardized.\n","description":null,"image":null,"permalink":"/golang/tutorials/microservice_dockerization/step5/","subtitle":null,"tags":null,"title":"Step 5. Run"},{"content":"While developing and debugging a project, you may find the need to run and connect to a microservice, for example, using a client. Readily available Docker images, like the ones we made in the previous steps, are quite handy in such situations.\nTo run our service, we’ll be using the scenario we wrote in the third step of this tutorial in the docker-compose.yml file:\nversion: \u0026#39;3.3\u0026#39; services: app: image: ${IMAGE} ports: - \u0026#34;8080:8080\u0026#34; depends_on: - mongo environment: - HTTP_PORT=8080 - MONGO_ENABLED=true - MONGO_SERVICE_HOST=mongo - MONGO_SERVICE_PORT=27017 mongo: image: mongo:latest To automated the running process, we can create a file named run.ps1 with the following script:\n#!/usr/bin/env pwsh Set-StrictMode -Version latest $ErrorActionPreference = \u0026#34;Stop\u0026#34; $component = Get-Content -Path \u0026#34;component.json\u0026#34; | ConvertFrom-Json $image=\u0026#34;$($component.registry)/$($component.name):$($component.version)-$($component.build)-rc\u0026#34; # Set environment variables $env:IMAGE = $image docker-compose -f ./docker/docker-compose.yml up docker-compose -f ./docker/docker-compose.yml down To run the script, enter the following command:\n./run.ps1 While running, the script will generate a name for the image using the data in the component.json file and then run it in Docker Compose. In accordance with the scenario, Docker Compose will run two containers: one with the service, and another with a DB. The service will be made available on port 8080.\nWhen the service is stopped, both containers will automatically be stopped as well.\nCongratulations! You now know how to Dockerize your microservices! We hope this knowledge helps you avoid environment related errors and keep your development process automated and standardized.\n","description":null,"image":null,"permalink":"/net/tutorials/microservice_dockerization/step5/","subtitle":null,"tags":null,"title":"Step 5. Run"},{"content":"While developing and debugging a project, you may find the need to run and connect to a microservice, for example, using a client. Readily available Docker images, like the ones we made in the previous steps, are quite handy in such situations.\nTo run our service, we’ll be using the scenario we wrote in the third step of this tutorial in the docker-compose.yml file:\nversion: \u0026#39;3.3\u0026#39; services: app: image: ${IMAGE} ports: - \u0026#34;8080:8080\u0026#34; depends_on: - mongo environment: - HTTP_PORT=8080 - MONGO_ENABLED=true - MONGO_SERVICE_HOST=mongo - MONGO_SERVICE_PORT=27017 mongo: image: mongo:latest To automated the running process, we can create a file named run.ps1 with the following script:\n#!/usr/bin/env pwsh Set-StrictMode -Version latest $ErrorActionPreference = \u0026#34;Stop\u0026#34; $component = Get-Content -Path \u0026#34;component.json\u0026#34; | ConvertFrom-Json $image=\u0026#34;$($component.registry)/$($component.name):$($component.version)-$($component.build)-rc\u0026#34; # Set environment variables $env:IMAGE = $image docker-compose -f ./docker/docker-compose.yml up docker-compose -f ./docker/docker-compose.yml down To run the script, enter the following command:\n./run.ps1 While running, the script will generate a name for the image using the data in the component.json file and then run it in Docker Compose. In accordance with the scenario, Docker Compose will run two containers: one with the service, and another with a DB. The service will be made available on port 8080.\nWhen the service is stopped, both containers will automatically be stopped as well.\nCongratulations! You now know how to Dockerize your microservices! We hope this knowledge helps you avoid environment related errors and keep your development process automated and standardized.\n","description":null,"image":null,"permalink":"/node/tutorials/microservice_dockerization/step5/","subtitle":null,"tags":null,"title":"Step 5. Run"},{"content":"While developing and debugging a project, you may find the need to run and connect to a microservice, for example, using a client. Readily available Docker images, like the ones we made in the previous steps, are quite handy in such situations.\nTo run our service, we’ll be using the scenario we wrote in the third step of this tutorial in the docker-compose.yml file:\nversion: \u0026#39;3.3\u0026#39; services: app: image: ${IMAGE} ports: - \u0026#34;8080:8080\u0026#34; depends_on: - mongo environment: - HTTP_PORT=8080 - MONGO_ENABLED=true - MONGO_SERVICE_HOST=mongo - MONGO_SERVICE_PORT=27017 mongo: image: mongo:latest To automated the running process, we can create a file named run.ps1 with the following script:\n#!/usr/bin/env pwsh Set-StrictMode -Version latest $ErrorActionPreference = \u0026#34;Stop\u0026#34; $component = Get-Content -Path \u0026#34;component.json\u0026#34; | ConvertFrom-Json $image=\u0026#34;$($component.registry)/$($component.name):$($component.version)-$($component.build)-rc\u0026#34; # Set environment variables $env:IMAGE = $image docker-compose -f ./docker/docker-compose.yml up docker-compose -f ./docker/docker-compose.yml down To run the script, enter the following command:\n./run.ps1 While running, the script will generate a name for the image using the data in the component.json file and then run it in Docker Compose. In accordance with the scenario, Docker Compose will run two containers: one with the service, and another with a DB. The service will be made available on port 8080.\nWhen the service is stopped, both containers will automatically be stopped as well.\nCongratulations! You now know how to Dockerize your microservices! We hope this knowledge helps you avoid environment related errors and keep your development process automated and standardized.\n","description":null,"image":null,"permalink":"/python/tutorials/microservice_dockerization/step5/","subtitle":null,"tags":null,"title":"Step 5. Run"},{"content":"A facade’s RESTful operations are implemented by REST services, which receive external requests and delegate their execution to operations.\nTo process requests made to the API’s first version, let’s create a file named FacadeServiceV1.ts in the services/version1 folder with the following code:\n/src/services/version1/FacadeServiceV1.ts\nimport { IReferences } from \u0026#39;pip-services3-commons-node\u0026#39;; import { ConfigParams } from \u0026#39;pip-services3-commons-node\u0026#39;; import { RestService } from \u0026#39;pip-services3-rpc-node\u0026#39;; import { AboutOperations } from \u0026#39;pip-services3-rpc-node\u0026#39;; import { AuthorizerV1 } from \u0026#39;../version1/AuthorizerV1\u0026#39;; import { SessionsOperationsV1 } from \u0026#39;../../operations/version1/SessionsOperationsV1\u0026#39;; import { SitesOperationsV1 } from \u0026#39;../../operations/version1/SitesOperationsV1\u0026#39;; import { InvitationsOperationsV1 } from \u0026#39;../../operations/version1/InvitationsOperationsV1\u0026#39;; import { BeaconsOperationsV2 } from \u0026#39;../../operations/version2/BeaconsOperationsV2\u0026#39;; export class FacadeServiceV2 extends RestService { private _aboutOperations = new AboutOperations(); private _sessionsOperations = new SessionsOperationsV1(); private _sitesOperations = new SitesOperationsV1(); private _invitationsOperations = new InvitationsOperationsV1(); private _beaconsOperations = new BeaconsOperationsV2(); public constructor() { super(); this._baseRoute = \u0026#34;api/v2\u0026#34; } public configure(config: ConfigParams): void { super.configure(config); this._aboutOperations.configure(config); this._sessionsOperations.configure(config); this._sitesOperations.configure(config); this._invitationsOperations.configure(config); this._beaconsOperations.configure(config); } public setReferences(references: IReferences): void { super.setReferences(references); this._aboutOperations.setReferences(references); this._sessionsOperations.setReferences(references); this._sitesOperations.setReferences(references); this._invitationsOperations.setReferences(references); this._beaconsOperations.setReferences(references); } public register(): void { let auth = new AuthorizerV1(); // Restore session middleware  this.registerInterceptor(\u0026#39;\u0026#39;, (req, res, next) =\u0026gt; { this._sessionsOperations.loadSession(req, res, next); }); // About Route  this.registerRouteWithAuth(\u0026#39;get\u0026#39;, \u0026#39;/about\u0026#39;, null, auth.anybody(), (req, res) =\u0026gt; { this._aboutOperations.about(req, res); }); // Session Routes  this.registerRouteWithAuth(\u0026#39;post\u0026#39;, \u0026#39;/signup\u0026#39;, null, auth.anybody(), (req, res) =\u0026gt; { this._sessionsOperations.signup(req, res); }); this.registerRouteWithAuth(\u0026#39;get\u0026#39;, \u0026#39;/signup/validate\u0026#39;, null, auth.anybody(), (req, res) =\u0026gt; { this._sessionsOperations.signupValidate(req, res); }); this.registerRouteWithAuth(\u0026#39;post\u0026#39;, \u0026#39;/signin\u0026#39;, null, auth.anybody(), (req, res) =\u0026gt; { this._sessionsOperations.signin(req, res); }); this.registerRouteWithAuth(\u0026#39;post\u0026#39;, \u0026#39;/signout\u0026#39;, null, auth.anybody(), (req, res) =\u0026gt; { this._sessionsOperations.signout(req, res); }); this.registerRouteWithAuth(\u0026#39;get\u0026#39;, \u0026#39;/sessions\u0026#39;, null, auth.admin(), (req, res) =\u0026gt; { this._sessionsOperations.getSessions(req, res); }); this.registerRouteWithAuth(\u0026#39;post\u0026#39;, \u0026#39;/sessions/restore\u0026#39;, null, auth.signed(), (req, res) =\u0026gt; { this._sessionsOperations.restoreSession(req, res); }); this.registerRouteWithAuth(\u0026#39;get\u0026#39;, \u0026#39;/sessions/current\u0026#39;, null, auth.signed(), (req, res) =\u0026gt; { this._sessionsOperations.getCurrentSession(req, res); }); this.registerRouteWithAuth(\u0026#39;get\u0026#39;, \u0026#39;/sessions/:user_id\u0026#39;, null, auth.ownerOrAdmin(\u0026#39;user_id\u0026#39;), (req, res) =\u0026gt; { this._sessionsOperations.getUserSessions(req, res); }); this.registerRouteWithAuth(\u0026#39;del\u0026#39;, \u0026#39;/sessions/:user_id/:session_id\u0026#39;, null, auth.ownerOrAdmin(\u0026#39;user_id\u0026#39;), (req, res) =\u0026gt; { this._sessionsOperations.closeSession(req, res); }); // Site Routes  this.registerRouteWithAuth(\u0026#39;get\u0026#39;, \u0026#39;/sites\u0026#39;, null, auth.signed(), (req, res) =\u0026gt; { this._sitesOperations.getAuthorizedSites(req, res); }); this.registerRouteWithAuth(\u0026#39;get\u0026#39;, \u0026#39;/sites/all\u0026#39;, null, auth.admin(), (req, res) =\u0026gt; { this._sitesOperations.getSites(req, res); }); this.registerRouteWithAuth(\u0026#39;get\u0026#39;, \u0026#39;/sites/find_by_code\u0026#39;, null, auth.anybody(), (req, res) =\u0026gt; { this._sitesOperations.findSiteByCode(req, res); }); this.registerRouteWithAuth(\u0026#39;get\u0026#39;, \u0026#39;/sites/:site_id\u0026#39;, null, auth.siteUser(), (req, res) =\u0026gt; { this._sitesOperations.getSite(req, res); }); this.registerRouteWithAuth(\u0026#39;post\u0026#39;, \u0026#39;/sites/:site_id/generate_code\u0026#39;, null, auth.siteAdmin(), (req, res) =\u0026gt; { this._sitesOperations.generateCode(req, res); }); this.registerRouteWithAuth(\u0026#39;post\u0026#39;, \u0026#39;/sites\u0026#39;, null, auth.signed(), (req, res) =\u0026gt; { this._sitesOperations.createSite(req, res); }); this.registerRouteWithAuth(\u0026#39;post\u0026#39;, \u0026#39;/sites/validate_code\u0026#39;, null, auth.signed(), (req, res) =\u0026gt; { this._sitesOperations.validateSiteCode(req, res); }); this.registerRouteWithAuth(\u0026#39;put\u0026#39;, \u0026#39;/sites/:site_id\u0026#39;, null, auth.siteAdmin(), (req, res) =\u0026gt; { this._sitesOperations.updateSite(req, res); }); this.registerRouteWithAuth(\u0026#39;del\u0026#39;, \u0026#39;/sites/:site_id\u0026#39;, null, auth.admin(), (req, res) =\u0026gt; { this._sitesOperations.deleteSite(req, res); }); this.registerRouteWithAuth(\u0026#39;post\u0026#39;, \u0026#39;/sites/:site_id/remove\u0026#39;, null, auth.siteUser(), (req, res) =\u0026gt; { this._sitesOperations.removeSite(req, res); }); // Invitation Routes  this.registerRouteWithAuth(\u0026#39;get\u0026#39;, \u0026#39;/sites/:site_id/invitations\u0026#39;, null, auth.siteUser(), (req, res) =\u0026gt; { this._invitationsOperations.getInvitations(req, res); }); this.registerRouteWithAuth(\u0026#39;get\u0026#39;, \u0026#39;/sites/:site_id/invitations/:invitation_id\u0026#39;, null, auth.siteUser(), (req, res) =\u0026gt; { this._invitationsOperations.getInvitation(req, res); }); this.registerRouteWithAuth(\u0026#39;post\u0026#39;, \u0026#39;/sites/:site_id/invitations\u0026#39;, null, auth.signed(), (req, res) =\u0026gt; { this._invitationsOperations.sendInvitation(req, res); }); this.registerRouteWithAuth(\u0026#39;post\u0026#39;, \u0026#39;/sites/:site_id/invitations/notify\u0026#39;, null, auth.siteManager(), (req, res) =\u0026gt; { this._invitationsOperations.notifyInvitation(req, res); }); this.registerRouteWithAuth(\u0026#39;del\u0026#39;, \u0026#39;/sites/:site_id/invitations/:invitation_id\u0026#39;, null, auth.siteManager(), (req, res) =\u0026gt; { this._invitationsOperations.deleteInvitation(req, res); }); this.registerRouteWithAuth(\u0026#39;post\u0026#39;, \u0026#39;/sites/:site_id/invitations/:invitation_id/approve\u0026#39;, null, auth.siteManager(), (req, res) =\u0026gt; { this._invitationsOperations.approveInvitation(req, res); }); this.registerRouteWithAuth(\u0026#39;post\u0026#39;, \u0026#39;/sites/:site_id/invitations/:invitation_id/deny\u0026#39;, null, auth.siteManager(), (req, res) =\u0026gt; { this._invitationsOperations.denyInvitation(req, res); }); this.registerRouteWithAuth(\u0026#39;post\u0026#39;, \u0026#39;/sites/:site_id/invitations/:invitation_id/resend\u0026#39;, null, auth.siteManager(), (req, res) =\u0026gt; { this._invitationsOperations.resendInvitation(req, res); }); // Beacon Routes  this.registerRouteWithAuth(\u0026#39;get\u0026#39;, \u0026#39;/sites/:site_id/xbeacons\u0026#39;, null, auth.siteUser(), (req, res) =\u0026gt; { this._beaconsOperations.getBeaconsX(req, res); }); this.registerRouteWithAuth(\u0026#39;get\u0026#39;, \u0026#39;/sites/:site_id/xbeacons/:beacon_id\u0026#39;, null, auth.siteUser(), (req, res) =\u0026gt; { this._beaconsOperations.getBeaconX(req, res); }); this.registerRouteWithAuth(\u0026#39;post\u0026#39;, \u0026#39;/sites/:site_id/xbeacons/calculate_position\u0026#39;, null, auth.siteManager(), (req, res) =\u0026gt; { this._beaconsOperations.calculatePositionX(req, res); }); this.registerRouteWithAuth(\u0026#39;post\u0026#39;, \u0026#39;/sites/:site_id/xbeacons\u0026#39;, null, auth.siteManager(), (req, res) =\u0026gt; { this._beaconsOperations.createBeaconX(req, res); }); this.registerRouteWithAuth(\u0026#39;post\u0026#39;, \u0026#39;/sites/:site_id/xbeacons/validate_udi\u0026#39;, null, auth.signed(), (req, res) =\u0026gt; { this._beaconsOperations.validateBeaconUdiX(req, res); }); this.registerRouteWithAuth(\u0026#39;put\u0026#39;, \u0026#39;/sites/:site_id/xbeacons/:beacon_id\u0026#39;, null, auth.siteManager(), (req, res) =\u0026gt; { this._beaconsOperations.updateBeaconX(req, res); }); this.registerRouteWithAuth(\u0026#39;del\u0026#39;, \u0026#39;/sites/:site_id/xbeacons/:beacon_id\u0026#39;, null, auth.siteManager(), (req, res) =\u0026gt; { this._beaconsOperations.deleteBeaconX(req, res); }); } } The FacadeServiceV1 component extends the standard RestService, which implements the majority of the component’s basic functionality. All that we have left to do is define some routes and delegate their processing to the operations we defined in the previous steps.\nA base route is defined in the constructor, which contains the API version that is implemented in the service.\nIn the register method, before we register our routes, we make sure to register the loadSession interceptor, which will be loading user sessions using the parameters set in the REST requests.\nNext, the routes are registered, access limits are set up using our Authorizer, and request handlers are defined using the business methods we implemented in our REST operation sets. For the sake of convenience, the registration functions are divided into 2 groups, each of which belongs to a specific operation-component.\nWhen implementing a new version of the API, the following must be done:\n Implement new REST operations or modify a copy of the existing ones; Create a new FacadeServiceVx and set a new “/api/vx” base route; Register routes for the new API and delegate their processing to the newly added and to already existing REST operations.  Continue on to Step 6 - Testing Operations to see how we can automate the testing of the service and operations we’ve created, including the authentication and authorization of requests.\nStep 6 - Testing Operations  ","description":null,"image":null,"permalink":"/node/tutorials/microservice_facade/step5/","subtitle":null,"tags":null,"title":"Step 5. Services and versioning"},{"content":"A facade’s RESTful operations are implemented by REST services, which receive external requests and delegate their execution to operations.\nTo process requests made to the API’s first version, let’s create a file named FacadeServiceV1.py in the services/version1 folder with the following code:\n/pip_facades_sample_python/services/version1/FacadeServiceV1.py\n# -*- coding: utf-8 -*- from typing import List import bottle from pip_services3_commons.convert import JsonConverter from pip_services3_commons.errors import UnauthorizedException from pip_services3_rpc.auth.BasicAuthorizer import BasicAuthorizer from pip_services3_rpc.auth.OwnerAuthorizer import OwnerAuthorizer from pip_services3_rpc.auth.RoleAuthorizer import RoleAuthorizer class AuthorizerV1: def __init__(self): self.__basic_auth = BasicAuthorizer() self.__role_auth = RoleAuthorizer() self.__owner_auth = OwnerAuthorizer() # Anybody who entered the system def anybody(self): return self.__basic_auth.anybody() # Only registered and authenticated users def signed(self): return self.__basic_auth.signed() # Only the user session owner def owner(self, id_param: str = \u0026#39;user_id\u0026#39;): return self.__owner_auth.owner(id_param) def owner_or_admin(self, id_param: str = \u0026#39;user_id\u0026#39;): return self.__owner_auth.owner_or_admin(id_param) def site_roles(self, roles: List[str], id_param: str = \u0026#39;site_id\u0026#39;): def inner(): user = None if not hasattr(bottle.request, \u0026#39;user\u0026#39;) else bottle.request.user user.roles = user.roles or [] if user is None: raise UnauthorizedException( None, \u0026#39;NOT_SIGNED\u0026#39;, \u0026#39;User must be signed in to perform this operation\u0026#39; ).with_status(401) else: site_id = bottle.request.params[\u0026#39;kwargs\u0026#39;].get(id_param) authorized = \u0026#39;admin\u0026#39; in user.roles if site_id is not None and not authorized: for role in roles: authorized = authorized or (site_id + \u0026#39;:\u0026#39; + role) in user.roles if not authorized: raise UnauthorizedException( None, \u0026#39;NOT_IN_SITE_ROLE\u0026#39;, \u0026#39;User must be site:\u0026#39; + \u0026#39; or site:\u0026#39;.join(roles) + \u0026#39; to perform this operation\u0026#39; ).with_details(\u0026#39;roles\u0026#39;, roles).with_status(403) return inner def admin(self): return self.__role_auth.user_in_role(\u0026#39;admin\u0026#39;) def site_admin(self, id_param: str = \u0026#39;site_id\u0026#39;): return self.site_roles([\u0026#39;admin\u0026#39;], id_param) def site_manager(self, id_param: str = \u0026#39;site_id\u0026#39;): return self.site_roles([\u0026#39;admin\u0026#39;, \u0026#39;manager\u0026#39;], id_param) def site_user(self, id_param: str = \u0026#39;site_id\u0026#39;): return self.site_roles([\u0026#39;admin\u0026#39;, \u0026#39;manager\u0026#39;, \u0026#39;user\u0026#39;], id_param) def site_admin_or_owner(self, user_id_param: str = \u0026#39;user_id\u0026#39;, site_id_param: str = \u0026#39;site_id\u0026#39;): def inner(): user = bottle.request.user if user is None: raise UnauthorizedException( None, \u0026#39;NOT_SIGNED\u0026#39;, \u0026#39;User must be signed in to perform this operation\u0026#39; ).with_status(401) else: user_id = dict(bottle.request.query.decode()).get(user_id_param) or JsonConverter.to_json( bottle.request.json) if user_id is not None and user_id == user.user_id: return else: site_id = bottle.request.params.get(site_id_param) authorized = \u0026#39;admin\u0026#39; in user.roles or site_id + \u0026#39;:admin\u0026#39; in user.roles if not authorized: raise UnauthorizedException( None, \u0026#39;NOT_IN_SITE_ROLE\u0026#39;, \u0026#39;User must be site:admin to perform this operation\u0026#39; ).with_details(\u0026#39;roles\u0026#39;, [\u0026#39;admin\u0026#39;]).with_status(403) return inner The FacadeServiceV1 component extends the standard RestService, which implements the majority of the component’s basic functionality. All that we have left to do is define some routes and delegate their processing to the operations we defined in the previous steps.\nA base route is defined in the constructor, which contains the API version that is implemented in the service.\nIn the register method, before we register our routes, we make sure to register the load_session interceptor, which will be loading user sessions using the parameters set in the REST requests.\nNext, the routes are registered, access limits are set up using our Authorizer, and request handlers are defined using the business methods we implemented in our REST operation sets. For the sake of convenience, the registration functions are divided into 2 groups, each of which belongs to a specific operation-component.\nWhen implementing a new version of the API, the following must be done:\n Implement new REST operations or modify a copy of the existing ones; Create a new FacadeServiceVx and set a new “/api/vx” base route; Register routes for the new API and delegate their processing to the newly added and to already existing REST operations.  Continue on to Step 6 - Testing Operations to see how we can automate the testing of the service and operations we’ve created, including the authentication and authorization of requests.\nStep 6 - Testing Operations  ","description":null,"image":null,"permalink":"/python/tutorials/microservice_facade/step5/","subtitle":null,"tags":null,"title":"Step 5. Services and versioning"},{"content":"In the previous steps, we were looking at the development of clients and at the clients themselves. However, both the client and the microservice were implemented in the same language, which allowed us to run components of the microservice from right inside the tests. In a multi-language environment, there are times when you need to create clients in a language that is different from the one that was used to write the microservice. In this last step, we will be demonstrating a similar situation, showing how to use Docker to link and run microservices and other infrastructure services, and describing how to integrate this into the development process. This step will be using the BeaconsCommandableHttpClientV1 class that we created in step 3, along with a new set of tests that still uses the Beacons microservice, but this time - one that is running in a separate Docker container. In other words, the Beacon microservice that is on DockerHub is written in Node.js, which may or may not be the language that you have been using throughout this tutorial. To run the microservice in Docker, we’ll first need to create a configuration file called docker/docker-compose.dev.yml:\nversion: \u0026#39;3.3\u0026#39; services: app: image: \u0026#34;pipdevs/data-microservice-node:1.0\u0026#34; ports: - \u0026#34;8080:8080\u0026#34; depends_on: - mongo  environment: - HTTP_ENABLED=true  - HTTP_PORT=8080  - MONGO_ENABLED=true  - MONGO_SERVICE_HOST=mongo  - MONGO_SERVICE_PORT=27017 mongo: image: mongo:latest  ports: - \u0026#34;27017:27017\u0026#34; This configuration will run the microservice alongside a Mongo DB for data storage. HTTP services will also be started on port 8080 and will be made accessible from outside the container. You can set up the microservice to run with a memory persistence as well. To do this, comment out the MONGO environment variables, as well as any other Mongo-related parameters. The image parameter contains the name of the Docker image being hosted on DockerHub (pipdevs/data-microservice-node:1.0), which is the microservice we want to be testing with. Once we get our microservice up and running, it will be available at http://localhost:8080, and the client will be able to work with it using this address. Let’s design a test, in which the client will work with our new service. We’ll be basing this test off of the one we wrote in Step 3. Place the code below into a file named test_BeaconsHttpClientV1.py.\n/test/version1/BeaconsHttpClientV1Test.py\n[Collection(\u0026#34;Sequential\u0026#34;)] public class BeaconsHttpClientV1Test : IDisposable { private static readonly ConfigParams RestConfig = ConfigParams.FromTuples( \u0026#34;connection.protocol\u0026#34;, \u0026#34;http\u0026#34;, \u0026#34;connection.host\u0026#34;, \u0026#34;localhost\u0026#34;, \u0026#34;connection.port\u0026#34;, 3000 ); private BeaconsMemoryPersistence _persistence; private BeaconsController _controller; private BeaconsRestServiceV1 _service; private BeaconsRestClientV1 _client; private BeaconsClientV1Fixture _fixture; public BeaconsHttpClientV1Test() { _persistence = new BeaconsMemoryPersistence(); _controller = new BeaconsController(); _service = new BeaconsRestServiceV1(); _client = new BeaconsRestClientV1(); IReferences references = References.FromTuples( new Descriptor(\u0026#34;beacons\u0026#34;, \u0026#34;persistence\u0026#34;, \u0026#34;memory\u0026#34;, \u0026#34;default\u0026#34;, \u0026#34;1.0\u0026#34;), _persistence, new Descriptor(\u0026#34;beacons\u0026#34;, \u0026#34;controller\u0026#34;, \u0026#34;default\u0026#34;, \u0026#34;default\u0026#34;, \u0026#34;1.0\u0026#34;), _controller, new Descriptor(\u0026#34;beacons\u0026#34;, \u0026#34;service\u0026#34;, \u0026#34;http\u0026#34;, \u0026#34;default\u0026#34;, \u0026#34;1.0\u0026#34;), _service, new Descriptor(\u0026#34;beacons\u0026#34;, \u0026#34;client\u0026#34;, \u0026#34;http\u0026#34;, \u0026#34;default\u0026#34;, \u0026#34;1.0\u0026#34;), _client ); _controller.SetReferences(references); _service.Configure(RestConfig); _service.SetReferences(references); _client.Configure(RestConfig); _client.SetReferences(references); _fixture = new BeaconsClientV1Fixture(_client); _service.OpenAsync(null).Wait(); _client.OpenAsync(null).Wait(); } public void Dispose() { _client.CloseAsync(null).Wait(); _service.CloseAsync(null).Wait(); } [Fact] public async Task TestCrudOperationsAsync() { await _fixture.TestCrudOperationsAsync(); } [Fact] public async Task TestCalculatePositionsAsync() { await _fixture.TestCalculatePositionsAsync(); } } This test differs from the previous one mainly in that we aren’t running the microservice’s components in the test itself. Instead, we are configuring our client to connect to the microservice, which will be running in our Docker container. Another difference is that we will be deleting all data from the microservice before each test, so that our test always starts off with a clean DB. Before we can start testing, we need to get our containerized microservice up and running. To do this, run the command:\ndocker-compose -f ./docker/docker-compose.dev.yml up In a separate console, run the test using the following command:\npython test.py The tests should all pass, and the container’s console should display information about what it was doing in the process:\n[beacons:INFO:2020-06-24T15:27:42.747Z] Press Control-C to stop the microservice... [beacons:DEBUG:2020-06-24T15:27:42.982Z] Opened REST service at http://0.0.0.0:8080 [beacons:INFO:2020-06-24T15:27:42.983Z] Container beacons started. [123:TRACE:2020-06-24T15:31:19.003Z] Executing v1/beacons.create_beacon method [123:TRACE:2020-06-24T15:31:19.007Z] Created item 1 [123:TRACE:2020-06-24T15:31:19.093Z] Executing v1/beacons.create_beacon method [123:TRACE:2020-06-24T15:31:19.093Z] Created item 2 [123:TRACE:2020-06-24T15:31:19.108Z] Executing v1/beacons.get_beacons method [123:TRACE:2020-06-24T15:31:19.111Z] Retrieved 2 items [123:TRACE:2020-06-24T15:31:19.165Z] Executing v1/beacons.update_beacon method [123:TRACE:2020-06-24T15:31:19.167Z] Updated item 1 [123:TRACE:2020-06-24T15:31:19.218Z] Executing v1/beacons.get_beacon_by_udi method [123:TRACE:2020-06-24T15:31:19.220Z] Found beacon by 00001 [123:TRACE:2020-06-24T15:31:19.270Z] Executing v1/beacons.delete_beacon_by_id method [123:TRACE:2020-06-24T15:31:19.271Z] Deleted item by 1 [123:TRACE:2020-06-24T15:31:19.322Z] Executing v1/beacons.get_beacon_by_id method [123:TRACE:2020-06-24T15:31:19.322Z] Cannot find item by 1 [123:TRACE:2020-06-24T15:31:19.332Z] Executing v1/beacons.delete_beacon_by_id method [123:TRACE:2020-06-24T15:31:19.333Z] Deleted item by 2 [123:TRACE:2020-06-24T15:31:21.435Z] Executing v1/beacons.create_beacon method [123:TRACE:2020-06-24T15:31:21.435Z] Created item 1 [123:TRACE:2020-06-24T15:31:21.448Z] Executing v1/beacons.create_beacon method [123:TRACE:2020-06-24T15:31:21.449Z] Created item 2 [123:TRACE:2020-06-24T15:31:21.505Z] Executing v1/beacons.calculate_position method [123:TRACE:2020-06-24T15:31:21.509Z] Retrieved 1 items [123:TRACE:2020-06-24T15:31:21.562Z] Executing v1/beacons.calculate_position method [123:TRACE:2020-06-24T15:31:21.563Z] Retrieved 2 items Using this approach, any combination of services and clients can be tested against one another.\n","description":null,"image":null,"permalink":"/net/tutorials/client_library/step5/","subtitle":null,"tags":null,"title":"Step 5. Testing the Client with a Remote Microservice"},{"content":"In the previous steps, we were looking at the development of clients and at the clients themselves. However, both the client and the microservice were implemented in the same language, which allowed us to run components of the microservice from right inside the tests. In a multi-language environment, there are times when you need to create clients in a language that is different from the one that was used to write the microservice. In this last step, we will be demonstrating a similar situation, showing how to use Docker to link and run microservices and other infrastructure services, and describing how to integrate this into the development process. This step will be using the BeaconsCommandableHttpClientV1 class that we created in step 3, along with a new set of tests that still uses the Beacons microservice, but this time - one that is running in a separate Docker container. In other words, the Beacon microservice that is on DockerHub is written in Node.js, which may or may not be the language that you have been using throughout this tutorial. To run the microservice in Docker, we’ll first need to create a configuration file called docker/docker-compose.dev.yml:\nversion: \u0026#39;3.3\u0026#39; services: app: image: \u0026#34;pipdevs/data-microservice-node:1.0\u0026#34; ports: - \u0026#34;8080:8080\u0026#34; depends_on: - mongo  environment: - HTTP_ENABLED=true  - HTTP_PORT=8080  - MONGO_ENABLED=true  - MONGO_SERVICE_HOST=mongo  - MONGO_SERVICE_PORT=27017 mongo: image: mongo:latest  ports: - \u0026#34;27017:27017\u0026#34; This configuration will run the microservice alongside a Mongo DB for data storage. HTTP services will also be started on port 8080 and will be made accessible from outside the container. You can set up the microservice to run with a memory persistence as well. To do this, comment out the MONGO environment variables, as well as any other Mongo-related parameters. The image parameter contains the name of the Docker image being hosted on DockerHub (pipdevs/data-microservice-node:1.0), which is the microservice we want to be testing with. Once we get our microservice up and running, it will be available at http://localhost:8080, and the client will be able to work with it using this address. Let’s design a test, in which the client will work with our new service. We’ll be basing this test off of the one we wrote in Step 3. Place the code below into a file named test_BeaconsHttpClientV1.ts.\n/test/version1/BeaconsHttpClient.test.ts\nimport { ConfigParams } from \u0026#39;pip-services3-commons-node\u0026#39;; import { Descriptor } from \u0026#39;pip-services3-commons-node\u0026#39;; import { References } from \u0026#39;pip-services3-commons-node\u0026#39;; import { BeaconsMemoryPersistence } from \u0026#39;pip-data-microservice-node\u0026#39;; import { BeaconsController } from \u0026#39;pip-data-microservice-node\u0026#39;; import { BeaconsHttpServiceV1 } from \u0026#39;pip-data-microservice-node\u0026#39;; import { BeaconsHttpClientV1 } from \u0026#39;../../src/version1/BeaconsHttpClientV1\u0026#39;; import { BeaconsClientV1Fixture } from \u0026#39;./BeaconsClientV1Fixture\u0026#39;; suite(\u0026#39;BeaconsHttpClientV1\u0026#39;, () =\u0026gt; { let persistence: BeaconsMemoryPersistence; let controller: BeaconsController; let service: BeaconsHttpServiceV1; let client: BeaconsHttpClientV1; let fixture: BeaconsClientV1Fixture; setup((done) =\u0026gt; { persistence = new BeaconsMemoryPersistence(); persistence.configure(new ConfigParams()); controller = new BeaconsController(); controller.configure(new ConfigParams()); let httpConfig = ConfigParams.fromTuples( \u0026#39;connection.protocol\u0026#39;, \u0026#39;http\u0026#39;, \u0026#39;connection.port\u0026#39;, 3000, \u0026#39;connection.host\u0026#39;, \u0026#39;localhost\u0026#39; ); service = new BeaconsHttpServiceV1(); service.configure(httpConfig); client = new BeaconsHttpClientV1(); client.configure(httpConfig); let references = References.fromTuples( new Descriptor(\u0026#39;beacons\u0026#39;, \u0026#39;persistence\u0026#39;, \u0026#39;memory\u0026#39;, \u0026#39;default\u0026#39;, \u0026#39;1.0\u0026#39;), persistence, new Descriptor(\u0026#39;beacons\u0026#39;, \u0026#39;controller\u0026#39;, \u0026#39;default\u0026#39;, \u0026#39;default\u0026#39;, \u0026#39;1.0\u0026#39;), controller, new Descriptor(\u0026#39;beacons\u0026#39;, \u0026#39;service\u0026#39;, \u0026#39;http\u0026#39;, \u0026#39;default\u0026#39;, \u0026#39;1.0\u0026#39;), service, new Descriptor(\u0026#39;beacons\u0026#39;, \u0026#39;client\u0026#39;, \u0026#39;http\u0026#39;, \u0026#39;default\u0026#39;, \u0026#39;1.0\u0026#39;), client ); controller.setReferences(references); service.setReferences(references); client.setReferences(references); fixture = new BeaconsClientV1Fixture(client); persistence.open(null, (err) =\u0026gt; { if (err) { done(err); return; } service.open(null, (err) =\u0026gt; { if (err) { done(err); return; } client.open(null, done); }); }); }); teardown((done) =\u0026gt; { client.close(null, (err) =\u0026gt; { service.close(null, (err) =\u0026gt; { persistence.close(null, done); }); }); }); test(\u0026#39;CRUD Operations\u0026#39;, (done) =\u0026gt; { fixture.testCrudOperations(done); }); test(\u0026#39;Calculate Position\u0026#39;, (done) =\u0026gt; { fixture.testCalculatePosition(done); }); }); This test differs from the previous one mainly in that we aren’t running the microservice’s components in the test itself. Instead, we are configuring our client to connect to the microservice, which will be running in our Docker container. Another difference is that we will be deleting all data from the microservice before each test, so that our test always starts off with a clean DB. Before we can start testing, we need to get our containerized microservice up and running. To do this, run the command:\ndocker-compose -f ./docker/docker-compose.dev.yml up In a separate console, run the test using the following command:\nnpm run test The tests should all pass, and the container’s console should display information about what it was doing in the process:\n[beacons:INFO:2020-06-24T15:27:42.747Z] Press Control-C to stop the microservice... [beacons:DEBUG:2020-06-24T15:27:42.982Z] Opened REST service at http://0.0.0.0:8080 [beacons:INFO:2020-06-24T15:27:42.983Z] Container beacons started. [123:TRACE:2020-06-24T15:31:19.003Z] Executing v1/beacons.create_beacon method [123:TRACE:2020-06-24T15:31:19.007Z] Created item 1 [123:TRACE:2020-06-24T15:31:19.093Z] Executing v1/beacons.create_beacon method [123:TRACE:2020-06-24T15:31:19.093Z] Created item 2 [123:TRACE:2020-06-24T15:31:19.108Z] Executing v1/beacons.get_beacons method [123:TRACE:2020-06-24T15:31:19.111Z] Retrieved 2 items [123:TRACE:2020-06-24T15:31:19.165Z] Executing v1/beacons.update_beacon method [123:TRACE:2020-06-24T15:31:19.167Z] Updated item 1 [123:TRACE:2020-06-24T15:31:19.218Z] Executing v1/beacons.get_beacon_by_udi method [123:TRACE:2020-06-24T15:31:19.220Z] Found beacon by 00001 [123:TRACE:2020-06-24T15:31:19.270Z] Executing v1/beacons.delete_beacon_by_id method [123:TRACE:2020-06-24T15:31:19.271Z] Deleted item by 1 [123:TRACE:2020-06-24T15:31:19.322Z] Executing v1/beacons.get_beacon_by_id method [123:TRACE:2020-06-24T15:31:19.322Z] Cannot find item by 1 [123:TRACE:2020-06-24T15:31:19.332Z] Executing v1/beacons.delete_beacon_by_id method [123:TRACE:2020-06-24T15:31:19.333Z] Deleted item by 2 [123:TRACE:2020-06-24T15:31:21.435Z] Executing v1/beacons.create_beacon method [123:TRACE:2020-06-24T15:31:21.435Z] Created item 1 [123:TRACE:2020-06-24T15:31:21.448Z] Executing v1/beacons.create_beacon method [123:TRACE:2020-06-24T15:31:21.449Z] Created item 2 [123:TRACE:2020-06-24T15:31:21.505Z] Executing v1/beacons.calculate_position method [123:TRACE:2020-06-24T15:31:21.509Z] Retrieved 1 items [123:TRACE:2020-06-24T15:31:21.562Z] Executing v1/beacons.calculate_position method [123:TRACE:2020-06-24T15:31:21.563Z] Retrieved 2 items Using this approach, any combination of services and clients can be tested against one another.\n","description":null,"image":null,"permalink":"/node/tutorials/client_library/step5/","subtitle":null,"tags":null,"title":"Step 5. Testing the Client with a Remote Microservice"},{"content":"In the previous steps, we were looking at the development of clients and at the clients themselves. However, both the client and the microservice were implemented in the same language, which allowed us to run components of the microservice from right inside the tests. In a multi-language environment, there are times when you need to create clients in a language that is different from the one that was used to write the microservice. In this last step, we will be demonstrating a similar situation, showing how to use Docker to link and run microservices and other infrastructure services, and describing how to integrate this into the development process. This step will be using the BeaconsCommandableHttpClientV1 class that we created in step 3, along with a new set of tests that still uses the Beacons microservice, but this time - one that is running in a separate Docker container. In other words, the Beacon microservice that is on DockerHub is written in Node.js, which may or may not be the language that you have been using throughout this tutorial. To run the microservice in Docker, we’ll first need to create a configuration file called docker/docker-compose.dev.yml:\nversion: \u0026#39;3.3\u0026#39; services: app: image: \u0026#34;pipdevs/data-microservice-node:1.0\u0026#34; ports: - \u0026#34;8080:8080\u0026#34; depends_on: - mongo  environment: - HTTP_ENABLED=true  - HTTP_PORT=8080  - MONGO_ENABLED=true  - MONGO_SERVICE_HOST=mongo  - MONGO_SERVICE_PORT=27017 mongo: image: mongo:latest  ports: - \u0026#34;27017:27017\u0026#34; This configuration will run the microservice alongside a Mongo DB for data storage. HTTP services will also be started on port 8080 and will be made accessible from outside the container. You can set up the microservice to run with a memory persistence as well. To do this, comment out the MONGO environment variables, as well as any other Mongo-related parameters. The image parameter contains the name of the Docker image being hosted on DockerHub (pipdevs/data-microservice-node:1.0), which is the microservice we want to be testing with. Once we get our microservice up and running, it will be available at http://localhost:8080, and the client will be able to work with it using this address. Let’s design a test, in which the client will work with our new service. We’ll be basing this test off of the one we wrote in Step 3. Place the code below into a file named test_BeaconsHttpClientV1.py.\n/test/version1/test_BeaconsHttpClientV1.py\nfrom pip_services3_commons.config import ConfigParams from pip_services3_commons.refer import References, Descriptor from src.clients.version1.BeaconsHttpClientV1 import BeaconsHttpClientV1 from src.logic.BeaconsController import BeaconsController from src.persistence.BeaconsMemoryPersistence import BeaconsMemoryPersistence from src.services.version1.BeaconsHttpServiceV1 import BeaconsHttpServiceV1 from test.clients.version1.BeaconsClientV1Fixture import BeaconsClientV1Fixture http_config = ConfigParams.from_tuples( \u0026#39;connection.protocol\u0026#39;, \u0026#39;http\u0026#39;, \u0026#39;connection.port\u0026#39;, 3000, \u0026#39;connection.host\u0026#39;, \u0026#39;localhost\u0026#39;) class TestBeaconsHttpClientV1: persistence: BeaconsMemoryPersistence controller: BeaconsController service: BeaconsHttpServiceV1 client: BeaconsHttpClientV1 fixture: BeaconsClientV1Fixture @classmethod def setup_class(cls): cls.controller = BeaconsController() cls.persistence = BeaconsMemoryPersistence() cls.service = BeaconsHttpServiceV1() cls.service.configure(http_config) cls.client = BeaconsHttpClientV1() cls.client.configure(http_config) cls.references = References.from_tuples( Descriptor(\u0026#39;beacons\u0026#39;, \u0026#39;persistence\u0026#39;, \u0026#39;memory\u0026#39;, \u0026#39;default\u0026#39;, \u0026#39;1.0\u0026#39;), cls.persistence, Descriptor(\u0026#39;beacons\u0026#39;, \u0026#39;controller\u0026#39;, \u0026#39;default\u0026#39;, \u0026#39;default\u0026#39;, \u0026#39;1.0\u0026#39;), cls.controller, Descriptor(\u0026#39;beacons\u0026#39;, \u0026#39;service\u0026#39;, \u0026#39;http\u0026#39;, \u0026#39;default\u0026#39;, \u0026#39;1.0\u0026#39;), cls.service, Descriptor(\u0026#39;beacons\u0026#39;, \u0026#39;client\u0026#39;, \u0026#39;http\u0026#39;, \u0026#39;default\u0026#39;, \u0026#39;1.0\u0026#39;), cls.client ) cls.controller.set_references(cls.references) cls.client.set_references(cls.references) cls.service.set_references(cls.references) cls.fixture = BeaconsClientV1Fixture(cls.client) cls.persistence.open(None) cls.service.open(None) cls.client.open(None) @classmethod def teardown_class(cls): cls.client.close(None) cls.service.close(None) cls.persistence.close(None) def test_crud_operations(self): self.fixture.test_crud_operations() def test_calculate_position(self): self.fixture.test_calculate_position() This test differs from the previous one mainly in that we aren’t running the microservice’s components in the test itself. Instead, we are configuring our client to connect to the microservice, which will be running in our Docker container. Another difference is that we will be deleting all data from the microservice before each test, so that our test always starts off with a clean DB. Before we can start testing, we need to get our containerized microservice up and running. To do this, run the command:\ndocker-compose -f ./docker/docker-compose.dev.yml up In a separate console, run the test using the following command:\npython test.py The tests should all pass, and the container’s console should display information about what it was doing in the process:\n[beacons:INFO:2020-06-24T15:27:42.747Z] Press Control-C to stop the microservice... [beacons:DEBUG:2020-06-24T15:27:42.982Z] Opened REST service at http://0.0.0.0:8080 [beacons:INFO:2020-06-24T15:27:42.983Z] Container beacons started. [123:TRACE:2020-06-24T15:31:19.003Z] Executing v1/beacons.create_beacon method [123:TRACE:2020-06-24T15:31:19.007Z] Created item 1 [123:TRACE:2020-06-24T15:31:19.093Z] Executing v1/beacons.create_beacon method [123:TRACE:2020-06-24T15:31:19.093Z] Created item 2 [123:TRACE:2020-06-24T15:31:19.108Z] Executing v1/beacons.get_beacons method [123:TRACE:2020-06-24T15:31:19.111Z] Retrieved 2 items [123:TRACE:2020-06-24T15:31:19.165Z] Executing v1/beacons.update_beacon method [123:TRACE:2020-06-24T15:31:19.167Z] Updated item 1 [123:TRACE:2020-06-24T15:31:19.218Z] Executing v1/beacons.get_beacon_by_udi method [123:TRACE:2020-06-24T15:31:19.220Z] Found beacon by 00001 [123:TRACE:2020-06-24T15:31:19.270Z] Executing v1/beacons.delete_beacon_by_id method [123:TRACE:2020-06-24T15:31:19.271Z] Deleted item by 1 [123:TRACE:2020-06-24T15:31:19.322Z] Executing v1/beacons.get_beacon_by_id method [123:TRACE:2020-06-24T15:31:19.322Z] Cannot find item by 1 [123:TRACE:2020-06-24T15:31:19.332Z] Executing v1/beacons.delete_beacon_by_id method [123:TRACE:2020-06-24T15:31:19.333Z] Deleted item by 2 [123:TRACE:2020-06-24T15:31:21.435Z] Executing v1/beacons.create_beacon method [123:TRACE:2020-06-24T15:31:21.435Z] Created item 1 [123:TRACE:2020-06-24T15:31:21.448Z] Executing v1/beacons.create_beacon method [123:TRACE:2020-06-24T15:31:21.449Z] Created item 2 [123:TRACE:2020-06-24T15:31:21.505Z] Executing v1/beacons.calculate_position method [123:TRACE:2020-06-24T15:31:21.509Z] Retrieved 1 items [123:TRACE:2020-06-24T15:31:21.562Z] Executing v1/beacons.calculate_position method [123:TRACE:2020-06-24T15:31:21.563Z] Retrieved 2 items Using this approach, any combination of services and clients can be tested against one another.\n","description":null,"image":null,"permalink":"/python/tutorials/client_library/step5/","subtitle":null,"tags":null,"title":"Step 5. Testing the Client with a Remote Microservice"},{"content":"Our service is pretty much done - all that is left is to place the components we’ve developed into a process container and configure it.\nWhen a container is started, it starts composing the microservice out of the components indicated in the configuration file. For the container to be able to build these components, it will need a component factory. In the build directory, create a BeaconsServiceFactory class and populate it with the following code:\n/src/service/build/BeaconsServiceFactory.cs\nnamespace Beacons.Build { public class BeaconsServiceFactory : Factory { public static Descriptor Descriptor = new Descriptor(\u0026#34;beacons\u0026#34;, \u0026#34;factory\u0026#34;, \u0026#34;service\u0026#34;, \u0026#34;default\u0026#34;, \u0026#34;1.0\u0026#34;); public static Descriptor MemoryPersistenceDescriptor = new Descriptor(\u0026#34;beacons\u0026#34;, \u0026#34;persistence\u0026#34;, \u0026#34;memory\u0026#34;, \u0026#34;*\u0026#34;, \u0026#34;1.0\u0026#34;); public static Descriptor MongoDbPersistenceDescriptor = new Descriptor(\u0026#34;beacons\u0026#34;, \u0026#34;persistence\u0026#34;, \u0026#34;mongodb\u0026#34;, \u0026#34;*\u0026#34;, \u0026#34;1.0\u0026#34;); public static Descriptor ControllerDescriptor = new Descriptor(\u0026#34;beacons\u0026#34;, \u0026#34;controller\u0026#34;, \u0026#34;default\u0026#34;, \u0026#34;*\u0026#34;, \u0026#34;1.0\u0026#34;); public static Descriptor HttpServiceDescriptor = new Descriptor(\u0026#34;beacons\u0026#34;, \u0026#34;service\u0026#34;, \u0026#34;http\u0026#34;, \u0026#34;*\u0026#34;, \u0026#34;1.0\u0026#34;); public BeaconsServiceFactory() { RegisterAsType(MemoryPersistenceDescriptor, typeof(BeaconsMemoryPersistence)); RegisterAsType(MongoDbPersistenceDescriptor, typeof(BeaconsMongoDbPersistence)); RegisterAsType(ControllerDescriptor, typeof(BeaconsController)); RegisterAsType(HttpServiceDescriptor, typeof(BeaconsHttpServiceV1)); } } } As shown in the code above, we start by creating descriptors for all of our components, and then, in the constructor, we register each component in the factory using its descriptor.\nNow let’s move on to creating the container itself. In the container directory, create a BeaconsProcess file with the following code:\n/src/service/containers/BeaconsProcess.cs\nnamespace Beacons.Containers { public class BeaconsProcess : ProcessContainer { public BeaconsProcess() : base(\u0026#34;beacons\u0026#34;, \u0026#34;Beacons microservice\u0026#34;) { AddFactory(new DefaultRpcFactory()); AddFactory(new DefaultSwaggerFactory()); AddFactory(new BeaconsServiceFactory()); } } } Next, add the factories that are missing from the standard container (the one from the pip-services3-container module), so that we can build all the objects our service needs. In our case, this means adding the factory for the components we’ve written, as well as the default RPC factory (from the pip-services3-rpc module), which is needed for the HTTP service to work.\nBefore we run the microservice, we need to prepare an initial configuration for it. In the config folder, create a config.yml file with the following configuration:\n/config/config.yml\n--- # Container descriptor - descriptor: \u0026#34;pip-services:context-info:default:default:1.0\u0026#34; name: \u0026#34;beacons\u0026#34; description: \u0026#34;Beacons microservice\u0026#34; # Console logger - descriptor: \u0026#34;pip-services:logger:console:default:1.0\u0026#34; level: \u0026#34;trace\u0026#34; # Tracer that posts records to log - descriptor: \u0026#34;pip-services:tracer:log:default:1.0\u0026#34; # Performance counters that post values to log - descriptor: \u0026#34;pip-services:counters:log:default:1.0\u0026#34; {{#unless MONGO_ENABLED}}{{#unless FILE_ENABLED}} # Memory persistence - descriptor: \u0026#34;beacons:persistence:memory:default:1.0\u0026#34; {{/unless}}{{/unless}} {{#if FILE_ENABLED}} # File persistence - descriptor: \u0026#34;beacons:persistence:file:default:1.0\u0026#34; path: {{FILE_PATH}}{{#unless FILE_PATH}}\u0026#34;./data/beacons.json\u0026#34;{{/unless}} {{/if}} {{#if MONGO_ENABLED}} # MongoDb persistence - descriptor: \u0026#34;beacons:persistence:mongodb:default:1.0\u0026#34; connection: uri: {{MONGO_SERVICE_URI}} host: {{MONGO_SERVICE_HOST}}{{#unless MONGO_SERVICE_HOST}}\u0026#34;localhost\u0026#34;{{/unless}} port: {{MONGO_SERVICE_PORT}}{{#unless MONGO_SERVICE_PORT}}27017{{/unless}} database: {{MONGO_DB}}{{#unless MONGO_DB}}\u0026#34;test\u0026#34;{{/unless}} {{/if}} # Controller - descriptor: \u0026#34;beacons:controller:default:default:1.0\u0026#34; # Shared HTTP Endpoint - descriptor: \u0026#34;pip-services:endpoint:http:default:1.0\u0026#34; connection: protocol: http host: 0.0.0.0 port: {{HTTP_PORT}}{{#unless HTTP_PORT}}8080{{/unless}} # HTTP Service V1 - descriptor: \u0026#34;beacons:service:http:default:1.0\u0026#34; swagger: enable: true # Hearbeat service - descriptor: \u0026#34;pip-services:heartbeat-service:http:default:1.0\u0026#34; # Status service - descriptor: \u0026#34;pip-services:status-service:http:default:1.0\u0026#34; # Swagger service - descriptor: \u0026#34;pip-services:swagger-service:http:default:1.0\u0026#34; Let’s take a closer look at “what’s what” in the configuration above. First of all, the file is structured in such a way that the configuration is divided into sections. Each section consists of one or more descriptors and, optionally, a set of configuration parameters. To keep things organized, a section is meant to configure no more than one component.\nIn our case, we first configure the context parameters for the container, to make its name and description available. This information will be displayed in the logs as well.\nIn the next section, the console logger is enabled, and its log level is set to “trace”.\nAfter that, performance counters are enabled and set to send information to the logger.\nThe next two sections are dedicated to configuring the persistent storage. However, which one we end up using will be determined by whether or not the MONGO_ENABLED environment variable is set. If it is set, then the MongoDB persistence will be used. Otherwise, we will just default to the in-memory persistence\nThe controller doesn’t need any special configuration parameters, so we just list its descriptor to make sure the component gets created.\nTo enable our microservice to work on a network, we configure an endpoint with a host + port pair. If the corresponding environment variables are set, then those values will be used. Otherwise, the default values indicated in this section will be used.\nThe descriptor in the next section creates our HTTP service, which will automatically start listening for requests using the endpoint we configured in the previous section.\nThe last section configures services that monitor the health and status of our microservice.\nNow that we’ve set up the container and a valid configuration, it’s time to move on to the final Step 7. Running and testing the microservice.\nStep 7. Running and testing the microservice. ","description":null,"image":null,"permalink":"/net/tutorials/data_microservice/step6/","subtitle":null,"tags":null,"title":"Step 6. Wrapping microservice into container"},{"content":"Our service is pretty much done - all that is left is to place the components we’ve developed into a process container and configure it.\nWhen a container is started, it starts composing the microservice out of the components indicated in the configuration file. For the container to be able to build these components, it will need a component factory. In the build directory, create a BeaconsServiceFactory class and populate it with the following code:\n/src/build/BeaconsServiceFactory.ts\nimport { Factory } from \u0026#39;pip-services3-components-node\u0026#39;; import { Descriptor } from \u0026#39;pip-services3-commons-node\u0026#39;; ‍ import { BeaconsMemoryPersistence } from \u0026#39;../../src/persistence/BeaconsMemoryPersistence\u0026#39;; import { BeaconsFilePersistence } from \u0026#39;../../src/persistence/BeaconsFilePersistence\u0026#39;; import { BeaconsMongoDbPersistence } from \u0026#39;../../src/persistence/BeaconsMongoDbPersistence\u0026#39;; import { BeaconsController } from \u0026#39;../../src/logic/BeaconsController\u0026#39;; import { BeaconsHttpServiceV1 } from \u0026#39;../../src/services/version1/BeaconsHttpServiceV1\u0026#39;; ‍ export class BeaconsServiceFactory extends Factory{ public static MemoryPersistenceDescriptor = new Descriptor(\u0026#39;beacons\u0026#39;, \u0026#39;persistence\u0026#39;, \u0026#39;memory\u0026#39;, \u0026#39;*\u0026#39;, \u0026#39;1.0\u0026#39;); public static FilePersistenceDescriptor = new Descriptor(\u0026#39;beacons\u0026#39;, \u0026#39;persistence\u0026#39;, \u0026#39;file\u0026#39;, \u0026#39;*\u0026#39;, \u0026#39;1.0\u0026#39;); public static MongoDbPersistenceDescriptor = new Descriptor(\u0026#39;beacons\u0026#39;, \u0026#39;persistence\u0026#39;, \u0026#39;mongodb\u0026#39;, \u0026#39;*\u0026#39;, \u0026#39;1.0\u0026#39;); public static ControllerDescriptor = new Descriptor(\u0026#39;beacons\u0026#39;, \u0026#39;controller\u0026#39;, \u0026#39;default\u0026#39;, \u0026#39;*\u0026#39;, \u0026#39;1.0\u0026#39;); public static HttpServiceV1Descriptor = new Descriptor(\u0026#39;beacons\u0026#39;, \u0026#39;service\u0026#39;, \u0026#39;http\u0026#39;, \u0026#39;*\u0026#39;, \u0026#39;1.0\u0026#39;); constructor(){ super(); ‍ this.registerAsType(BeaconsServiceFactory.MemoryPersistenceDescriptor, BeaconsMemoryPersistence); this.registerAsType(BeaconsServiceFactory.FilePersistenceDescriptor, BeaconsFilePersistence); this.registerAsType(BeaconsServiceFactory.MongoDbPersistenceDescriptor, BeaconsMongoDbPersistence); this.registerAsType(BeaconsServiceFactory.ControllerDescriptor, BeaconsController); this.registerAsType(BeaconsServiceFactory.HttpServiceV1Descriptor, BeaconsHttpServiceV1); } } As shown in the code above, we start by creating descriptors for all of our components, and then, in the constructor, we register each component in the factory using its descriptor.\nNow let’s move on to creating the container itself. In the container directory, create a BeaconsProcess file with the following code:\nimport { ProcessContainer } from \u0026#39;pip-services3-container-node\u0026#39;; import { DefaultRpcFactory } from \u0026#39;pip-services3-rpc-node\u0026#39;; ‍ import {BeaconsServiceFactory} from \u0026#39;../build/BeaconsServiceFactory\u0026#39;; ‍ export class BeaconsProcess extends ProcessContainer{ public constructor(){ super(\u0026#39;beacons\u0026#39;, \u0026#39;Beacons microservice\u0026#39;); ‍ this._factories.add(new BeaconsServiceFactory()); this._factories.add(new DefaultRpcFactory()); } } Next, add the factories that are missing from the standard container (the one from the pip-services3-container module), so that we can build all the objects our service needs. In our case, this means adding the factory for the components we’ve written, as well as the default RPC factory (from the pip-services3-rpc module), which is needed for the HTTP service to work.\nBefore we run the microservice, we need to prepare an initial configuration for it. In the config folder, create a config.yml file with the following configuration:\n/config/config.yml\n--- # Container descriptor - descriptor: \u0026#34;pip-services:context-info:default:default:1.0\u0026#34; name: \u0026#34;beacons\u0026#34; description: \u0026#34;Beacons microservice\u0026#34; ‍ # Console logger - descriptor: \u0026#34;pip-services:logger:console:default:1.0\u0026#34; level: \u0026#34;trace\u0026#34; ‍ # Performance counter that post values to log - descriptor: \u0026#34;pip-services:counters:log:default:1.0\u0026#34; ‍ {{^if MONGO_ENABLED}} # Memory persistence- descriptor: \u0026#34;beacons:persistence:memory:default:1.0\u0026#34; {{/if}} ‍ {{#if MONGO_ENABLED}} # MongoDb persistence - descriptor: \u0026#34;beacons:persistence:mongodb:default:1.0\u0026#34; connection: uri: {{MONGO_SERVICE_URI}} host: {{MONGO_SERVICE_HOST}}{{^if MONGO_SERVICE_HOST}}\u0026#34;localhost\u0026#34;{{/if}} port: {{MONGO_SERVICE_PORT}}{{^if MONGO_SERVICE_PORT}}27017{{/if}} database: {{MONGO_DB}}{{^if MONGO_DB}}\u0026#34;test\u0026#34;{{/if}} {{/if}} ‍ # Controller - descriptor: \u0026#34;beacons:controller:default:default:1.0\u0026#34; ‍ # Shared HTTP Endpoint - descriptor: \u0026#34;pip-services:endpoint:http:default:1.0\u0026#34; connection: protocol: http host: 0.0.0.0 port: {{HTTP_PORT}}{{^if HTTP_PORT}}8080{{/if}} ‍ # HTTP Service V1 - descriptor: \u0026#34;beacons:service:http:default:1.0\u0026#34; ‍ # Heartbeat service - descriptor: \u0026#34;pip-services:heartbeat-service:http:default:1.0\u0026#34; # Status service - descriptor: \u0026#34;pip-services:status-service:http:default:1.0\u0026#34; Let’s take a closer look at “what’s what” in the configuration above. First of all, the file is structured in such a way that the configuration is divided into sections. Each section consists of one or more descriptors and, optionally, a set of configuration parameters. To keep things organized, a section is meant to configure no more than one component.\nIn our case, we first configure the context parameters for the container, to make its name and description available. This information will be displayed in the logs as well.\nIn the next section, the console logger is enabled, and its log level is set to “trace”.\nAfter that, performance counters are enabled and set to send information to the logger.\nThe next two sections are dedicated to configuring the persistent storage. However, which one we end up using will be determined by whether or not the MONGO_ENABLED environment variable is set. If it is set, then the MongoDB persistence will be used. Otherwise, we will just default to the in-memory persistence\nThe controller doesn’t need any special configuration parameters, so we just list its descriptor to make sure the component gets created.\nTo enable our microservice to work on a network, we configure an endpoint with a host + port pair. If the corresponding environment variables are set, then those values will be used. Otherwise, the default values indicated in this section will be used.\nThe descriptor in the next section creates our HTTP service, which will automatically start listening for requests using the endpoint we configured in the previous section.\nThe last section configures services that monitor the health and status of our microservice.\nNow that we’ve set up the container and a valid configuration, it’s time to move on to the final Step 7. Running and testing the microservice.\nStep 7. Running and testing the microservice. ","description":null,"image":null,"permalink":"/node/tutorials/data_microservice/step6/","subtitle":null,"tags":null,"title":"Step 6. Wrapping microservice into container"},{"content":"Our service is pretty much done - all that is left is to place the components we’ve developed into a process container and configure it.\nWhen a container is started, it starts composing the microservice out of the components indicated in the configuration file. For the container to be able to build these components, it will need a component factory. In the build directory, create a BeaconsServiceFactory class and populate it with the following code:\n/src/build/BeaconsServiceFactory.py\nfrom pip_services3_commons.refer import Descriptor from pip_services3_components.build import Factory from ..logic.BeaconsController import BeaconsController from ..persistence.BeaconsFilePersistence import BeaconsFilePersistence from ..persistence.BeaconsMemoryPersistence import BeaconsMemoryPersistence from ..persistence.BeaconsMongoDbPersistence import BeaconsMongoDbPersistence from ..services.version1.BeaconsHttpServiceV1 import BeaconsHttpServiceV1 class BeaconsServiceFactory(Factory): MemoryPersistenceDescriptor = Descriptor(\u0026#39;beacons\u0026#39;, \u0026#39;persistence\u0026#39;, \u0026#39;memory\u0026#39;, \u0026#39;*\u0026#39;, \u0026#39;1.0\u0026#39;) FilePersistenceDescriptor = Descriptor(\u0026#39;beacons\u0026#39;, \u0026#39;persistence\u0026#39;, \u0026#39;file\u0026#39;, \u0026#39;*\u0026#39;, \u0026#39;1.0\u0026#39;) MongoDbPersistenceDescriptor = Descriptor(\u0026#39;beacons\u0026#39;, \u0026#39;persistence\u0026#39;, \u0026#39;mongodb\u0026#39;, \u0026#39;*\u0026#39;, \u0026#39;1.0\u0026#39;) ControllerDescriptor = Descriptor(\u0026#39;beacons\u0026#39;, \u0026#39;controller\u0026#39;, \u0026#39;default\u0026#39;, \u0026#39;*\u0026#39;, \u0026#39;1.0\u0026#39;) HttpServiceV1Descriptor = Descriptor(\u0026#39;beacons\u0026#39;, \u0026#39;service\u0026#39;, \u0026#39;http\u0026#39;, \u0026#39;*\u0026#39;, \u0026#39;1.0\u0026#39;) def __init__(self): super(BeaconsServiceFactory, self).__init__() self.register_as_type(BeaconsServiceFactory.MemoryPersistenceDescriptor, BeaconsMemoryPersistence) self.register_as_type(BeaconsServiceFactory.FilePersistenceDescriptor, BeaconsFilePersistence) self.register_as_type(BeaconsServiceFactory.MongoDbPersistenceDescriptor, BeaconsMongoDbPersistence) self.register_as_type(BeaconsServiceFactory.ControllerDescriptor, BeaconsController) self.register_as_type(BeaconsServiceFactory.HttpServiceV1Descriptor, BeaconsHttpServiceV1) As shown in the code above, we start by creating descriptors for all of our components, and then, in the constructor, we register each component in the factory using its descriptor.\nNow let’s move on to creating the container itself. In the container directory, create a BeaconsProcess file with the following code:\nimport sys from pip_services3_container.ProcessContainer import ProcessContainer from pip_services3_rpc.build.DefaultRpcFactory import DefaultRpcFactory from pip_services3_swagger.build.DefaultSwaggerFactory import DefaultSwaggerFactory from ..build.BeaconsServiceFactory import BeaconsServiceFactory class BeaconsProcess(ProcessContainer): def __init__(self): super(BeaconsProcess, self).__init__(\u0026#39;beacons\u0026#39;, \u0026#39;Beacons microservice\u0026#39;) self._factories.add(BeaconsServiceFactory()) self._factories.add(DefaultRpcFactory()) self._factories.add(DefaultSwaggerFactory()) Next, add the factories that are missing from the standard container (the one from the pip-services3-container module), so that we can build all the objects our service needs. In our case, this means adding the factory for the components we’ve written, as well as the default RPC factory (from the pip-services3-rpc module), which is needed for the HTTP service to work.\nBefore we run the microservice, we need to prepare an initial configuration for it. In the config folder, create a config.yml file with the following configuration:\n/config/config.yml\n--- # Container descriptor - descriptor: \u0026#34;pip-services:context-info:default:default:1.0\u0026#34; name: \u0026#34;beacons\u0026#34; description: \u0026#34;Beacons microservice\u0026#34; # Console logger - descriptor: \u0026#34;pip-services:logger:console:default:1.0\u0026#34; level: \u0026#34;trace\u0026#34; # Tracer that posts records to log - descriptor: \u0026#34;pip-services:tracer:log:default:1.0\u0026#34; # Performance counters that post values to log - descriptor: \u0026#34;pip-services:counters:log:default:1.0\u0026#34; {{#unless MONGO_ENABLED}}{{#unless FILE_ENABLED}} # Memory persistence - descriptor: \u0026#34;beacons:persistence:memory:default:1.0\u0026#34; {{/unless}}{{/unless}} {{#if FILE_ENABLED}} # File persistence - descriptor: \u0026#34;beacons:persistence:file:default:1.0\u0026#34; path: {{FILE_PATH}}{{#unless FILE_PATH}}\u0026#34;./data/beacons.json\u0026#34;{{/unless}} {{/if}} {{#if MONGO_ENABLED}} # MongoDb persistence - descriptor: \u0026#34;beacons:persistence:mongodb:default:1.0\u0026#34; connection: uri: {{MONGO_SERVICE_URI}} host: {{MONGO_SERVICE_HOST}}{{#unless MONGO_SERVICE_HOST}}\u0026#34;localhost\u0026#34;{{/unless}} port: {{MONGO_SERVICE_PORT}}{{#unless MONGO_SERVICE_PORT}}27017{{/unless}} database: {{MONGO_DB}}{{#unless MONGO_DB}}\u0026#34;test\u0026#34;{{/unless}} {{/if}} # Controller - descriptor: \u0026#34;beacons:controller:default:default:1.0\u0026#34; # Shared HTTP Endpoint - descriptor: \u0026#34;pip-services:endpoint:http:default:1.0\u0026#34; connection: protocol: http host: 0.0.0.0 port: {{HTTP_PORT}}{{#unless HTTP_PORT}}8080{{/unless}} # HTTP Service V1 - descriptor: \u0026#34;beacons:service:http:default:1.0\u0026#34; swagger: enable: true # Hearbeat service - descriptor: \u0026#34;pip-services:heartbeat-service:http:default:1.0\u0026#34; # Status service - descriptor: \u0026#34;pip-services:status-service:http:default:1.0\u0026#34; # Swagger service - descriptor: \u0026#34;pip-services:swagger-service:http:default:1.0\u0026#34; Let’s take a closer look at “what’s what” in the configuration above. First of all, the file is structured in such a way that the configuration is divided into sections. Each section consists of one or more descriptors and, optionally, a set of configuration parameters. To keep things organized, a section is meant to configure no more than one component.\nIn our case, we first configure the context parameters for the container, to make its name and description available. This information will be displayed in the logs as well.\nIn the next section, the console logger is enabled, and its log level is set to “trace”.\nAfter that, performance counters are enabled and set to send information to the logger.\nThe next two sections are dedicated to configuring the persistent storage. However, which one we end up using will be determined by whether or not the MONGO_ENABLED environment variable is set. If it is set, then the MongoDB persistence will be used. Otherwise, we will just default to the in-memory persistence\nThe controller doesn’t need any special configuration parameters, so we just list its descriptor to make sure the component gets created.\nTo enable our microservice to work on a network, we configure an endpoint with a host + port pair. If the corresponding environment variables are set, then those values will be used. Otherwise, the default values indicated in this section will be used.\nThe descriptor in the next section creates our HTTP service, which will automatically start listening for requests using the endpoint we configured in the previous section.\nThe last section configures services that monitor the health and status of our microservice.\nNow that we’ve set up the container and a valid configuration, it’s time to move on to the final Step 7. Running and testing the microservice.\nStep 7. Running and testing the microservice. ","description":null,"image":null,"permalink":"/python/tutorials/data_microservice/step6/","subtitle":null,"tags":null,"title":"Step 6. Wrapping microservice into container"},{"content":"Before we integrate our new facade with the actual system, we should put it through its paces and thoroughly test it. So let’s develop a set of tests and helper elements for testing all of the operations registered in the facade. We’ll start off by creating a set of helper classes. One will test our dependencies, another will test how well the facade works with users, and the last one will contain a set of test users. All of these files will be placed in the folder /test/fixtures.\nThe file for testing dependencies will be called TestReferences.ts and will allow us to test how well the facade is able to work with the microservices it depends on. This file’s code is listed below:\n/test/fixture/TestReferences.ts\nlet _ = require(\u0026#39;lodash\u0026#39;); import { ConfigParams } from \u0026#39;pip-services3-commons-node\u0026#39;; import { Descriptor } from \u0026#39;pip-services3-commons-node\u0026#39;; import { References } from \u0026#39;pip-services3-commons-node\u0026#39;; import { Opener } from \u0026#39;pip-services3-commons-node\u0026#39;; import { Closer } from \u0026#39;pip-services3-commons-node\u0026#39;; import { Referencer } from \u0026#39;pip-services3-commons-node\u0026#39;; import { ManagedReferences } from \u0026#39;pip-services3-container-node\u0026#39;; import { IAccountsClientV1 } from \u0026#39;../../src/clients/version1/IAccountsClientV1\u0026#39;; import { AccountV1 } from \u0026#39;../../src/clients/version1/AccountV1\u0026#39;; import { IRolesClientV1 } from \u0026#39;../../src/clients/version1/IRolesClientV1\u0026#39;; import { UserRolesV1 } from \u0026#39;../../src/clients/version1/UserRolesV1\u0026#39;; import { ISessionsClientV1 } from \u0026#39;../../src/clients/version1/ISessionsClientV1\u0026#39;; import { SessionV1 } from \u0026#39;../../src/clients/version1/SessionV1\u0026#39;; import { ISitesClientV1 } from \u0026#39;../../src/clients/version1/ISitesClientV1\u0026#39;; import { SiteV1 } from \u0026#39;../../src/clients/version1/SiteV1\u0026#39;; import { SessionUserV1 } from \u0026#39;../../src/operations/version1/SessionUserV1\u0026#39;; import { TestUsers } from \u0026#39;./TestUsers\u0026#39;; import { TestSites } from \u0026#39;./TestSites\u0026#39;; import { ClientFacadeFactory } from \u0026#39;../../src/build/ClientFacadeFactory\u0026#39;; import { HttpEndpoint, DefaultRpcFactory } from \u0026#39;pip-services3-rpc-node\u0026#39;; import { FacadeServiceV1 } from \u0026#39;../../src/services/version1/FacadeServiceV1\u0026#39;; import { FacadeServiceV2 } from \u0026#39;../../src/services/version2/FacadeServiceV2\u0026#39;; import { AccountsMemoryClientV1 } from \u0026#39;../../src/clients/version1/AccountsMemoryClientV1\u0026#39;; import { SessionsMemoryClientV1 } from \u0026#39;../../src/clients/version1/SessionsMemoryClientV1\u0026#39;; import { PasswordsNullClientV1 } from \u0026#39;../../src/clients/version1/PasswordsNullClientV1\u0026#39;; import { RolesMemoryClientV1 } from \u0026#39;../../src/clients/version1/RolesMemoryClientV1\u0026#39;; import { EmailSettingsMemoryClientV1 } from \u0026#39;../../src/clients/version1/EmailSettingsMemoryClientV1\u0026#39;; import { SitesMemoryClientV1 } from \u0026#39;../../src/clients/version1/SitesMemoryClientV1\u0026#39;; export class TestReferences extends ManagedReferences { private _factory = new ClientFacadeFactory(); public constructor() { super(); this.appendDependencies(); this.configureService(); this.createUsersAndSessions(); } private appendDependencies() { // Add factories  this.put(null, new ClientFacadeFactory()); this.put(null, new DefaultRpcFactory()); // Add service  this.put(null, new FacadeServiceV1()); this.put(null, new FacadeServiceV2()); // Add services  this.put(new Descriptor(\u0026#39;pip-services-accounts\u0026#39;, \u0026#39;client\u0026#39;, \u0026#39;memory\u0026#39;, \u0026#39;default\u0026#39;, \u0026#39;*\u0026#39;), new AccountsMemoryClientV1()); this.put(new Descriptor(\u0026#39;pip-services-sessions\u0026#39;, \u0026#39;client\u0026#39;, \u0026#39;memory\u0026#39;, \u0026#39;default\u0026#39;, \u0026#39;*\u0026#39;), new SessionsMemoryClientV1()); this.put(new Descriptor(\u0026#39;pip-services-passwords\u0026#39;, \u0026#39;client\u0026#39;, \u0026#39;null\u0026#39;, \u0026#39;default\u0026#39;, \u0026#39;*\u0026#39;), new PasswordsNullClientV1()); this.put(new Descriptor(\u0026#39;pip-services-roles\u0026#39;, \u0026#39;client\u0026#39;, \u0026#39;memory\u0026#39;, \u0026#39;default\u0026#39;, \u0026#39;*\u0026#39;), new RolesMemoryClientV1()); this.put(new Descriptor(\u0026#39;pip-services-emailsettings\u0026#39;, \u0026#39;client\u0026#39;, \u0026#39;memory\u0026#39;, \u0026#39;default\u0026#39;, \u0026#39;*\u0026#39;), new EmailSettingsMemoryClientV1()); this.put(new Descriptor(\u0026#39;nov-services-sites\u0026#39;, \u0026#39;client\u0026#39;, \u0026#39;direct\u0026#39;, \u0026#39;memory\u0026#39;, \u0026#39;*\u0026#39;), new SitesMemoryClientV1()); } private configureService(): void { // Configure Facade service  let service = this.getOneRequired\u0026lt;HttpEndpoint\u0026gt;( new Descriptor(\u0026#39;pip-services\u0026#39;, \u0026#39;endpoint\u0026#39;, \u0026#39;http\u0026#39;, \u0026#39;default\u0026#39;, \u0026#39;*\u0026#39;) ); service.configure(ConfigParams.fromTuples( \u0026#39;root_path\u0026#39;, \u0026#39;\u0026#39;, //\u0026#39;/api/v1\u0026#39;,  \u0026#39;connection.protocol\u0026#39;, \u0026#39;http\u0026#39;, \u0026#39;connection.host\u0026#39;, \u0026#39;0.0.0.0\u0026#39;, \u0026#39;connection.port\u0026#39;, 3000 )); } private createUsersAndSessions(): void { // Create accounts  let accountsClient = this.getOneRequired\u0026lt;IAccountsClientV1\u0026gt;( new Descriptor(\u0026#39;pip-services-accounts\u0026#39;, \u0026#39;client\u0026#39;, \u0026#39;*\u0026#39;, \u0026#39;*\u0026#39;, \u0026#39;*\u0026#39;) ); let adminUserAccount = \u0026lt;AccountV1\u0026gt;{ id: TestUsers.AdminUserId, login: TestUsers.AdminUserLogin, name: TestUsers.AdminUserName, active: true, create_time: new Date() }; accountsClient.createAccount(null, adminUserAccount, () =\u0026gt; {}); let user1Account = \u0026lt;AccountV1\u0026gt;{ id: TestUsers.User1Id, login: TestUsers.User1Login, name: TestUsers.User1Name, active: true, create_time: new Date() }; accountsClient.createAccount(null, user1Account, () =\u0026gt; {}); let user2Account = \u0026lt;AccountV1\u0026gt;{ id: TestUsers.User2Id, login: TestUsers.User2Login, name: TestUsers.User2Name, active: true, create_time: new Date() }; accountsClient.createAccount(null, user2Account, () =\u0026gt; {}); // Create test site(s)  let sitesClient = this.getOneRequired\u0026lt;ISitesClientV1\u0026gt;( new Descriptor(\u0026#39;nov-services-sites\u0026#39;, \u0026#39;client\u0026#39;, \u0026#39;*\u0026#39;, \u0026#39;*\u0026#39;, \u0026#39;*\u0026#39;) ); let site1 = \u0026lt;SiteV1\u0026gt;{ id: TestSites.Site1Id, name: TestSites.Site1Name }; sitesClient.createSite(null, site1, () =\u0026gt; {}); // Create user roles  let rolesClient = this.getOneRequired\u0026lt;IRolesClientV1\u0026gt;( new Descriptor(\u0026#39;pip-services-roles\u0026#39;, \u0026#39;client\u0026#39;, \u0026#39;*\u0026#39;, \u0026#39;*\u0026#39;, \u0026#39;*\u0026#39;) ); rolesClient.setRoles( null, TestUsers.AdminUserId, [ \u0026#39;admin\u0026#39;, TestSites.Site1Id + \u0026#39;:admin\u0026#39; ], () =\u0026gt; {}); rolesClient.setRoles( null, TestUsers.User1Id, [ TestSites.Site1Id + \u0026#39;:manager\u0026#39; ], () =\u0026gt; {}); rolesClient.setRoles( null, TestUsers.User2Id, [ TestSites.Site1Id + \u0026#39;:user\u0026#39; ], () =\u0026gt; {}); // Create opened sessions  let sessionsClient = this.getOneRequired\u0026lt;ISessionsClientV1\u0026gt;( new Descriptor(\u0026#39;pip-services-sessions\u0026#39;, \u0026#39;client\u0026#39;, \u0026#39;*\u0026#39;, \u0026#39;*\u0026#39;, \u0026#39;*\u0026#39;) ); let adminUserData = _.clone(adminUserAccount); adminUserData.roles = [ \u0026#39;admin\u0026#39;, TestSites.Site1Id + \u0026#39;:admin\u0026#39; ]; sessionsClient.openSession( null, TestUsers.AdminUserId, TestUsers.AdminUserName, null, null, adminUserData, null, (err, session) =\u0026gt; { session.id = TestUsers.AdminUserSessionId }); let user1Data = _.clone(user1Account); user1Data.roles = [ TestSites.Site1Id + \u0026#39;:manager\u0026#39; ]; sessionsClient.openSession( null, TestUsers.User1Id, TestUsers.User1Name, null, null, user1Data, null, (err, session) =\u0026gt; { session.id = TestUsers.User1SessionId }); let user2Data = _.clone(user2Account); user2Data.roles = [ TestSites.Site1Id + \u0026#39;:user\u0026#39; ]; sessionsClient.openSession( null, TestUsers.User2Id, TestUsers.User2Name, null, null, user2Data, null, (err, session) =\u0026gt; { session.id = TestUsers.User2SessionId }); } } Now, let’s create a file with a test client, which will help us test our user and session related operations. Place the code below into a file named TestRestClient.ts:\n/test/fixture/TestRestClient.ts\nlet restify = require(\u0026#39;restify-clients\u0026#39;); import { TestUsers } from \u0026#39;./TestUsers\u0026#39;; export class TestRestClient { private _rest: any; public constructor() { let url = \u0026#39;http://localhost:3000\u0026#39;; this._rest = restify.createJsonClient({ url: url, version: \u0026#39;*\u0026#39; }); } public get(path: string, callback: (err: any, req: any, res: any, result: any) =\u0026gt; void): void { delete this._rest.headers[\u0026#39;x-session-id\u0026#39;]; this._rest.get(path, callback); } public head(path: string, callback: (err: any, req: any, res: any, result: any) =\u0026gt; void): void { delete this._rest.headers[\u0026#39;x-session-id\u0026#39;]; this._rest.head(path, callback) } public post(path: string, params: any, callback: (err: any, req: any, res: any, result: any) =\u0026gt; void): void { delete this._rest.headers[\u0026#39;x-session-id\u0026#39;]; this._rest.post(path, params, callback); } public put(path: string, params: any, callback: (err: any, req: any, res: any, result: any) =\u0026gt; void): void { delete this._rest.headers[\u0026#39;x-session-id\u0026#39;]; this._rest.put(path, params, callback); } public del(path: string, callback: (err: any, req: any, res: any, result: any) =\u0026gt; void): void { delete this._rest.headers[\u0026#39;x-session-id\u0026#39;]; this._rest.del(path, callback); } public getAsUser(sessionId: string, path: string, callback: (err: any, req: any, res: any, result: any) =\u0026gt; void): void { this._rest.headers[\u0026#39;x-session-id\u0026#39;] = sessionId; this._rest.get(path, callback); } public headAsUser(sessionId: string, path: string, callback: (err: any, req: any, res: any, result: any) =\u0026gt; void): void { this._rest.headers[\u0026#39;x-session-id\u0026#39;] = sessionId; this._rest.head(path, callback) } public postAsUser(sessionId: string, path: string, params: any, callback: (err: any, req: any, res: any, result: any) =\u0026gt; void): void { this._rest.headers[\u0026#39;x-session-id\u0026#39;] = sessionId; this._rest.post(path, params, callback); } public putAsUser(sessionId: string, path: string, params: any, callback: (err: any, req: any, res: any, result: any) =\u0026gt; void): void { this._rest.headers[\u0026#39;x-session-id\u0026#39;] = sessionId; this._rest.put(path, params, callback); } public delAsUser(sessionId: string, path: string, callback: (err: any, req: any, res: any, result: any) =\u0026gt; void): void { this._rest.headers[\u0026#39;x-session-id\u0026#39;] = sessionId; this._rest.del(path, callback); } } Lastly, define some test users in a file named TestUsers.ts, as shown below:\n/test/fixture/TestUsers.ts\nexport class TestUsers { public static readonly AdminUserId: string = \u0026#39;1\u0026#39;; public static readonly AdminUserName: string = \u0026#39;Admin User\u0026#39;; public static readonly AdminUserLogin: string = \u0026#39;admin\u0026#39;; public static readonly AdminUserPassword: string = \u0026#39;pwd123\u0026#39;; public static readonly AdminUserSessionId: string = \u0026#39;111\u0026#39;; public static readonly User1Id: string = \u0026#39;2\u0026#39;; public static readonly User1Name: string = \u0026#39;User #1\u0026#39;; public static readonly User1Login: string = \u0026#39;user1\u0026#39;; public static readonly User1Password: string = \u0026#39;pwd123\u0026#39;; public static readonly User1SessionId: string = \u0026#39;222\u0026#39;; public static readonly User2Id: string = \u0026#39;3\u0026#39;; public static readonly User2Name: string = \u0026#39;User #2\u0026#39;; public static readonly User2Login: string = \u0026#39;user2\u0026#39;; public static readonly User2Password: string = \u0026#39;pwd123\u0026#39;; public static readonly User2SessionId: string = \u0026#39;333\u0026#39;; }; Now we can move on to the tests themselves. Create the following files in the folder test/operations:\nBeaconsRoutesV1.test.ts - for testing business logic operations of the Beacons microservice:\n/test/operations/BeaconsRoutesV1.test.ts\nlet _ = require(\u0026#39;lodash\u0026#39;); let async = require(\u0026#39;async\u0026#39;); let assert = require(\u0026#39;chai\u0026#39;).assert; import { ConfigParams } from \u0026#39;pip-services3-commons-node\u0026#39;; import { Descriptor } from \u0026#39;pip-services3-commons-node\u0026#39;; import { BeaconV1 } from \u0026#39;../../../src/clients/version1/BeaconV1\u0026#39;; import { BeaconsMemoryClientV1 } from \u0026#39;../../../src/clients/version1/BeaconsMemoryClientV1\u0026#39;; import { TestUsers } from \u0026#39;../../fixtures/TestUsers\u0026#39;; import { TestReferences } from \u0026#39;../../fixtures/TestReferences\u0026#39;; import { TestRestClient } from \u0026#39;../../fixtures/TestRestClient\u0026#39;; import { BeaconsOperationsV1 } from \u0026#39;../../../src/operations/version1/BeaconsOperationsV1\u0026#39;; let BEACON1: BeaconV1 = { id: \u0026#39;1\u0026#39;, udi: \u0026#39;000001\u0026#39;, site_id: \u0026#39;1\u0026#39;, label: \u0026#39;TestBeacon1\u0026#39;, center: { type: \u0026#39;Point\u0026#39;, coordinates: [0, 0] }, radius: 50 }; let BEACON2: BeaconV1 = { id: \u0026#39;2\u0026#39;, udi: \u0026#39;000002\u0026#39;, site_id: \u0026#39;1\u0026#39;, label: \u0026#39;TestBeacon2\u0026#39;, center: { type: \u0026#39;Point\u0026#39;, coordinates: [2, 2] }, radius: 70 }; let BEACON3: BeaconV1 = { id: \u0026#39;3\u0026#39;, udi: \u0026#39;000003\u0026#39;, site_id: \u0026#39;2\u0026#39;, label: \u0026#39;TestBeacon3\u0026#39;, center: { type: \u0026#39;Point\u0026#39;, coordinates: [10, 10] }, radius: 50 }; suite(\u0026#39;BeaconsOperationsV2\u0026#39;, () =\u0026gt; { let references: TestReferences; let rest: TestRestClient; setup((done) =\u0026gt; { rest = new TestRestClient(); references = new TestReferences(); references.put(new Descriptor(\u0026#39;nov-services-beacons\u0026#39;, \u0026#39;client\u0026#39;, \u0026#39;memory\u0026#39;, \u0026#39;default\u0026#39;, \u0026#39;1.0\u0026#39;), new BeaconsMemoryClientV1()); references.open(null, done); }); teardown((done) =\u0026gt; { references.close(null, done); }); test(\u0026#39;should perform beacon operations\u0026#39;, (done) =\u0026gt; { let beacon1, beacon2, beacon3: BeaconV1; async.series([ // Create one beacon  (callback) =\u0026gt; { rest.postAsUser( TestUsers.AdminUserSessionId, \u0026#39;/api/v2/sites/\u0026#39; + BEACON1.site_id + \u0026#39;/xbeacons\u0026#39;, BEACON1, (err, req, res, beacon) =\u0026gt; { assert.isNull(err); assert.isObject(beacon); assert.equal(beacon.site_id, BEACON1.site_id); assert.equal(beacon.udi, BEACON1.udi); assert.equal(beacon.label, BEACON1.label); assert.isNotNull(beacon.center); beacon1 = beacon; callback(); } ); }, // Create another beacon  (callback) =\u0026gt; { rest.postAsUser( TestUsers.AdminUserSessionId, \u0026#39;/api/v2/sites/\u0026#39; + BEACON2.site_id + \u0026#39;/xbeacons\u0026#39;, BEACON2, (err, req, res, beacon) =\u0026gt; { assert.isNull(err); assert.isObject(beacon); assert.equal(beacon.site_id, BEACON2.site_id); assert.equal(beacon.udi, BEACON2.udi); assert.equal(beacon.label, BEACON2.label); assert.isNotNull(beacon.center); beacon2 = beacon; callback(); } ); }, // Create yet another beacon  (callback) =\u0026gt; { rest.postAsUser( TestUsers.AdminUserSessionId, \u0026#39;/api/v2/sites/\u0026#39; + BEACON3.site_id + \u0026#39;/xbeacons\u0026#39;, BEACON3, (err, req, res, beacon) =\u0026gt; { assert.isNull(err); assert.isObject(beacon); assert.equal(beacon.site_id, BEACON3.site_id); assert.equal(beacon.udi, BEACON3.udi); assert.equal(beacon.label, BEACON3.label); assert.isNotNull(beacon.center); beacon3 = beacon; callback(); } ); }, // Get all beacons  (callback) =\u0026gt; { rest.getAsUser( TestUsers.AdminUserSessionId, \u0026#39;/api/v2/sites/\u0026#39; + BEACON1.site_id + \u0026#39;/xbeacons\u0026#39;, (err, req, res, page) =\u0026gt; { assert.isNull(err); assert.isObject(page); assert.lengthOf(page.data, 2); callback(); } ); }, // Calculate positions  (callback) =\u0026gt; { rest.postAsUser( TestUsers.AdminUserSessionId, \u0026#39;/api/v2/sites/\u0026#39; + BEACON1.site_id + \u0026#39;/xbeacons/calculate_position\u0026#39;, { site_id: BEACON1.site_id, udis: [BEACON1.udi] }, (err, req, res, position) =\u0026gt; { assert.isNull(err); assert.isObject(position); assert.equal(position.type, \u0026#39;Point\u0026#39;); callback(); } ); }, // Validate beacon udi  (callback) =\u0026gt; { rest.postAsUser( TestUsers.AdminUserSessionId, \u0026#39;/api/v2/sites/\u0026#39; + beacon1.site_id + \u0026#39;/xbeacons/validate_udi?udi=\u0026#39; + beacon1.udi, {}, (err, req, res, result) =\u0026gt; { assert.isNull(err); assert.equal(result, beacon1.id); callback(); } ); }, // Update the beacon  (callback) =\u0026gt; { beacon1.label = \u0026#39;ABC\u0026#39;; rest.putAsUser( TestUsers.AdminUserSessionId, \u0026#39;/api/v2/sites/\u0026#39; + beacon1.site_id + \u0026#39;/xbeacons/\u0026#39; + beacon1.id, beacon1, (err, req, res, beacon) =\u0026gt; { assert.isNull(err); assert.isObject(beacon); assert.equal(beacon.label, \u0026#39;ABC\u0026#39;); beacon1 = beacon; callback(); } ); }, // Delete beacon  (callback) =\u0026gt; { rest.delAsUser( TestUsers.AdminUserSessionId, \u0026#39;/api/v2/sites/\u0026#39; + beacon1.site_id + \u0026#39;/xbeacons/\u0026#39; + beacon1.id, (err, req, res, result) =\u0026gt; { assert.isNull(err); //assert.isNull(result);  callback(); } ); }, // Try to get delete beacon  (callback) =\u0026gt; { rest.getAsUser( TestUsers.AdminUserSessionId, \u0026#39;/api/v2/sites/\u0026#39; + beacon1.site_id + \u0026#39;/xbeacons/\u0026#39; + beacon1.id, (err, req, res, result) =\u0026gt; { assert.isNull(err); //assert.isNull(result);  callback(); } ); } ], done); }); }); SessionsRoutesV1.test.ts - for testing user and session related operations:\n/test/operations/SessionsRoutesV1.test.ts\nlet _ = require(\u0026#39;lodash\u0026#39;); let async = require(\u0026#39;async\u0026#39;); let assert = require(\u0026#39;chai\u0026#39;).assert; import { Descriptor } from \u0026#39;pip-services3-commons-node\u0026#39;; import { TestReferences } from \u0026#39;../../fixtures/TestReferences\u0026#39;; import { TestUsers } from \u0026#39;../../fixtures/TestUsers\u0026#39;; import { TestRestClient } from \u0026#39;../../fixtures/TestRestClient\u0026#39;; suite(\u0026#39;SessionRoutesV1\u0026#39;, () =\u0026gt; { let USER = { login: \u0026#39;test\u0026#39;, name: \u0026#39;Test User\u0026#39;, email: \u0026#39;test@conceptual.vision\u0026#39;, password: \u0026#39;test123\u0026#39; }; let references: TestReferences; let rest: TestRestClient; setup((done) =\u0026gt; { rest = new TestRestClient(); references = new TestReferences(); references.open(null, done); }); teardown((done) =\u0026gt; { references.close(null, done); }); test(\u0026#39;should signup new user\u0026#39;, (done) =\u0026gt; { rest.post(\u0026#39;/api/v1/signup\u0026#39;, USER, (err, req, res, session) =\u0026gt; { assert.isNull(err); assert.isDefined(session); assert.isDefined(session.id); assert.equal(session.user_name, USER.name); done(); } ); }); test(\u0026#39;should check login for signup\u0026#39;, (done) =\u0026gt; { async.series([ // Check registered email  (callback) =\u0026gt; { rest.get(\u0026#39;/api/v1/signup/validate?login=\u0026#39; + TestUsers.User1Login, (err, req, res, result) =\u0026gt; { assert.isNotNull(err); callback(); } ); }, // Check not registered email  (callback) =\u0026gt; { rest.get(\u0026#39;/api/v1/signup/validate?login=xxx@gmail.com\u0026#39;, (err, req, res, result) =\u0026gt; { assert.isNull(err); callback(); } ); } ], done); }); test(\u0026#39;should not signup with the same email\u0026#39;, (done) =\u0026gt; { async.series([ // Sign up  (callback) =\u0026gt; { rest.post(\u0026#39;/api/v1/signup\u0026#39;, USER, (err, req, res, session) =\u0026gt; { assert.isNull(err); callback(); } ); }, // Try to sign up again  (callback) =\u0026gt; { rest.post(\u0026#39;/api/v1/signup\u0026#39;, USER, (err, req, res, session) =\u0026gt; { assert.isNotNull(err); callback(); } ); } ], done); }); test(\u0026#39;should signout\u0026#39;, (done) =\u0026gt; { rest.post(\u0026#39;/api/v1/signout\u0026#39;, null, (err, req, res, result) =\u0026gt; { assert.isNull(err); done(); } ); }); test(\u0026#39;should signin with email and password\u0026#39;, (done) =\u0026gt; { async.series([ // Sign up  (callback) =\u0026gt; { rest.post(\u0026#39;/api/v1/signup\u0026#39;, USER, (err, req, res, session) =\u0026gt; { assert.isNull(err); callback(); } ); }, // Sign in with username  (callback) =\u0026gt; { rest.post(\u0026#39;/api/v1/signin\u0026#39;, { login: USER.login, password: USER.password }, (err, req, res, session) =\u0026gt; { assert.isNull(err); callback(); } ); } ], done); }); test(\u0026#39;should get sessions as admin\u0026#39;, (done) =\u0026gt; { rest.getAsUser( TestUsers.AdminUserSessionId, \u0026#39;/api/v1/sessions?paging=1\u0026amp;skip=0\u0026amp;take=2\u0026#39;, (err, req, res, page) =\u0026gt; { assert.isNull(err); assert.isObject(page); done(); } ); }); test(\u0026#39;should get user sessions as owner\u0026#39;, (done) =\u0026gt; { rest.getAsUser( TestUsers.User1SessionId, \u0026#39;/api/v1/sessions/\u0026#39; + TestUsers.User1Id + \u0026#39;?paging=1\u0026amp;skip=0\u0026amp;take=2\u0026#39;, (err, req, res, page) =\u0026gt; { assert.isNull(err); assert.isObject(page); done(); } ); }); }); Run the tests using the following command:\nnpm run test Once all the tests pass successfully, you can move on to Step 7 - Running the facade - to learn how to deploy all of these microservices using Docker.\nStep 7 - Running the facade  ","description":null,"image":null,"permalink":"/node/tutorials/microservice_facade/step6/","subtitle":null,"tags":null,"title":"Step 6. Testing of operations"},{"content":"Before we integrate our new facade with the actual system, we should put it through its paces and thoroughly test it. So let’s develop a set of tests and helper elements for testing all of the operations registered in the facade. We’ll start off by creating a set of helper classes. One will test our dependencies, another will test how well the facade works with users, and the last one will contain a set of test users. All of these files will be placed in the folder /test/fixtures.\nThe file for testing dependencies will be called TestReferences.py and will allow us to test how well the facade is able to work with the microservices it depends on. This file’s code is listed below:\n/test/fixture/ReferencesTest.py\n# -*- coding: utf-8 -*- import datetime from copy import deepcopy from pip_services3_commons.config.ConfigParams import ConfigParams from pip_services3_commons.refer.Descriptor import Descriptor from pip_services3_container.refer.ManagedReferences import ManagedReferences # from pip_services3_mongodb.build.DefaultMongoDbFactory import DefaultMongoDbFactory from pip_services3_rpc.build.DefaultRpcFactory import DefaultRpcFactory from pip_facades_sample_python.build.ClientFacadeFactory import ClientFacadeFactory from pip_facades_sample_python.clients.version1.AccountV1 import AccountV1 from pip_facades_sample_python.clients.version1.AccountsMemoryClientV1 import AccountsMemoryClientV1 from pip_facades_sample_python.clients.version1.EmailSettingsMemoryClientV1 import EmailSettingsMemoryClientV1 from pip_facades_sample_python.clients.version1.IAccountsClientV1 import IAccountsClientV1 from pip_facades_sample_python.clients.version1.IRolesClientV1 import IRolesClientV1 from pip_facades_sample_python.clients.version1.ISessionsClientV1 import ISessionsClientV1 from pip_facades_sample_python.clients.version1.ISitesClientV1 import ISitesClientV1 from pip_facades_sample_python.clients.version1.PasswordsNullClientV1 import PasswordsNullClientV1 from pip_facades_sample_python.clients.version1.RolesMemoryClientV1 import RolesMemoryClientV1 from pip_facades_sample_python.clients.version1.SessionsMemoryClientV1 import SessionsMemoryClientV1 from pip_facades_sample_python.clients.version1.SiteV1 import SiteV1 from pip_facades_sample_python.clients.version1.SitesMemoryClientV1 import SitesMemoryClientV1 from pip_facades_sample_python.services.version1.FacadeServiceV1 import FacadeServiceV1 from pip_facades_sample_python.services.version2.FacadeServiceV2 import FacadeServiceV2 from test.fixtures.TestSites import TestSites from test.fixtures.TestUsers import TestUsers class ReferencesTest(ManagedReferences): def __init__(self): super(ReferencesTest, self).__init__() self._factory = ClientFacadeFactory() self.__append_dependencies() self.__configure_service() self.__create_user_and_sessions() def __append_dependencies(self): # Add factories self.put(None, ClientFacadeFactory()) self.put(None, DefaultRpcFactory()) # Add service self.put(None, FacadeServiceV1()) self.put(None, FacadeServiceV2()) # Add services self.put(Descriptor(\u0026#39;pip-services-accounts\u0026#39;, \u0026#39;client\u0026#39;, \u0026#39;memory\u0026#39;, \u0026#39;default\u0026#39;, \u0026#39;*\u0026#39;), AccountsMemoryClientV1()) self.put(Descriptor(\u0026#39;pip-services-sessions\u0026#39;, \u0026#39;client\u0026#39;, \u0026#39;memory\u0026#39;, \u0026#39;default\u0026#39;, \u0026#39;*\u0026#39;), SessionsMemoryClientV1()) self.put(Descriptor(\u0026#39;pip-services-passwords\u0026#39;, \u0026#39;client\u0026#39;, \u0026#39;null\u0026#39;, \u0026#39;default\u0026#39;, \u0026#39;*\u0026#39;), PasswordsNullClientV1()) self.put(Descriptor(\u0026#39;pip-services-roles\u0026#39;, \u0026#39;client\u0026#39;, \u0026#39;memory\u0026#39;, \u0026#39;default\u0026#39;, \u0026#39;*\u0026#39;), RolesMemoryClientV1()) self.put(Descriptor(\u0026#39;pip-services-emailsettings\u0026#39;, \u0026#39;client\u0026#39;, \u0026#39;memory\u0026#39;, \u0026#39;default\u0026#39;, \u0026#39;*\u0026#39;), EmailSettingsMemoryClientV1()) self.put(Descriptor(\u0026#39;nov-services-sites\u0026#39;, \u0026#39;client\u0026#39;, \u0026#39;direct\u0026#39;, \u0026#39;memory\u0026#39;, \u0026#39;*\u0026#39;), SitesMemoryClientV1()) def __configure_service(self): # Configure Facade service service = self.get_one_required(Descriptor(\u0026#39;pip-services\u0026#39;, \u0026#39;endpoint\u0026#39;, \u0026#39;http\u0026#39;, \u0026#39;default\u0026#39;, \u0026#39;*\u0026#39;)) service.configure(ConfigParams.from_tuples( \u0026#39;root_path\u0026#39;, \u0026#39;\u0026#39;, # \u0026#39;/api/v1\u0026#39;, \u0026#39;connection.protocol\u0026#39;, \u0026#39;http\u0026#39;, \u0026#39;connection.host\u0026#39;, \u0026#39;localhost\u0026#39;, \u0026#39;connection.port\u0026#39;, 3000 )) def __create_user_and_sessions(self): # Create accounts accounts_client: IAccountsClientV1 = self.get_one_required( Descriptor(\u0026#39;pip-services-accounts\u0026#39;, \u0026#39;client\u0026#39;, \u0026#39;*\u0026#39;, \u0026#39;*\u0026#39;, \u0026#39;*\u0026#39;)) admin_user_account = AccountV1( id=TestUsers.AdminUserId, login=TestUsers.AdminUserLogin, name=TestUsers.AdminUserName, active=True, create_time=datetime.datetime.now() ) accounts_client.create_account(None, admin_user_account) user_1_account = AccountV1( id=TestUsers.User1Id, login=TestUsers.User1Login, name=TestUsers.User1Name, active=True, create_time=datetime.datetime.now() ) accounts_client.create_account(None, user_1_account) user_2_account = AccountV1( id=TestUsers.User2Id, login=TestUsers.User2Login, name=TestUsers.User2Name, active=True, create_time=datetime.datetime.now() ) accounts_client.create_account(None, user_2_account) # Create test site(s) sites_client: ISitesClientV1 = self.get_one_required(Descriptor(\u0026#39;nov-services-sites\u0026#39;, \u0026#39;client\u0026#39;, \u0026#39;*\u0026#39;, \u0026#39;*\u0026#39;, \u0026#39;*\u0026#39;)) site1 = SiteV1( id=TestSites.Site1Id, name=TestSites.Site1Name ) sites_client.create_site(None, site1) # Create user roles roles_client: IRolesClientV1 = self.get_one_required(Descriptor(\u0026#39;pip-services-roles\u0026#39;, \u0026#39;client\u0026#39;, \u0026#39;*\u0026#39;, \u0026#39;*\u0026#39;, \u0026#39;*\u0026#39;)) roles_client.set_roles(None, TestUsers.AdminUserId, [\u0026#39;admin\u0026#39;, TestSites.Site1Id + \u0026#39;:admin\u0026#39;]) roles_client.set_roles(None, TestUsers.User1Id, [TestSites.Site1Id + \u0026#39;:manager\u0026#39;]) roles_client.set_roles(None, TestUsers.User2Id, [TestSites.Site1Id + \u0026#39;:user\u0026#39;]) # Create opened sessions sessions_client: ISessionsClientV1 = self.get_one_required( Descriptor(\u0026#39;pip-services-sessions\u0026#39;, \u0026#39;client\u0026#39;, \u0026#39;*\u0026#39;, \u0026#39;*\u0026#39;, \u0026#39;*\u0026#39;)) admin_user_data = deepcopy(admin_user_account) admin_user_data.roles = [\u0026#39;admin\u0026#39;, TestSites.Site1Id + \u0026#39;:admin\u0026#39;] sessions_client.open_session(None, TestUsers.AdminUserId, TestUsers.AdminUserName, None, None, admin_user_data, None).id = TestUsers.AdminUserSessionId user_1_data = deepcopy(user_1_account) user_1_data.roles = [TestSites.Site1Id + \u0026#39;:manager\u0026#39;] sessions_client.open_session(None, TestUsers.User1Id, TestUsers.User1Name, None, None, user_1_data, None, ).id = TestUsers.User1SessionId user_2_data = deepcopy(user_2_account) user_2_data.roles = [TestSites.Site1Id + \u0026#39;:manager\u0026#39;] sessions_client.open_session(None, TestUsers.User2Id, TestUsers.User2Name, None, None, user_2_data, None, ).id = TestUsers.User2SessionId Now, let’s create a file with a test client, which will help us test our user and session related operations. Place the code below into a file named RestClientTest.py:\n/test/fixture/RestClientTest.py\n# -*- coding: utf-8 -*- import requests class RestClientTest: _rest = None headers = {\u0026#39;Content-type\u0026#39;: \u0026#39;application/json\u0026#39;} url = \u0026#39;http://localhost:3000\u0026#39; def __init__(self): self._rest = requests.Session() def get(self, path): response = self._rest.request(\u0026#39;GET\u0026#39;, self.url + path, headers=self.headers) return response def head(self, path): response = self._rest.request(\u0026#39;HEAD\u0026#39;, self.url + path, headers=self.headers) return response def post(self, path, params): response = self._rest.request(\u0026#39;POST\u0026#39;, self.url + path, json=params, headers=self.headers) return response def put(self, path, params): response = self._rest.request(\u0026#39;PUT\u0026#39;, self.url + path, json=params, headers=self.headers) return response def delete(self, path, params=None): response = self._rest.request(\u0026#39;DELETE\u0026#39;, self.url + path, json=params, headers=self.headers) return response def get_as_user(self, session_id, path): self.headers.update({\u0026#39;x-session-id\u0026#39;: session_id}) # self._rest.request(\u0026#39;GET\u0026#39;, path, headers=self.headers) return self._rest.get(self.url + path, headers=self.headers) def head_as_user(self, session_id, path): self.headers.update({\u0026#39;x-session-id\u0026#39;: session_id}) return self._rest.head(self.url + path, headers=self.headers) def post_as_user(self, session_id, path, params): self.headers.update({\u0026#39;x-session-id\u0026#39;: session_id}) return self._rest.post(self.url + path, json=params, headers=self.headers) def put_as_user(self, session_id, path, params): self.headers.update({\u0026#39;x-session-id\u0026#39;: session_id}) return self._rest.put(self.url + path, json=params, headers=self.headers) def delete_as_user(self, session_id, path): self.headers.update({\u0026#39;x-session-id\u0026#39;: session_id}) return self._rest.delete(self.url + path, headers=self.headers) Lastly, define some test users in a file named TestUsers.py, as shown below:\n/test/fixture/TestUsers.py\n# -*- coding: utf-8 -*- class TestUsers: AdminUserId: str = \u0026#39;1\u0026#39; AdminUserName: str = \u0026#39;Admin User\u0026#39; AdminUserLogin: str = \u0026#39;admin\u0026#39; AdminUserPassword: str = \u0026#39;pwd123\u0026#39; AdminUserSessionId: str = \u0026#39;111\u0026#39; User1Id: str = \u0026#39;2\u0026#39; User1Name: str = \u0026#39;User #1\u0026#39; User1Login: str = \u0026#39;user1\u0026#39; User1Password: str = \u0026#39;pwd123\u0026#39; User1SessionId: str = \u0026#39;222\u0026#39; User2Id: str = \u0026#39;3\u0026#39; User2Name: str = \u0026#39;User #2\u0026#39; User2Login: str = \u0026#39;user2\u0026#39; User2Password: str = \u0026#39;pwd123\u0026#39; User2SessionId: str = \u0026#39;333\u0026#39; Now we can move on to the tests themselves. Create the following files in the folder test/operations:\ntest_BeaconsRoutesV1.py - for testing business logic operations of the Beacons microservice:\n/test/operations/test_BeaconsRoutesV1.py\n# -*- coding: utf-8 -*- from pip_services3_commons.convert import JsonConverter, TypeCode from pip_services3_commons.refer import Descriptor from pip_facades_sample_python.clients.version1.BeaconV1 import BeaconV1 from pip_facades_sample_python.clients.version1.BeaconsMemoryClientV1 import BeaconsMemoryClientV1 from test.fixtures.ReferencesTest import ReferencesTest from test.fixtures.RestClientTest import RestClientTest from test.fixtures.TestUsers import TestUsers BEACON1 = BeaconV1(id=\u0026#34;1\u0026#34;, site_id=\u0026#34;1\u0026#34;, udi=\u0026#34;00001\u0026#34;, label=\u0026#34;TestBeacon1\u0026#34;, center={\u0026#34;type\u0026#34;: \u0026#39;Point\u0026#39;, \u0026#34;coordinates\u0026#34;: [0, 0]}, radius=50) BEACON2 = BeaconV1(id=\u0026#34;2\u0026#34;, site_id=\u0026#34;1\u0026#34;, udi=\u0026#34;00002\u0026#34;, label=\u0026#34;TestBeacon2\u0026#34;, center={\u0026#34;type\u0026#34;: \u0026#39;Point\u0026#39;, \u0026#34;coordinates\u0026#34;: [2, 2]}, radius=70) BEACON3 = BeaconV1(id=\u0026#34;3\u0026#34;, site_id=\u0026#34;2\u0026#34;, udi=\u0026#34;00003\u0026#34;, label=\u0026#34;TestBeacon3\u0026#34;, center={\u0026#34;type\u0026#34;: \u0026#39;Point\u0026#39;, \u0026#34;coordinates\u0026#34;: [10, 10]}, radius=50) class TestBeaconsOperationsV1: references: ReferencesTest = None rest: RestClientTest = None @classmethod def setup_class(cls): cls.rest = RestClientTest() cls.references = ReferencesTest() cls.references.put(Descriptor(\u0026#39;nov-services-beacons\u0026#39;, \u0026#39;client\u0026#39;, \u0026#39;memory\u0026#39;, \u0026#39;default\u0026#39;, \u0026#39;1.0\u0026#39;), BeaconsMemoryClientV1()) cls.references.open(None) @classmethod def teardown_class(cls): cls.references.close(None) def test_beacons_operations(self): # Create one beacon response = self.rest.post_as_user(TestUsers.AdminUserSessionId, \u0026#39;/api/v1/sites/\u0026#39; + BEACON1.site_id + \u0026#39;/beacons\u0026#39;, JsonConverter.to_json(BEACON1)) created_beacon = JsonConverter.from_json(TypeCode.Map, response.content) beacon1 = created_beacon assert response.status_code \u0026lt; 300 assert BEACON1.udi == created_beacon[\u0026#39;udi\u0026#39;] assert BEACON1.id == created_beacon[\u0026#39;id\u0026#39;] assert BEACON1.site_id == created_beacon[\u0026#39;site_id\u0026#39;] assert created_beacon[\u0026#39;center\u0026#39;] is not None # Create the second beacon response = self.rest.post_as_user(TestUsers.AdminUserSessionId, \u0026#39;/api/v1/sites/\u0026#39; + BEACON2.site_id + \u0026#39;/beacons\u0026#39;, JsonConverter.to_json(BEACON2)) assert response.status_code \u0026lt; 300 created_beacon = JsonConverter.from_json(TypeCode.Map, response.content) assert BEACON2.udi == created_beacon[\u0026#39;udi\u0026#39;] assert BEACON2.id == created_beacon[\u0026#39;id\u0026#39;] assert BEACON2.site_id == created_beacon[\u0026#39;site_id\u0026#39;] assert created_beacon[\u0026#39;center\u0026#39;] is not None # Create yet another beacon response = self.rest.post_as_user(TestUsers.AdminUserSessionId, \u0026#39;/api/v1/sites/\u0026#39; + BEACON3.site_id + \u0026#39;/beacons\u0026#39;, JsonConverter.to_json(BEACON3)) assert response.status_code \u0026lt; 300 created_beacon = JsonConverter.from_json(TypeCode.Map, response.content) assert BEACON3.udi == created_beacon[\u0026#39;udi\u0026#39;] assert BEACON3.id == created_beacon[\u0026#39;id\u0026#39;] assert BEACON3.site_id == created_beacon[\u0026#39;site_id\u0026#39;] assert created_beacon[\u0026#39;center\u0026#39;] is not None # Get all beacons response = self.rest.get_as_user(TestUsers.AdminUserSessionId, \u0026#39;/api/v1/sites/\u0026#39; + BEACON1.site_id + \u0026#39;/beacons\u0026#39;, ) beacons = JsonConverter.from_json(TypeCode.Map, response.content) assert len(beacons[\u0026#39;data\u0026#39;]) == 2 # Calculate position for one beacon response = self.rest.post_as_user(TestUsers.AdminUserSessionId, \u0026#39;/api/v1/sites/\u0026#39; + BEACON1.site_id + \u0026#39;/beacons/calculate_position\u0026#39;, { \u0026#39;site_id\u0026#39;: BEACON1.site_id, \u0026#39;udis\u0026#39;: [BEACON1.udi] }) calc_position = JsonConverter.from_json(TypeCode.Map, response.content) assert response.status_code \u0026lt; 300 assert calc_position[\u0026#39;type\u0026#39;] == \u0026#39;Point\u0026#39; assert len(calc_position[\u0026#39;coordinates\u0026#39;]) == 2 # Validate beacon udi response = self.rest.post_as_user(TestUsers.AdminUserSessionId, \u0026#39;/api/v1/sites/\u0026#39; + beacon1[\u0026#39;site_id\u0026#39;] + \u0026#39;/beacons/validate_udi?udi=\u0026#39; + beacon1[\u0026#39;udi\u0026#39;], {}, ) assert JsonConverter.from_json(TypeCode.Map, response.content)[\u0026#39;id\u0026#39;] == beacon1[\u0026#39;id\u0026#39;] # Update the beacon BEACON1.label = \u0026#39;ABC\u0026#39; response = self.rest.put_as_user(TestUsers.AdminUserSessionId, \u0026#39;/api/v1/sites/\u0026#39; + beacon1[\u0026#39;site_id\u0026#39;] + \u0026#39;/beacons/\u0026#39; + beacon1[\u0026#39;id\u0026#39;], JsonConverter.to_json(BEACON1)) updated_beacon = JsonConverter.from_json(TypeCode.Map, response.content) beacon1 = updated_beacon assert response.status_code \u0026lt; 300 assert BEACON1.id == updated_beacon[\u0026#39;id\u0026#39;] assert updated_beacon[\u0026#39;label\u0026#39;] == \u0026#39;ABC\u0026#39; # Delete the beacon response = self.rest.delete_as_user(TestUsers.AdminUserSessionId, \u0026#39;/api/v1/sites/\u0026#39; + beacon1[\u0026#39;site_id\u0026#39;] + \u0026#39;/beacons/\u0026#39; + beacon1[\u0026#39;id\u0026#39;]) deleted_result = JsonConverter.from_json(TypeCode.Map, response.content) assert deleted_result[\u0026#39;id\u0026#39;] == BEACON1.id # Try to get deleted beacon response = self.rest.get_as_user(TestUsers.AdminUserSessionId, \u0026#39;/api/v1/sites/\u0026#39; + beacon1[\u0026#39;site_id\u0026#39;] + \u0026#39;/beacons/\u0026#39; + beacon1[\u0026#39;id\u0026#39;], ) assert response.status_code == 204 test_SessionsRoutesV1.py - for testing user and session related operations:\n/test/operations/test_SessionsRoutesV1.py\n# -*- coding: utf-8 -*- import json from pip_services3_commons.convert import JsonConverter, TypeCode from test.fixtures.ReferencesTest import ReferencesTest from test.fixtures.RestClientTest import RestClientTest from test.fixtures.TestUsers import TestUsers USER = { \u0026#39;login\u0026#39;: \u0026#39;test\u0026#39;, \u0026#39;name\u0026#39;: \u0026#39;Test User\u0026#39;, \u0026#39;email\u0026#39;: \u0026#39;test@conceptual.vision\u0026#39;, \u0026#39;password\u0026#39;: \u0026#39;test123\u0026#39; } class TestSessionRoutesV1: references: ReferencesTest = None rest: RestClientTest = None def setup_method(self): self.rest = RestClientTest() self.references = ReferencesTest() self.references.open(None) def teardown_method(self): self.references.close(None) def test_should_signup_new_user(self): response = self.rest.post(\u0026#39;/api/v1/signup\u0026#39;, USER) session = json.loads(response.content) JsonConverter.from_json(TypeCode.Map, response.content) assert session is not None assert session[\u0026#39;id\u0026#39;] is not None assert session[\u0026#39;user_name\u0026#39;] == USER[\u0026#39;name\u0026#39;] def test_should_check_login_for_signup(self): # Check registered email response = self.rest.get(\u0026#39;/api/v1/signup/validate?login=\u0026#39; + TestUsers.User1Login) result = json.loads(response.content) assert result[\u0026#39;status\u0026#39;] == 400 assert result[\u0026#39;code\u0026#39;] == \u0026#34;LOGIN_ALREADY_USED\u0026#34; # Check not registered email response = self.rest.get(\u0026#39;/api/v1/signup/validate?login=xxx@gmail.com\u0026#39;) assert response.status_code == 204 assert response.content == b\u0026#39;\u0026#39; def test_should_not_signup_with_the_same_email(self): # Sign up response = self.rest.post(\u0026#39;/api/v1/signup\u0026#39;, USER) session = json.loads(response.content) assert response.status_code == 200 # Try to sign up again response = self.rest.post(\u0026#39;/api/v1/signup\u0026#39;, USER) result = json.loads(response.content) assert result[\u0026#39;status\u0026#39;] == 400 assert result[\u0026#39;code\u0026#39;] == \u0026#39;DUPLICATE_LOGIN\u0026#39; def test_should_signout(self): response = self.rest.post(\u0026#39;/api/v1/signout\u0026#39;, {}) assert response.status_code == 204 assert response.content == b\u0026#39;\u0026#39; def test_should_signin_with_email_and_password(self): # Sign up response = self.rest.post(\u0026#39;/api/v1/signup\u0026#39;, USER) session = json.loads(response.content) assert response.status_code == 200 assert isinstance(session, dict) # Sign in with username response = self.rest.post(\u0026#39;/api/v1/signin\u0026#39;, { \u0026#39;login\u0026#39;: USER[\u0026#39;login\u0026#39;], \u0026#39;password\u0026#39;: USER[\u0026#39;password\u0026#39;] }) session = json.loads(response.content) assert response.status_code == 200 assert isinstance(session, dict) def test_should_get_sessions_as_admin(self): response = self.rest.get_as_user(TestUsers.AdminUserSessionId, \u0026#39;/api/v1/sessions?paging=1\u0026amp;skip=0\u0026amp;take=2\u0026#39;) page = json.loads(response.content) assert page is not None and page != {} def test_should_get_user_sessions_as_owner(self): response = self.rest.get_as_user(TestUsers.User1SessionId, \u0026#39;/api/v1/sessions/\u0026#39; + TestUsers.User1Id + \u0026#39;?paging=1\u0026amp;skip=0\u0026amp;take=2\u0026#39;, ) page = json.loads(response.content) assert page is not None and page != {} Run the tests using the following command:\npython test.py Once all the tests pass successfully, you can move on to Step 7 - Running the facade - to learn how to deploy all of these microservices using Docker.\nStep 7 - Running the facade  ","description":null,"image":null,"permalink":"/python/tutorials/microservice_facade/step6/","subtitle":null,"tags":null,"title":"Step 6. Testing of operations"},{"content":"To run our microservice, we need to add just one last bit of code. In the bin folder, create a Program.cs file with the following code:\n/src/service/process/Program.cs\nnamespace Process { class Program { static void Main(string[] args) { try { var process = new BeaconsProcess(); process.RunAsync(args).Wait(); } catch (Exception ex) { Console.WriteLine(ex); Console.ReadLine(); } } } } In the code above, all we’re doing is creating an instance of the container we described earlier, telling it where to find the configuration file, and running it using the RunAsync() method.\nTo run the microservice, execute the following command from a terminal at the root of the project:\ndotnet build # build dotnet src/process/bin/debug/net5.0/main.dll -c ./config/config.yml # start with config file You should get a result similar to the one shown below.\nSince we opted for the console logger in our configuration file, all information is going to be printed to the console. The service is using the in-memory persistence by default. To switch over to the MongoDB persistence, the MONGO_ENABLED environment variable has to be set and MongoDB should be running. This can be done either by starting the service from a script, in which we set our environment variables beforehand, or by configuring them in the OS’s environment.\nLet’s use the following two commands to set our environment variable and start our microservice using the MongoDB persistence:\nexport MONGO_ENABLED=true dotnet src/process/bin/debug/net5.0/main.dll -c ./config/config.yml Make sure that you have MongoDB running locally (see Setup environment) or in an accessible Docker container (i.e. whose ports are exposed), and that the connection parameters set in the configuration file are correct.\nWe can use the following docker composer configuration to run MongoDB in Docker:\n/docker/docker-compose.yml\nversion: \u0026#39;3.3\u0026#39; services: mongo: image: mongo:latest ports: - \u0026#34;27017:27017\u0026#34; And use the following command to get it up and running:\ndocker-compose -f ./docker/docker-compose.yml up Once the microservice has started, we can check whether or not it is available by requesting the following URL from a browser: http://localhost:8080/heartbeat. If everything is working correctly, we should receive the current date and UTC time in the JSON format. This mechanism allows us to check whether or not our microservice is up and running at any given time.\nNow let’s request the status URL from our browser: http://localhost:8080/status. This should generate a response with information about the service in a JSON format, such as: its name, what modules are loaded, etc. This mechanism allows us to identify our microservices while they’re running.\n{ \u0026#34;id\u0026#34;: \u0026#34;microservice-server\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;beacons\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;Beacons microservice\u0026#34;, \u0026#34;start_time\u0026#34;: \u0026#34;2021-05-25T16:46:30.079416Z\u0026#34;, \u0026#34;current_time\u0026#34;: \u0026#34;2021-05-25T16:47:07.027093Z\u0026#34;, \u0026#34;uptime\u0026#34;: 36947.676999999996, \u0026#34;properties\u0026#34;: {}, \u0026#34;components\u0026#34;: [ \u0026#34;pip-services:context-info:default:*:1.0\u0026#34;, \u0026#34;pip-services:factory:container:default:1.0\u0026#34;, \u0026#34;pip-services:context-info:default:default:1.0\u0026#34;, \u0026#34;pip-services:logger:console:default:1.0\u0026#34;, \u0026#34;pip-services:tracer:log:default:1.0\u0026#34;, \u0026#34;pip-services:counters:log:default:1.0\u0026#34;, \u0026#34;beacons:persistence:memory:default:1.0\u0026#34;, \u0026#34;beacons:controller:default:default:1.0\u0026#34;, \u0026#34;pip-services:endpoint:http:default:1.0\u0026#34;, \u0026#34;beacons:service:http:default:1.0\u0026#34;, \u0026#34;pip-services:swagger-service:*:*:1.0\u0026#34;, \u0026#34;pip-services:heartbeat-service:http:default:1.0\u0026#34;, \u0026#34;pip-services:status-service:http:default:1.0\u0026#34;, \u0026#34;pip-services:swagger-service:http:default:1.0\u0026#34; ] } Let’s move on to testing the main functionality of our microservice. Our set of commands for working with the service is available at the base path of http://localhost:8080/v1/beacons, using the POST method.\nWe could use a REST client to test our microservice, but for the sake of this example, we’ll be using curl instead.\nLet’s check the availability of our commands - the very same ones we defined in our CommandSet.\nFirst, we’ll attempt to create a few beacons in the system:\ncurl -X POST -H \u0026#34;Content-Type: application/json\u0026#34; -d \u0026#34;{\\\u0026#34;beacon\\\u0026#34;:{\\\u0026#34;id\\\u0026#34;: \\\u0026#34;1\\\u0026#34;, \\\u0026#34;udi\\\u0026#34;: \\\u0026#34;00001\\\u0026#34;, \\\u0026#34;type\\\u0026#34;: \\\u0026#34;altbeacon\\\u0026#34;, \\\u0026#34;site_id\\\u0026#34;: \\\u0026#34;1\\\u0026#34;, \\\u0026#34;label\\\u0026#34;: \\\u0026#34;TestBeacon1\\\u0026#34;, \\\u0026#34;center\\\u0026#34;: { \\\u0026#34;type\\\u0026#34;: \\\u0026#34;Point\\\u0026#34;, \\\u0026#34;coordinates\\\u0026#34;: [ 0, 0 ] },\\\u0026#34;radius\\\u0026#34;: 50}}\u0026#34; http://localhost:8080/v1/beacons/create_beacon ‍ curl -X POST -H \u0026#34;Content-Type: application/json\u0026#34; -d \u0026#34;{\\\u0026#34;beacon\\\u0026#34;:{\\\u0026#34;id\\\u0026#34;: \\\u0026#34;2\\\u0026#34;, \\\u0026#34;udi\\\u0026#34;: \\\u0026#34;00002\\\u0026#34;, \\\u0026#34;type\\\u0026#34;: \\\u0026#34;altbeacon\\\u0026#34;, \\\u0026#34;site_id\\\u0026#34;: \\\u0026#34;1\\\u0026#34;, \\\u0026#34;label\\\u0026#34;: \\\u0026#34;TestBeacon2\\\u0026#34;, \\\u0026#34;center\\\u0026#34;: { \\\u0026#34;type\\\u0026#34;: \\\u0026#34;Point\\\u0026#34;, \\\u0026#34;coordinates\\\u0026#34;: [ 2, 2 ] },\\\u0026#34;radius\\\u0026#34;: 70}}\u0026#34; http://localhost:8080/v1/beacons/create_beacon Update the second beacon by changing its coordinates and radius:\ncurl -X POST -H \u0026#34;Content-Type: application/json\u0026#34; -d \u0026#34;{\\\u0026#34;beacon\\\u0026#34;:{\\\u0026#34;id\\\u0026#34;: \\\u0026#34;2\\\u0026#34;, \\\u0026#34;udi\\\u0026#34;: \\\u0026#34;00002\\\u0026#34;, \\\u0026#34;type\\\u0026#34;: \\\u0026#34;altbeacon\\\u0026#34;, \\\u0026#34;site_id\\\u0026#34;: \\\u0026#34;1\\\u0026#34;, \\\u0026#34;label\\\u0026#34;: \\\u0026#34;TestBeacon2\\\u0026#34;, \\\u0026#34;center\\\u0026#34;: { \\\u0026#34;type\\\u0026#34;: \\\u0026#34;Point\\\u0026#34;, \\\u0026#34;coordinates\\\u0026#34;: [ 2, 4 ] },\\\u0026#34;radius\\\u0026#34;: 80}}\u0026#34; http://localhost:8080/v1/beacons/update_beacon Retrieve a list of all available beacons using the command below:\ncurl -X POST http://localhost:8080/v1/beacons/get_beacons We should get the following JSON response with all of the beacons currently in the system:\n{ \u0026#34;total\u0026#34;:2, \u0026#34;data\u0026#34;:[ { \u0026#34;id\u0026#34;:\u0026#34;1\u0026#34;, \u0026#34;udi\u0026#34;:\u0026#34;00001\u0026#34;, \u0026#34;type\u0026#34;:\u0026#34;altbeacon\u0026#34;, \u0026#34;site_id\u0026#34;:\u0026#34;1\u0026#34;, \u0026#34;label\u0026#34;:\u0026#34;TestBeacon1\u0026#34;, \u0026#34;center\u0026#34;:{ \u0026#34;type\u0026#34;:\u0026#34;Point\u0026#34;, \u0026#34;coordinates\u0026#34;:[ 0, 0 ] }, \u0026#34;radius\u0026#34;:50 }, { \u0026#34;id\u0026#34;:\u0026#34;2\u0026#34;, \u0026#34;udi\u0026#34;:\u0026#34;00002\u0026#34;, \u0026#34;type\u0026#34;:\u0026#34;altbeacon\u0026#34;, \u0026#34;site_id\u0026#34;:\u0026#34;1\u0026#34;, \u0026#34;label\u0026#34;:\u0026#34;TestBeacon2\u0026#34;, \u0026#34;center\u0026#34;:{ \u0026#34;type\u0026#34;:\u0026#34;Point\u0026#34;, \u0026#34;coordinates\u0026#34;:[ 2, 4 ] }, \u0026#34;radius\u0026#34;:80 } ] } Try to get the first beacon by its UDI using the command:\ncurl -X POST -H \u0026#34;Content-Type: application/json\u0026#34; -d \u0026#34;{\\\u0026#34;udi\\\u0026#34;:\\\u0026#34;00001\\\u0026#34;}\u0026#34; http://localhost:8080/v1/beacons/get_beacon_by_udi We should receive the following response:\n{ \u0026#34;id\u0026#34;:\u0026#34;1\u0026#34;, \u0026#34;udi\u0026#34;:\u0026#34;00001\u0026#34;, \u0026#34;type\u0026#34;:\u0026#34;altbeacon\u0026#34;, \u0026#34;site_id\u0026#34;:\u0026#34;1\u0026#34;, \u0026#34;label\u0026#34;:\u0026#34;TestBeacon1\u0026#34;, \u0026#34;center\u0026#34;:{ \u0026#34;type\u0026#34;:\u0026#34;Point\u0026#34;, \u0026#34;coordinates\u0026#34;:[ 0, 0 ] }, \u0026#34;radius\u0026#34;:50 } To calculate a device’s position, use the following request:\ncurl -X POST -H \u0026#34;Content-Type: application/json\u0026#34; -d \u0026#34;{\\\u0026#34;site_id\\\u0026#34;: \\\u0026#34;1\\\u0026#34;,\\\u0026#34;udis\\\u0026#34;: [\\\u0026#34;00001\\\u0026#34;, \\\u0026#34;00002\\\u0026#34;]}\u0026#34; http://localhost:8080/v1/beacons/calculate_position As a result, you should get the following coordinates:\n``json {\u0026ldquo;type\u0026rdquo;:\u0026ldquo;Point\u0026rdquo;,\u0026ldquo;coordinates\u0026rdquo;:[1,2]}\n Now let’s delete a beacon by its id: ```bash curl -X POST -H \u0026quot;Content-Type: application/json\u0026quot; -d \u0026quot;{\\\u0026quot;beacon_id\\\u0026quot;:\\\u0026quot;1\\\u0026quot;}\u0026quot; http://localhost:8080/v1/beacons/delete_beacon_by_id The system will return the deleted beacon if deletion was successful:\n{ \u0026#34;id\u0026#34;:\u0026#34;1\u0026#34;, \u0026#34;udi\u0026#34;:\u0026#34;00001\u0026#34;, \u0026#34;type\u0026#34;:\u0026#34;altbeacon\u0026#34;, \u0026#34;site_id\u0026#34;:\u0026#34;1\u0026#34;, \u0026#34;label\u0026#34;:\u0026#34;TestBeacon1\u0026#34;, \u0026#34;center\u0026#34;:{ \u0026#34;type\u0026#34;:\u0026#34;Point\u0026#34;, \u0026#34;coordinates\u0026#34;:[ 0, 0 ] }, \u0026#34;radius\u0026#34;:50 } Let’s make sure that there’s only one beacon left in the system by asking again for a list of all available beacons:\ncurl -X POST http://localhost:8080/v1/beacons/get_beacons As a result, only the beacon with an id of “2” is returned.\n{ \u0026#34;total\u0026#34;:1, \u0026#34;data\u0026#34;:[ { \u0026#34;id\u0026#34;:\u0026#34;2\u0026#34;, \u0026#34;udi\u0026#34;:\u0026#34;00002\u0026#34;, \u0026#34;type\u0026#34;:\u0026#34;altbeacon\u0026#34;, \u0026#34;site_id\u0026#34;:\u0026#34;1\u0026#34;, \u0026#34;label\u0026#34;:\u0026#34;TestBeacon2\u0026#34;, \u0026#34;center\u0026#34;:{ \u0026#34;type\u0026#34;:\u0026#34;Point\u0026#34;, \u0026#34;coordinates\u0026#34;:[ 2, 4 ] }, \u0026#34;radius\u0026#34;:80 } ] } And that’s it! Congratulations! You’ve created a microservice that’s far more advanced than the regular “Hello, World” example! All source code is available on Github\n","description":null,"image":null,"permalink":"/net/tutorials/data_microservice/step7/","subtitle":null,"tags":null,"title":"Step 7. Running and testing the microservice"},{"content":"To run our microservice, we need to add just one last bit of code. In the bin folder, create a run.js file with the following:\n/bin/run.js\nlet BeaconsProcess = require(\u0026#39;../obj/src/container/BeaconsProcess\u0026#39;).BeaconsProcess; ‍ try { let proc = new BeaconsProcess(); proc._configPath = \u0026#34;./config/config.yml\u0026#34;; proc.run(process.argv); } catch (ex) { console.error(ex); } In the code above, all we’re doing is creating an instance of the container we described earlier, telling it where to find the configuration file, and running it using the run() method.\nTo run the microservice, execute the following command from a terminal at the root of the project:\nnode ./bin/run.js You should get a result similar to the one shown below.\nSince we opted for the console logger in our configuration file, all information is going to be printed to the console. The service is using the in-memory persistence by default. To switch over to the MongoDB persistence, the MONGO_ENABLED environment variable has to be set and MongoDB should be running. This can be done either by starting the service from a script, in which we set our environment variables beforehand, or by configuring them in the OS’s environment.\nLet’s use the following two commands to set our environment variable and start our microservice using the MongoDB persistence:\nexport MONGO_ENABLED=true node .\\bin\\run.js Make sure that you have MongoDB running locally (see Setup environment) or in an accessible Docker container (i.e. whose ports are exposed), and that the connection parameters set in the configuration file are correct.\nWe can use the following docker composer configuration to run MongoDB in Docker:\n/docker/docker-compose.yml\nversion: \u0026#39;3.3\u0026#39; services: mongo: image: mongo:latest ports: - \u0026#34;27017:27017\u0026#34; And use the following command to get it up and running:\ndocker-compose -f ./docker/docker-compose.yml up Once the microservice has started, we can check whether or not it is available by requesting the following URL from a browser: http://localhost:8080/heartbeat. If everything is working correctly, we should receive the current date and UTC time in the JSON format. This mechanism allows us to check whether or not our microservice is up and running at any given time.\nNow let’s request the status URL from our browser: http://localhost:8080/status. This should generate a response with information about the service in a JSON format, such as: its name, what modules are loaded, etc. This mechanism allows us to identify our microservices while they’re running.\n{ \u0026#34;id\u0026#34;: \u0026#34;microservice-server\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;beacons\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;Beacons microservice\u0026#34;, \u0026#34;start_time\u0026#34;: \u0026#34;2021-05-25T16:46:30.079416Z\u0026#34;, \u0026#34;current_time\u0026#34;: \u0026#34;2021-05-25T16:47:07.027093Z\u0026#34;, \u0026#34;uptime\u0026#34;: 36947.676999999996, \u0026#34;properties\u0026#34;: {}, \u0026#34;components\u0026#34;: [ \u0026#34;pip-services:context-info:default:*:1.0\u0026#34;, \u0026#34;pip-services:factory:container:default:1.0\u0026#34;, \u0026#34;pip-services:context-info:default:default:1.0\u0026#34;, \u0026#34;pip-services:logger:console:default:1.0\u0026#34;, \u0026#34;pip-services:tracer:log:default:1.0\u0026#34;, \u0026#34;pip-services:counters:log:default:1.0\u0026#34;, \u0026#34;beacons:persistence:memory:default:1.0\u0026#34;, \u0026#34;beacons:controller:default:default:1.0\u0026#34;, \u0026#34;pip-services:endpoint:http:default:1.0\u0026#34;, \u0026#34;beacons:service:http:default:1.0\u0026#34;, \u0026#34;pip-services:swagger-service:*:*:1.0\u0026#34;, \u0026#34;pip-services:heartbeat-service:http:default:1.0\u0026#34;, \u0026#34;pip-services:status-service:http:default:1.0\u0026#34;, \u0026#34;pip-services:swagger-service:http:default:1.0\u0026#34; ] } Let’s move on to testing the main functionality of our microservice. Our set of commands for working with the service is available at the base path of http://localhost:8080/v1/beacons, using the POST method.\nWe could use a REST client to test our microservice, but for the sake of this example, we’ll be using curl instead.\nLet’s check the availability of our commands - the very same ones we defined in our CommandSet.\nFirst, we’ll attempt to create a few beacons in the system:\ncurl -X POST -H \u0026#34;Content-Type: application/json\u0026#34; -d \u0026#34;{\\\u0026#34;beacon\\\u0026#34;:{\\\u0026#34;id\\\u0026#34;: \\\u0026#34;1\\\u0026#34;, \\\u0026#34;udi\\\u0026#34;: \\\u0026#34;00001\\\u0026#34;, \\\u0026#34;type\\\u0026#34;: \\\u0026#34;altbeacon\\\u0026#34;, \\\u0026#34;site_id\\\u0026#34;: \\\u0026#34;1\\\u0026#34;, \\\u0026#34;label\\\u0026#34;: \\\u0026#34;TestBeacon1\\\u0026#34;, \\\u0026#34;center\\\u0026#34;: { \\\u0026#34;type\\\u0026#34;: \\\u0026#34;Point\\\u0026#34;, \\\u0026#34;coordinates\\\u0026#34;: [ 0, 0 ] },\\\u0026#34;radius\\\u0026#34;: 50}}\u0026#34; http://localhost:8080/v1/beacons/create_beacon ‍ curl -X POST -H \u0026#34;Content-Type: application/json\u0026#34; -d \u0026#34;{\\\u0026#34;beacon\\\u0026#34;:{\\\u0026#34;id\\\u0026#34;: \\\u0026#34;2\\\u0026#34;, \\\u0026#34;udi\\\u0026#34;: \\\u0026#34;00002\\\u0026#34;, \\\u0026#34;type\\\u0026#34;: \\\u0026#34;altbeacon\\\u0026#34;, \\\u0026#34;site_id\\\u0026#34;: \\\u0026#34;1\\\u0026#34;, \\\u0026#34;label\\\u0026#34;: \\\u0026#34;TestBeacon2\\\u0026#34;, \\\u0026#34;center\\\u0026#34;: { \\\u0026#34;type\\\u0026#34;: \\\u0026#34;Point\\\u0026#34;, \\\u0026#34;coordinates\\\u0026#34;: [ 2, 2 ] },\\\u0026#34;radius\\\u0026#34;: 70}}\u0026#34; http://localhost:8080/v1/beacons/create_beacon Update the second beacon by changing its coordinates and radius:\ncurl -X POST -H \u0026#34;Content-Type: application/json\u0026#34; -d \u0026#34;{\\\u0026#34;beacon\\\u0026#34;:{\\\u0026#34;id\\\u0026#34;: \\\u0026#34;2\\\u0026#34;, \\\u0026#34;udi\\\u0026#34;: \\\u0026#34;00002\\\u0026#34;, \\\u0026#34;type\\\u0026#34;: \\\u0026#34;altbeacon\\\u0026#34;, \\\u0026#34;site_id\\\u0026#34;: \\\u0026#34;1\\\u0026#34;, \\\u0026#34;label\\\u0026#34;: \\\u0026#34;TestBeacon2\\\u0026#34;, \\\u0026#34;center\\\u0026#34;: { \\\u0026#34;type\\\u0026#34;: \\\u0026#34;Point\\\u0026#34;, \\\u0026#34;coordinates\\\u0026#34;: [ 2, 4 ] },\\\u0026#34;radius\\\u0026#34;: 80}}\u0026#34; http://localhost:8080/v1/beacons/update_beacon Retrieve a list of all available beacons using the command below:\ncurl -X POST http://localhost:8080/v1/beacons/get_beacons We should get the following JSON response with all of the beacons currently in the system:\n{ \u0026#34;total\u0026#34;:2, \u0026#34;data\u0026#34;:[ { \u0026#34;id\u0026#34;:\u0026#34;1\u0026#34;, \u0026#34;udi\u0026#34;:\u0026#34;00001\u0026#34;, \u0026#34;type\u0026#34;:\u0026#34;altbeacon\u0026#34;, \u0026#34;site_id\u0026#34;:\u0026#34;1\u0026#34;, \u0026#34;label\u0026#34;:\u0026#34;TestBeacon1\u0026#34;, \u0026#34;center\u0026#34;:{ \u0026#34;type\u0026#34;:\u0026#34;Point\u0026#34;, \u0026#34;coordinates\u0026#34;:[ 0, 0 ] }, \u0026#34;radius\u0026#34;:50 }, { \u0026#34;id\u0026#34;:\u0026#34;2\u0026#34;, \u0026#34;udi\u0026#34;:\u0026#34;00002\u0026#34;, \u0026#34;type\u0026#34;:\u0026#34;altbeacon\u0026#34;, \u0026#34;site_id\u0026#34;:\u0026#34;1\u0026#34;, \u0026#34;label\u0026#34;:\u0026#34;TestBeacon2\u0026#34;, \u0026#34;center\u0026#34;:{ \u0026#34;type\u0026#34;:\u0026#34;Point\u0026#34;, \u0026#34;coordinates\u0026#34;:[ 2, 4 ] }, \u0026#34;radius\u0026#34;:80 } ] } Try to get the first beacon by its UDI using the command:\ncurl -X POST -H \u0026#34;Content-Type: application/json\u0026#34; -d \u0026#34;{\\\u0026#34;udi\\\u0026#34;:\\\u0026#34;00001\\\u0026#34;}\u0026#34; http://localhost:8080/v1/beacons/get_beacon_by_udi We should receive the following response:\n{ \u0026#34;id\u0026#34;:\u0026#34;1\u0026#34;, \u0026#34;udi\u0026#34;:\u0026#34;00001\u0026#34;, \u0026#34;type\u0026#34;:\u0026#34;altbeacon\u0026#34;, \u0026#34;site_id\u0026#34;:\u0026#34;1\u0026#34;, \u0026#34;label\u0026#34;:\u0026#34;TestBeacon1\u0026#34;, \u0026#34;center\u0026#34;:{ \u0026#34;type\u0026#34;:\u0026#34;Point\u0026#34;, \u0026#34;coordinates\u0026#34;:[ 0, 0 ] }, \u0026#34;radius\u0026#34;:50 } To calculate a device’s position, use the following request:\ncurl -X POST -H \u0026#34;Content-Type: application/json\u0026#34; -d \u0026#34;{\\\u0026#34;site_id\\\u0026#34;: \\\u0026#34;1\\\u0026#34;,\\\u0026#34;udis\\\u0026#34;: [\\\u0026#34;00001\\\u0026#34;, \\\u0026#34;00002\\\u0026#34;]}\u0026#34; http://localhost:8080/v1/beacons/calculate_position As a result, we should get the following coordinates:\n``json {\u0026ldquo;type\u0026rdquo;:\u0026ldquo;Point\u0026rdquo;,\u0026ldquo;coordinates\u0026rdquo;:[1,2]}\n Now let’s delete a beacon by its id: ```bash curl -X POST -H \u0026quot;Content-Type: application/json\u0026quot; -d \u0026quot;{\\\u0026quot;beacon_id\\\u0026quot;:\\\u0026quot;1\\\u0026quot;}\u0026quot; http://localhost:8080/v1/beacons/delete_beacon_by_id The system will return the deleted beacon if deletion was successful:\n{ \u0026#34;id\u0026#34;:\u0026#34;1\u0026#34;, \u0026#34;udi\u0026#34;:\u0026#34;00001\u0026#34;, \u0026#34;type\u0026#34;:\u0026#34;altbeacon\u0026#34;, \u0026#34;site_id\u0026#34;:\u0026#34;1\u0026#34;, \u0026#34;label\u0026#34;:\u0026#34;TestBeacon1\u0026#34;, \u0026#34;center\u0026#34;:{ \u0026#34;type\u0026#34;:\u0026#34;Point\u0026#34;, \u0026#34;coordinates\u0026#34;:[ 0, 0 ] }, \u0026#34;radius\u0026#34;:50 } Let’s make sure that there’s only one beacon left in the system by asking again for a list of all available beacons:\ncurl -X POST http://localhost:8080/v1/beacons/get_beacons As a result, only the beacon with an id of “2” is returned.\n{ \u0026#34;total\u0026#34;:1, \u0026#34;data\u0026#34;:[ { \u0026#34;id\u0026#34;:\u0026#34;2\u0026#34;, \u0026#34;udi\u0026#34;:\u0026#34;00002\u0026#34;, \u0026#34;type\u0026#34;:\u0026#34;altbeacon\u0026#34;, \u0026#34;site_id\u0026#34;:\u0026#34;1\u0026#34;, \u0026#34;label\u0026#34;:\u0026#34;TestBeacon2\u0026#34;, \u0026#34;center\u0026#34;:{ \u0026#34;type\u0026#34;:\u0026#34;Point\u0026#34;, \u0026#34;coordinates\u0026#34;:[ 2, 4 ] }, \u0026#34;radius\u0026#34;:80 } ] } And that’s it! Congratulations! You’ve created a microservice that’s far more advanced than the regular “Hello, World” example! All source code is available on Github\n","description":null,"image":null,"permalink":"/node/tutorials/data_microservice/step7/","subtitle":null,"tags":null,"title":"Step 7. Running and testing the microservice"},{"content":"To run our microservice, we need to add just one last bit of code. In the bin folder, create a main.py file with the following code:\n/bin/main.py\nimport sys import traceback import os from pip_services3_components.log import ConsoleLogger # add parent directory to path sys.path.append(os.path.dirname(os.path.dirname(os.path.realpath(__file__)))) from src.containers.BeaconsProcess import BeaconsProcess if __name__ == \u0026#39;__main__\u0026#39;: runner = BeaconsProcess() try: runner.run() except Exception as ex: ConsoleLogger().fatal(\u0026#34;Beacons\u0026#34;, ex, \u0026#34;Error: \u0026#34;) print(traceback.format_exc()) sys.stderr.write(str(ex) + \u0026#39;\\n\u0026#39;) In the code above, all we’re doing is creating an instance of the container we described earlier, telling it where to find the configuration file, and running it using the run() method.\nTo run the microservice, execute the following command from a terminal at the root of the project:\npython ./bin/main.py You should get a result similar to the one shown below.\nSince we opted for the console logger in our configuration file, all information is going to be printed to the console. The service is using the in-memory persistence by default. To switch over to the MongoDB persistence, the MONGO_ENABLED environment variable has to be set and MongoDB should be running. This can be done either by starting the service from a script, in which we set our environment variables beforehand, or by configuring them in the OS’s environment.\nLet’s use the following two commands to set our environment variable and start our microservice using the MongoDB persistence:\nexport MONGO_ENABLED=true python .\\bin\\main.py Make sure that you have MongoDB running locally (see Setup environment) or in an accessible Docker container (i.e. whose ports are exposed), and that the connection parameters set in the configuration file are correct.\nWe can use the following docker composer configuration to run MongoDB in Docker:\n/docker/docker-compose.yml\nversion: \u0026#39;3.3\u0026#39; services: mongo: image: mongo:latest ports: - \u0026#34;27017:27017\u0026#34; And use the following command to get it up and running:\ndocker-compose -f ./docker/docker-compose.yml up Once the microservice has started, we can check whether or not it is available by requesting the following URL from a browser: http://localhost:8080/heartbeat. If everything is working correctly, we should receive the current date and UTC time in the JSON format. This mechanism allows us to check whether or not our microservice is up and running at any given time.\nNow let’s request the status URL from our browser: http://localhost:8080/status. This should generate a response with information about the service in a JSON format, such as: its name, what modules are loaded, etc. This mechanism allows us to identify our microservices while they’re running.\n{ \u0026#34;id\u0026#34;: \u0026#34;microservice-server\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;beacons\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;Beacons microservice\u0026#34;, \u0026#34;start_time\u0026#34;: \u0026#34;2021-05-25T16:46:30.079416Z\u0026#34;, \u0026#34;current_time\u0026#34;: \u0026#34;2021-05-25T16:47:07.027093Z\u0026#34;, \u0026#34;uptime\u0026#34;: 36947.676999999996, \u0026#34;properties\u0026#34;: {}, \u0026#34;components\u0026#34;: [ \u0026#34;pip-services:context-info:default:*:1.0\u0026#34;, \u0026#34;pip-services:factory:container:default:1.0\u0026#34;, \u0026#34;pip-services:context-info:default:default:1.0\u0026#34;, \u0026#34;pip-services:logger:console:default:1.0\u0026#34;, \u0026#34;pip-services:tracer:log:default:1.0\u0026#34;, \u0026#34;pip-services:counters:log:default:1.0\u0026#34;, \u0026#34;beacons:persistence:memory:default:1.0\u0026#34;, \u0026#34;beacons:controller:default:default:1.0\u0026#34;, \u0026#34;pip-services:endpoint:http:default:1.0\u0026#34;, \u0026#34;beacons:service:http:default:1.0\u0026#34;, \u0026#34;pip-services:swagger-service:*:*:1.0\u0026#34;, \u0026#34;pip-services:heartbeat-service:http:default:1.0\u0026#34;, \u0026#34;pip-services:status-service:http:default:1.0\u0026#34;, \u0026#34;pip-services:swagger-service:http:default:1.0\u0026#34; ] } Let’s move on to testing the main functionality of our microservice. Our set of commands for working with the service is available at the base path of http://localhost:8080/v1/beacons, using the POST method.\nWe could use a REST client to test our microservice, but for the sake of this example, we’ll be using curl instead.\nLet’s check the availability of our commands - the very same ones we defined in our CommandSet.\nFirst, we’ll attempt to create a few beacons in the system:\ncurl -X POST -H \u0026#34;Content-Type: application/json\u0026#34; -d \u0026#34;{\\\u0026#34;beacon\\\u0026#34;:{\\\u0026#34;id\\\u0026#34;: \\\u0026#34;1\\\u0026#34;, \\\u0026#34;udi\\\u0026#34;: \\\u0026#34;00001\\\u0026#34;, \\\u0026#34;type\\\u0026#34;: \\\u0026#34;altbeacon\\\u0026#34;, \\\u0026#34;site_id\\\u0026#34;: \\\u0026#34;1\\\u0026#34;, \\\u0026#34;label\\\u0026#34;: \\\u0026#34;TestBeacon1\\\u0026#34;, \\\u0026#34;center\\\u0026#34;: { \\\u0026#34;type\\\u0026#34;: \\\u0026#34;Point\\\u0026#34;, \\\u0026#34;coordinates\\\u0026#34;: [ 0, 0 ] },\\\u0026#34;radius\\\u0026#34;: 50}}\u0026#34; http://localhost:8080/v1/beacons/create_beacon ‍ curl -X POST -H \u0026#34;Content-Type: application/json\u0026#34; -d \u0026#34;{\\\u0026#34;beacon\\\u0026#34;:{\\\u0026#34;id\\\u0026#34;: \\\u0026#34;2\\\u0026#34;, \\\u0026#34;udi\\\u0026#34;: \\\u0026#34;00002\\\u0026#34;, \\\u0026#34;type\\\u0026#34;: \\\u0026#34;altbeacon\\\u0026#34;, \\\u0026#34;site_id\\\u0026#34;: \\\u0026#34;1\\\u0026#34;, \\\u0026#34;label\\\u0026#34;: \\\u0026#34;TestBeacon2\\\u0026#34;, \\\u0026#34;center\\\u0026#34;: { \\\u0026#34;type\\\u0026#34;: \\\u0026#34;Point\\\u0026#34;, \\\u0026#34;coordinates\\\u0026#34;: [ 2, 2 ] },\\\u0026#34;radius\\\u0026#34;: 70}}\u0026#34; http://localhost:8080/v1/beacons/create_beacon Update the second beacon by changing its coordinates and radius:\ncurl -X POST -H \u0026#34;Content-Type: application/json\u0026#34; -d \u0026#34;{\\\u0026#34;beacon\\\u0026#34;:{\\\u0026#34;id\\\u0026#34;: \\\u0026#34;2\\\u0026#34;, \\\u0026#34;udi\\\u0026#34;: \\\u0026#34;00002\\\u0026#34;, \\\u0026#34;type\\\u0026#34;: \\\u0026#34;altbeacon\\\u0026#34;, \\\u0026#34;site_id\\\u0026#34;: \\\u0026#34;1\\\u0026#34;, \\\u0026#34;label\\\u0026#34;: \\\u0026#34;TestBeacon2\\\u0026#34;, \\\u0026#34;center\\\u0026#34;: { \\\u0026#34;type\\\u0026#34;: \\\u0026#34;Point\\\u0026#34;, \\\u0026#34;coordinates\\\u0026#34;: [ 2, 4 ] },\\\u0026#34;radius\\\u0026#34;: 80}}\u0026#34; http://localhost:8080/v1/beacons/update_beacon Retrieve a list of all available beacons using the command below:\ncurl -X POST http://localhost:8080/v1/beacons/get_beacons We should get the following JSON response with all of the beacons currently in the system:\n{ \u0026#34;total\u0026#34;:2, \u0026#34;data\u0026#34;:[ { \u0026#34;id\u0026#34;:\u0026#34;1\u0026#34;, \u0026#34;udi\u0026#34;:\u0026#34;00001\u0026#34;, \u0026#34;type\u0026#34;:\u0026#34;altbeacon\u0026#34;, \u0026#34;site_id\u0026#34;:\u0026#34;1\u0026#34;, \u0026#34;label\u0026#34;:\u0026#34;TestBeacon1\u0026#34;, \u0026#34;center\u0026#34;:{ \u0026#34;type\u0026#34;:\u0026#34;Point\u0026#34;, \u0026#34;coordinates\u0026#34;:[ 0, 0 ] }, \u0026#34;radius\u0026#34;:50 }, { \u0026#34;id\u0026#34;:\u0026#34;2\u0026#34;, \u0026#34;udi\u0026#34;:\u0026#34;00002\u0026#34;, \u0026#34;type\u0026#34;:\u0026#34;altbeacon\u0026#34;, \u0026#34;site_id\u0026#34;:\u0026#34;1\u0026#34;, \u0026#34;label\u0026#34;:\u0026#34;TestBeacon2\u0026#34;, \u0026#34;center\u0026#34;:{ \u0026#34;type\u0026#34;:\u0026#34;Point\u0026#34;, \u0026#34;coordinates\u0026#34;:[ 2, 4 ] }, \u0026#34;radius\u0026#34;:80 } ] } Try to get the first beacon by its UDI using the command:\ncurl -X POST -H \u0026#34;Content-Type: application/json\u0026#34; -d \u0026#34;{\\\u0026#34;udi\\\u0026#34;:\\\u0026#34;00001\\\u0026#34;}\u0026#34; http://localhost:8080/v1/beacons/get_beacon_by_udi We should receive the following response:\n{ \u0026#34;id\u0026#34;:\u0026#34;1\u0026#34;, \u0026#34;udi\u0026#34;:\u0026#34;00001\u0026#34;, \u0026#34;type\u0026#34;:\u0026#34;altbeacon\u0026#34;, \u0026#34;site_id\u0026#34;:\u0026#34;1\u0026#34;, \u0026#34;label\u0026#34;:\u0026#34;TestBeacon1\u0026#34;, \u0026#34;center\u0026#34;:{ \u0026#34;type\u0026#34;:\u0026#34;Point\u0026#34;, \u0026#34;coordinates\u0026#34;:[ 0, 0 ] }, \u0026#34;radius\u0026#34;:50 } To calculate a device’s position, use the following request:\ncurl -X POST -H \u0026#34;Content-Type: application/json\u0026#34; -d \u0026#34;{\\\u0026#34;site_id\\\u0026#34;: \\\u0026#34;1\\\u0026#34;,\\\u0026#34;udis\\\u0026#34;: [\\\u0026#34;00001\\\u0026#34;, \\\u0026#34;00002\\\u0026#34;]}\u0026#34; http://localhost:8080/v1/beacons/calculate_position As a result, you should get the following coordinates:\n``json {\u0026ldquo;type\u0026rdquo;:\u0026ldquo;Point\u0026rdquo;,\u0026ldquo;coordinates\u0026rdquo;:[1,2]}\n Now let’s delete a beacon by its id: ```bash curl -X POST -H \u0026quot;Content-Type: application/json\u0026quot; -d \u0026quot;{\\\u0026quot;beacon_id\\\u0026quot;:\\\u0026quot;1\\\u0026quot;}\u0026quot; http://localhost:8080/v1/beacons/delete_beacon_by_id The system will return the deleted beacon if deletion was successful:\n{ \u0026#34;id\u0026#34;:\u0026#34;1\u0026#34;, \u0026#34;udi\u0026#34;:\u0026#34;00001\u0026#34;, \u0026#34;type\u0026#34;:\u0026#34;altbeacon\u0026#34;, \u0026#34;site_id\u0026#34;:\u0026#34;1\u0026#34;, \u0026#34;label\u0026#34;:\u0026#34;TestBeacon1\u0026#34;, \u0026#34;center\u0026#34;:{ \u0026#34;type\u0026#34;:\u0026#34;Point\u0026#34;, \u0026#34;coordinates\u0026#34;:[ 0, 0 ] }, \u0026#34;radius\u0026#34;:50 } Let’s make sure that there’s only one beacon left in the system by asking again for a list of all available beacons:\ncurl -X POST http://localhost:8080/v1/beacons/get_beacons As a result, only the beacon with an id of “2” is returned.\n{ \u0026#34;total\u0026#34;:1, \u0026#34;data\u0026#34;:[ { \u0026#34;id\u0026#34;:\u0026#34;2\u0026#34;, \u0026#34;udi\u0026#34;:\u0026#34;00002\u0026#34;, \u0026#34;type\u0026#34;:\u0026#34;altbeacon\u0026#34;, \u0026#34;site_id\u0026#34;:\u0026#34;1\u0026#34;, \u0026#34;label\u0026#34;:\u0026#34;TestBeacon2\u0026#34;, \u0026#34;center\u0026#34;:{ \u0026#34;type\u0026#34;:\u0026#34;Point\u0026#34;, \u0026#34;coordinates\u0026#34;:[ 2, 4 ] }, \u0026#34;radius\u0026#34;:80 } ] } And that’s it! Congratulations! You’ve created a microservice that’s far more advanced than the regular “Hello, World” example! All source code is available on Github\n","description":null,"image":null,"permalink":"/python/tutorials/data_microservice/step7/","subtitle":null,"tags":null,"title":"Step 7. Running and testing the microservice"},{"content":"Before we can run our facade, we need to add three more things: a factory for the component’s we’ve created, a container, and the code that will run it all. The process of implementing these pieces is the same as the one described in Data Microservice, so this time around we’ll just list the code:\nCreate three factories in the src/build/ folder:\nOne factory for the facade in a file named FacadeFactory.ts, containing the following code:\n/src/build/FacadeFactory.ts\nimport { Factory } from \u0026#39;pip-services3-components-node\u0026#39;; import { Descriptor } from \u0026#39;pip-services3-commons-node\u0026#39;; import { FacadeServiceV1 } from \u0026#39;../services/version1/FacadeServiceV1\u0026#39;; import { FacadeServiceV2 } from \u0026#39;../services/version2/FacadeServiceV2\u0026#39;; export class FacadeFactory extends Factory { public static FacadeServiceV1Descriptor = new Descriptor(\u0026#34;nov-facades-application\u0026#34;, \u0026#34;service\u0026#34;, \u0026#34;http\u0026#34;, \u0026#34;*\u0026#34;, \u0026#34;1.0\u0026#34;); public static FacadeServiceV2Descriptor = new Descriptor(\u0026#34;nov-facades-application\u0026#34;, \u0026#34;service\u0026#34;, \u0026#34;http\u0026#34;, \u0026#34;*\u0026#34;, \u0026#34;2.0\u0026#34;); public constructor() { super(); this.registerAsType(FacadeFactory.FacadeServiceV1Descriptor, FacadeServiceV1); this.registerAsType(FacadeFactory.FacadeServiceV2Descriptor, FacadeServiceV2); } } And last but not least, a factory for the clients that that facade depends on in a file named ClientFacadeFactory.ts:\n/src/build/ClientFacadeFactory.ts\nimport { Factory } from \u0026#39;pip-services3-components-node\u0026#39;; import { Descriptor } from \u0026#39;pip-services3-commons-node\u0026#39;; import { SettingsNullClientV1 } from \u0026#39;../clients/version1/SettingsNullClientV1\u0026#39;; import { AccountsMemoryClientV1 } from \u0026#39;../clients/version1/AccountsMemoryClientV1\u0026#39;; import { PasswordsNullClientV1 } from \u0026#39;../clients/version1/PasswordsNullClientV1\u0026#39;; import { RolesMemoryClientV1 } from \u0026#39;../clients/version1/RolesMemoryClientV1\u0026#39;; import { SessionsMemoryClientV1 } from \u0026#39;../clients/version1/SessionsMemoryClientV1\u0026#39;; import { EmailSettingsMemoryClientV1 } from \u0026#39;../clients/version1/EmailSettingsMemoryClientV1\u0026#39;; import { SitesMemoryClientV1 } from \u0026#39;../clients/version1/SitesMemoryClientV1\u0026#39;; import { InvitationsNullClientV1 } from \u0026#39;../clients/version1/InvitationsNullClientV1\u0026#39;; import { BeaconsMemoryClientV1 } from \u0026#39;../clients/version1/BeaconsMemoryClientV1\u0026#39; export class ClientFacadeFactory extends Factory { public static SettingsNullClientV1Descriptor = new Descriptor(\u0026#34;pip-services-settings\u0026#34;, \u0026#34;client\u0026#34;, \u0026#34;null\u0026#34;, \u0026#34;*\u0026#34;, \u0026#34;1.0\u0026#34;); public static AccountsMemoryClientV1Descriptor = new Descriptor(\u0026#34;pip-services-accounts\u0026#34;, \u0026#34;client\u0026#34;, \u0026#34;memory\u0026#34;, \u0026#34;*\u0026#34;, \u0026#34;1.0\u0026#34;); public static PasswordNullClientV1Descriptor = new Descriptor(\u0026#34;pip-services-passwords\u0026#34;, \u0026#34;client\u0026#34;, \u0026#34;null\u0026#34;, \u0026#34;*\u0026#34;, \u0026#34;1.0\u0026#34;); public static RolesMemoryClientV1Descriptor = new Descriptor(\u0026#34;pip-services-roles\u0026#34;, \u0026#34;client\u0026#34;, \u0026#34;memory\u0026#34;, \u0026#34;*\u0026#34;, \u0026#34;1.0\u0026#34;); public static SessionsMemoryClientV1Descriptor = new Descriptor(\u0026#34;pip-services-sessions\u0026#34;, \u0026#34;client\u0026#34;, \u0026#34;memory\u0026#34;, \u0026#34;*\u0026#34;, \u0026#34;1.0\u0026#34;); public static EmailSettingsMemoryClientV1Descriptor = new Descriptor(\u0026#34;pip-services-emailsettings\u0026#34;, \u0026#34;client\u0026#34;, \u0026#34;memory\u0026#34;, \u0026#34;*\u0026#34;, \u0026#34;1.0\u0026#34;); public static SitesMemoryClientV1Descriptor = new Descriptor(\u0026#34;nov-services-sites\u0026#34;, \u0026#34;client\u0026#34;, \u0026#34;memory\u0026#34;, \u0026#34;*\u0026#34;, \u0026#34;1.0\u0026#34;); public static InvitationsNullClientV1Descriptor = new Descriptor(\u0026#34;nov-services-invitations\u0026#34;, \u0026#34;client\u0026#34;, \u0026#34;null\u0026#34;, \u0026#34;*\u0026#34;, \u0026#34;1.0\u0026#34;); public static BeaconsMemoryClientV1Descriptor = new Descriptor(\u0026#34;nov-services-beacons\u0026#34;, \u0026#34;client\u0026#34;, \u0026#34;memory\u0026#34;, \u0026#34;*\u0026#34;, \u0026#34;1.0\u0026#34;); public constructor() { super(); this.registerAsType(ClientFacadeFactory.SettingsNullClientV1Descriptor, SettingsNullClientV1); this.registerAsType(ClientFacadeFactory.AccountsMemoryClientV1Descriptor, AccountsMemoryClientV1); this.registerAsType(ClientFacadeFactory.PasswordNullClientV1Descriptor, PasswordsNullClientV1); this.registerAsType(ClientFacadeFactory.RolesMemoryClientV1Descriptor, RolesMemoryClientV1); this.registerAsType(ClientFacadeFactory.SessionsMemoryClientV1Descriptor, SessionsMemoryClientV1); this.registerAsType(ClientFacadeFactory.EmailSettingsMemoryClientV1Descriptor, EmailSettingsMemoryClientV1); this.registerAsType(ClientFacadeFactory.SitesMemoryClientV1Descriptor, SitesMemoryClientV1); this.registerAsType(ClientFacadeFactory.InvitationsNullClientV1Descriptor, InvitationsNullClientV1); this.registerAsType(ClientFacadeFactory.BeaconsMemoryClientV1Descriptor, BeaconsMemoryClientV1); } } The container that we want to run our facade in should be implemented in a file named FacadeProcess.ts and placed in the /container folder:\n/src/container/FacadeProcess.ts\nimport { IReferences } from \u0026#39;pip-services3-commons-node\u0026#39;; import { ProcessContainer } from \u0026#39;pip-services3-container-node\u0026#39;; import { DefaultRpcFactory } from \u0026#39;pip-services3-rpc-node\u0026#39;; import { ClientFacadeFactory } from \u0026#39;../build/ClientFacadeFactory\u0026#39;; import { FacadeFactory } from \u0026#39;../build/FacadeFactory\u0026#39;; export class FacadeProcess extends ProcessContainer { public constructor() { super(\u0026#34;nov-facades-application\u0026#34;, \u0026#34;Sample facade for NOV\u0026#34;); this._factories.add(new ClientFacadeFactory); this._factories.add(new FacadeFactory); this._factories.add(new DefaultRpcFactory); } } For us to be able to run the container, create a run.js file in the /bin folder with the following code:\n/bin/run.ts\nlet FacadeProcess = require(\u0026#39;../obj/src/container/FacadeProcess\u0026#39;).FacadeProcess; try { new FacadeProcess().run(process.argv); } catch (ex) { console.error(ex); } Our facade will need to be configured before running, so create a config-distributed.yml file in the /config folder of the project with the following:\n/config/config.yml\n--- # Container info - descriptor: \u0026#34;pip-services:container-info:default:default:*\u0026#34; name: \u0026#34;nov-facade\u0026#34; description: \u0026#34;Sample facade for NOV\u0026#34; # Console logger - descriptor: \u0026#34;pip-services:logger:console:default:*\u0026#34; level: trace # Log counters - descriptor: \u0026#34;pip-services:counters:log:default:*\u0026#34; # Settings components - descriptor: \u0026#34;pip-services-settings:client:null:default:*\u0026#34; # Accounts components - descriptor: \u0026#34;pip-services-accounts:client:memory:default:*\u0026#34; # Email settings components - descriptor: \u0026#34;pip-services-emailsettings:client:memory:default:*\u0026#34; # Passwords components - descriptor: \u0026#34;pip-services-passwords:client:null:default:*\u0026#34; # Roles components - descriptor: \u0026#34;pip-services-roles:client:memory:default:*\u0026#34; # Session components - descriptor: \u0026#34;pip-services-sessions:client:memory:default:*\u0026#34; # Sites components - descriptor: \u0026#34;nov-services-sites:client:memory:default:*\u0026#34; # Beacons components - descriptor: \u0026#34;nov-services-beacons:client:memory:default:*\u0026#34; # Invitations components - descriptor: \u0026#34;nov-services-invitations:client:null:default:*\u0026#34; # Main facade service - descriptor: \u0026#34;pip-services:endpoint:http:default:*\u0026#34; root_path: \u0026#34;\u0026#34; connection: protocol: \u0026#34;http\u0026#34; host: \u0026#34;0.0.0.0\u0026#34; port: 8080 options: debug: true maintenance_enabled: false max_req_size: \u0026#34;1mb\u0026#34; # Facade API V1 - descriptor: \u0026#34;nov-facades-application:service:http:default:1.0\u0026#34; # Facade API V2 - descriptor: \u0026#34;nov-facades-application:service:http:default:2.0\u0026#34; # Hearbeat service - descriptor: \u0026#34;pip-services:heartbeat-service:http:default:1.0\u0026#34; # Status service - descriptor: \u0026#34;pip-services:status-service:http:default:1.0\u0026#34; For demonstration purposes, we’ll be running our system in a distributed mode, with all of its components running in their own, individual containers. The configuration above is designed specifically for this type of distributed deployment.\nThe process of running a service in a Docker container is described in detail in the Dockerization tutorial\nTo run our system using Docker Compose, create a docker-compose.yml file with the following:\nBuild and run the facade using the respective scripts (described in the Docker tutorial we mentioned above), which can be found in this example project’s repository.\nTo build the facade’s image and load the rest of the services’ images, run the “package” script using the command below:\n.\\package.ps1 Once the build process successfully finishes, run the entire system with all of its microservices in Docker Compose using the “run” script. This can be done with the following command:\n.\\run.ps1 When running the facade, you should see something like this in the console:\n app_1 | [pip-facades-example:DEBUG:2021-06-17T22:03:56.128800] Opened REST service at http://0.0.0.0:8080 app_1 | [pip-facades-example:INFO:2021-06-17T22:03:56.180451] Container pip-facades-example started. app_1 | [pip-facades-example:INFO:2021-06-17T22:03:56.180451] Press Control-C to stop the microservice... Now we’re ready to move on to manually testing our facade. In Step 8 - Manually testing the facade - we’ll show you how this can be done.\nStep 8 - Manually testing the facade  ","description":null,"image":null,"permalink":"/node/tutorials/microservice_facade/step7/","subtitle":null,"tags":null,"title":"Step 7. Running facade"},{"content":"Before we can run our facade, we need to add three more things: a factory for the component’s we’ve created, a container, and the code that will run it all. The process of implementing these pieces is the same as the one described in Data Microservice, so this time around we’ll just list the code:\nCreate three factories in the pip_facades_sample_python/build/ folder:\nOne factory for the facade in a file named FacadeFactory.py, containing the following code:\n/pip_facades_sample_python/build/FacadeFactory.py\n# -*- coding: utf-8 -*- from pip_services3_commons.refer.Descriptor import Descriptor from pip_services3_components.build.Factory import Factory from pip_facades_sample_python.services.version1.FacadeServiceV1 import FacadeServiceV1 from pip_facades_sample_python.services.version2.FacadeServiceV2 import FacadeServiceV2 class FacadeFactory(Factory): FacadeServiceV1Descriptor = Descriptor(\u0026#34;nov-facades-application\u0026#34;, \u0026#34;service\u0026#34;, \u0026#34;http\u0026#34;, \u0026#34;*\u0026#34;, \u0026#34;1.0\u0026#34;) FacadeServiceV2Descriptor = Descriptor(\u0026#34;nov-facades-application\u0026#34;, \u0026#34;service\u0026#34;, \u0026#34;http\u0026#34;, \u0026#34;*\u0026#34;, \u0026#34;2.0\u0026#34;) def __init__(self): super(FacadeFactory, self).__init__() self.register_as_type(FacadeFactory.FacadeServiceV1Descriptor, FacadeServiceV1) self.register_as_type(FacadeFactory.FacadeServiceV2Descriptor, FacadeServiceV2) And last but not least, a factory for the clients that that facade depends on in a file named ClientFacadeFactory.py:\n/pip_facades_sample_python/build/ClientFacadeFactory.py\n# -*- coding: utf-8 -*- from pip_services3_commons.refer import Descriptor from pip_services3_components.build import Factory from pip_facades_sample_python.clients.version1.AccountsMemoryClientV1 import AccountsMemoryClientV1 from pip_facades_sample_python.clients.version1.BeaconsMemoryClientV1 import BeaconsMemoryClientV1 from pip_facades_sample_python.clients.version1.EmailSettingsMemoryClientV1 import EmailSettingsMemoryClientV1 from pip_facades_sample_python.clients.version1.InvitationsNullClientV1 import InvitationsNullClientV1 from pip_facades_sample_python.clients.version1.PasswordsNullClientV1 import PasswordsNullClientV1 from pip_facades_sample_python.clients.version1.RolesMemoryClientV1 import RolesMemoryClientV1 from pip_facades_sample_python.clients.version1.SessionsMemoryClientV1 import SessionsMemoryClientV1 from pip_facades_sample_python.clients.version1.SettingsNullClientV1 import SettingsNullClientV1 from pip_facades_sample_python.clients.version1.SitesMemoryClientV1 import SitesMemoryClientV1 class ClientFacadeFactory(Factory): SettingsNullClientV1Descriptor = Descriptor(\u0026#34;pip-services-settings\u0026#34;, \u0026#34;client\u0026#34;, \u0026#34;null\u0026#34;, \u0026#34;*\u0026#34;, \u0026#34;1.0\u0026#34;) AccountsMemoryClientV1Descriptor = Descriptor(\u0026#34;pip-services-accounts\u0026#34;, \u0026#34;client\u0026#34;, \u0026#34;memory\u0026#34;, \u0026#34;*\u0026#34;, \u0026#34;1.0\u0026#34;) PasswordNullClientV1Descriptor = Descriptor(\u0026#34;pip-services-passwords\u0026#34;, \u0026#34;client\u0026#34;, \u0026#34;null\u0026#34;, \u0026#34;*\u0026#34;, \u0026#34;1.0\u0026#34;) RolesMemoryClientV1Descriptor = Descriptor(\u0026#34;pip-services-roles\u0026#34;, \u0026#34;client\u0026#34;, \u0026#34;memory\u0026#34;, \u0026#34;*\u0026#34;, \u0026#34;1.0\u0026#34;) SessionsMemoryClientV1Descriptor = Descriptor(\u0026#34;pip-services-sessions\u0026#34;, \u0026#34;client\u0026#34;, \u0026#34;memory\u0026#34;, \u0026#34;*\u0026#34;, \u0026#34;1.0\u0026#34;) EmailSettingsMemoryClientV1Descriptor = Descriptor(\u0026#34;pip-services-emailsettings\u0026#34;, \u0026#34;client\u0026#34;, \u0026#34;memory\u0026#34;, \u0026#34;*\u0026#34;, \u0026#34;1.0\u0026#34;) SitesMemoryClientV1Descriptor = Descriptor(\u0026#34;nov-services-sites\u0026#34;, \u0026#34;client\u0026#34;, \u0026#34;memory\u0026#34;, \u0026#34;*\u0026#34;, \u0026#34;1.0\u0026#34;) InvitationsNullClientV1Descriptor = Descriptor(\u0026#34;nov-services-invitations\u0026#34;, \u0026#34;client\u0026#34;, \u0026#34;null\u0026#34;, \u0026#34;*\u0026#34;, \u0026#34;1.0\u0026#34;) BeaconsMemoryClientV1Descriptor = Descriptor(\u0026#34;nov-services-beacons\u0026#34;, \u0026#34;client\u0026#34;, \u0026#34;memory\u0026#34;, \u0026#34;*\u0026#34;, \u0026#34;1.0\u0026#34;) def __init__(self): super(ClientFacadeFactory, self).__init__() self.register_as_type(ClientFacadeFactory.SettingsNullClientV1Descriptor, SettingsNullClientV1) self.register_as_type(ClientFacadeFactory.AccountsMemoryClientV1Descriptor, AccountsMemoryClientV1) self.register_as_type(ClientFacadeFactory.PasswordNullClientV1Descriptor, PasswordsNullClientV1) self.register_as_type(ClientFacadeFactory.RolesMemoryClientV1Descriptor, RolesMemoryClientV1) self.register_as_type(ClientFacadeFactory.SessionsMemoryClientV1Descriptor, SessionsMemoryClientV1) self.register_as_type(ClientFacadeFactory.EmailSettingsMemoryClientV1Descriptor, EmailSettingsMemoryClientV1) self.register_as_type(ClientFacadeFactory.SitesMemoryClientV1Descriptor, SitesMemoryClientV1) self.register_as_type(ClientFacadeFactory.InvitationsNullClientV1Descriptor, InvitationsNullClientV1) self.register_as_type(ClientFacadeFactory.BeaconsMemoryClientV1Descriptor, BeaconsMemoryClientV1) The container that we want to run our facade in should be implemented in a file named FacadeProcess.py and placed in the /container folder:\n/pip_facades_sample_python/container/FacadeProcess.py\n# -*- coding: utf-8 -*- from pip_services3_container import ProcessContainer from pip_services3_rpc.build.DefaultRpcFactory import DefaultRpcFactory from ..build.ClientFacadeFactory import ClientFacadeFactory from ..build.FacadeFactory import FacadeFactory class FacadeProcess(ProcessContainer): def __init__(self): super(FacadeProcess, self).__init__(\u0026#34;pip-facades-example\u0026#34;, \u0026#34;Example Pip.Services facade\u0026#34;) self._factories.add(ClientFacadeFactory()) self._factories.add(FacadeFactory()) self._factories.add(DefaultRpcFactory()) For us to be able to run the container, create a run.js file in the /bin folder with the following code:\n/bin/run.py\n# -*- coding: utf-8 -*- import os import sys # add parent directory to path sys.path.append(os.path.dirname(os.path.dirname(os.path.realpath(__file__)))) from pip_facades_sample_python.container.FacadeProcess import FacadeProcess try: FacadeProcess().run() except Exception as ex: sys.stderr.write(str(ex)) Our facade will need to be configured before running, so create a config-distributed.yml file in the /config folder of the project with the following:\n/config/config.yml\n--- # Container info - descriptor: \u0026#34;pip-services:container-info:default:default:*\u0026#34; name: \u0026#34;nov-facade\u0026#34; description: \u0026#34;Sample facade for NOV\u0026#34; # Console logger - descriptor: \u0026#34;pip-services:logger:console:default:*\u0026#34; level: trace # Log counters - descriptor: \u0026#34;pip-services:counters:log:default:*\u0026#34; # Settings components - descriptor: \u0026#34;pip-services-settings:client:null:default:*\u0026#34; # Accounts components - descriptor: \u0026#34;pip-services-accounts:client:memory:default:*\u0026#34; # Email settings components - descriptor: \u0026#34;pip-services-emailsettings:client:memory:default:*\u0026#34; # Passwords components - descriptor: \u0026#34;pip-services-passwords:client:null:default:*\u0026#34; # Roles components - descriptor: \u0026#34;pip-services-roles:client:memory:default:*\u0026#34; # Session components - descriptor: \u0026#34;pip-services-sessions:client:memory:default:*\u0026#34; # Sites components - descriptor: \u0026#34;nov-services-sites:client:memory:default:*\u0026#34; # Beacons components - descriptor: \u0026#34;nov-services-beacons:client:memory:default:*\u0026#34; # Invitations components - descriptor: \u0026#34;nov-services-invitations:client:null:default:*\u0026#34; # Main facade service - descriptor: \u0026#34;pip-services:endpoint:http:default:*\u0026#34; root_path: \u0026#34;\u0026#34; connection: protocol: \u0026#34;http\u0026#34; host: \u0026#34;0.0.0.0\u0026#34; port: 8080 options: debug: true maintenance_enabled: false max_req_size: \u0026#34;1mb\u0026#34; # Facade API V1 - descriptor: \u0026#34;nov-facades-application:service:http:default:1.0\u0026#34; # Facade API V2 - descriptor: \u0026#34;nov-facades-application:service:http:default:2.0\u0026#34; # Hearbeat service - descriptor: \u0026#34;pip-services:heartbeat-service:http:default:1.0\u0026#34; # Status service - descriptor: \u0026#34;pip-services:status-service:http:default:1.0\u0026#34; For demonstration purposes, we’ll be running our system in a distributed mode, with all of its components running in their own, individual containers. The configuration above is designed specifically for this type of distributed deployment.\nThe process of running a service in a Docker container is described in detail in the Dockerization tutorial\nTo run our system using Docker Compose, create a docker-compose.yml file with the following:\nBuild and run the facade using the respective scripts (described in the Docker tutorial we mentioned above), which can be found in this example project’s repository.\nTo build the facade’s image and load the rest of the services’ images, run the “package” script using the command below:\n.\\package.ps1 Once the build process successfully finishes, run the entire system with all of its microservices in Docker Compose using the “run” script. This can be done with the following command:\n.\\run.ps1 When running the facade, you should see something like this in the console:\n app_1 | [pip-facades-example:DEBUG:2021-06-17T22:03:56.128800] Opened REST service at http://0.0.0.0:8080 app_1 | [pip-facades-example:INFO:2021-06-17T22:03:56.180451] Container pip-facades-example started. app_1 | [pip-facades-example:INFO:2021-06-17T22:03:56.180451] Press Control-C to stop the microservice... Now we’re ready to move on to manually testing our facade. In Step 8 - Manually testing the facade - we’ll show you how this can be done.\nStep 8 - Manually testing the facade  ","description":null,"image":null,"permalink":"/python/tutorials/microservice_facade/step7/","subtitle":null,"tags":null,"title":"Step 7. Running facade"},{"content":"Once all of the system’s microservices are up and running, we can perform some manual testing of the facade we’ve created, to ensure that everything’s working as intended.\nFirst, let’s create a few users without any additional privileges. This can be done with the following command:\ncurl -X POST -H \u0026#34;Content-Type: application/json\u0026#34; -d \u0026#34;{\\\u0026#34;name\\\u0026#34;: \\\u0026#34;User1\\\u0026#34;,\\\u0026#34;login\\\u0026#34;: \\\u0026#34;user1@gmail.com\\\u0026#34;,\\\u0026#34;email\\\u0026#34;: \\\u0026#34;user1@gmail.com\\\u0026#34;,\\\u0026#34;language\\\u0026#34;: \\\u0026#34;en\\\u0026#34;,\\\u0026#34;theme\\\u0026#34;: \\\u0026#34;light\\\u0026#34;,\\\u0026#34;time_zone\\\u0026#34;: \\\u0026#34;\\\u0026#34;,\\\u0026#34;password\\\u0026#34;: \\\u0026#34;12345678\\\u0026#34;}\u0026#34; http://localhost:8080/api/v1/signup { \u0026#34;id\u0026#34;: \u0026#34;2f60829282a040899077f93000740272\u0026#34;, \u0026#34;user_id\u0026#34;: \u0026#34;1dbb2a5f1b4d43309cbe1c14b1bdcebe\u0026#34;, \u0026#34;user_name\u0026#34;: \u0026#34;User1\u0026#34;, \u0026#34;active\u0026#34;: true, \u0026#34;open_time\u0026#34;: \u0026#34;2021-06-18T01:14:06.342197Z\u0026#34;, \u0026#34;close_time\u0026#34;: null, \u0026#34;request_time\u0026#34;: \u0026#34;2021-06-18T01:14:06.342197Z\u0026#34;, \u0026#34;address\u0026#34;: null, \u0026#34;client\u0026#34;: \u0026#34;insomnia/2021.3.0\u0026#34;, \u0026#34;user\u0026#34;: { \u0026#34;id\u0026#34;: \u0026#34;1dbb2a5f1b4d43309cbe1c14b1bdcebe\u0026#34;, \u0026#34;login\u0026#34;: \u0026#34;user1@gmail.com\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;User1\u0026#34;, \u0026#34;create_time\u0026#34;: \u0026#34;2021-06-18T01:14:02.063595Z\u0026#34;, \u0026#34;time_zone\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;language\u0026#34;: \u0026#34;en\u0026#34;, \u0026#34;theme\u0026#34;: \u0026#34;light\u0026#34;, \u0026#34;roles\u0026#34;: [], \u0026#34;change_pwd_time\u0026#34;: null, \u0026#34;sites\u0026#34;: [], \u0026#34;settings\u0026#34;: {}, \u0026#34;custom_hdr\u0026#34;: null, \u0026#34;custom_dat\u0026#34;: null }, \u0026#34;data\u0026#34;: null } curl -X POST -H \u0026#34;Content-Type: application/json\u0026#34; -d \u0026#34;{\\\u0026#34;name\\\u0026#34;: \\\u0026#34;John Doe\\\u0026#34;,\\\u0026#34;login\\\u0026#34;: \\\u0026#34;johndoe@gmail.com\\\u0026#34;,\\\u0026#34;email\\\u0026#34;: \\\u0026#34;johndoe@gmail.com\\\u0026#34;,\\\u0026#34;language\\\u0026#34;: \\\u0026#34;en\\\u0026#34;,\\\u0026#34;theme\\\u0026#34;: \\\u0026#34;light\\\u0026#34;,\\\u0026#34;time_zone\\\u0026#34;: \\\u0026#34;\\\u0026#34;,\\\u0026#34;password\\\u0026#34;: \\\u0026#34;12345678\\\u0026#34;}\u0026#34; http://localhost:8080/api/v1/signup { \u0026#34;id\u0026#34;: \u0026#34;0e987d19ea3a49908704b5b3a7a1b0b4\u0026#34;, \u0026#34;user_id\u0026#34;: \u0026#34;7c65490e034846cba1c2072dda5c4156\u0026#34;, \u0026#34;user_name\u0026#34;: \u0026#34;John Doe\u0026#34;, \u0026#34;active\u0026#34;: true, \u0026#34;open_time\u0026#34;: \u0026#34;2021-06-18T01:21:52.214016Z\u0026#34;, \u0026#34;close_time\u0026#34;: null, \u0026#34;request_time\u0026#34;: \u0026#34;2021-06-18T01:21:52.214016Z\u0026#34;, \u0026#34;address\u0026#34;: null, \u0026#34;client\u0026#34;: \u0026#34;insomnia/2021.3.0\u0026#34;, \u0026#34;user\u0026#34;: { \u0026#34;id\u0026#34;: \u0026#34;7c65490e034846cba1c2072dda5c4156\u0026#34;, \u0026#34;login\u0026#34;: \u0026#34;johndoe@gmail.com\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;John Doe\u0026#34;, \u0026#34;create_time\u0026#34;: \u0026#34;2021-06-18T01:21:52.214016Z\u0026#34;, \u0026#34;time_zone\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;language\u0026#34;: \u0026#34;en\u0026#34;, \u0026#34;theme\u0026#34;: \u0026#34;light\u0026#34;, \u0026#34;roles\u0026#34;: [], \u0026#34;change_pwd_time\u0026#34;: null, \u0026#34;sites\u0026#34;: [], \u0026#34;settings\u0026#34;: {}, \u0026#34;custom_hdr\u0026#34;: null, \u0026#34;custom_dat\u0026#34;: null }, \u0026#34;data\u0026#34;: null } As a result of this operation, we should receive the same data structure in the response as the one we defined in our SessionUserV1 class. The parameter that’s of most importance to us right now is the session ID - the value of the last id field.\nLogin as User1 to receive access to the Beacons microservice’s methods. This can be done with the following command:\ncurl -X POST -H \u0026#34;Content-Type: application/json\u0026#34; -d \u0026#34;{\\\u0026#34;login\\\u0026#34;: \\\u0026#34;user1@gmail.com\\\u0026#34;, \\\u0026#34;password\\\u0026#34;:\\\u0026#34;12345678\\\u0026#34;}\u0026#34; http://localhost:8080/api/v1/signin { \u0026#34;id\u0026#34;: \u0026#34;ce42e40c56aa47148eb12ed928eacb45\u0026#34;, \u0026#34;user_id\u0026#34;: \u0026#34;09a2a7d6fc5c4fbcac54c9a6208194c3\u0026#34;, \u0026#34;user_name\u0026#34;: \u0026#34;User1\u0026#34;, \u0026#34;active\u0026#34;: true, \u0026#34;open_time\u0026#34;: \u0026#34;2021-06-18T01:25:08.542505Z\u0026#34;, \u0026#34;close_time\u0026#34;: null, \u0026#34;request_time\u0026#34;: \u0026#34;2021-06-18T01:25:08.543543Z\u0026#34;, \u0026#34;address\u0026#34;: null, \u0026#34;client\u0026#34;: \u0026#34;insomnia/2021.3.0\u0026#34;, \u0026#34;user\u0026#34;: { \u0026#34;id\u0026#34;: \u0026#34;09a2a7d6fc5c4fbcac54c9a6208194c3\u0026#34;, \u0026#34;login\u0026#34;: \u0026#34;user1@gmail.com\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;User1\u0026#34;, \u0026#34;create_time\u0026#34;: \u0026#34;2021-06-18T01:21:40.151448Z\u0026#34;, \u0026#34;time_zone\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;language\u0026#34;: \u0026#34;en\u0026#34;, \u0026#34;theme\u0026#34;: \u0026#34;light\u0026#34;, \u0026#34;roles\u0026#34;: null, \u0026#34;change_pwd_time\u0026#34;: null, \u0026#34;sites\u0026#34;: [], \u0026#34;settings\u0026#34;: {}, \u0026#34;custom_hdr\u0026#34;: null, \u0026#34;custom_dat\u0026#34;: null }, \u0026#34;data\u0026#34;: null } For future operations, use the session id that was returned:\n\u0026quot;id\u0026quot;: \u0026quot;ce42e40c56aa47148eb12ed928eacb45\u0026quot; Let’s test how our business logic works. Make a request to get all of the Beacons currently in the system using the session ID we mentioned above. You can do this using the following command:\ncurl -X GET -H \u0026#34;x-session-id:ce42e40c56aa47148eb12ed928eacb45\u0026#34; http://localhost:8080/api/v1/beacons {\u0026#34;total\u0026#34;:null,\u0026#34;data\u0026#34;:[]} We receive an empty list as a result, since we haven’t created any Beacons yet in the system.\nAttempting to request the URL without a valid session will result in an authentication error:\ncurl -X GET http://localhost:8080/api/v1/beacons { \u0026#34;type\u0026#34;:null, \u0026#34;category\u0026#34;:\u0026#34;Unauthorized\u0026#34;, \u0026#34;status\u0026#34;:401, \u0026#34;code\u0026#34;:\u0026#34;NOT_SIGNED\u0026#34;, \u0026#34;message\u0026#34;:\u0026#34;User must be signed in to perform this operation\u0026#34;, \u0026#34;details\u0026#34;:null, \u0026#34;correlation_id\u0026#34;:null, \u0026#34;cause\u0026#34;:null, \u0026#34;stack_trace\u0026#34;: null } Feel free to explore the rest of the system’s functionality on your own using the routes we registered in the facade’s service and the sample data from the Data microservice tutorial.\nCongratulations! Having completed all of the steps of this tutorial, you’ve created your first full-fledged facade and are now capable of creating your own using the Pip.Services Toolkit!\nThis example’s source code is available in our repository on GitHub\n","description":null,"image":null,"permalink":"/node/tutorials/microservice_facade/step8/","subtitle":null,"tags":null,"title":"Step 8. Manual testing of facade"},{"content":"Once all of the system’s microservices are up and running, we can perform some manual testing of the facade we’ve created, to ensure that everything’s working as intended.\nFirst, let’s create a few users without any additional privileges. This can be done with the following command:\ncurl -X POST -H \u0026#34;Content-Type: application/json\u0026#34; -d \u0026#34;{\\\u0026#34;name\\\u0026#34;: \\\u0026#34;User1\\\u0026#34;,\\\u0026#34;login\\\u0026#34;: \\\u0026#34;user1@gmail.com\\\u0026#34;,\\\u0026#34;email\\\u0026#34;: \\\u0026#34;user1@gmail.com\\\u0026#34;,\\\u0026#34;language\\\u0026#34;: \\\u0026#34;en\\\u0026#34;,\\\u0026#34;theme\\\u0026#34;: \\\u0026#34;light\\\u0026#34;,\\\u0026#34;time_zone\\\u0026#34;: \\\u0026#34;\\\u0026#34;,\\\u0026#34;password\\\u0026#34;: \\\u0026#34;12345678\\\u0026#34;}\u0026#34; http://localhost:8080/api/v1/signup { \u0026#34;id\u0026#34;: \u0026#34;2f60829282a040899077f93000740272\u0026#34;, \u0026#34;user_id\u0026#34;: \u0026#34;1dbb2a5f1b4d43309cbe1c14b1bdcebe\u0026#34;, \u0026#34;user_name\u0026#34;: \u0026#34;User1\u0026#34;, \u0026#34;active\u0026#34;: true, \u0026#34;open_time\u0026#34;: \u0026#34;2021-06-18T01:14:06.342197Z\u0026#34;, \u0026#34;close_time\u0026#34;: null, \u0026#34;request_time\u0026#34;: \u0026#34;2021-06-18T01:14:06.342197Z\u0026#34;, \u0026#34;address\u0026#34;: null, \u0026#34;client\u0026#34;: \u0026#34;insomnia/2021.3.0\u0026#34;, \u0026#34;user\u0026#34;: { \u0026#34;id\u0026#34;: \u0026#34;1dbb2a5f1b4d43309cbe1c14b1bdcebe\u0026#34;, \u0026#34;login\u0026#34;: \u0026#34;user1@gmail.com\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;User1\u0026#34;, \u0026#34;create_time\u0026#34;: \u0026#34;2021-06-18T01:14:02.063595Z\u0026#34;, \u0026#34;time_zone\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;language\u0026#34;: \u0026#34;en\u0026#34;, \u0026#34;theme\u0026#34;: \u0026#34;light\u0026#34;, \u0026#34;roles\u0026#34;: [], \u0026#34;change_pwd_time\u0026#34;: null, \u0026#34;sites\u0026#34;: [], \u0026#34;settings\u0026#34;: {}, \u0026#34;custom_hdr\u0026#34;: null, \u0026#34;custom_dat\u0026#34;: null }, \u0026#34;data\u0026#34;: null } curl -X POST -H \u0026#34;Content-Type: application/json\u0026#34; -d \u0026#34;{\\\u0026#34;name\\\u0026#34;: \\\u0026#34;John Doe\\\u0026#34;,\\\u0026#34;login\\\u0026#34;: \\\u0026#34;johndoe@gmail.com\\\u0026#34;,\\\u0026#34;email\\\u0026#34;: \\\u0026#34;johndoe@gmail.com\\\u0026#34;,\\\u0026#34;language\\\u0026#34;: \\\u0026#34;en\\\u0026#34;,\\\u0026#34;theme\\\u0026#34;: \\\u0026#34;light\\\u0026#34;,\\\u0026#34;time_zone\\\u0026#34;: \\\u0026#34;\\\u0026#34;,\\\u0026#34;password\\\u0026#34;: \\\u0026#34;12345678\\\u0026#34;}\u0026#34; http://localhost:8080/api/v1/signup { \u0026#34;id\u0026#34;: \u0026#34;0e987d19ea3a49908704b5b3a7a1b0b4\u0026#34;, \u0026#34;user_id\u0026#34;: \u0026#34;7c65490e034846cba1c2072dda5c4156\u0026#34;, \u0026#34;user_name\u0026#34;: \u0026#34;John Doe\u0026#34;, \u0026#34;active\u0026#34;: true, \u0026#34;open_time\u0026#34;: \u0026#34;2021-06-18T01:21:52.214016Z\u0026#34;, \u0026#34;close_time\u0026#34;: null, \u0026#34;request_time\u0026#34;: \u0026#34;2021-06-18T01:21:52.214016Z\u0026#34;, \u0026#34;address\u0026#34;: null, \u0026#34;client\u0026#34;: \u0026#34;insomnia/2021.3.0\u0026#34;, \u0026#34;user\u0026#34;: { \u0026#34;id\u0026#34;: \u0026#34;7c65490e034846cba1c2072dda5c4156\u0026#34;, \u0026#34;login\u0026#34;: \u0026#34;johndoe@gmail.com\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;John Doe\u0026#34;, \u0026#34;create_time\u0026#34;: \u0026#34;2021-06-18T01:21:52.214016Z\u0026#34;, \u0026#34;time_zone\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;language\u0026#34;: \u0026#34;en\u0026#34;, \u0026#34;theme\u0026#34;: \u0026#34;light\u0026#34;, \u0026#34;roles\u0026#34;: [], \u0026#34;change_pwd_time\u0026#34;: null, \u0026#34;sites\u0026#34;: [], \u0026#34;settings\u0026#34;: {}, \u0026#34;custom_hdr\u0026#34;: null, \u0026#34;custom_dat\u0026#34;: null }, \u0026#34;data\u0026#34;: null } As a result of this operation, we should receive the same data structure in the response as the one we defined in our SessionUserV1 class. The parameter that’s of most importance to us right now is the session ID - the value of the last id field.\nLogin as User1 to receive access to the Beacons microservice’s methods. This can be done with the following command:\ncurl -X POST -H \u0026#34;Content-Type: application/json\u0026#34; -d \u0026#34;{\\\u0026#34;login\\\u0026#34;: \\\u0026#34;user1@gmail.com\\\u0026#34;, \\\u0026#34;password\\\u0026#34;:\\\u0026#34;12345678\\\u0026#34;}\u0026#34; http://localhost:8080/api/v1/signin { \u0026#34;id\u0026#34;: \u0026#34;ce42e40c56aa47148eb12ed928eacb45\u0026#34;, \u0026#34;user_id\u0026#34;: \u0026#34;09a2a7d6fc5c4fbcac54c9a6208194c3\u0026#34;, \u0026#34;user_name\u0026#34;: \u0026#34;User1\u0026#34;, \u0026#34;active\u0026#34;: true, \u0026#34;open_time\u0026#34;: \u0026#34;2021-06-18T01:25:08.542505Z\u0026#34;, \u0026#34;close_time\u0026#34;: null, \u0026#34;request_time\u0026#34;: \u0026#34;2021-06-18T01:25:08.543543Z\u0026#34;, \u0026#34;address\u0026#34;: null, \u0026#34;client\u0026#34;: \u0026#34;insomnia/2021.3.0\u0026#34;, \u0026#34;user\u0026#34;: { \u0026#34;id\u0026#34;: \u0026#34;09a2a7d6fc5c4fbcac54c9a6208194c3\u0026#34;, \u0026#34;login\u0026#34;: \u0026#34;user1@gmail.com\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;User1\u0026#34;, \u0026#34;create_time\u0026#34;: \u0026#34;2021-06-18T01:21:40.151448Z\u0026#34;, \u0026#34;time_zone\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;language\u0026#34;: \u0026#34;en\u0026#34;, \u0026#34;theme\u0026#34;: \u0026#34;light\u0026#34;, \u0026#34;roles\u0026#34;: null, \u0026#34;change_pwd_time\u0026#34;: null, \u0026#34;sites\u0026#34;: [], \u0026#34;settings\u0026#34;: {}, \u0026#34;custom_hdr\u0026#34;: null, \u0026#34;custom_dat\u0026#34;: null }, \u0026#34;data\u0026#34;: null } For future operations, use the session id that was returned:\n\u0026quot;id\u0026quot;: \u0026quot;ce42e40c56aa47148eb12ed928eacb45\u0026quot; Let’s test how our business logic works. Make a request to get all of the Beacons currently in the system using the session ID we mentioned above. You can do this using the following command:\ncurl -X GET -H \u0026#34;x-session-id:ce42e40c56aa47148eb12ed928eacb45\u0026#34; http://localhost:8080/api/v1/beacons {\u0026#34;total\u0026#34;:null,\u0026#34;data\u0026#34;:[]} We receive an empty list as a result, since we haven’t created any Beacons yet in the system.\nAttempting to request the URL without a valid session will result in an authentication error:\ncurl -X GET http://localhost:8080/api/v1/beacons { \u0026#34;type\u0026#34;:null, \u0026#34;category\u0026#34;:\u0026#34;Unauthorized\u0026#34;, \u0026#34;status\u0026#34;:401, \u0026#34;code\u0026#34;:\u0026#34;NOT_SIGNED\u0026#34;, \u0026#34;message\u0026#34;:\u0026#34;User must be signed in to perform this operation\u0026#34;, \u0026#34;details\u0026#34;:null, \u0026#34;correlation_id\u0026#34;:null, \u0026#34;cause\u0026#34;:null, \u0026#34;stack_trace\u0026#34;: null } Feel free to explore the rest of the system’s functionality on your own using the routes we registered in the facade’s service and the sample data from the Data microservice tutorial.\nCongratulations! Having completed all of the steps of this tutorial, you’ve created your first full-fledged facade and are now capable of creating your own using the Pip.Services Toolkit!\nThis example’s source code is available in our repository on GitHub\n","description":null,"image":null,"permalink":"/python/tutorials/microservice_facade/step8/","subtitle":null,"tags":null,"title":"Step 8. Manual testing of facade"},{"content":"Description The StringConverter class allows you to convert arbitrary values into strings using the following extended conversion rules:\n Numbers: are converted with \u0026lsquo;.\u0026rsquo; as decimal point DateTime: using ISO format Boolean: \u0026ldquo;true\u0026rdquo; for true and \u0026ldquo;false\u0026rdquo; for false Arrays: as comma-separated list Other objects: using ToString() method  Methods ToNullableString Converts a value into a string or returns nil when the value is nil.\n ToNullableString(value interface{}) *string\n  value: interface{} - value to convert. returns: *string - string value or nil when value is nil.  ToString Converts a value into a string or returns \u0026quot;\u0026quot; when the value is nil.\n ToString(value interface{}) string\n  value: interface{} - value to convert. returns: string - string value or \u0026quot;\u0026quot; when value is nil.  ToStringWithDefault Converts a value into a string or returns a default value when the value is nil.\n ToStringWithDefault(value interface{}, defaultValue string) string\n  value: interface{} - value to convert. defaultValue: string - default value. returns: string - string value or default value when value is nil.  Examples var value1 = convert.StringConverter.ToString(123.456) var value2 = convert.StringConverter.ToString(true) var value3 = convert.StringConverter.ToString(time.Now()) var value4 = convert.StringConverter.ToString([...]int{1, 2, 3}) fmt.Println(value1) // 123.456 fmt.Println(value2) // true fmt.Println(value3) // 2019-08-20T23:54:47+03:00 fmt.Println(value4) // 1,2,3 ","description":"The StringConverter class allows you to convert arbitrary values into strings.\n","image":null,"permalink":"/golang/commons/convert/string_converter/","subtitle":null,"tags":null,"title":"StringConverter"},{"content":"Description The StringConverter class allows you to convert arbitrary values into strings using the following extended conversion rules:\n Numbers: are converted with \u0026lsquo;.\u0026rsquo; as decimal point DateTime: using ISO format Boolean: \u0026ldquo;true\u0026rdquo; for true and \u0026ldquo;false\u0026rdquo; for false Arrays: as comma-separated list Other objects: using ToString() method  Static methods ToNullableString Converts value into a string or returns null when value is null.\n public static string ToNullableString(object value)\n  value: object - value to convert. returns: string - string value or null when value is null.  ToString Converts value into a string or returns \u0026quot;\u0026quot; when value is null.\n public static string ToString(object value)\n  value: object - value to convert. returns: string - string value or \u0026quot;\u0026quot; when value is null.  ToStringWithDefault Converts value into string or returns default when value is null.\n public static string ToStringWithDefault(object value, string defaultValue)\n  value: object - value to convert. defaultValue: string - default value. returns: string - string value or default when value is null.  Examples var value1 = StringConverter.ToString(123.456); // Result: \u0026#34;123.456\u0026#34; var value2 = StringConverter.ToString(true); // Result: \u0026#34;true\u0026#34; var value3 = StringConverter.ToString(ZonedDateTime.now()); // Result: \u0026#34;2018-01-01T00:00:00.00\u0026#34; var value4 = StringConverter.ToString(new int[]{1, 2, 3}); // Result: \u0026#34;1,2,3\u0026#34; ","description":"The StringConverter class allows you to convert arbitrary values into strings.\n","image":null,"permalink":"/net/commons/convert/string_converter/","subtitle":null,"tags":null,"title":"StringConverter"},{"content":"Description The StringConverter class allows you to convert arbitrary values into strings using the following extended conversion rules:\n Numbers: are converted with \u0026lsquo;.\u0026rsquo; as decimal point DateTime: using the ISO format Boolean: \u0026ldquo;true\u0026rdquo; for true and \u0026ldquo;false\u0026rdquo; for false Arrays: as comma-separated list Other objects: using toString() method  Static methods toNullableString Converts a value into a string or returns null when the value is null.\n public static toNullableString(value: any): string\n  value: any - value to convert. returns: string - string value or null when value is null.  toString Converts a value into string or returns \u0026quot;\u0026quot; when the value is null.\n public static toString(value: any): string\n  value: any - value to convert. returns: string - string value or \u0026quot;\u0026quot; when value is null.  toStringWithDefault Converts a value into a string or returns a given default when the value is null.\n public static toStringWithDefault(value: any, defaultValue: string): string\n  value: any - value to convert. defaultValue: string - default value. returns: string - string value or given default when value is null.  Examples let value1 = StringConverter.ToString(123.456); // Result: \u0026#34;123.456\u0026#34; let value2 = StringConverter.ToString(true); // Result: \u0026#34;true\u0026#34; let value3 = StringConverter.ToString(new Date(2018,0,1)); // Result: \u0026#34;2018-01-01T00:00:00.00\u0026#34; let value4 = StringConverter.ToString([1,2,3]); // Result: \u0026#34;1,2,3\u0026#34; ","description":"The StringConverter class allows you to convert arbitrary values into strings.\n","image":null,"permalink":"/node/commons/convert/string_converter/","subtitle":null,"tags":null,"title":"StringConverter"},{"content":"Description The StringConverter class allows you to convert arbitrary values into strings using the following extended conversion rules:\n Numbers: are converted with \u0026lsquo;.\u0026rsquo; as decimal point DateTime: using ISO format Boolean: \u0026ldquo;true\u0026rdquo; for true and \u0026ldquo;false\u0026rdquo; for false Arrays: as comma-separated list Other objects: using to_string() method  Static methods to_nullable_string Converts value into string or returns None when value is None.\n static to_nullable_string(value: Any): Optional[str]\n  value: Any - the value to convert. returns: Optional[str] - string value or None when value is None.  to_string Converts value into string or returns \u0026quot;\u0026quot; when value is None.\n static to_string(value: Any): str\n  value: Any - the value to convert. returns: str - string value or \u0026quot;\u0026quot; when value is None.  to_string_with_default Converts value into string or returns default when value is None.\n public static to_string_with_default(value: Any, default_value: str): str\n  value: Any - the value to convert. default_value: str - the default value. returns: str - string value or default when value is None.  Examples import datetime value1 = StringConverter.to_string(123.456) # Returns \u0026#39;123.456\u0026#39; value2 = StringConverter.to_string(True) # Returs \u0026#39;True\u0026#39; value3 = StringConverter.to_string(datetime.datetime(2018,10,1)) # Returns \u0026#39;2018-10-01T00:00:00Z\u0026#39;\u0026#34;2018-01-01T00:00:00.00\u0026#34; value4 = StringConverter.to_string([\u0026#34;a\u0026#34;,\u0026#34;b\u0026#34;,\u0026#34;c\u0026#34;]) # Returns \u0026#39;a,b,c\u0026#39; ","description":"The StringConverter class allows you to convert arbitrary values into strings.\n","image":null,"permalink":"/python/commons/convert/string_converter/","subtitle":null,"tags":null,"title":"StringConverter"},{"content":"Implements: IScanner\nDescription The StringScanner class is used to scan characters in a string that allows tokenizers to look ahead through a stream to perform lexical analysis.\nConstructors Creates an instance of this class.\n public constructor(content: string)\n  content: string - text content to be read.  Properties Eof EOF\n public static Eof: number = -1\n Instance methods column Gets the column in the current line\n public column(): number\n  returns: number - column in the current line in the stream.  line Gets the current line number\n public line(): number\n  returns: number - current line number in the stream.  peek Returns the character from the top of the stream without moving the stream pointer.\n public peek(): number\n  returns: number - character from the top of the stream or -1 if the stream is empty.  peekColumn Gets the next character column number.\n public peekColumn(): number\n  returns: number - next character column number in the stream.  peekLine Gets the next character line number.\n public peekLine(): number\n  returns: number - next character line number in the stream.  read Reads a character from the top of the stream.\n public read(): number\n  returns: number - read character or -1 if the stream is processed to the end.  reset Resets scanner to the initial position\n public reset(): void\n unread Puts one character back into the stream stream.\n public unread(): void\n unreadMany Pushes the specified number of characters to the top of the stream.\n public unreadMany(count: number): void\n  count: number - number of characcted to be pushed back.  ","description":"Scan characters in a string that allows tokenizers to look ahead through stream to perform lexical analysis.\n","image":null,"permalink":"/node/expressions/io/string_scanner/","subtitle":null,"tags":null,"title":"StringScanner"},{"content":"Description The StringValueMap class allows you to create a cross-language implementation of a map (dictionary) where all keys and values are strings.\nImportant points\n The class provides several methods to convert the stored values to different types, such as array, boolean or datetime. This class is widely used in Pip.Services as a basis for variety of classes, such as ConfigParams, ConnectionParams, CredentialParams (in the Pip.Services components package) and others.  Constructors NewStringValueMap Creates a new instance of the map and assigns its value.\n NewStringValueMap(value map[string]string) *StringValueMap\n  map: map[string]string - (optional) values to initialize this map.  NewEmptyStringValueMap Creates a new instance of the map and assigns its value.\n NewEmptyStringValueMap() *StringValueMap\n NewStringValueMapFromMaps Creates a new AnyValueMap by merging two or more maps. Maps defined later in the list override values from previously defined maps.\n NewStringValueMapFromMaps(maps \u0026hellip;map[string]string) StringValueMap\n  maps: \u0026hellip;map[string]string - an array of maps to be merged returns: StringValueMap - newly created StringValueMap.  NewStringValueMapFromString Parses semicolon-separated key-value pairs and returns them as a StringValueMap.\n NewStringValueMapFromString(line string) *StringValueMap\n  line: string - semicolon-separated key-value list to initialize StringValueMap. returns: *StringValueMap - newly created StringValueMap.  NewStringValueMapFromTuples Creates a new StringValueMap from a list of key-value pairs called tuples.\n NewStringValueMapFromTuples(tuples \u0026hellip;interface{}) *StringValueMap\n  tuples: \u0026hellip;interface{} - list of values where odd elements are keys and the following even elements are values returns: *StringValueMap - newly created StringValueMap.  NewStringValueMapFromTuplesArray Creates a new StringValueMap from a list of key-value pairs called tuples. The method is similar to NewStringValueMapFromTuples but tuples are passed as array instead of parameters.\n NewStringValueMapFromTuplesArray(tuples []interface{}) *StringValueMap\n  tuples: []interface{} - list of values where odd elements are keys and the following even elements are values returns: *StringValueMap - newly created StringValueMap.  NewStringValueMapFromValue Converts specified value into StringValueMap.\n NewStringValueMapFromValue(value interface{}) *StringValueMap\n  value: interface{} - value to be converted returns: *StringValueMap - newly created StringValueMap.  Methods Append Appends new elements to this map.\n (c *StringValueMap) Append(values map[string]string)\n  map: map[string]string - map with elements to be added.  Clear Clears this map by removing all its elements.\n (c *StringValueMap) Clear()\n Clone Creates a binary clone of this object.\n (c *StringValueMap) Clone() interface{}\n  returns: interface{} - clone of this object.  Get Gets a map element specified by its key.\n (c *StringValueMap) Get(key string) string\n  key: string - key of the element to get. returns: string - value of the map element.  GetAsArray Converts a map element into an AnyValueArray or returns an empty AnyValueArray if the conversion is not possible.\nSee AnyValueArray, AnyValueArray.NewAnyValueArrayFromValue\n (c *StringValueMap) GetAsArray(key string) *AnyValueArray\n  key: string - key of element to get. returns: *AnyValueArray - AnyValueArray value of the element or empty AnyValueArray if the conversion is not supported.  GetAsArrayWithDefault Converts a map element into an AnyValueArray or returns a default value if the conversion is not possible.\nSee AnyValueArray\n (c *StringValueMap) GetAsArrayWithDefault(key string, defaultValue *AnyValueArray) *AnyValueArray\n  key: string - a key of element to get. defaultValue: *AnyValueArray - default value returns: *AnyValueArray - AnyValueArray value of the element or default value if conversion is not supported.  GetAsBoolean Converts a map element into a boolean or returns false if the conversion is not possible.\n (c *StringValueMap) GetAsBoolean(key string) bool\n  key: string - a key of element to get. returns: bool - boolean value of the element or false if the conversion is not supported.  GetAsBooleanWithDefault Converts a map element into a boolean or returns a default value if the conversion is not possible.\nSee BooleanConverter.ToBooleanWithDefault\n (c *StringValueMap) GetAsBooleanWithDefault(key string, defaultValue bool) bool\n  key: string - key of element to get. defaultValue: bool - default value returns: bool - boolean value of the element or default value if the conversion is not supported.  GetAsDateTime Converts a map element into a Date or returns the current date if the conversion is not possible.\nSee BooleanConverter.ToBooleanWithDefault\n (c *StringValueMap) GetAsDateTime(key string) time.Time\n  key: string - key of element to get. returns: time.Time - Date value of the element or the current date if the conversion is not supported.  GetAsDateTimeWithDefault Converts a map element into a Date or returns a default value if the conversion is not possible.\nSee DateTimeConverter.ToDateTimeWithDefault\n (c *StringValueMap) GetAsDateTimeWithDefault(key string, defaultValue time.Time) time.Time\n  key: string - key of element to get. defaultValue: time.Time - default value returns: time.Time - Date value of the element or default value if the conversion is not supported.  GetAsDouble Converts a map element into a double or returns 0 if the conversion is not possible.\n (c *StringValueMap) GetAsDouble(key string) float64\n  key: string - key of element to get. returns: float64 - double value of the element or 0 if the conversion is not supported.  GetAsDoubleWithDefault Converts a map element into a double or returns default value if the conversion is not possible.\nSee DoubleConverter.ToDoubleWithDefault\n (c *StringValueMap) GetAsDoubleWithDefault(key string, defaultValue float64) float64\n  key: string - key of element to get. defaultValue: float64 - default value returns: float64 - double value of the element or default value if the conversion is not supported.  GetAsFloat Converts a map element into a float or returns 0 if the conversion is not possible.\n (c *StringValueMap) GetAsFloat(key string) float32\n  key: string - key of element to get. returns: float32 - float value of the element or 0 if the conversion is not supported.  GetAsFloatWithDefault Converts a map element into a float or returns a default value if the conversion is not possible.\nSee FloatConverter.ToFloatWithDefault\n (c *StringValueMap) GetAsFloatWithDefault(key string, defaultValue float32) float32\n  key: string - key of element to get. defaultValue: float32 - default value returns: float32 - flot value of the element or default value if the conversion is not supported.  GetAsInteger Converts map element into an integer or returns 0 if the conversion is not possible.\n (c *StringValueMap) GetAsInteger(key string) int\n  key: string - key of element to get. returns: int - integer value of the element or 0 if the conversion is not supported.  GetAsIntegerWithDefault Converts a map element into an integer or returns a default value if the conversion is not possible.\nSee IntegerConverter.ToIntegerWithDefault\n (c *StringValueMap) GetAsIntegerWithDefault(key string, defaultValue int) int\n  key: string - key of element to get. defaultValue: int - default value returns: int - integer value of the element or default value if the conversion is not supported.  GetAsLong Converts map element into a long or returns 0 if the conversion is not possible.\n (c *StringValueMap) GetAsLong(key string) int64\n  key: string - key of element to get. returns: int64 - long value of the element or 0 if the conversion is not supported.  GetAsLongWithDefault Converts a map element into a long or returns default value if the conversion is not possible.\nSee LongConverter.ToLongWithDefault\n (c *StringValueMap) GetAsLongWithDefault(key string, defaultValue int64) int64\n  key: string - key of element to get. defaultValue: int64 - the default value returns: int64 - long value of the element or default value if the conversion is not supported.  GetAsMap Converts a map element into an AnyValueMap or returns an empty AnyValueMap if the conversion is not possible.\n (c *StringValueMap) GetAsMap(key string) *AnyValueMap\n  key: string - key of element to get. returns: *AnyValueMap - long value of the element or 0 if the conversion is not supported.  GetAsMapWithDefault Converts a map element into an AnyValueMap or returns a default value if the conversion is not possible.\n (c *StringValueMap) GetAsMapWithDefault(key string, defaultValue *AnyValueMap) *AnyValueMap\n  key: string - key of element to get. defaultValue: *AnyValueMap - default value returns: *AnyValueMap - AnyValueMap value of the element or default value if the conversion is not supported.  GetAsNullableArray Converts a map element into an AnyValueArray or returns nil if the conversion is not possible.\nSee AnyValueMap, AnyValueMap.NewAnyValueMapFromValue\n (c *StringValueMap) GetAsNullableArray(key string) *AnyValueArray\n  key: string - key of element to get. returns: *AnyValueArray - AnyValueMap value of the element or default value if the conversion is not supported.  GetAsNullableBoolean Converts a map element into a boolean or returns nil if the conversion is not possible.\nSee BooleanConverter.ToNullableBoolean\n (c *StringValueMap) GetAsNullableBoolean(key string) *bool\n  key: string - key of element to get. returns: *bool - boolean value of the element or nil if the conversion is not supported.  GetAsNullableDateTime Converts a map element into a Date or returns nil if the conversion is not possible.\nSee DateTimeConverter.ToNullableDateTime\n (c *StringValueMap) GetAsNullableDateTime(key string) *time.Time\n  key: string - key of element to get. returns: *time.Time - Date value of the element or nil if the conversion is not supported.  GetAsNullableDouble Converts a map element into a double or returns nil if the conversion is not possible.\nSee DoubleConverter.ToNullableDouble\n (c *StringValueMap) GetAsNullableDouble(key string) *float64\n  key: string - key of element to get. returns: number - double value of the element or nil if the conversion is not supported.  GetAsNullableDouble Converts a map element into a float or returns nil if the conversion is not possible.\nSee FloatConverter.ToNullableFloat\n (c *StringValueMap) GetAsNullableDouble(key string) *float64\n  key: string - key of element to get. returns: *float64 - float value of the element or nil if the conversion is not supported.  GetAsNullableInteger Converts a map element into an integer or returns nil if the conversion is not possible.\nSee IntegerConverter.ToNullableInteger\n (c *StringValueMap) GetAsNullableInteger(key string) *int\n  key: string - key of element to get. returns: *int - integer value of the element or nil if the conversion is not supported.  GetAsNullableLong Converts a map element into a long or returns nil if the conversion is not possible.\nSee LongConverter.ToNullableLong\n (c *StringValueMap) GetAsNullableLong(key string) *int64\n  key: string - key of element to get. returns: *int64 - long value of the element or nil if the conversion is not supported.  GetAsNullableMap Converts a map element into an AnyValueMap or returns nil if the conversion is not possible.\n (c *StringValueMap) GetAsNullableMap(key string) *AnyValueMap\n  key: string - key of element to get. returns: *AnyValueMap - AnyValueMap value of the element or nil if the conversion is not supported.  GetAsNullableString Converts a map element into a string or returns nil if the conversion is not possible.\nSee StringConverter.ToNullableString\n (c *StringValueMap) GetAsNullableString(key string) *string\n  key: string - key of element to get. returns: *string - string value of the element or nil if the conversion is not supported.  GetAsNullableType Converts a map element into a value defined by a specified typecode. If conversion is not possible it returns nil. See TypeConverter.ToNullableType\n (c *StringValueMap) GetAsNullableType(typ convert.TypeCode, key string) interface{}\n  typ: convert.TypeCode - TypeCode that defined the type of the result key: string - key of element to get. returns: interface{} - element value defined by the typecode or nil if the conversion is not supported.  GetAsObject Gets the value stored in a map element without any conversions. When element key is not defined it returns the entire map value.\n (c *StringValueMap) GetAsObject(key string) interface{}\n  key: string - (optional) key of the element to get returns: interface{} - element value or value of the map when index is not defined.  GetAsString Converts a map element into a string or returns \u0026quot;\u0026quot; if the conversion is not possible.\n (c *StringValueMap) GetAsString(key string) string\n  key: string - (optional) key of the element to get returns: string - string value of the element or \u0026quot;\u0026quot; if the conversion is not supported.  GetAsStringWithDefault Converts a map element into a string or returns \u0026quot;\u0026quot; if the conversion is not possible.\n (c *StringValueMap) GetAsStringWithDefault(key string, defaultValue string) string\n  key: string - key of element to get. defaultValue: string - default value returns: string - string value of the element or default value if the conversion is not supported.  GetAsType Converts a map element into a value defined by a specified typecode. If conversion is not possible it returns a default value for the specified type.\n (c *StringValueMap) GetAsType(typ convert.TypeCode, key string) interface{}\n  type: convert.TypeCode - TypeCode that defined the type of the result key: string - key of element to get. returns: interface{} - element value defined by the typecode or default if the conversion is not supported.  GetAsTypeWithDefault Converts a map element into a value defined by a specified typecode. If the conversion is not possible it returns a default value for the specified type.\nSee TypeConverter.ToTypeWithDefault\n (c *StringValueMap) GetAsTypeWithDefault(typ convert.TypeCode, key string, defaultValue interface{}) interface{}\n  type: convert.TypeCode - TypeCode that defined the type of the result key: string - key of element to get. defaultValue: interface{} - default value returns: interface{} - element value defined by the typecode or default value if the conversion is not supported.  GetAsValue Converts a map element into an AnyValue or returns an empty AnyValue if the conversion is not possible.\nSee AnyValue, AnyValue.constructors\n (c *StringValueMap) GetAsValue(key string) *AnyValue\n  key: string - key of element to get. returns: *AnyValue - AnyValue value of the element or empty AnyValue if the conversion is not supported.  Keys Gets keys of all elements stored in this map.\n (c *StringValueMap) Keys() []string\n  returns: string[] - list with all map keys.  Len Gets a number of elements stored in this map.\n (c *StringValueMap) Len() int\n  returns: int - number of elements in this map.  Put Puts a new value into a map element specified by its key.\n (c *StringValueMap) Put(key string, value interface{})\n  key: string - key of the element to put. value: interface{} - new value for map element.  Remove Removes a map element specified by its key\n (c *StringValueMap) Remove(key string)\n  key: string - key of the element to remove.  SetAsObject Sets a new value to a map element specified by its index. When the index is not defined, it resets the entire map value. This method has double purpose because method overrides are not supported in JavaScript.\nSee MapConverter.ToMap\n (c *StringValueMap) SetAsObject(key string, value interface{})\n  key: string - (optional) key of the element to set value: interface{} - new element or map value.  String Gets a string representation of the object. The result is a semicolon-separated list of key-value pairs as \u0026ldquo;key1=value1;key2=value2;key=value3\u0026rdquo;\n (c *StringValueMap) String() string\n  returns: string - string representation of the object.  Examples value1 := NewStringValueMapFromString(\u0026#34;key1=1;key2=123.456;key3=2018-01-01\u0026#34;); value1.GetAsBoolean(\u0026#34;key1\u0026#34;); // Result: true value1.GetAsInteger(\u0026#34;key2\u0026#34;); // Result: 123 value1.GetAsFloat(\u0026#34;key2\u0026#34;); // Result: 123.456 value1.GetAsDateTime(\u0026#34;key3\u0026#34;); // Result: new Date(2018,0,1) See also   StringConverter   TypeConverter   StringConverter   BooleanConverter   IntegerConverter   LongConverter   DoubleConverter   FloatConverter   DateTimeConverter   ICloneable   ","description":"Cross-language implementation of a map (dictionary) where all keys and values are strings.\n","image":null,"permalink":"/golang/commons/data/string_value_map/","subtitle":null,"tags":null,"title":"StringValueMap"},{"content":"Description The StringValueMap class allows you to create a cross-language implementation of a map (dictionary) where all keys and values are strings.\nImportant points\n The class provides several methods to convert the stored values to different types, such as array, bool or datetime. This class is widely used in Pip.Services as a basis for variety of classes, such as ConfigParams, ConnectionParams, CredentialParams (in the Pip.Services components package) and others.  Constructors Creates a new instance of the map and assigns its value.\n public StringValueMap(IDictionary\u0026lt;string, string\u0026gt; map)\n  map: IDictionary\u0026lt;string, string\u0026gt; - (optional) values to initialize this map.  Creates a new instance of the map and assigns its value.\n public StringValueMap(object map)\n  map: object - (optional) values to initialize this map.  Creates a new instance of the map and assigns its value.\n public StringValueMap()\n Instance methods Append Appends new elements to this map.\n public void Append(IDictionary\u0026lt;\\string, object\u0026gt; map)\n  map: IDictionary\u0026lt;\\string, object\u0026gt; - map with elements to be added.  Append Appends new elements to this map.\n public void Append(IDictionary\u0026lt;\\string, string\u0026gt; map)\n  map: IDictionary\u0026lt;\\string, string\u0026gt; - map with elements to be added.  Clone Creates a binary clone of this object.\n public object Clone()\n  returns: object - clone of this object.  Get Gets a map element specified by its key.\n public virtual string Get(string key)\n  key: string - key of the element to get. returns: string - value of the map element.  GetAsArray Converts a map element into an AnyValueArray or returns an empty AnyValueArray if the conversion is not possible.\nSee AnyValueArray, AnyValueArray.fromValue\n public AnyValueArray GetAsArray(string key)\n  key: string - key of the element to get. returns: AnyValueArray - AnyValueArray value of the element or an empty AnyValueArray if the conversion is not supported.  GetAsArrayWithDefault Converts a map element into an AnyValueArray or returns a given default value if the conversion is not possible.\nSee AnyValueArray\n public AnyValueArray GetAsArrayWithDefault(string key, AnyValueArray defaultValue)\n  key: string - key of the element to get. defaultValue: AnyValueArray - default value returns: AnyValueArray - AnyValueArray value of the element or given default value if the conversion is not supported.  GetAsBoolean Converts a map element into a bool or returns false if the conversion is not possible.\n public bool GetAsBoolean(string key)\n  key: string - key of the element to get. returns: bool - bool value of the element or false if the conversion is not supported.  GetAsBooleanWithDefault Converts a map element into a bool or returns a given default value if the conversion is not possible.\nSee BooleanConverter.ToBooleanWithDefault\n public bool GetAsBooleanWithDefault(string key, bool defaultValue)\n  key: string - key of element to get. defaultValue: bool - default value returns: bool - bool value of the element or given default value if the conversion is not supported.  GetAsDateTime Converts a map element into a DateTime or returns the current date if the conversion is not possible.\nSee BooleanConverter.toBooleanWithDefault\n public DateTime GetAsDateTime(string key)\n  key: string - key of element to get. returns: DateTime - DateTime value of the element or the current date if the conversion is not supported.  GetAsDateTimeWithDefault Converts a map element into a DateTime or returns a given default value if the conversion is not possible.\nSee DateTimeConverter.ToDateTimeWithDefault\n public DateTime GetAsDateTimeWithDefault(string key, DateTime defaultValue)\n  key: string - key of element to get. defaultValue: DateTime - default value returns: DateTime - DateTime value of the element or given default value if conversion is not supported.  GetAsNullableTimeSpan Converts a map element into a TimeSpan or returns null if the conversion is not possible.\n public TimeSpan GetAsNullableTimeSpan(string key)\n  key: string - key of the element to get returns: TimeSpan - TimeSpan of the element or null if the conversion is not possible.  GetAsTimeSpan Converts a map element into a TimeSpan.\n public TimeSpan GetAsTimeSpan(string key)\n  key: string - key of the element to get returns: TimeSpan - TimeSpan of the element  GetAsTimeSpanWithDefault Converts a map element into a TimeSpan or returns a given default value if the conversion is not possible.\n public TimeSpan GetAsTimeSpanWithDefault(string key, TimeSpan? defaultValue)\n  key: string - key of the element to get defaultValue: TimeSpan - default value returns: TimeSpan - Timespan of the element or given default value if the conversion is not possible.  GetAsNullableEnum Converts a map element into an Enum or returns null if the conversion is not possible.\n public T GetAsNullableEnum\u0026lt;T\u0026gt;(string key)\n  key: string - key of the element to get returns: T - Enum of the element or null if the conversion is not possible  GetAsEnum Converts a map element into an Enum.\n public T GetAsEnum\u0026lt;T\u0026gt;(string key)\n  key: string - key of the element to get returns: T - Enum of the element.  GetAsEnumWithDefault Converts a map element into an Enum or returns a given default value if the conversion is not possible.\n public T GetAsEnumWithDefault\u0026lt;T\u0026gt;(string key, T defaultValue)\n  key: string - key of the element to get defaultValue: T - default value returns: T - Enum or given default value if the conversion is not possible.  GetAsDouble Converts a map element into a double or returns 0 if the conversion is not possible.\n public double GetAsDouble(string key)\n  key: string - key of element to get. returns: double - double value of the element or 0 if the conversion is not supported.  GetAsDoubleWithDefault Converts a map element into a double or returns a given default value if conversion is not possible.\nSee DoubleConverter.ToDoubleWithDefault\n public double GetAsDoubleWithDefault(string key, double defaultValue)\n  key: string - key of element to get. defaultValue: double - default value returns: double - double value of the element or given default value if the conversion is not supported.  GetAsFloat Converts a map element into a float or returns 0 if the conversion is not possible.\n public float GetAsFloat(string key)\n  key: string - key of element to get. returns: float - float value of the element or 0 if theconversion is not supported.  GetAsFloatWithDefault Converts a map element into a flot or returns a given default value if the conversion is not possible.\nSee FloatConverter.ToFloatWithDefault\n public float GetAsFloatWithDefault(string key, float defaultValue)\n  key: string - key of element to get. defaultValue: float - default value returns: float - flot value of the element or given default value if conversion is not supported.  GetAsInteger Converts a map element into an integer or returns 0 if the conversion is not possible.\n public int GetAsInteger(string key)\n  key: string - key of element to get. returns: int - integer value of the element or 0 if the conversion is not supported.  GetAsIntegerWithDefault Converts a map element into an integer or returns a given default value if the conversion is not possible.\nSee IntegerConverter.ToIntegerWithDefault\n public int GetAsIntegerWithDefault(string key, int defaultValue)\n  key: string - key of element to get. defaultValue: int - default value returns: int - integer value of the element or given default value if the conversion is not supported.  GetAsLong Converts a map element into a long or returns 0 if the conversion is not possible.\n public long GetAsLong(long key)\n  key: string - key of element to get. returns: long - long value of the element or 0 if the conversion is not supported.  GetAsLongWithDefault Converts a map element into a long or returns a given default value if the conversion is not possible.\nSee LongConverter.ToLongWithDefault\n public long GetAsLongWithDefault(string key, long defaultValue)\n  key: string - key of element to get. defaultValue: long - default value returns: long - long value of the element or given default value if the conversion is not supported.  GetAsMap Converts a map element into an AnyValueMap or returns an empty AnyValueMap if the conversion is not possible.\n public AnyValueMap GetAsMap(string key)\n  key: string - a key of element to get. returns: AnyValueMap - long value of the element or an empty AnyValueMap if conversion is not supported.  GetAsMapWithDefault Converts a map element into an AnyValueMap or returns a given default value if the conversion is not possible.\n public AnyValueMap GetAsMapWithDefault(string key, AnyValueMap defaultValue)\n  key: string - key of element to get. defaultValue: AnyValueMap - default value returns: AnyValueMap - AnyValueMap value of the element or give default value if the conversion is not supported.  GetAsNullableArray Converts a map element into an AnyValueArray or returns null if the conversion is not possible.\nSee AnyValueMap, AnyValueMap.FromValue\n public AnyValueMap GetAsNullableArray(string key)\n  key: string - key of element to get. returns: AnyValueMap - AnyValueMap value of the element or null if the conversion is not supported.  GetAsNullableBoolean Converts a map element into a bool or returns null if the conversion is not possible.\nSee BooleanConverter.ToNullableBoolean\n public bool GetAsNullableBoolean(string key)\n  key: string - key of element to get. returns: bool - bool value of the element or null if the conversion is not supported.  GetAsNullableDateTime Converts a map element into a DateTime or returns null if conversion is not possible.\nSee DateTimeConverter.ToNullableDateTime\n public DateTime GetAsNullableDateTime(string key)\n  key: string - key of element to get. returns: DateTime - DateTime value of the element or null if the conversion is not supported.  GetAsNullableDouble Converts map element into a double or returns null if conversion is not possible.\nSee DoubleConverter.ToNullableDouble\n public double GetAsNullableDouble(string key)\n  key: string - key of element to get. returns: double - double value of the element or null if the conversion is not supported.  GetAsNullableFloat Converts a map element into a float or returns null if the conversion is not possible.\nSee FloatConverter.ToNullableFloat\n public float GetAsNullableFloat(string key)\n  key: string - key of element to get. returns: float - float value of the element or null if the conversion is not supported.  GetAsNullableInteger Converts a map element into an integer or returns null if the conversion is not possible.\nSee IntegerConverter.ToNullableInteger\n public int GetAsNullableInteger(string key)\n  key: string - key of element to get. returns: int - integer value of the element or null if the conversion is not supported.  GetAsNullableLong Converts a map element into a long or returns null if the conversion is not possible.\nSee LongConverter.ToNullableLong\n public long GetAsNullableLong(string key)\n  key: string - key of element to get. returns: long - long value of the element or null if the conversion is not supported.  GetAsNullableMap Converts map element into an AnyValueMap or returns null if conversion is not possible.\n public AnyValueMap GetAsNullableMap(string key)\n  key: string - key of element to get. returns: AnyValueMap - AnyValueMap value of the element or null if the conversion is not supported.  GetAsNullableString Converts a map element into a string or returns null if the conversion is not possible.\nSee StringConverter.ToNullableString\n public string GetAsNullableString(string key)\n  key: string - key of element to get. returns: string - string value of the element or null if the conversion is not supported.  GetAsNullableType Converts a map element into a value defined by a specified typecode. If conversion is not possible, it returns null. T - the class type.\nSee TypeConverter.ToNullableType\n public T GetAsNullableType\u0026lt;T\u0026gt;(string key)\n  key: string - key of element to get. returns: T - element value defined by the typecode or null if the conversion is not supported.  GetAsObject Gets the value stored in map element without any conversions. When element key is not defined, it returns the entire map.\n public object GetAsObject(string key)\n  key: string - (optional) key of the element to get returns: object - element value or entire map when the key is not defined.  GetAsObject Gets the value stored in this map element without any conversions\n public object GetAsObject()\n  returns: object - the element value or value of the map when key is not defined.  GetAsString Converts a map element into a string or returns \u0026quot;\u0026quot; if the conversion is not possible.\n public string GetAsString(string key)\n  key: string - (optional) key of the element to get returns: string - string value of the element or \u0026quot;\u0026quot; if the conversion is not supported.  GetAsStringWithDefault Converts a map element into a string or returns \u0026quot;\u0026quot; if the conversion is not possible.\n public string GetAsStringWithDefault(string key, string defaultValue)\n  key: string - key of element to get. defaultValue: string - default value returns: string - string value of the element or default value if the conversion is not supported.  GetAsType Converts a map element into a value defined by a specified typecode. If conversion is not possible, it returns the default value for the specified type. T - class type.\n public string GetAsType\u0026lt;T\u0026gt;(string key)\n  key: string - key of element to get. returns: T - element value defined by the typecode or default if the conversion is not supported.  GetAsTypeWithDefault Converts a map element into a value defined by a specified typecode. If conversion is not possible, it returns default value for the specified type.\nT - class type.\nSee TypeConverter.ToTypeWithDefault\n public T GetAsTypeWithDefault\u0026lt;T\u0026gt;(string key, T defaultValue)\n  key: string - key of element to get. defaultValue: T - default value returns: T - element value defined by the typecode or default value if the conversion is not supported.  GetAsValue Converts a map element into an AnyValue or returns an empty AnyValue if the conversion is not possible.\nSee AnyValue, AnyValue.constructors\n public AnyValue GetAsValue(string key)\n  key: string - key of element to get. returns: AnyValue - AnyValue value of the element or empty AnyValue if the conversion is not supported.  Set Sets a new value into a map element specified by its key.\n public virtual void Set(string key, string value)\n  key: string - key of the element to put. value: string - new value for the map element.  SetAsObject Sets a new value to a map element specified by its index. When the index is not defined, it resets the entire map value. See MapConverter.ToMap\n public void SetAsObject(string key, object value)\n  key: string - (optional) key of the element to set value: object - new element or map value.  SetAsObject Sets a new value for this array element\n public void SetAsObject(object value)\n  value: object - new element or map value.  ToString Gets a string representation of the object. The result is a semicolon-separated list of key-value pairs as \u0026ldquo;key1=value1;key2=value2;key=value3\u0026rdquo;\n public override string ToString()\n  returns: string - string representation of the object.  Static methods FromMaps Creates a new AnyValueMap by merging two or more maps. Maps defined later in the list override values from previously defined maps.\n public static StringValueMap FromMaps(params IDictionary\u0026lt;string, string\u0026gt;[] maps)\n  maps: IDictionary\u0026lt;string, string\u0026gt;[] - array of maps to be merged returns: StringValueMap - newly created StringValueMap.  FromString Parses semicolon-separated key-value pairs and returns them as a StringValueMap.\n public static StringValueMap FromString(string line)\n  line: string - semicolon-separated key-value list to initialize StringValueMap. returns: StringValueMap - newly created StringValueMap.  FromTuples Creates a new StringValueMap from a list of key-value pairs called tuples.\n public static StringValueMap FromTuples(object[] tuples)\n  tuples: object[] - list of values where odd elements are keys and the following even elements are values returns: StringValueMap - newly created StringValueMap.  FromTuplesArray! Note: this method is not available for this language\nCreates a new StringValueMap from a list of key-value pairs called tuples. The method is similar to FromTuples but tuples are passed as an array instead of parameters.\n public static StringValueMap FromTuplesArray(params object[] tuples)\n  tuples: object[] - list of values where odd elements are keys and the following even elements are values returns: StringValueMap - newly created StringValueMap.  FromValue! Note: this method is not available for this language\nConverts a specified value into StringValueMap.\n public static StringValueMap FromValue(object value)\n  value: object - value to be converted returns: StringValueMap - newly created StringValueMap.  Examples var value1 = StringValueMap.FromString(\u0026#34;key1=1;key2=123.456;key3=2018-01-01\u0026#34;); value1.GetAsBoolean(\u0026#34;key1\u0026#34;); // Result: true value1.GetAsInteger(\u0026#34;key2\u0026#34;); // Result: 123 value1.GetAsFloat(\u0026#34;key2\u0026#34;); // Result: 123.456 value1.GetAsDateTime(\u0026#34;key3\u0026#34;); // Result: new DateTime(2018,0,1)  See also   StringConverter   TypeConverter   StringConverter   BooleanConverter   IntegerConverter   LongConverter   DoubleConverter   FloatConverter   DateTimeConverter   ICloneable   ","description":"Cross-language implementation of a map (dictionary) where all keys and values are strings.\n","image":null,"permalink":"/net/commons/data/string_value_map/","subtitle":null,"tags":null,"title":"StringValueMap"},{"content":"Description The StringValueMap class allows you to create a cross-language implementation of a map (dictionary) where all keys and values are strings.\nImportant points\n The class provides several methods to convert the stored values to different types, such as array, boolean or datetime. This class is widely used in Pip.Services as a basis for variety of classes, such as ConfigParams, ConnectionParams, CredentialParams (in the Pip.Services components package) and others.  Constructors Creates a new instance of the map and assigns its value.\n public constructor(map: any = null)\n  map: any - (optional) values to initialize this map.  Instance methods append Appends new elements to this map.\n public append(map: any): void\n  map: any - map with elements to be added.  clear Clears this map by removing all its elements.\n public clear(): void\n clone Creates a binary clone of this object.\n public clone(): any\n  returns: any - clone of this object.  get Gets a map element specified by its key.\n public get(key: string): string\n  key: string - key of the element to get. returns: string - value of the map element.  getAsArray Converts a map\u0026rsquo;s element into an AnyValueArray object or returns an empty AnyValueArray object if the conversion is not possible.\nSee AnyValueArray, AnyValueArray.fromValue\n public getAsArray(key: string): AnyValueArray\n  key: string -key of element to get. returns: AnyValueArray - AnyValueArray value of the element or empty AnyValueArray if the conversion is not supported.  getAsArrayWithDefault Converts a map\u0026rsquo;s element into an AnyValueArray object or returns a given default value if the conversion is not possible.\nSee AnyValueArray\n public getAsArrayWithDefault(key: string, defaultValue: AnyValueArray): AnyValueArray\n  key: string - key of the element to get. defaultValue: AnyValueArray - default value returns: AnyValueArray - AnyValueArray value of the element or given default value if the conversion is not supported.  getAsBoolean Converts a map\u0026rsquo;s element into a boolean or returns false if the conversion is not possible.\n public getAsBoolean(key: string): boolean\n  key: string - key of the element to get. returns: boolean - boolean value of the element or false if the conversion is not supported.  getAsBooleanWithDefault Converts a map\u0026rsquo;s element into a boolean or returns a given default value if the conversion is not possible.\nSee BooleanConverter.toBooleanWithDefault\n public getAsBooleanWithDefault(key: string, defaultValue: boolean): boolean\n  key: string - key of element to get. defaultValue: boolean - default value returns: boolean - boolean value of the element or given default value if the conversion is not supported.  getAsDateTime Converts a map\u0026rsquo;s element into a Date or returns the current date if the conversion is not possible.\nSee BooleanConverter.toBooleanWithDefault\n public getAsDateTime(key: string): Date\n  key: string - key of element to get. returns: Date - Date value of the element or the current date if the conversion is not supported.  getAsDateTimeWithDefault Converts a map\u0026rsquo;s element into a Date or returns a given default value if the conversion is not possible.\nSee DateTimeConverter.toDateTimeWithDefault\n public getAsDateTimeWithDefault(key: string, defaultValue: Date): Date\n  key: string - key of the element to get. defaultValue: Date - default value returns: Date - Date value of the element or given default value if the conversion is not supported.  getAsDouble Converts a map\u0026rsquo;s element into a double or returns 0 if the conversion is not possible.\n public getAsDouble(key: string): number\n  key: string - key of the element to get. returns: number - double value of the element or 0 if the conversion is not supported.  getAsDoubleWithDefault Converts a map\u0026rsquo;s element into a double or returns a given default value if the conversion is not possible.\nSee DoubleConverter.toDoubleWithDefault\n public getAsDoubleWithDefault(key: string, defaultValue: number): number\n  key: string - key of the element to get. defaultValue: number - default value returns: number - double value of the element or given default value if the conversion is not supported.  getAsFloat Converts a map\u0026rsquo;s element into a float or returns 0 if the conversion is not possible.\n public getAsFloat(key: string): number\n  key: string - key the of element to get. returns: number - float value of the element or 0 if the conversion is not supported.  getAsFloatWithDefault Converts a map\u0026rsquo;s element into a float or returns a given default value if the conversion is not possible.\nSee FloatConverter.toFloatWithDefault\n public getAsFloatWithDefault(key: string, defaultValue: number): number\n  key: string - key of the element to get. defaultValue: number - default value returns: number - float value of the element or given default value if the conversion is not supported.  getAsInteger Converts a map\u0026rsquo;s element into an integer or returns 0 if the conversion is not possible.\n public getAsInteger(key: string): number\n  key: string - key of the element to get. returns: number - integer value of the element or 0 if the conversion is not supported.  getAsIntegerWithDefault Converts a map\u0026rsquo;s element into an integer or returns a given default value if the conversion is not possible.\nSee IntegerConverter.toIntegerWithDefault\n public getAsIntegerWithDefault(key: string, defaultValue: number): number\n  key: string - key of the element to get. defaultValue: number - default value returns: number - integer value of the element or given default value if the conversion is not supported.  getAsLong Converts a map\u0026rsquo;s element into a long or returns 0 if the conversion is not possible.\n public getAsLong(key: string): number\n  key: string - key of the element to get. returns: number - long value of the element or 0 if the conversion is not supported.  getAsLongWithDefault Converts a map\u0026rsquo;s element into a long or returns a given default value if the conversion is not possible.\nSee LongConverter.toLongWithDefault\n public getAsLongWithDefault(key: string, defaultValue: number): number\n  key: string - key of the element to get. defaultValue: number - default value returns: number - long value of the element or default value if the conversion is not supported.  getAsMap Converts a map\u0026rsquo;s element into an AnyValueMap object or returns an empty AnyValueMap object if the conversion is not possible.\n public getAsMap(key: string): AnyValueMap\n  key: string - key of the element to get. returns: AnyValueMap - long value of the element or 0 if the conversion is not supported.  getAsMapWithDefault Converts a map\u0026rsquo;s element into an AnyValueMap object or returns a given default value if the conversion is not possible.\n public getAsMapWithDefault(key: string, defaultValue: AnyValueMap): AnyValueMap\n  key: string - key of the element to get. defaultValue: AnyValueMap - default value returns: AnyValueMap - AnyValueMap value of the element or given default value if the conversion is not supported.  getAsNullableArray Converts a map\u0026rsquo;s element into an AnyValueArray or returns null if the conversion is not possible.\nSee AnyValueMap, AnyValueMap.fromValue\n public getAsNullableArray(key: string): AnyValueMap\n  key: string - key of the element to get. returns: AnyValueMap - AnyValueMap value of the element or given default value if the conversion is not supported.  getAsNullableBoolean Converts a map\u0026rsquo;s element into a boolean or returns null if the conversion is not possible.\nSee BooleanConverter.toNullableBoolean\n public getAsNullableBoolean(key: string): boolean\n  key: string - key of the element to get. returns: boolean - boolean value of the element or null if the conversion is not supported.  getAsNullableDateTime Converts a map\u0026rsquo;s element into a Date or returns null if the conversion is not possible.\nSee DateTimeConverter.toNullableDateTime\n public getAsNullableDateTime(key: string): Date\n  key: string - key of the element to get. returns: Date - Date value of the element or null if the conversion is not supported.  getAsNullableDouble Converts a map\u0026rsquo;s element into a double or returns null if the conversion is not possible.\nSee DoubleConverter.toNullableDouble\n public getAsNullableDouble(key: string): number\n  key: string - key of the element to get. returns: number - double value of the element or null if the conversion is not supported.  getAsNullableFloat Converts a map\u0026rsquo;s element into a float or returns null if the conversion is not possible.\nSee FloatConverter.toNullableFloat\n public getAsNullableFloat(key: string): number\n  key: string - key of the element to get. returns: number - float value of the element or null if the conversion is not supported.  getAsNullableInteger Converts a map\u0026rsquo;s element into an integer or returns null if the conversion is not possible.\nSee IntegerConverter.toNullableInteger\n public getAsNullableInteger(key: string): number\n  key: string - key of the element to get. returns: number - integer value of the element or null if the conversion is not supported.  getAsNullableLong Converts a map\u0026rsquo;s element into a long or returns null if the conversion is not possible.\nSee LongConverter.toNullableLong\n public getAsNullableLong(key: string): number\n  key: string - key of the element to get. returns: number - long value of the element or null if the conversion is not supported.  getAsNullableMap Converts a map\u0026rsquo;s element into an AnyValueMap object or returns null if the conversion is not possible.\n public getAsNullableMap(key: string): AnyValueMap\n  key: string - key of the element to get. returns: AnyValueMap - AnyValueMap value of the element or null if the conversion is not supported.  getAsNullableString Converts a map\u0026rsquo;s element into a string or returns null if the conversion is not possible.\nSee StringConverter.toNullableString\n public getAsNullableString(key: string): string\n  key: string - key of the element to get. returns: string - string value of the element or null if the conversion is not supported.  getAsNullableType Converts a map\u0026rsquo;s element into a value defined by a specified typecode. If conversion is not possible, it returns null. See TypeConverter.toNullableType\n public getAsNullableType\u0026lt;T\u0026gt;(type: TypeCode, key: string): T\n  type: TypeCode - TypeCode that defines the type of the result. key: string - key of the element to get. returns: T - element value defined by the typecode or null if the conversion is not supported.  getAsObject Gets the value stored in map element without any conversions. When the element\u0026rsquo;s key is not defined, it returns the entire map value.\n public getAsObject(key: string = undefined): any\n  key: string - (optional) key of the element to get. returns: any - element value or value of the map when the index is not defined.  getAsString Converts map\u0026rsquo;s element into a string or returns \u0026quot;\u0026quot; if the conversion is not possible.\n public getAsString(key: string): string\n  key: string - (optional) key of the element to get. returns: string - string value of the element or \u0026quot;\u0026quot; if the conversion is not supported.  getAsStringWithDefault Converts map\u0026rsquo;s element into a string or returns \u0026quot;\u0026quot; if the conversion is not possible.\n public getAsStringWithDefault(key: string, defaultValue: string): string\n  key: string - key of the element to get. defaultValue: string - default value returns: string - string value of the element or default value if the conversion is not supported.  getAsType Converts a map\u0026rsquo;s element into a value defined by a specified typecode. If conversion is not possible it returns the default value for the specified type.\n public getAsType\u0026lt;T\u0026gt;(type: TypeCode, key: string): T\n  type: TypeCode - TypeCode that defines the type of the result. key: string - key of the element to get. returns: T - element value defined by the typecode or default if the conversion is not supported.  getAsTypeWithDefault Converts a map\u0026rsquo;s element into a value defined by a specified typecode. If the conversion is not possible, it returns the default value for the specified type.\nSee TypeConverter.toTypeWithDefault\n public getAsTypeWithDefault\u0026lt;T\u0026gt;(type: TypeCode, key: string, defaultValue: T): T\n  type: TypeCode - TypeCode that defines the type of the result key: string - key of the element to get. defaultValue: T - default value returns: T - element\u0026rsquo;s value defined by the typecode or default value if the conversion is not supported.  getAsValue Converts a map\u0026rsquo;s element into an AnyValue or returns an empty AnyValue if the conversion is not possible.\nSee AnyValue, AnyValue.constructors\n public getAsValue(key: string): AnyValue\n  key: string - key of the element to get. returns: AnyValue - AnyValue value of the element or an empty AnyValue object if the conversion is not supported.  getKeys Gets keys of all elements stored in this map.\n public getKeys(): string[]\n  returns: string[] - list with all map keys.  length Gets the number of elements stored in this map.\n public length(): number\n  returns: number - number of elements in this map.  put Puts a new value into a map\u0026rsquo;s element specified by its key.\n public put(key: string, value: any): void\n  key: string - key of the element to put. value: any - new value for the map\u0026rsquo;s element.  remove Removes a map\u0026rsquo;s element specified by its key.\n public remove(key: string): void\n  key: string - key of the element to remove.  setAsObject Sets a new value to a map\u0026rsquo;s element specified by its index. When the index is not defined, it resets the entire map value. This method has double purpose, because method overrides are not supported in JavaScript.\nSee MapConverter.toMap\n public setAsObject(key: any, value: any = undefined): void\n  key: string - (optional) key of the element to set value: any - new element or map value.  toString Gets a string representation of the object. The result is a semicolon-separated list of key-value pairs as \u0026ldquo;key1=value1;key2=value2;key=value3\u0026rdquo;\n public toString(): string\n  returns: string - string representation of the object.  Static methods fromMaps Creates a new AnyValueMap by merging two or more maps. Maps defined later in the list override values from previously defined maps.\n public static fromMaps(\u0026hellip;maps: any[]): StringValueMap\n  maps: any[] - array of maps to be merged returns: StringValueMap - newly created StringValueMap.  fromString Parses semicolon-separated key-value pairs and returns them as a StringValueMap.\n public static fromString(line: string): StringValueMap\n  line: string - semicolon-separated key-value list to initialize StringValueMap. returns: StringValueMap - newly created StringValueMap.  fromTuples Creates a new StringValueMap object from a list of key-value pairs called tuples.\n public static fromTuples(\u0026hellip;tuples: any[]): StringValueMap\n  tuples: any[] - list of values where odd elements are keys and the following even elements are values. returns: StringValueMap - newly created StringValueMap.  fromTuplesArray Creates a new StringValueMap object from a list of key-value pairs called tuples. The method is similar to fromTuples but tuples are passed as array instead of parameters.\n public static fromTuplesArray(tuples: any[]): StringValueMap\n  tuples: any[] - list of values where odd elements are keys and the following even elements are values. returns: StringValueMap - newly created StringValueMap.  fromValue Converts a specified value into StringValueMap.\n public static fromValue(value: any): StringValueMap\n  value: any - value to be converted returns: StringValueMap - newly created StringValueMap.  Examples let value1 = StringValueMap.fromString(\u0026#34;key1=1;key2=123.456;key3=2018-01-01\u0026#34;); value1.getAsBoolean(\u0026#34;key1\u0026#34;); // Result: true value1.getAsInteger(\u0026#34;key2\u0026#34;); // Result: 123 value1.getAsFloat(\u0026#34;key2\u0026#34;); // Result: 123.456 value1.getAsDateTime(\u0026#34;key3\u0026#34;); // Result: new Date(2018,0,1)  See also   StringConverter   TypeConverter   StringConverter   BooleanConverter   IntegerConverter   LongConverter   DoubleConverter   FloatConverter   DateTimeConverter   ICloneable   ","description":"Cross-language implementation of a map (dictionary) where all keys and values are strings.\n","image":null,"permalink":"/node/commons/data/string_value_map/","subtitle":null,"tags":null,"title":"StringValueMap"},{"content":"Description The StringValueMap class allows you to create a cross-language implementation of a map (dictionary) where all keys and values are strings.\nImportant points\n The class provides several methods to convert the stored values to different types, such as array, boolean or datetime. This class is widely used in Pip.Services as a basis for variety of classes, such as ConfigParams, ConnectionParams, CredentialParams (in the Pip.Services components package) and others.  Constructors Creates a new instance of the map and assigns its value.\n StringValueMap(map: Any = None)\n  map: Any - (optional) values to initialize this map.  Instance methods append Appends new elements to this map.\n append(map: Any)\n  map: Any - a map with elements to be added.  clear Clears this map by removing all its elements.\n clear()\n clone Creates a binary clone of this object.\n clone(): Any\n  returns: Any - a clone of this object.  get Gets a map element specified by its key.\n get(key: str): str\n  key: str - a key of the element to get. returns: str - the value of the map element.  get_as_array Converts map element into an AnyValueArray or returns empty AnyValueArray if conversion is not possible.\nSee AnyValueArray, AnyValueArray.from_value\n get_as_array(key: str): AnyValueArray\n  key: get_as_array - a key of element to get. returns: AnyValueArray - AnyValueArray value of the element or empty AnyValueArray if conversion is not supported.  get_as_array_with_default Converts map element into an AnyValueArray or returns default value if conversion is not possible.\nSee AnyValueArray\n get_as_array_with_default(key: str, default_value: AnyValueArray): AnyValueArray\n  key: str - a key of element to get. default_value: AnyValueArray - the default value returns: AnyValueArray - AnyValueArray value of the element or default value if conversion is not supported.  get_as_boolean Converts map element into a boolean or returns false if conversion is not possible.\n get_as_boolean(key: str): bool\n  key: str - a key of element to get. returns: bool - boolean value of the element or false if conversion is not supported.  get_as_boolean_with_default Converts map element into a boolean or returns default value if conversion is not possible.\nSee BooleanConverter.to_boolean_with_default.\n get_as_boolean_with_default(key: str, default_value: bool): bool\n  key: str - a key of element to get. default_value: bool - the default value returns: bool - boolean value of the element or default value if conversion is not supported.  get_as_datetime Converts map element into a Date or returns the current date if conversion is not possible.\nSee BooleanConverter.to_boolean_with_default.\n get_as_datetime(key: str): datetime\n  key: str - a key of element to get. returns: datetime - date value of the element or the current date if conversion is not supported.  get_as_datetime_with_default Converts map element into a Date or returns default value if conversion is not possible.\nSee DateTimeConverter.to_datetime_with_default.\n get_as_datetime_with_default(key: str, default_value: datetime): datetime\n  key: str - a key of element to get. default_value: datetime - the default value returns: datetime - Date value of the element or default value if conversion is not supported.  get_as_double Converts map element into a double or returns 0 if conversion is not possible.\n get_as_double(key: str): float\n  key: str - a key of element to get. returns: float - double value of the element or 0 if conversion is not supported.  get_as_double_with_default Converts map element into a double or returns default value if conversion is not possible.\nSee DoubleConverter.toDoubleWithDefault.\n get_as_double_with_default(key: str, default_value: float): float\n  key: str - a key of element to get. default_value: float - the default value returns: float - double value of the element or default value if conversion is not supported.  get_as_double Converts map element into a float or returns 0 if conversion is not possible.\n get_as_double(key: str): float\n  key: str - a key of element to get. returns: float - float value of the element or 0 if conversion is not supported.  get_as_float_with_default Converts map element into a float or returns default value if conversion is not possible.\nSee FloatConverter.to_float_with_default\n get_as_float_with_default(key: str, default_value: float): float\n  key: str - a key of element to get. default_value: float - the default value returns: float - flot value of the element or default value if conversion is not supported.  get_as_integer Converts map element into an integer or returns 0 if conversion is not possible.\n get_as_integer(key: str): int\n  key: str - a key of element to get. returns: int - integer value of the element or 0 if conversion is not supported.  get_as_integer_with_default Converts map element into an integer or returns default value if conversion is not possible.\nSee IntegerConverter.to_integer_with_default\n get_as_integer_with_default(key: str, default_value: int): int\n  key: str - a key of element to get. default_value: int - the default value returns: int - integer value of the element or default value if conversion is not supported.  get_as_long Converts map element into a long or returns 0 if conversion is not possible.\n get_as_long(key: str): float\n  key: str - a key of element to get. returns: float - long value of the element or 0 if conversion is not supported.  get_as_long_with_default Converts map element into a long or returns default value if conversion is not possible.\nSee LongConverter.to_long_with_default.\n get_as_long_with_default(key: str, default_value: float): float\n  key: str - a key of element to get. default_value: float - the default value returns: float - long value of the element or default value if conversion is not supported.  get_as_map Converts map element into an AnyValueMap or returns empty AnyValueMap if conversion is not possible.\n get_as_map(key: str): AnyValueMap\n  key: str - a key of element to get. returns: AnyValueMap - long value of the element or 0 if conversion is not supported.  get_as_map_with_default Converts map element into an AnyValueMap or returns default value if conversion is not possible.\n get_as_map_with_default(key: str, default_value: AnyValueMap): AnyValueMap\n  key: str - a key of element to get. default_value: AnyValueMap - the default value returns: AnyValueMap - AnyValueMap value of the element or default value if conversion is not supported.  get_as_nullable_array Converts map element into an AnyValueArray or returns None if conversion is not possible.\nSee AnyValueMap, AnyValueMap.from_value.\n get_as_nullable_array(key: str): Optional[AnyValueMap]\n  key: str - a key of element to get. returns: Optional[AnyValueMap] - AnyValueMap value of the element or default value if conversion is not supported.  get_as_nullable_boolean Converts map element into a boolean or returns None if conversion is not possible.\nSee BooleanConverter.to_nullable_boolean.\n get_as_nullable_boolean(key: str): Optional[bool]\n  key: str - a key of element to get. returns: Optional[bool] - boolean value of the element or None if conversion is not supported.  get_as_nullable_datetime Converts map element into a Date or returns None if conversion is not possible.\nSee DateTimeConverter.to_nullable_datetime.\n get_as_nullable_datetime(key: str): Optional[datetime]\n  key: str - a key of element to get. returns: Optional[datetime] - Date value of the element or None if conversion is not supported.  get_as_nullable_double Converts map element into a double or returns None if conversion is not possible.\nSee DoubleConverter.to_nullable_double.\n get_as_nullable_double(key: str): Optional[float]\n  key: str - key of the element to get. returns: Optional[float] - double value of the element or None if conversion is not supported.  get_as_nullable_float Converts map element into a float or returns None if conversion is not possible.\nSee FloatConverter.to_nullable_float.\n get_as_nullable_float(key: str): Optional[float]\n  key: str - a key of element to get. returns: Optional[float] - float value of the element or None if conversion is not supported.  get_as_nullable_integer Converts map element into an integer or returns None if conversion is not possible.\nSee IntegerConverter.to_nullable_integer.\n get_as_nullable_integer(key: str): Optional[int]\n  key: str - a key of element to get. returns: Optional[int] - integer value of the element or None if conversion is not supported.  get_as_nullable_long Converts map element into a long or returns None if conversion is not possible.\nSee LongConverter.to_nullable_long.\n get_as_nullable_long(key: str): Optional[float]\n  key: str - a key of element to get. returns: Optional[float] - long value of the element or None if conversion is not supported.  get_as_nullable_map Converts map element into an AnyValueMap or returns None if conversion is not possible.\n get_as_nullable_map(key: str): Optional[AnyValueMap]\n  key: str - a key of element to get. returns: Optional[AnyValueMap] - AnyValueMap value of the element or None if conversion is not supported.  get_as_nullable_string Converts map element into a string or returns None if conversion is not possible.\nSee StringConverter.to_nullable_string.\n get_as_nullable_string(key: str): Optional[str]\n  key: str - a key of element to get. returns: str - string value of the element or None if conversion is not supported.  get_as_nullable_type Converts map element into a value defined by specied typecode. If conversion is not possible it returns None. See TypeConverter.to_nullable_type.\n get_as_nullable_type(value_type: TypeCode, key: str): Optional[Any]\n  value_type: TypeCode - the TypeCode that defined the type of the result key: str - a key of element to get. returns: Optional[Any] - element value defined by the typecode or None if conversion is not supported.  get_as_object Gets the value stored in map element without any conversions. When element key is not defined it returns the entire map value.\n get_as_object(key: str = None): Any\n  key: str - (optional) a key of the element to get returns: Any - the element value or value of the map when index is not defined.  get_as_string Converts map element into a string or returns \u0026quot;\u0026quot; if conversion is not possible.\n get_as_string(key: str): str\n  key: str - (optional) a key of the element to get returns: str - string value of the element or \u0026quot;\u0026quot; if conversion is not supported.  get_as_string_with_default Converts map element into a string or returns \u0026quot;\u0026quot; if conversion is not possible.\n get_as_string_with_default(key: str, default_value: str): str\n  key: str - a key of element to get. default_value: str - the default value returns: str - string value of the element or default value if conversion is not supported.  get_as_type Converts map element into a value defined by a specied typecode. If conversion is not possible it returns default value for the specified type.\n get_as_type(value_type: TypeCode, key: str): Any\n  value_type: TypeCode - the TypeCode that defined the type of the result key: str - a key of element to get. returns: Any - element value defined by the typecode or default if conversion is not supported.  get_as_type_with_default Converts map element into a value defined by a specified typecode. If conversion is not possible it returns default value for the specified type.\nSee TypeConverter.to_type_with_default.\n get_as_type_with_default(value_type: TypeCode, key: str, default_value: Any): Any\n  value_type: TypeCode - the TypeCode that defines the type of the result key: str - a key of element to get. default_value: Any - the default value returns: Any - element value defined by the typecode or default value if conversion is not supported.  get_as_value Converts map element into an AnyValue or returns an empty AnyValue if conversion is not possible.\nSee AnyValue, AnyValue.constructors.\n get_as_value(key: str): AnyValue\n  key: str - a key of element to get. returns: AnyValue - AnyValue value of the element or empty AnyValue if conversion is not supported.  get_keys Gets keys of all elements stored in this map.\n get_keys(): List[str]\n  returns: List[str] - a list with all map keys.  length Gets a number of elements stored in this map.\n length(): int\n  returns: int - the number of elements in this map.  put Puts a new value into map element specified by its key.\n put(key: str, value: Any): Any\n  key: str - a key of the element to put. value: Any - a new value for map element.  remove Removes a map element specified by its key\n remove(key: str)\n  key: str - a key of the element to remove.  set_as_object Sets a new value to map element specified by its index. When the index is not defined, it resets the entire map value. See MapConverter.to_map\n set_as_object(key: Any, value: Any = None)\n  key: str - (optional) a key of the element to set value: Any - a new element or map value.  to_string Gets a string representation of the object. The result is a semicolon-separated list of key-value pairs as \u0026ldquo;key1=value1;key2=value2;key=value3\u0026rdquo;\n to_string(): str\n  returns: str - a string representation of the object.  Static methods from_maps Creates a new AnyValueMap by merging two or more maps. Maps defined later in the list override values from previously defined maps.\n static from_maps(*maps: dict): StringValueMap\n  maps: dict - an array of maps to be merged returns: StringValueMap - a newly created StringValueMap.  from_string Parses semicolon-separated key-value pairs and returns them as a StringValueMap.\n static from_string(line: str): StringValueMap\n  line: str - semicolon-separated key-value list to initialize StringValueMap. returns: StringValueMap - a newly created StringValueMap.  from_tuples Creates a new StringValueMap from a list of key-value pairs called tuples.\n static from_tuples(*tuples: Any): StringValueMap\n  tuples: Any - a list of values where odd elements are keys and the following even elements are values returns: StringValueMap - a newly created StringValueMap.  from_tuples_array Creates a new StringValueMap from a list of key-value pairs called tuples. The method is similar to from_tuples but tuples are passed as array instead of parameters.\n static from_tuples_array(tuples: Sequence[Any]): StringValueMap\n  tuples: Sequence[Any] - a list of values where odd elements are keys and the following even elements are values returns: StringValueMap - a newly created StringValueMap.  from_value Converts specified value into StringValueMap.\n static from_value(value: Any): StringValueMap\n  value: Any - value to be converted returns: StringValueMap - a newly created StringValueMap.  Examples value1 = StringValueMap.fromString(\u0026#34;key1=1;key2=123.456;key3=2018-01-01\u0026#34;) value1.get_as_boolean(\u0026#34;key1\u0026#34;) // Result: true value1.get_as_integer(\u0026#34;key2\u0026#34;) // Result: 123 value1.get_as_float(\u0026#34;key2\u0026#34;) // Result: 123.456 value1.get_as_datetime(\u0026#34;key3\u0026#34;) // Result: Date 2018,0,1 See also   StringConverter   TypeConverter   StringConverter   BooleanConverter   IntegerConverter   LongConverter   DoubleConverter   FloatConverter   DateTimeConverter   ICloneable   ","description":"Cross-language implementation of a map (dictionary) where all keys and values are strings.\n","image":null,"permalink":"/python/commons/data/string_value_map/","subtitle":null,"tags":null,"title":"StringValueMap"},{"content":"Implements: RestService\nDescription The SwaggerService class allows you to create a Swagger UI service.\nConstructors NewSwaggerService Creates a new instance of the Swagger service.\n NewSwaggerService() *SwaggerService\n Instance methods register Registers the Swagger service.\n (c *SwaggerService) Register()\n RegisterOpenApiSpec Performs the required Swagger registration steps.\n (c *SwaggerService) RegisterOpenApiSpec(baseRoute string, swaggerRoute string)\n  baseRoute: string - base route swaggerRoute: string - Swagger route  ","description":"Swagger UI service.\n","image":null,"permalink":"/golang/swagger/services/swagger_service/","subtitle":null,"tags":null,"title":"SwaggerService"},{"content":"Inherits: ISwaggerService, IConfigurable, IReferenceable, IInitializable\nDescription The SwaggerService class allows you to create a Swagger UI service.\nFields _endpoint The HTTP endpoint that exposes this service.\n protected _endpoint: HttpEndpoint\n _dependencyResolver The dependency resolver.\n protected _dependencyResolver: DependencyResolver\n _routes Routes with swagger doc\n protected _routes: Dictionary\u0026lt;string, string\u0026gt;\n  Instance methods Configure Configures a component by its passing configuration parameters.\n public virtual void Configure(ConfigParams config)\n  config: ConfigParams - configuration parameters to be set.  Initialize TODO: add description\n public void Initialize(IApplicationBuilder applicationBuilder)\n  applicationBuilder: IApplicationBuilder - TODO: add description  RegisterOpenApiSpec Performs the required Swagger registration steps.\n public void RegisterOpenApiSpec(string baseRoute, string swaggerRoute)\n  baseRoute: string - base route swaggerRoute: string - Swagger route  SetReferences Sets references to dependent components.\n public virtual void SetReferences(IReferences references)\n  references: IReferences - references to locate the component dependencies.  ","description":"Swagger UI service.\n","image":null,"permalink":"/net/swagger/services/swagger_service/","subtitle":null,"tags":null,"title":"SwaggerService"},{"content":"Implements: ISwaggerService\nExtends: RestService\nDescription The SwaggerService class allows you to create a Swagger UI service.\nInstance methods register Registers the Swagger service.\n public register()\n registerOpenApiSpec Performs the required Swagger registration steps.\n public registerOpenApiSpec(baseRoute: string, swaggerRoute?: string): void\n  baseRoute: string - base route swaggerRoute: string - Swagger route  ","description":"Swagger UI service.\n","image":null,"permalink":"/node/swagger/services/swagger_service/","subtitle":null,"tags":null,"title":"SwaggerService"},{"content":"Implements: RestService, ISwaggerService\nDescription The SwaggerService class allows you to create a Swagger UI service.\nInstance methods register Registers the Swagger service.\n register()\n register_open_api_spec Performs the required Swagger registration steps.\n register_open_api_spec(base_route: str, swagger_route: str = None)\n  base_route: str - base route swagger_route: str - Swagger route  ","description":"Swagger UI service.\n","image":null,"permalink":"/python/swagger/services/swagger_service/","subtitle":null,"tags":null,"title":"SwaggerService"},{"content":"Description The SymbolNode class allows you to construct a SymbolNode.\nImportant points\n A SymbolNode object is a member of a tree that contains all possible prefixes of allowable symbols. Multi-character symbols appear in a SymbolNode tree with one node for each character. For example, the symbol =:~ will appear in a tree as three nodes. The first node contains an equals sign, and has a child; that child contains a colon and has a child; this third child contains a tilde, and has no children of its own. If the colon node had another child for a dollar sign character, then the tree would contain the symbol =:$. A tree of SymbolNode objects collaborate to read a (potentially multi-character) symbol from an input stream. A root node with no character of its own finds an initial node that represents the first character in the input. This node looks to see if the next character in the stream matches one of its children. If so, the node delegates its reading task to its child. This approach walks down the tree, pulling symbols from the input that match the path down the tree. When a node does not have a child that matches the next character, we will have read the longest possible symbol prefix. This prefix may or may not be a valid symbol. Consider a tree that has had =:~ added and has not had =: added. In this tree, of the three nodes that contain =:~, only the first and third contain complete symbols. If, say, the input contains =:a, the colon node will not have a child that matches the \u0026lsquo;a\u0026rsquo; and so it will stop reading. The colon node has to \u0026ldquo;unread\u0026rdquo;: it must push back its character, and ask its parent to unread. Unreading continues until it reaches an ancestor that represents a valid symbol.  Constructors Constructs a SymbolNode with the given parent, representing the given character.\n public constructor(parent: SymbolNode, character: number)\n  parent: SymbolNode - node\u0026rsquo;s parent character: number - node\u0026rsquo;s associated character.  Properties tokenType Token type\n public tokenType(): TokenType\n  returns: TokenType - token type   public tokenType(value: TokenType)\n  value: TokenType - token type  valid Boolean variable\n public valid(): boolean\n  returns: boolean - true or false   public valid(value: boolean)\n  value: boolean - true or false  Instance methods addDescendantLine Adds a line of descendants that represents the characters in the given string.\n public addDescendantLine(value: string, tokenType: TokenType): void\n  value: string - given string tokenType: TokenType - token type  ancestry Shows the symbol this node represents.\n public ancestry(): string\n  returns: string - symbol this node represents.  deepestRead Establishes characters in the given range as valid characters for the part of a word after the first character. Note that the tokenizer must determine which characters are valid as the beginning character of a word.\n public deepestRead(scanner: IScanner): SymbolNode\n  scanner: IScanner - scanner returns: SymbolNode - symbol\u0026rsquo;s node  ensureChildWithChar Finds or creates a child for the given character.\n public ensureChildWithChar(value: number): SymbolNode\n  value: number - chararacters\u0026rsquo;s returns: SymbolNode - TODO: add description  findChildWithChar Finds a child with the given character.\n public findChildWithChar(value: number): SymbolNode\n  value: number - value returns: SymbolNode - symbol\u0026rsquo;s node  unreadToValid Unwinds to a valid node; this node is \u0026ldquo;valid\u0026rdquo; if its ancestry represents a complete symbol. If this node is not valid, puts back the character and asks the parent to unwind.\n public unreadToValid(scanner: IScanner): SymbolNode\n  scanner: IScanner - scanner returns: SymbolNode - symbol\u0026rsquo;s node  ","description":"Constructs a SymbolNode.\n","image":null,"permalink":"/node/expressions/tokenizers/generic/symbol_node/","subtitle":null,"tags":null,"title":"SymbolNode"},{"content":"Extends: SymbolNode\nDescription The SymbolRootNode class is a special case of SymbolNode. A SymbolRootNode object has no symbol of its own, but has children that represent all possible symbols.\nConstructors Creates and initializes a root node.\n public constructor()\n Instance methods add Adds the given string as a symbol.\n public add(value: string, tokenType: TokenType): void\n  value: string - character sequence to add. tokenType: TokenType - token type  ancestry Shows the symbol this node represents.\n public ancestry(): string\n  returns: string - symbol this node represents.  nextToken Returns a symbol string from a scanner.\n public nextToken(scanner: IScanner): Token\n  scanner: IScanner - scanner to read from returns: SymbolNode - symbol string from a scanner  ","description":"This class is a special case of *SymbolNode*. A *SymbolRootNode* object has no symbol of its own, but has children that represent all possible symbols.\n","image":null,"permalink":"/node/expressions/tokenizers/generic/symbol_root_node/","subtitle":null,"tags":null,"title":"SymbolRootNode"},{"content":"Extends: BadRequestException\nDescription The SyntaxErrorCode class defines general syntax errors.\nFields ErrorNear Error near.\n public static ErrorNear: string = \u0026ldquo;ERROR_NEAR\u0026rdquo;\n Internal Internal error.\n public static Internal: string = \u0026ldquo;INTERNAL\u0026rdquo;\n MissedCloseParenthesis Missed close parenthesis.\n public static MissedCloseParenthesis: string = \u0026ldquo;MISSED_CLOSE_PARENTHESIS\u0026rdquo;\n MissedCloseSquareBracket Missed close square bracket.\n public static MissedCloseSquareBracket: string = \u0026ldquo;MISSED_CLOSE_SQUARE_BRACKET\u0026rdquo;\n UnexpectedEnd Unexpected end.\n public static UnexpectedEnd: string = \u0026ldquo;UNEXPECTED_END\u0026rdquo;;\n Unknown Unknown\n public static Unknown: string = \u0026ldquo;UNKNOWN\u0026rdquo;\n UnknownSymbol Unknown symbol\n public static UnknownSymbol: string = \u0026ldquo;UNKNOWN_SYMBOL\u0026rdquo;\n  ","description":"General syntax errors.\n","image":null,"permalink":"/node/expressions/calculator/syntax_error_code/","subtitle":null,"tags":null,"title":"SyntaxErrorCode"},{"content":"Extends: BadRequestException\nDescription The SyntaxException class defines the exceptions that can be thrown by the ExpressionParser class\nConstructors Creates a new instance of the SyntaxException class.\n public constructor(correlationId: string, code: string, message: string, line: number, column: number)\n  correlationId: string - transaction id used to trace execution through the call chain. code: string - code message: string - human-readable error message. line: number - line number column: number - column number  ","description":"Exception that can be thrown by ExpressionParser.\n","image":null,"permalink":"/node/expressions/calculator/syntax_exception/","subtitle":null,"tags":null,"title":"SyntaxException"},{"content":"Keeps track of search tags entered by a party (user or other party he or she represents). Later the tags can be used to enhance user experience in autocomplete and search functions.\n Server implementations: NodeJS Communication protocols: Direct, Commandable HTTP, Commandable GRPC, GRPC Persistence: Memory, Flat Files, MongoDB, Couchbase Deployment options: Monolith, Process, Docker, AWS Lambda Client implementations: NodeJS  ","description":null,"image":null,"permalink":"/microservices/content/tags/","subtitle":null,"tags":null,"title":"Tags Microservice"},{"content":"Description The TagsProcessor class allows you to extract and process search tags from objects.\nImportant points\n The search tags can be kept individually or embedded as hash tags inside text. E.g. \u0026ldquo;This text has #hash_tag that can be used for search.\u0026rdquo;  Methods CompressTag Compress a tag by removing special symbols like spaces, \u0026lsquo;_\u0026rsquo; and \u0026lsquo;#\u0026rsquo; and converting the tag to lower case. When tags are compressed they can be matched in search queries.\n (c *TTagsProcessor) CompressTag(tag string) string\n  tag: string - tag to compress. returns: string - compressed tag.  CompressTagList Compresses a comma-separated list of tags.\n (c *TTagsProcessor) CompressTagList(tagList string) []string\n  tagList: string - comma-separated list of tags to compress. returns: []string - list with compressed tags.  CompressTags Compresses a list of tags.\n (c *TTagsProcessor) CompressTags(tags []string) []string\n  tagList: []string - tags to compress. returns: []string - list with normalized tags.  EqualTags Compares two tags using their compressed form.\n (c *TTagsProcessor) EqualTags(tag1 string, tag2 string) bool\n  tag1: string - first tag. tag2: string - second tag. returns: bool - true if the tags are equal and false otherwise.  ExtractHashTags Extracts hash tags from a text.\n (c *TTagsProcessor) ExtractHashTags(text string) []string\n  text: string - text that contains hash tags returns: []string - list with extracted and compressed tags.  ExtractHashTagsFromValue Note: this is not implemented for this language yet\nExtracts hash tags from selected fields in an object.\n public static extractHashTagsFromValue(obj: any, \u0026hellip;searchFields: string[]): string[]\n  obj: any - object which contains hash tags. searchFields: string[] - list of fields in the objects where to extract tags returns: string[] - list of extracted and compressed tags.  NormalizeTag Normalizes a tag by replacing special symbols like \u0026lsquo;_\u0026rsquo; and \u0026lsquo;#\u0026rsquo; with spaces. When tags are normalized then they can be used in similar shape and form.\n (c *TTagsProcessor) NormalizeTag(tag string) string\n  tag: string - tag to normalize. returns: string - normalized tag.  NormalizeTagList Normalizes a comma-separated list of tags.\n (c *TTagsProcessor) NormalizeTagList(tagList string) []string\n  tagList: string - comma-separated list of tags to normalize. returns: []string - list with normalized tags.  NormalizeTags Normalizes a list of tags.\n (c *TTagsProcessor) NormalizeTags(tags []string) []string\n  tags: []string - tags to normalize. returns: []string - list with normalized tags.  ","description":"Helper class used to extract and process search tags from objects.\n","image":null,"permalink":"/golang/commons/data/tags_processor/","subtitle":null,"tags":null,"title":"TagsProcessor"},{"content":"Description The TagsProcessor class allows you to extract and process search tags from objects.\nImportant points\n The search tags can be kept individually or embedded as hash tags inside text. E.g. \u0026ldquo;This text has #hash_tag that can be used for search.\u0026rdquo;  Static methods compressTag Compress a tag by removing special symbols like spaces, \u0026lsquo;_\u0026rsquo; and \u0026lsquo;#\u0026rsquo; and converting the tag to lower case. When tags are compressed, they can be matched in search queries.\n public static compressTag(tag: string): string\n  tag: string - tag to compress. returns: string - compressed tag.  compressTagList Compresses a comma-separated list of tags.\n public static compressTagList(tagList: string): string[]\n  tagList: string - comma-separated list of tags to compress. returns: string[] - list with compressed tags.  compressTags Compresses a list of tags.\n public static compressTags(tags: string[]): string[]\n  tagList: string[] - tags to compress. returns: string[] - list with normalized tags.  equalTags Compares two tags using their compressed form.\n public static equalTags(tag1: string, tag2: string): boolean\n  tag1: string - first tag. tag2: string - second tag. returns: boolean - true if the tags are equal and false otherwise.  extractHashTags Extracts hash tags from a text.\n public static extractHashTags(text: string): string[]\n  text: string - text that contains hash tags returns: string[] - list with extracted and compressed tags.  extractHashTagsFromValue Extracts hash tags from selected fields in an object.\n public static extractHashTagsFromValue(obj: any, \u0026hellip;searchFields: string[]): string[]\n  obj: any - object which contains hash tags. searchFields: string[] - list of fields in the objects where to extract tags returns: string[] - list of extracted and compressed tags.  normalizeTag Normalizes a tag by replacing special symbols like \u0026lsquo;_\u0026rsquo; and \u0026lsquo;#\u0026rsquo; with spaces. When tags are normalized, they are presented in similar shape and form.\n public static normalizeTag(tag: string): string\n  tag: string - tag to normalize. returns: string - normalized tag.  normalizeTagList Normalizes a comma-separated list of tags.\n public static normalizeTagList(tagList: string): string[]\n  tagList: string - comma-separated list of tags to normalize. returns: string[] - list with normalized tags.  normalizeTags Normalizes a list of tags.\n public static normalizeTags(tags: string[]): string[]\n  tags: string[] - tags to normalize. returns: string[] - list with normalized tags.  ","description":"Helper class used to extract and process search tags from objects.\n","image":null,"permalink":"/node/commons/data/tags_processor/","subtitle":null,"tags":null,"title":"TagsProcessor"},{"content":"Description The TagsProcessor class allows you to extract and process search tags from objects.\nImportant points\n The search tags can be kept individually or embedded as hash tags inside text. E.g. \u0026ldquo;This text has #hash_tag that can be used for search.\u0026rdquo;  Static methods compress_tag Compress a tag by removing special symbols like spaces, \u0026lsquo;_\u0026rsquo; and \u0026lsquo;#\u0026rsquo; and converting the tag to lower case. When tags are compressed they can be matched in search queries.\n static compress_tag(tag: str): str\n  tag: str - the tag to compress. returns: str - a compressed tag.  compress_tag_list Compresses a comma-separated list of tags.\n static compress_tag_list(tag_list: str): List[str]\n  tag_list: str - a comma-separated list of tags to compress. returns: List[str] - a list with compressed tags.  compress_tags Compresses a list of tags.\n static compress_tags(tags: List[str]): List[str]\n  tagList: List[str] - the tags to compress. returns: List[str] - a list with normalized tags.  equal_tags Compares two tags using their compressed form.\n static equal_tags(tag1: str, tag2: str): bool\n  tag1: str - the first tag. tag2: str - the second tag. returns: bool - true if the tags are equal and false otherwise.  extract_hash_tags Extracts hash tags from a text.\n static extractHashTags(text: str): List[str]\n  text: str - a text that contains hash tags returns: List[str] - a list with extracted and compressed tags.  extract_hash_tags_from_value Extracts hash tags from selected fields in an object.\n static extract_hash_tags_from_value(obj: Any, *search_fields: str): List[str]\n  obj: Any - an object which contains hash tags. search_fields: str - a list of fields in the objects where to extract tags returns: List[str] -a list of extracted and compressed tags.  normalize_tag Normalizes a tag by replacing special symbols like \u0026lsquo;_\u0026rsquo; and \u0026lsquo;#\u0026rsquo; with spaces. When tags are normalized then can be used in a similar shape and form.\n static normalize_tag(tag: str): str\n  tag: str - the tag to normalize. returns: str - a normalized tag.  normalize_tag_list Normalizes a comma-separated list of tags.\n static normalize_tag_list(tagList: str): List[str]\n  tag_list: str - a comma-separated list of tags to normalize. returns: List[str] - a list with normalized tags.  normalize_tags Normalizes a list of tags.\n public static normalize_tags(tags: List[str]): List[str]\n  tags: List[str] - the tags to normalize. returns: List[str] - a list with normalized tags.  ","description":"Helper class used to extract and process search tags from objects.\n","image":null,"permalink":"/python/commons/data/tags_processor/","subtitle":null,"tags":null,"title":"TagsProcessor"},{"content":"","description":"Helper class used to extract and process search tags from objects.\n\n**Note: this class is not available for this language**\n","image":null,"permalink":"/net/commons/data/tags_processor/","subtitle":null,"tags":null,"title":"TagsProcessor!"},{"content":"Implements: CommandableGrpcClient\nDescription The TestCommandableGrpcClient class allows you to create a commandable GRPC client for automated testing.\nConstructors NewTestCommandableGrpcClient Creates a new instance of the TestCommandableGrpcClient class.\n NewTestCommandableGrpcClient(name string) *TestCommandableGrpcClient\n  name: string - a service name.  ","description":"GRPC client for automated testing.\n","image":null,"permalink":"/golang/grpc/test/test_commandable_grpc_client/","subtitle":null,"tags":null,"title":"TestCommandableGrpcClient"},{"content":"Extends: CommandableGrpcClient\nDescription The TestCommandableGrpcClient class allows you to create a commandable GRPC client for automated testing.\nConstructors Creates a new instance of the TestCommandableGrpcClient class.\n public constructor(name: string)\n  name: string - a service name.  Instance methods callCommand Calls a remote method via GRPC commadable protocol. The call is made via Invoke method and all parameters are sent in args object. The complete route to remote method is defined as serviceName + \u0026ldquo;.\u0026rdquo; + name.\n public callCommand(name: string, correlationId: string, params: any): Promise\u0026lt;any\u0026gt;\n  name:string - a name of the command to call. correlationId: string - (optional) transaction id used to trace execution through the call chain. params: any - command parameters. returns: Promise\u0026lt;any\u0026gt; - the received result.  ","description":"GRPC client for automated testing.\n","image":null,"permalink":"/node/grpc/test/test_commandable_grpc_client/","subtitle":null,"tags":null,"title":"TestCommandableGrpcClient"},{"content":"Inherits: CommandableHttpClient\nDescription The TestCommandableHttpClient class allows you to create a commandable HTTP client for automated testing.\nConstructors Creates a new instance of the TestCommandableHttpClient class.\n public TestCommandableHttpClient(string baseRoute)\n  baseRoute: string - base route to the remote method.  Instance methods CallCommand Calls a remote method via HTTP commadable protocol. The call is made via POST operation and all parameters are sent in the body object. The complete route to the remote method is defined as baseRoute + \u0026ldquo;/\u0026rdquo; + name.\n public new Task\u0026lt;T\u0026gt; CallCommandAsync\u0026lt;T\u0026gt;(string route, string correlationId, object requestEntity)\n  name:string - name of the command to call. correlationId: string - (optional) transaction id used to trace execution through the call chain. requestEntity: object - body object. returns: Task\u0026lt;T\u0026gt; - command execution result.  ","description":"HTTP client for automated testing.\n","image":null,"permalink":"/net/rpc/test/test_commandable_http_client/","subtitle":null,"tags":null,"title":"TestCommandableHttpClient"},{"content":"Extends: CommandableHttpClient\nDescription The TestCommandableHttpClient class allows you to create a commandable HTTP client for automated testing.\nConstructors Creates a new instance of the TestCommandableHttpClient class.\n public constructor(baseRoute: string)\n  baseRoute: string - base route to the remote method.  Instance methods callCommand Calls a remote method via HTTP commadable protocol. The call is made via POST operation and all parameters are sent in the body object. The complete route to the remote method is defined as baseRoute + \u0026ldquo;/\u0026rdquo; + name.\n public callCommand\u0026lt;T\u0026gt;(name:string, correlationId: string, params: any): Promise\u0026lt;T\u0026gt;\n  name:string - name of the command to call. correlationId: string - (optional) transaction id used to trace execution through the call chain. params: any - command parameters. returns: Promise\u0026lt;T\u0026gt; - command execution result.  ","description":"HTTP client for automated testing.\n","image":null,"permalink":"/node/rpc/test/test_commandable_http_client/","subtitle":null,"tags":null,"title":"TestCommandableHttpClient"},{"content":"Implements: CommandableHttpClient\nDescription The TestCommandableHttpClient class allows you to create a commandable HTTP client for automated testing.\nConstructors Creates a new instance of the TestCommandableHttpClient class.\n CommandableHttpClient(base_route: str)\n  base_route: str - base route to the remote method.  Instance methods call_command Calls a remote method via HTTP commadable protocol. The call is made via POST operation and all parameters are sent in the body object. The complete route to the remote method is defined as baseRoute + \u0026ldquo;/\u0026rdquo; + name.\n call_command(name:str, correlation_id: Optional[str], params: Any): Any\n  name:str - name of the command to call. correlation_id: Optional[str] - (optional) transaction id used to trace execution through the call chain. params: Any - command parameters. returns: Any - command execution result.  ","description":"HTTP client for automated testing.\n","image":null,"permalink":"/python/rpc/test/test_commandable_http_client/","subtitle":null,"tags":null,"title":"TestCommandableHttpClient"},{"content":"Extends: CommandableLambdaClient\nDescription The TestCommandableLambdaClient class provides an AWS Commandable Lambda client that can be used for automated testing.\nConstructors Creates a new instance of this class.\npublic constructor(baseRoute: string)\n baseRoute: string - base route  Instance methods callCommand Calls a remote action in AWS Lambda function. The name of the action is added as \u0026ldquo;cmd\u0026rdquo; parameter to the action parameters.\n public callCommand\u0026lt;T\u0026gt;(name: string, correlationId: string, params: any): Promise\u0026lt;T\u0026gt;\n  name: string - an action name correlationId: string - (optional) transaction id used to trace execution through the call chain. params: any - command parameters. returns: Promise\u0026lt;T\u0026gt; - action result.  ","description":"AWS Commandable Lambda client used for automated testing.\n","image":null,"permalink":"/node/aws/test/test_commandable_lambda_client/","subtitle":null,"tags":null,"title":"TestCommandableLambdaClient"},{"content":"Implements: GrpcClient\nDescription The TestGrpcClient class allows you to create a REST client that can be used for automated testing.\nConstructors NewTestGrpcClient Creates a new instance of the TestGrpcClient class.\n NewTestGrpcClient(name string) *TestGrpcClient\n  name: string - service name.  ","description":"GRPC client used for automated testing.\n","image":null,"permalink":"/golang/grpc/test/test_grpc_client/","subtitle":null,"tags":null,"title":"TestGrpcClient"},{"content":"Extends: GrpcClient\nDescription The TestGrpcClient class allows you to create a REST client that can be used for automated testing.\nConstructors Creates a new instance of the TestGrpcClient class.\n public constructor(clientTypeOrPath: any, clientName?: string, packageOptions?: any)\n  clientTypeOrPath: any - TODO: add description clientName: string - TODO: add description packageOptions: any - TODO: add description  Instance methods call Calls a remote method via the HTTP/REST protocol.\n public call(method: string, correlationId?: string, request: any = {}): Promise\u0026lt;any\u0026gt;\n  method: string - HTTP method: \u0026ldquo;get\u0026rdquo;, \u0026ldquo;head\u0026rdquo;, \u0026ldquo;post\u0026rdquo;, \u0026ldquo;put\u0026rdquo;, \u0026ldquo;delete\u0026rdquo; correlationId: string - (optional) transaction id used to trace execution through the call chain. request: any - (optional) request object. returns: Promise\u0026lt;T\u0026gt; - the received result.  ","description":"GRPC client used for automated testing.\n","image":null,"permalink":"/node/grpc/test/test_grpc_client/","subtitle":null,"tags":null,"title":"TestGrpcClient"},{"content":"Extends: LambdaClient\nDescription The TestLambdaClient class allows you to create an AWS Lambda client that can be used for automated testing.\nConstructors Creates an instance of this class.\n public constructor()\n Instance methods call Calls a remote action in AWS Lambda function. The name of the action is added as \u0026ldquo;cmd\u0026rdquo; parameter to the action parameters.\n public call(cmd: string, correlationId: string, params: any = {}): Promise\u0026lt;any\u0026gt;\n  cmd: string - action name to be called. correlationId: string - (optional) transaction id used to trace execution through the call chain. params: any - (optional) action parameters. returns: Promise\u0026lt;any\u0026gt; - action result.  callOneWay Calls an AWS Lambda Function action asynchronously without waiting for the response.\n public callOneWay(cmd: string, correlationId: string, params: any = {}): Promise\u0026lt;any\u0026gt;\n  cmd: string - action name to be called. correlationId: string - (optional) transaction id used to trace execution through the call chain. params: any - (optional) action parameters. returns: Promise\u0026lt;any\u0026gt; - action result.  ","description":"AWS Lambda client used for automated testing.\n","image":null,"permalink":"/node/aws/test/test_lambda_client/","subtitle":null,"tags":null,"title":"TestLambdaClient"},{"content":"Inherits: IMessageReceiver, ICleanable\nDescription The TestMessageReceiver allows you to receive a message, obtain a list of received messages and the number of received messages, and to clear the message list.\nConstructors Creates a TestMessageReceiver component.\n public TestMessageReceiver()\n Properties messages Gets the list of received messages.\n public List\u0026lt;MessageEnvelope\u0026gt; Messages { get; }\n MessageCount Gets the received message count.\n public int MessageCount { get; }\n Instance methods ClearAsync Clears all received messagers.\n public Task ClearAsync(string correlationId)\n  correlationId: string - (optional) transaction id to trace execution through call chain.  ReceiveMessageAsync Receives incoming message from the queue.\nSee also MessageEnvelope, IMessageQueue\n public Task ReceiveMessageAsync(MessageEnvelope message, IMessageQueue queue)\n  envelope: MessageEnvelope - an incoming message queue: IMessageQueue - a queue where the message comes from  ","description":"Class used to receive a message, obtain a list of received messages and the number of received messages, and to clear the message list. \n","image":null,"permalink":"/net/messaging/test/test_message_receiver/","subtitle":null,"tags":null,"title":"TestMessageReceiver"},{"content":"Implements: IMessageReceiver, ICleanable\nDescription The TestMessageReceiver allows you to receive a message, obtain a list of received messages and the number of received messages, and to clear the message list.\nConstructors Creates a TestMessageReceiver component.\n public constructor()\n Properties messages Gets the list of received messages.\n public messages(): MessageEnvelope[]\n  returns: MessageEnvelope[] - list of received messages  messageCount Gets the received message count.\n public messageCount(): number\n  returns: number - number of messages  Instance methods clear Clears all received messagers.\n public clear(correlationId: string): Promise\u0026lt;void\u0026gt;\n  correlationId: string - (optional) transaction id to trace execution through call chain.  receiveMessage Receives incoming message from the queue.\nSee also MessageEnvelope, IMessageQueue\n public receiveMessage(envelope: MessageEnvelope, queue: IMessageQueue): Promise\u0026lt;void\u0026gt;\n  envelope: MessageEnvelope - an incoming message queue: IMessageQueue - a queue where the message comes from  ","description":"Class used to receive a message, obtain a list of received messages and the number of received messages, and to clear the message list. \n","image":null,"permalink":"/node/messaging/test/test_message_receiver/","subtitle":null,"tags":null,"title":"TestMessageReceiver"},{"content":"Implements: IMessageReceiver, ICleanable\nDescription The TestMessageReceiver allows you to receive a message, obtain a list of received messages and the number of received messages, and to clear the message list.\nConstructors Creates a TestMessageReceiver component.\n TestMessageReceiver()\n Properties messages Gets the list of received messages.\n messages(): List[MessageEnvelope]\n  returns: List[MessageEnvelope] - list of received messages  message_count Gets the received message count.\n message_count(): int\n  returns: int - number of messages  Instance methods clear Clears all received messagers.\n clear(correlation_id: Optional[str])\n  correlationId: Optional[str] - (optional) transaction id used to trace execution through the call chain.  receive_message Receives an incoming message from the queue.\nSee also MessageEnvelope, IMessageQueue\n receive_message(envelope: MessageEnvelope, queue: IMessageQueue)\n  envelope: MessageEnvelope - incoming message queue: IMessageQueue - queue where the message comes from  ","description":"Class used to receive a message, obtain a list of received messages and the number of received messages, and to clear the message list. \n","image":null,"permalink":"/python/messaging/test/test_message_receiver/","subtitle":null,"tags":null,"title":"TestMessageReceiver"},{"content":"Inherits: RestClient\nDescription The TestRestClient class allows you to create a REST client that can be used for automated testing.\nConstructors Creates a new instance of the TestRestClient class.\n public TestRestClient(string baseRoute)\n  baseRoute: string - base route to the REST client.  Instance methods CallAsync Calls a remote method via the HTTP/REST protocol.\n public Task CallAsync(string correlationId, HttpMethod method, string route)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. method: HttpMethod - HTTP method: \u0026ldquo;get\u0026rdquo;, \u0026ldquo;head\u0026rdquo;, \u0026ldquo;post\u0026rdquo;, \u0026ldquo;put\u0026rdquo;, \u0026ldquo;delete\u0026rdquo; route: string - command route. The base route will be added to this route   public Task CallAsync(string correlationId, HttpMethod method, string route, object requestEntity)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. method: HttpMethod - HTTP method: \u0026ldquo;get\u0026rdquo;, \u0026ldquo;head\u0026rdquo;, \u0026ldquo;post\u0026rdquo;, \u0026ldquo;put\u0026rdquo;, \u0026ldquo;delete\u0026rdquo; route: string - command route. The base route will be added to this route requestEntity: object - request body object.   public Task\u0026lt;T\u0026gt; CallAsync\u0026lt;T\u0026gt;(string correlationId, HttpMethod method, string route)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. method: HttpMethod - HTTP method: \u0026ldquo;get\u0026rdquo;, \u0026ldquo;head\u0026rdquo;, \u0026ldquo;post\u0026rdquo;, \u0026ldquo;put\u0026rdquo;, \u0026ldquo;delete\u0026rdquo; route: string - command route. The base route will be added to this route returns: Task\u0026lt;T\u0026gt; - result object.   public Task\u0026lt;T\u0026gt; CallAsync\u0026lt;T\u0026gt;(string correlationId, HttpMethod method, string route, object requestEntity)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. method: HttpMethod - HTTP method: \u0026ldquo;get\u0026rdquo;, \u0026ldquo;head\u0026rdquo;, \u0026ldquo;post\u0026rdquo;, \u0026ldquo;put\u0026rdquo;, \u0026ldquo;delete\u0026rdquo; route: string - command route. The base route will be added to this route requestEntity: object - request body object. returns: Task\u0026lt;T\u0026gt; - result object.  SafeCallAsync Safely calls a remote method via HTTP/REST protocol and logs execution time.\n public Task\u0026lt;T\u0026gt; SafeCallAsync\u0026lt;T\u0026gt;(string correlationId, HttpMethod method, string route, object requestEntity)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. method: HttpMethod - HTTP method: \u0026ldquo;get\u0026rdquo;, \u0026ldquo;head\u0026rdquo;, \u0026ldquo;post\u0026rdquo;, \u0026ldquo;put\u0026rdquo;, \u0026ldquo;delete\u0026rdquo;. route: string - a command route. Base route will be added to this route. requestEntity: object - request body object. returns: Task\u0026lt;T\u0026gt; - result object.   public Task\u0026lt;T\u0026gt; SafeCallAsync\u0026lt;T\u0026gt;(string correlationId, HttpMethod method, string route)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. method: HttpMethod - HTTP method: \u0026ldquo;get\u0026rdquo;, \u0026ldquo;head\u0026rdquo;, \u0026ldquo;post\u0026rdquo;, \u0026ldquo;put\u0026rdquo;, \u0026ldquo;delete\u0026rdquo;. route: string - a command route. Base route will be added to this route. returns: Task\u0026lt;T\u0026gt; - result object.  ","description":"REST client used for automated testing.\n","image":null,"permalink":"/net/rpc/test/test_rest_client/","subtitle":null,"tags":null,"title":"TestRestClient"},{"content":"Extends: RestClient\nDescription The TestRestClient class allows you to create a REST client that can be used for automated testing.\nConstructors Creates a new instance of the TestRestClient class.\n public constructor(baseRoute: string)\n  baseRoute: string - base route to the REST client.  Instance methods call Calls a remote method via the HTTP/REST protocol.\n public call\u0026lt;T\u0026gt;(method: string, route: string, correlationId?: string, params: any = {}, data?: any): Promise\u0026lt;T\u0026gt;\n  method: string - HTTP method: \u0026ldquo;get\u0026rdquo;, \u0026ldquo;head\u0026rdquo;, \u0026ldquo;post\u0026rdquo;, \u0026ldquo;put\u0026rdquo;, \u0026ldquo;delete\u0026rdquo; route: string - command route. The base route will be added to this route correlationId: string - (optional) transaction id used to trace execution through the call chain. params: Any - (optional) query parameters. data: Any - (optional) body object. returns: Promise\u0026lt;T\u0026gt; - result object.  ","description":"REST client used for automated testing.\n","image":null,"permalink":"/node/rpc/test/test_rest_client/","subtitle":null,"tags":null,"title":"TestRestClient"},{"content":"Implements: RestClient\nDescription The TestRestClient class allows you to create a REST client that can be used for automated testing.\nConstructors Creates a new instance of the TestRestClient class.\n TestRestClient(base_route: str)\n  base_route: str - base route to the REST client.  Instance methods call Calls a remote method via the HTTP/REST protocol.\n call(method: str, route: str, correlation_id: Optional[str] = None, params: Any = None, data: Any = None): Any\n  method: str - HTTP method: \u0026ldquo;get\u0026rdquo;, \u0026ldquo;head\u0026rdquo;, \u0026ldquo;post\u0026rdquo;, \u0026ldquo;put\u0026rdquo;, \u0026ldquo;delete\u0026rdquo; route: str - command route. The base route will be added to this route correlation_id: Optional[str] - (optional) transaction id used to trace execution through the call chain. params: Any - (optional) query parameters. data: Any - (optional) body object. returns: Any - result object.  ","description":"REST client used for automated testing.\n","image":null,"permalink":"/python/rpc/test/test_rest_client/","subtitle":null,"tags":null,"title":"TestRestClient"},{"content":"Description The TimeSpanConverter class allows you to convert objects to TimeSpans.\nStatic methods ToNullableTimeSpan Converts value into TimeSpan or returns null when value is null.\n public static TimeSpan? ToNullableTimeSpan(object value)\n  value: object - value to converted returns: TimeSpan - TimeSpan value or null when value is null.  ToTimeSpan Converts value into TimeSpan.\n public static TimeSpan ToTimeSpan(object value)\n  value: object - value to converted returns: TimeSpan - TimeSpan value or null when value is null.  ToTimeSpanWithDefault Converts value into TimeSpan or returns a given default when value is null.\n public static TimeSpan ToTimeSpanWithDefault(object value, TimeSpan? defaultValue)\n  value: object - value to converted defaultValue: TimeSpan - default value returns: TimeSpan - TimeSpan value or null when value is null.  ","description":"Converts objects to TimeSpans.\n","image":null,"permalink":"/net/commons/convert/time_span_converter/","subtitle":null,"tags":null,"title":"TimeSpanConverter"},{"content":"Shows useful tips to users that help them use application more effectively. Each tip:\n  Can be written in multiple languages\n  Can include pictures and document attachments\n  Supports editing lifecycle via status tracking\n  Server implementations: NodeJS\n  Communication protocols: Direct, Commandable HTTP, Commandable GRPC, GRPC\n  Persistence: Memory, Flat Files, MongoDB, Couchbase\n  Deployment options: Monolith, Process, Docker, AWS Lambda\n  Client implementations: NodeJS\n  This microservice has dependencies on the following microservices:\n Blob Attachments - to reference pictures and documents associates with tips  ","description":null,"image":null,"permalink":"/microservices/content/tips/","subtitle":null,"tags":null,"title":"Tips Microservice"},{"content":"Description The Token class represents a token. A token represents a logical chunk of a string. For example, a typical tokenizer would break the string \u0026ldquo;1.23 \u0026lt;= 12.3\u0026rdquo; into three tokens: the number 1.23, a less-than-or-equal symbol, and the number 12.3. A token is a receptacle, and relies on a tokenizer to decide precisely how to divide a string into tokens.\nConstructors Constructs a token with a type and value.\n public constructor(type: TokenType, value: string, line: number, column: number)\n  type: TokenType - type of this token. value: string - token string value. line: number - line number where the token is. column: number - column number where the token is.  Properties column Column number where the token is.\n public column(): number\n  returns: number - column number.  line Line number where the token is.\n public line(): number\n  returns: number - line number.  type Token type.\n public type(): TokenType\n  returns: TokenType - token type.  value Token value.\n public value(): string\n  returns: string - token value.  Instance methods equals Compares this token to an object.\n public equals(obj: any): boolean\n  obj: any - compared object returns: boolean - true if the type and value are the same, false otherwise.  ","description":"Represents a token.\n","image":null,"permalink":"/node/expressions/tokenizers/token/","subtitle":null,"tags":null,"title":"Token"},{"content":"Description The TokenizedDataPageData allows you to create a transfer object that is used to pass the results of paginated queries.\nImportant points\n This object contains the items of the retrieved page and the total number of items (optional). Additionally, the data page returns a token that has to be passed to the next search as a starting point. Most often, this object type is used to send responses to paginated queries. Pagination parameters are defined by a TokenizedPagingParams object.  The token parameter in the TokenizedPagingParams defines where to start the search. The takes parameter sets number of items to be returned in the page.   The optional total parameter tells to return the total number of items in the query. However, not all implementations support the total parameter, because its generation may lead to severe performance implications.  Constructors NewTokenizedDataPage Creates a new instance of a data page and assigns its values.\n NewTokenizedDataPage(token string, data []interface{}) *TokenizedDataPage\n  token: string - (optional) token to define astarting point for the next search. data: []interface{} - list of items from the retrieved page.  NewEmptyTokenizedDataPage Creates a new empty instance of a data page.\n NewEmptyTokenizedDataPage() [*DataPage]\n Fields Data Items of the retrieved page.\n Data: string\n Token starting point for the next search.\n Token: []interface{}\n  Examples err, page = myDataClient.getDataByFilter( \u0026#34;123\u0026#34;, FilterParams.fromTuples(\u0026#34;completed\u0026#34;: true), NewTokenizedPagingParams(\u0026#34;\u0026#34;, 100, true) }; if err != nil { panic() } for item range page.Data { fmt.Println(item); } See also   PagingParams   ","description":"Data transfer object that is used to pass the results of paginated queries.\n       \n","image":null,"permalink":"/golang/commons/data/tokenized_data_page/","subtitle":null,"tags":null,"title":"TokenizedDataPage"},{"content":"Description The TokenizedDataPageData allows you to create a transfer object that is used to pass the results of paginated queries.\nImportant points\n This object contains the items of the retrieved page and the total number of items (optional). Additionally, the data page returns a token that has to be passed to the next search as a starting point. Most often, this object type is used to send responses to paginated queries. Pagination parameters are defined by a TokenizedPagingParams object.  The token parameter in the TokenizedPagingParams defines where to start the search. The takes parameter sets the number of items to be returned in the page.   The optional total parameter tells to return the total number of items in the query. However, not all implementations support the total parameter, because its generation may lead to severe performance implications.  Constructors Creates a new instance of data page and assigns its values.\n public constructor(data: T[] = null, token: string = null, total: number = null)\n  data: T[] - list of items from the retrieved page. token: string - (optional) token used to define a starting point for the next search. total: number - (optional) total number of objects in the result.  Fields data Items of the retrieved page.\n public data: T[]\n token starting point for the next search.\n public token: string\n total Total amount of items in a request.\n public total: number\n  Examples page := await myDataClient.getDataByFilter( \u0026#34;123\u0026#34;, FilterParams.fromTuples(\u0026#34;completed\u0026#34;: true), new TokenizedPagingParams(null, 100, true) ); See also   PagingParams   ","description":"Data transfer object that is used to pass the results of paginated queries.\n       \n","image":null,"permalink":"/node/commons/data/tokenized_data_page/","subtitle":null,"tags":null,"title":"TokenizedDataPage"},{"content":"Description The TokenizedDataPageData allows you to create a transfer object that is used to pass the results of paginated queries.\nImportant points\n This object contains the items of the retrieved page and the total number of items (optional). Additionally, the data page returns a token that has to be passed to the next search as a starting point. Most often, this object type is used to send responses to paginated queries. Pagination parameters are defined by a TokenizedPagingParams object.  The token parameter in the TokenizedPagingParams defines where to start the search. The takes parameter sets number of items to be returned in the page.   The optional total parameter tells to return the total number of items in the query. However, not all implementations support the total parameter, because its generation may lead to severe performance implications.  Constructors Creates a new instance of data page and assigns its values.\n TokenizedDataPage(data: List[Any], token: str = None, total: int = None)\n  data: List[Any] - a list of items from the retrieved page. token: str - (optional) a token to define astarting point for the next search. total: int - (optional) a total number of objects in the result.  Fields data The items of the retrieved page.\n data: List[Any]\n token The starting point for the next search.\n token: str\n total The total amount of items in a request.\n total: int\n  Examples page = my_data_client.get_data_by_filter( \u0026#34;123\u0026#34;, FilterParams.from_tuples(\u0026#34;completed\u0026#34;, True), TokenizedPagingParams(None, 100, True) ) See also   PagingParams   ","description":"Data transfer object that is used to pass the results of paginated queries.\n       \n","image":null,"permalink":"/python/commons/data/tokenized_data_page/","subtitle":null,"tags":null,"title":"TokenizedDataPage"},{"content":"","description":"Data transfer object that is used to pass the results of paginated queries.\n\n**Note: this class is not available for this language **\n","image":null,"permalink":"/net/commons/data/tokenized_data_page/","subtitle":null,"tags":null,"title":"TokenizedDataPage!"},{"content":"Description The TokenizedPagingParams allows you to create data transfer objects used to pass tokenized parameters for queries.\nImportant points\n The page is defined by two parameters:  the token token that defines a starting point for the search. the take parameter sets how many items to return in a page.   Additionally, the optional total parameter tells to return the total number of items in the query. However, not all implementations support the total parameter because its generation may lead to severe performance implications. In general, this class can be used for complex paging scenarios, like paging across multiple databases where the previous state is encoded in a token. The token is usually retrieved from the previous response. The initial request shall go with token == nil  Constructors Creates a new instance and sets its values.\n NewTokenizedPagingParams(token, take, total interface{}) *TokenizedPagingParams\n  token: string - token that defines a starting point for the search. take: *int64 - the number of items to return. total: bool - true to return the total number of items.  Fields Token Start token\n Token: string\n Take Number of items to return.\n Take: *int64\n Total Flag to return the total number of items.\n Total: bool\n  Methods GetTake Gets the number of items to return in a page.\n (c *TokenizedPagingParams) GetTake(maxTake int64) int64\n  maxTake: int64 - maximum number of items to return. returns: int64 - number of items to return.  Methods NewTokenizedPagingParamsFromMap Creates a new TokenizedPagingParams and sets it parameters from the specified map\n NewTokenizedPagingParamsFromMap(value *AnyValueMap) *TokenizedPagingParams\n  map: *AnyValueMap - AnyValueMap or StringValueMap to initialize this TokenizedPagingParams returns: *TokenizedPagingParams - newly created PagingParams.  NewTokenizedPagingParamsFromTuples Creates a new TokenizedPagingParams from a list of key-value pairs called tuples.\n NewTokenizedPagingParamsFromTuples(tuples \u0026hellip;interface{}) *TokenizedPagingParams\n  tuples: \u0026hellip;interface{} - list of values where odd elements are keys and the following even elements are values returns: TokenizedPagingParams - newly created TokenizedPagingParams.  NewTokenizedPagingParamsFromValue Converts a specified value into TokenizedPagingParams.\n NewTokenizedPagingParamsFromValue(value interface{}) *TokenizedPagingParams\n  value: interface{} - value to be converted returns: TokenizedPagingParams - newly created PagingParams.  Examples filter := NewFilterParamsFromTuples(\u0026#34;type\u0026#34;, \u0026#34;Type1\u0026#34;); paging := NewTokenizedPagingParams(\u0026#34;\u0026#34;, 100); err, page = myDataClient.getDataByFilter(filter, paging); ","description":"Data transfer object used to pass tokenized paging parameters for queries. \n","image":null,"permalink":"/golang/commons/data/tokenized_paging_params/","subtitle":null,"tags":null,"title":"TokenizedPagingParams"},{"content":"Description The TokenizedPagingParams allows you to create data transfer objects used to pass tokenized parameters for queries.\nImportant points\n The page is defined by two parameters:  the token token that defines a starting point for the search. the take parameter sets how many items to return in a page.   Additionally, the optional total parameter tells to return the total number of items in the query. However, not all implementations support the total parameter because its generation may lead to severe performance implications. In general, this class can be used for complex paging scenarios, like paging across multiple databases where the previous state is encoded in a token. The token is usually retrieved from the previous response. The initial request shall go with token == null  Constructors Creates a new instance and sets its values.\n public constructor(token: string = null, take: number = null, total: boolean = null)\n  token: string - token that defines a starting point for the search. take: number - the number of items to return. total: boolean - true to return the total number of items.  Fields token Start token\n public token: string\n take Number of items to return.\n public take: number\n total Flag used to define whether the total number of items must be returned or not.\n public total: boolean\n  Instance methods getTake Gets the number of items to return in a page.\n public getTake(maxTake: number): number\n  maxTake: number - maximum number of items to return. returns: number - number of items to return.  Static methods fromMap Creates a new TokenizedPagingParams object and sets its parameters from the specified map.\n public static fromMap(map: AnyValueMap): TokenizedPagingParams\n  map: AnyValueMap - AnyValueMap or StringValueMap object used to initialize this TokenizedPagingParams object. returns: TokenizedPagingParams - newly created TokenizedPagingParams object.  fromTuples Creates a new TokenizedPagingParams object from a list of key-value pairs called tuples.\n public static fromTuples(\u0026hellip;tuples: any[]): TokenizedPagingParams\n  tuples: any[] - list of values where odd elements are keys and the following even elements are values returns: TokenizedPagingParams - newly created TokenizedPagingParams object.  fromValue Converts a specified value into a TokenizedPagingParams object.\n public static fromValue(value: any): TokenizedPagingParams\n  value: any - value to be converted returns: TokenizedPagingParams - newly created TokenizedPagingParams object.  Examples let filter = FilterParams.fromTuples(\u0026#34;type\u0026#34;, \u0026#34;Type1\u0026#34;); let paging = new TokenizedPagingParams(null, 100); myDataClient.getDataByFilter(filter, paging, (err, page) =\u0026gt; {...}); ","description":"Data transfer object used to pass tokenized paging parameters for queries. \n","image":null,"permalink":"/node/commons/data/tokenized_paging_params/","subtitle":null,"tags":null,"title":"TokenizedPagingParams"},{"content":"Description The TokenizedPagingParams allows you to create data transfer objects used to pass tokenized parameters for queries.\nImportant points\n The page is defined by two parameters:  the token token that defines a starting point for the search. the take parameter sets how many items to return in a page.   Additionally, the optional total parameter tells to return the total number of items in the query. However, not all implementations support the total parameter because its generation may lead to severe performance implications. In general, this class can be used for complex paging scenarios, like paging across multiple databases where the previous state is encoded in a token. The token is usually retrieved from the previous response. The initial request shall go with token == None  Constructors Creates a new instance and sets its values.\n TokenizedPagingParams(token: str = None, take: int = None, total: bool = None)\n  token: str - token that defines a starting point for the search. take: int - the number of items to return. total: bool - true to return the total number of items.  Fields token The start token\n token: str\n take The number of items to return.\n take: int\n total The flag to return the total number of items.\n total: boolean\n  Instance methods get_take Gets the number of items to return in a page.\n get_take(max_take: int): int\n  max_take: int - the maximum number of items to return. returns: int - the number of items to return.  Static methods from_map Creates a new TokenizedPagingParams and sets it parameters from the specified map.\n static from_map(map: AnyValueMap): TokenizedPagingParams\n  map: AnyValueMap - a AnyValueMap or StringValueMap to initialize this TokenizedPagingParams returns: TokenizedPagingParams - a newly created PagingParams.  from_tuples Creates a new TokenizedPagingParams from a list of key-value pairs called tuples.\n static from_tuples(*tuples: Any): TokenizedPagingParams\n  tuples: Any - a list of values where odd elements are keys and the following even elements are values returns: TokenizedPagingParams - a newly created TokenizedPagingParams.  from_value Converts specified value into TokenizedPagingParams.\n static from_value(value: Any): TokenizedPagingParams\n  value: Any - value to be converted returns: TokenizedPagingParams - a newly created PagingParams.  Examples filter = FilterParams.from_tuples(\u0026#34;type\u0026#34;, \u0026#34;Type1\u0026#34;); paging = TokenizedPagingParams(None, 100); result = my_data_client.get_data_by_filter(filter, paging) ","description":"Data transfer object used to pass tokenized paging parameters for queries. \n","image":null,"permalink":"/python/commons/data/tokenized_paging_params/","subtitle":null,"tags":null,"title":"TokenizedPagingParams"},{"content":"","description":"Data transfer object used to pass tokenized paging parameters for queries. \n\n**Note: this class is not available for this language**\n","image":null,"permalink":"/net/commons/data/tokenized_paging_params/","subtitle":null,"tags":null,"title":"TokenizedPagingParams!"},{"content":"Extends: BadRequestException\nDescription The TokenizedPagingParamsSchema class allows you to create schemas to validate TokenizedPagingParams.\nConstructors NewTokenizedPagingParamsSchema Creates a new instance of a validation schema.\n NewTokenizedPagingParamsSchema() *ObjectSchema\n ","description":"Schema to validate TokenizedPagingParams.\n","image":null,"permalink":"/golang/commons/validate/tokenized_paging_params_schema/","subtitle":null,"tags":null,"title":"TokenizedPagingParamsSchema"},{"content":"Description The TokenType class defines different types (categories) of tokens, such as \u0026ldquo;number\u0026rdquo;, \u0026ldquo;symbol\u0026rdquo; and \u0026ldquo;word\u0026rdquo;.\nEnumeration members The codes are as follows:\n Unknown = 0 Eof = 1 Eol = 2 Float = 3 Integer = 4 HexDecimal = 5 Number = 6 Symbol = 7 Quoted = 8 Word = 9 Keyword = 10 Whitespace = 11 Comment = 12 Special = 13  ","description":"Types (categories) of tokens such as \"number\", \"symbol\" and \"word\".\n","image":null,"permalink":"/node/expressions/tokenizers/token_type/","subtitle":null,"tags":null,"title":"TokenType"},{"content":"Description The TraceTiming class is used to create the timing object returned by ITracer.begin_trace to end the timing of an execution block and record the associated trace.\nConstructors NewTraceTiming Creates a new instance of the timing callback object.\n NewTraceTiming(correlationId string, component string, operation string, tracer ITracer) *TraceTiming\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. component: string - associated component name operation: string - associated operation name tracer: ITracer - callback that shall be called when endTiming is called.  Methods EndFailure Ends timing of a failed block, calculates elapsed time and records the associated trace.\n (c *TraceTiming) EndFailure(err error)\n  err: error - error object associated with this trace.  EndTrace Ends timing of an execution block, calculates the elapsed time and records the associated trace.\n (c *TraceTiming) EndTrace()\n Examples var timing = tracer.BeginTrace(\u0026#34;mymethod.exec_time\u0026#34;); ... timing.EndTrace(); if err != nil { timing.EndFailure(err); } ","description":"Timing object returned by [ITracer.begin_trace](../itracer/#begin_trace) to end the timing of an execution block and record the associated trace.\n","image":null,"permalink":"/golang/components/trace/trace_timing/","subtitle":null,"tags":null,"title":"TraceTiming"},{"content":"Description The TraceTiming class is used to create the timing object returned by ITracer.begin_trace to end the timing of and execution block and record the associated trace.\nConstructors Creates a new instance of the timing callback object.\n public TraceTiming(string correlationId, string component, string operation, ITracer tracer = null)\n  correlationId: string - (optional) transaction id to trace execution through a call chain. component: string - an associated component name operation: string - an associated operation name tracer: ITracer - a callback that shall be called when endTiming is called.  Instance methods EndFailure Ends timing of a failed block, calculates elapsed time and records the associated trace.\n public void EndFailure(Exception error)\n  error: Exception - an error object associated with this trace.  EndTrace Ends timing of an execution block, calculates the elapsed time and records the associated trace.\n public void EndTrace()\n Examples var timing = tracer.BeginTrace(\u0026#34;mymethod.exec_time\u0026#34;); try { ... timing.EndTrace(); } catch (Exception err) { timing.EndFailure(err); } ","description":"Timing object returned by [ITracer.begin_trace](../itracer/#begin_trace) to end the timing of an execution block and record the associated trace.\n","image":null,"permalink":"/net/components/trace/trace_timing/","subtitle":null,"tags":null,"title":"TraceTiming"},{"content":"Description The TraceTiming class is used to create the timing object returned by ITracer.begin_trace to end the timing of and execution block and record the associated trace.\nConstructors Creates a new instance of the timing callback object.\n public constructor(correlationId: string, component: string, operation: string, tracer: ITracer = null)\n  correlationId: string - (optional) transaction id to trace execution through a call chain. component: string - an associated component name operation: string - an associated operation name tracer: ITracer - a callback that shall be called when endTiming is called.  Instance methods endFailure Ends timing of a failed block, calculates elapsed time and records the associated trace.\n public endFailure(error: Error): void\n  error: Error - an error object associated with this trace.  endTrace Ends timing of an execution block, calculates the elapsed time and records the associated trace.\n public endTrace(): void\n Examples let timing = tracer.beginTrace(\u0026#34;mymethod.exec_time\u0026#34;); try { ... timing.endTrace(); } catch (err) { timing.endFailure(err); } ","description":"Timing object returned by [ITracer.begin_trace](../itracer/#begin_trace) to end the timing of an execution block and record the associated trace.\n","image":null,"permalink":"/node/components/trace/trace_timing/","subtitle":null,"tags":null,"title":"TraceTiming"},{"content":"Description The TraceTiming class is used to create the timing object returned by ITracer.begin_trace to end the timing of and execution block and record the associated trace.\nConstructors Creates a new instance of the timing callback object.\n TraceTiming(correlation_id: Optional[str], component: str, operation: str, tracer: ITracer = None)\n  correlation_id: Optional[str] - (optional) transaction id to trace execution through a call chain. component: str - an associated component name operation: str - an associated operation name tracer: ITracer - a callback that shall be called when endTiming is called.  Instance methods end_failure Ends timing of a failed block, calculates elapsed time and records the associated trace.\n end_failure(error: Exception)\n  error: Exception - an error object associated with this trace.  end_trace Ends timing of an execution block, calculates the elapsed time and records the associated trace.\n end_trace()\n Examples timing = tracer.begin_trace(\u0026#34;mymethod.exec_time\u0026#34;); try: ... timing.end_trace(); except Exceptions as err: timing.end_failure(err); ","description":"Timing object returned by [ITracer.begin_trace](../itracer/#begin_trace) to end the timing of an execution block and record the associated trace.\n","image":null,"permalink":"/python/components/trace/trace_timing/","subtitle":null,"tags":null,"title":"TraceTiming"},{"content":"Records historical data of controlled objects.\n Server implementations: NodeJS Communication protocols: Direct, Commandable HTTP, Commandable GRPC, GRPC Persistence: Memory, Flat Files, MongoDB, Couchbase Deployment options: Monolith, Process, Docker, AWS Lambda Client implementations: NodeJS  ","description":null,"image":null,"permalink":"/microservices/iot/transducerdata/","subtitle":null,"tags":null,"title":"Transducer data Microservice"},{"content":"Description The TypeCode class contains the codes for data types that are used by the class TypeConverter.\nEnumeration members The codes are as follows:\n Unknown = iota String = iota Boolean = iota Integer = iota Long = iota Float = iota Double = iota DateTime = iota Duration = iota Object = iota Enum = iota Array = iota Map = iota  ","description":"The TypeCode class contains the codes for data types that are used by the class [TypeConverter](../type_converter).\n","image":null,"permalink":"/golang/commons/convert/type_code/","subtitle":null,"tags":null,"title":"TypeCode"},{"content":"Description The TypeCode class contains the codes for data types that are used by the class TypeConverter.\nEnumeration members The codes are as follows:\n Unknown String Boolean Integer Long Float Double DateTime Duration Object Enum Array Map  ","description":"The TypeCode class contains the codes for data types that are used by the class [TypeConverter](../type_converter).\n","image":null,"permalink":"/net/commons/convert/type_code/","subtitle":null,"tags":null,"title":"TypeCode"},{"content":"Description The TypeCode class contains the codes for data types that are used by the class TypeConverter.\nEnumeration members The codes are as follows:\n Unknown = 0 String = 1 Boolean = 2 Integer = 3 Long = 4 Float = 5 Double = 6 DateTime = 7 Duration = 8 Object = 9 Enum = 10 Array = 11 Map = 12  ","description":"The TypeCode class contains the codes for data types that are used by the class [TypeConverter](../type_converter).\n","image":null,"permalink":"/node/commons/convert/type_code/","subtitle":null,"tags":null,"title":"TypeCode"},{"content":"Description The TypeCode class contains the codes for data types that are used by the class TypeConverter.\nEnumeration members The codes are as follows:\n Unknown = 0 String = 1 Boolean = 2 Integer = 3 Long = 4 Float = 5 Double = 6 DateTime = 7 Duration = 8 Object = 9 Enum = 10 Array = 11 Map = 12  ","description":"The TypeCode class contains the codes for data types that are used by the class [TypeConverter](../type_converter).\n","image":null,"permalink":"/python/commons/convert/type_code/","subtitle":null,"tags":null,"title":"TypeCode"},{"content":"See also TypeCode\nDescription The TypeConverter class allows you to convert arbitrary values into objects specified by a code type and to get the code type of an object. The code types are defined in the TypeCode class.\nMethods ToNullableType Converts a value into an object type specified by TypeCode or returns nil when the conversion is not possible.\n ToNullableType(typ TypeCode, value interface{}) interface{}\n  typ: TypeCode - TypeCode for the data type into which \u0026lsquo;value\u0026rsquo; is to be converted. value: interface{} - value to convert. returns: interface{} - object value of type corresponding to TypeCode, or nil when the conversion is not supported.  ToString Converts a TypeCode into its string name.\n ToString(typ TypeCode) string\n  typ: TypeCode - TypeCode to convert into a string. returns: string - name of the TypeCode passed as a string value.  ToType Converts a value into an object type specified by TypeCode or returns type default when the conversion is not possible.\n ToType(typ TypeCode, value interface{}) interface{}\n  typ: TypeCode - value to convert. value: interface{} - value to convert. returns: interface{} - object value of type corresponding to TypeCode, or type default when the conversion is not supported.  ToTypeCode Gets the TypeCode for a specific value.\n ToTypeCode(value interface{}) TypeCode\n  value: interface{} - value whose TypeCode is to be resolved. returns: TypeCode - TypeCode that corresponds to the passed object\u0026rsquo;s type.  ToTypeWithDefault Converts a value into an object type specified by TypeCode or returns default value when conversion is not possible.\n ToTypeWithDefault(typ TypeCode, value interface{}, defaultValue interface{}) interface{}\n  type: TypeCode - TypeCode for the data type into which \u0026lsquo;value\u0026rsquo; is to be converted. value: interface{} - value to convert. defaultValue: interface{} - default value to return if conversion is not possible (returns nil). returns: interface{} - object value of type corresponding to TypeCode, or default value when conversion is not supported.  Examples value1 := convert.TypeConverter.ToType(convert.Integer, \u0026#34;123.456\u0026#34;) value2 := convert.TypeConverter.ToType(convert.DateTime, 123) value3 := convert.TypeConverter.ToType(convert.Boolean, \u0026#34;F\u0026#34;) fmt.Println(value1) // 123 fmt.Println(value2) // 1970-01-01 02:02:03 +0200 EET fmt.Println(value3) // false See also   TypeCode   ","description":"The TypeConverter class allows you to convert arbitrary values into objects specified by a code type and to get the code type of an object.\n","image":null,"permalink":"/golang/commons/convert/type_converter/","subtitle":null,"tags":null,"title":"TypeConverter"},{"content":"See also TypeCode\nDescription The TypeConverter class allows you to convert arbitrary values into objects specified by a code type and to get the code type of an object. The code types are defined in the TypeCode class.\nStatic methods ToNullableType Converts value into an object type specified by Type Code or returns null when the conversion is not possible. T - Class type for the data type.\n public static T ToNullableType\u0026lt;T\u0026gt;(object value)\n  value: object - value to convert. returns: T - object value of type corresponding to TypeCode, or null when the conversion is not supported.  ToString Converts a TypeCode into its string name.\n public static string ToString(TypeCode type)\n  type: TypeCode - TypeCode to convert into a string. returns: string - the name of the TypeCode passed as a string value.  ToType Converts value into an object type specified by Type Code or returns the default type when the conversion is not possible. T - Class type for the data type into which \u0026lsquo;value\u0026rsquo; is to be converted.\n public static T ToType\u0026lt;T\u0026gt;(object value)\n  value: object - value to convert. returns: T - object value of type corresponding to TypeCode, or the default type when the onversion is not supported.  ToTypeCode Gets the TypeCode for a specific value.\n public static TypeCode ToTypeCode(Type type)\n  type: Type - Class type for the data type. returns: TypeCode - TypeCode that corresponds to the passed object\u0026rsquo;s type.  ToTypeCode Gets the TypeCode for specific value.\n public static TypeCode ToTypeCode(object value)\n  value: object - value whose TypeCode is to be resolved. returns: TypeCode - TypeCode that corresponds to the passed object\u0026rsquo;s type.  ToTypeWithDefault Converts a value into an object of type specified by TypeCode or returns a given default value when the conversion is not possible. T - Class type for the data type into which \u0026lsquo;value\u0026rsquo; is to be converted.\n public static T ToTypeWithDefault\u0026lt;T\u0026gt;(object value, T defaultValue)\n  value: object - value to convert. defaultValue: T - default value to return if the conversion is not possible (returns null). returns: T - object value of type corresponding to TypeCode, or the given default value when the conversion is not supported.  Examples var value1 = TypeConverter.ToType(TypeCode.Integer, \u0026#34;123.456\u0026#34;); // Result: 123 var value2 = TypeConverter.ToType(TypeCode.DateTime, 123); // Result: DateTime(123) var value3 = TypeConverter.ToType(TypeCode.Boolean, \u0026#34;F\u0026#34;); // Result: false See also   TypeCode   ","description":"The TypeConverter class allows you to convert arbitrary values into objects specified by a code type and to get the code type of an object.\n","image":null,"permalink":"/net/commons/convert/type_converter/","subtitle":null,"tags":null,"title":"TypeConverter"},{"content":"See also TypeCode\nDescription The TypeConverter class allows you to convert arbitrary values into objects specified by a code type and to get the code type of an object. The code types are defined in the TypeCode class.\nStatic methods toNullableType Converts a value into an object of the type specified by a TypeCode or returns null when the conversion is not possible.\n public static toNullableType\u0026lt;T\u0026gt;(type: TypeCode, value: any): T\n  type: any - TypeCode for the data type into which \u0026lsquo;value\u0026rsquo; is to be converted. value: any - value to convert. returns: T - object value of type corresponding to TypeCode, or null when the conversion is not supported.  toString Converts a TypeCode into its string name.\n public static toString(type: TypeCode): string\n  type: TypeCode - TypeCode to convert into a string. returns: string - name of the TypeCode passed as a string value.  toType Converts a value into an object of the type specified by Type Code or returns an object of default type when the conversion is not possible.\n public static toType\u0026lt;T\u0026gt;(type: TypeCode, value: any): T\n  type: TypeCode - type to which the value is to be converted into. value: any - value to convert. returns: T - object value of type corresponding to TypeCode, or object of default type when the conversion is not supported.  toTypeCode Gets a TypeCode for a specific value.\n public static toTypeCode(value: any): TypeCode\n  value: any - value whose TypeCode is to be resolved. returns: TypeCode - TypeCode that corresponds to the passed object\u0026rsquo;s type.  toTypeWithDefault Converts a value into an object of the type specified by Type Code or returns a default value when the conversion is not possible.\n public static toTypeWithDefault\u0026lt;T\u0026gt;(type: TypeCode, value: any, defaultValue: T): T\n  type: TypeCode - TypeCode for the data type into which \u0026lsquo;value\u0026rsquo; is to be converted. value: any - value to convert. defaultValue: T - default value to return if conversion is not possible (returns null). returns: T - object value of type corresponding to TypeCode, or default value when the conversion is not supported.  Examples let value1 = TypeConverter.toType(TypeCode.Integer, \u0026#34;123.456\u0026#34;); // Result: 123 let value2 = TypeConverter.toType(TypeCode.DateTime, 123); // Result: Date(123) let value3 = TypeConverter.toType(TypeCode.Boolean, \u0026#34;F\u0026#34;); // Result: false See also   TypeCode   ","description":"The TypeConverter class allows you to convert arbitrary values into objects specified by a code type and to get the code type of an object.\n","image":null,"permalink":"/node/commons/convert/type_converter/","subtitle":null,"tags":null,"title":"TypeConverter"},{"content":"Description The TypeConverter class allows you to convert arbitrary values into objects specified by a code type and to get the code type of an object. The code types are defined in the TypeCode class.\nStatic methods to_nullable_type Converts value into an object type specified by Type Code or returns None when conversion is not possible.\n static to_nullable_type(type: TypeCode, value: Any): Any\n  type: Any - the TypeCode for the data type into which \u0026lsquo;value\u0026rsquo; is to be converted. value: Any - the value to convert. returns: Any - object value of type corresponding to TypeCode, or None when conversion is not supported.  to_string Converts a TypeCode into its string name.\n static to_string(type: TypeCode): str\n  type: TypeCode - the TypeCode to convert into a string. returns: str - the name of the TypeCode passed as a string value.  to_type Converts value into an object type specified by Type Code or returns type default when conversion is not possible.\n static to_type(type: TypeCode, value: Any): Any\n  type: TypeCode - the value to convert. value: Any - the value to convert. returns: Any - object value of type corresponding to TypeCode, or type default when conversion is not supported.  to_type_code Gets TypeCode for specific value.\n static to_type_code(value: Any): TypeCode\n  value: Any - value whose TypeCode is to be resolved. returns: TypeCode - the TypeCode that corresponds to the passed object\u0026rsquo;s type.  to_type_with_default Converts value into an object type specified by Type Code or returns default value when conversion is not possible.\n static to_type_with_default(type: TypeCode, value: Any, default_value: Any): Any\n  type: TypeCode - the TypeCode for the data type into which \u0026lsquo;value\u0026rsquo; is to be converted. value: Any - the value to convert. default_value: Any - the default value to return if conversion is not possible (returns None). returns: Any - object value of type corresponding to TypeCode, or default value when conversion is not supported.  Examples value1 = TypeConverter.to_type_code(\u0026#34;Hello world\u0026#34;) # Returns 1 See also   TypeCode   ","description":"The TypeConverter class allows you to convert arbitrary values into objects specified by a code type and to get the code type of an object.\n","image":null,"permalink":"/python/commons/convert/type_converter/","subtitle":null,"tags":null,"title":"TypeConverter"},{"content":"Description The TypeDescriptor class stores a reference to a type represented by the type name and library (module) where the type is defined.\nImportant points\n This class has symmetric implementation across all languages supported by the Pip.Services toolkit and it is used to support dynamic data processing.  Constructors NewTypeDescriptor Creates a new instance of the type descriptor and sets its values.\n NewTypeDescriptor(name string, pkg string) *TypeDescriptor\n  name: string - name of the object type. pkg: string - library or module where this object type is implemented.  Methods Equals Compares this descriptor to a value. If the value is also a TypeDescriptor it compares their name and library fields. Otherwise this method returns false.\n (c *TypeDescriptor) Equals(obj interface{}) bool\n  obj: interface{} - value to compare. returns: bool - true if value is identical TypeDescriptor and false otherwise.  Package Gets the name of the library or module where the object type is defined.\n (c *TypeDescriptor) Package() string\n  returns: string - name of the library or module.  Name Get the name of the object type.\n (c *TypeDescriptor) Name() string\n  returns: string - name of the object type.  ParseTypeDescriptorFromString Parses a string to get descriptor fields and returns them as a Descriptor. The string must have format name[,library]\nThrows a ConfigError if the descriptor string is of a wrong format.\n ParseTypeDescriptorFromString(value string) (*TypeDescriptor, error)\n  value: string - a string to parse. returns: (*TypeDescriptor, error) - a newly created Descriptor.  String Gets a string representation of the object. The result has format name[,package]\n (c *TypeDescriptor) String() string\n  returns: string - string representation of the object.  ","description":"The TypeDescriptor class stores a reference to a type represented by the type name and library (module) where the type is defined.\n","image":null,"permalink":"/golang/commons/reflect/type_descriptor/","subtitle":null,"tags":null,"title":"TypeDescriptor"},{"content":"Description The TypeDescriptor class stores a reference to a type represented by the type name and library (module) where the type is defined.\nImportant points\n This class has symmetric implementation across all languages supported by the Pip.Services toolkit and it is used to support dynamic data processing.  Constructors Creates a new instance of the type descriptor and sets its values.\n public TypeDescriptor(string name, string library)\n  name: string - name of the object type. library: string - library or module where this object type is implemented.  Creates a new instance of the type descriptor.\n public TypeDescriptor()\n Properties Name Name of the object type.\n public string Name { get; }\n Library Gets the name of the library or module where the object type is defined.\n public string Library { get; }\n Instance methods Equals Compares this descriptor to a value. If the value is also a TypeDescriptor it compares their name and library fields. Otherwise this method returns false.\n public override bool Equals(object value)\n  value: object - value to compare. returns: bool - true if value is identical TypeDescriptor and false otherwise.  GetHashCode Gets the Hash code\n public override int GetHashCode()\n  returns: int - Hash code  ToString Gets a string representation of the object. The result has format name[,library]\n public override string ToString()\n  returns: string - string representation of the object.  Static methods FromString Parses a string to get descriptor fields and returns them as a Descriptor. The string must have format the name[,library]\nThrows a ConfigException if the descriptor string is of a wrong format.\n public static TypeDescriptor FromString(string value)\n  value: string - string to parse. returns: TypeDescriptor - newly created Descriptor.  ","description":"The TypeDescriptor class stores a reference to a type represented by the type name and library (module) where the type is defined.\n","image":null,"permalink":"/net/commons/reflect/type_descriptor/","subtitle":null,"tags":null,"title":"TypeDescriptor"},{"content":"Description The TypeDescriptor class stores a reference to a type represented by the type name and library (module) where the type is defined.\nImportant points\n This class has symmetric implementation across all languages supported by the Pip.Services toolkit and it is used to support dynamic data processing.  Constructors Creates a new instance of the type descriptor and sets its values.\n public constructor(name: string, library: string)\n  name: string - name of the object type. library: string - library or module where this object type is implemented.  Instance methods equals Compares this descriptor to a value. If the value is also a TypeDescriptor, it compares their name and library fields. Otherwise this method returns false.\n public equals(value: any): boolean\n  value: any - value to compare. returns: boolean - true if value is identical to the TypeDescriptor and false otherwise.  getLibrary Gets the name of the library or module where the object type is defined.\n public getLibrary(): string\n  returns: string - name of the library or module.  getName Gets the name of the object type.\n public getName(): string\n  returns: string - name of the object type.  toString Gets a string representation of the object. The result has format name[,library]\n public toString(): string\n  returns: string - string representation of the object.  Static methods fromString Parses a string to get descriptor fields and returns them as a Descriptor. The string must have the format name[,library].\nThrows a ConfigException if the descriptor string is of a wrong format.\n public static fromString(value: string): TypeDescriptor\n  value: string - string to parse. returns: TypeDescriptor - newly created Descriptor.  ","description":"The TypeDescriptor class stores a reference to a type represented by the type name and library (module) where the type is defined.\n","image":null,"permalink":"/node/commons/reflect/type_descriptor/","subtitle":null,"tags":null,"title":"TypeDescriptor"},{"content":"Description The TypeDescriptor class stores a reference to a type represented by the type name and library (module) where the type is defined.\nImportant points\n This class has symmetric implementation across all languages supported by the Pip.Services toolkit and it is used to support dynamic data processing.  Constructors Creates a new instance of the type descriptor and sets its values.\n TypeDescriptor(name: str, library: str)\n  name: str - name of the object type. library: str - a library or module where this object type is implemented.  Instance methods equals Compares this descriptor to a value. If the value is also a TypeDescriptor, it compares their name and library fields. Otherwise this method returns false.\n equals(value: Any): bool\n  value: Any - a value to compare. returns: bool - true if value is identical TypeDescriptor and false otherwise.  get_library Gets the name of the library or module where the object type is defined.\n get_library(): str\n  returns: str - the name of the library or module.  get_name Gets the name of the object type.\n get_name(): str\n  returns: str - the name of the object type.  to_string Gets a string representation of the object. The result has format name[,library]\n to_string(): str\n  returns: str - a string representation of the object.  Static methods from_string Parses a string to get descriptor fields and returns them as a Descriptor. The string must have format name[,library]\nThrows a ConfigException if the descriptor string has the wrong format.\n static from_string(value: str): TypeDescriptor\n  value: str - a string to parse. returns: TypeDescriptor - a newly created Descriptor.  ","description":"The TypeDescriptor class stores a reference to a type represented by the type name and library (module) where the type is defined.\n","image":null,"permalink":"/python/commons/reflect/type_descriptor/","subtitle":null,"tags":null,"title":"TypeDescriptor"},{"content":"Description The TypeMatcher class allows you to match value types based on equality.\nImportant points\n This class has symmetric implementation across all languages supported by the Pip.Services toolkit and it is used to support dynamic data processing.  Methods MatchType Matches expected type to an actual type. The types can be specified as types, type names or TypeCode.\n (c *TTypeMatcher) MatchType(expectedType interface{}, actualType refl.Type) bool\n  expectedType: interface{} - expected type to match. actualType: refl.Type - actual type to match defined by type code. returns: bool - true if types are matching and false if they don\u0026rsquo;t.  MatchTypeByName  (c *TTypeMatcher) MatchTypeByName(expectedType string, actualType refl.Type) bool\n  expectedType: string - expected type name to match. actualType: refl.Type - actual type to match defined by a type code. returns: bool - true if types are matching and false if they don\u0026rsquo;t.  MatchValueType! Note: this is not implemented for this language yet\nMatches expected type to a type of a value. The expected type can be specified by a type, type name or TypeCode.\n public static matchValueType(expectedType: any, actualValue: any): bool\n  expectedType: any - expected type to match. actualValue: any - value to match its type to the expected one. returns: bool - true if types are matching and false if they don\u0026rsquo;t.  MatchValueTypeByName! Note: this is not implemented for this language yet\nMatches expected type to a type of a value.\n public static matchValueTypeByName(expectedType: string, actualValue: any): bool\n  expectedType: any - expected type name to match. actualValue: any - value to match its type to the expected one. returns: bool - true if types are matching and false if they don\u0026rsquo;t.  See also   TypeCode   ","description":"Helper class that allows you to match value types based on equality.\n","image":null,"permalink":"/golang/commons/reflect/type_matcher/","subtitle":null,"tags":null,"title":"TypeMatcher"},{"content":"Description The TypeMatcher class allows you to match value types based on equality.\nImportant points\n This class has symmetric implementation across all languages supported by the Pip.Services toolkit and it is used to support dynamic data processing.  Static methods MatchType Matches an expected type to an actual type. The types can be specified as types, type names or TypeCode.\n public static bool MatchType(object expectedType, Type actualType)\n  expectedType: object - expected type to match. actualType: Type - actual type to match. returns: bool - true if the types are matching and false if they don\u0026rsquo;t.  MatchTypeByName Matches an expected type to type specified by its name. The types can be specified as types, type names or TypeCode.\n public static bool MatchTypeByName(expectedType: string, Type actualType)\n  expectedType: string - expected type name to match. actualType: Type - actual type to match defined by type code. returns: bool - true if the types are matching and false if they don\u0026rsquo;t.  MatchValue Matches an expected type to a type of a value. The expected type can be specified by a type, type name or TypeCode.\n public static bool MatchValue(object expectedType, object actualValue)\n  expectedType: object - expected type to match. actualValue: object - value to match its type to the expected one. returns: bool - true if the types are matching and false if they don\u0026rsquo;t.  MatchValueByName Matches expected type to a type of a value.\n public static bool MatchValueByName(string expectedType, object actualValue)\n  expectedType: string - expected type name to match. actualValue: object - value to match its type to the expected one. returns: bool - true if the types are matching and false if they don\u0026rsquo;t.  See also   TypeCode   ","description":"Helper class that allows you to match value types based on equality.\n","image":null,"permalink":"/net/commons/reflect/type_matcher/","subtitle":null,"tags":null,"title":"TypeMatcher"},{"content":"Description The TypeMatcher class allows you to match value types based on equality.\nImportant points\n This class has symmetric implementation across all languages supported by the Pip.Services toolkit and it is used to support dynamic data processing.  Static methods matchType Matches the expected type to an actual type. The types can be specified as types, type names or TypeCode.\n public static matchType(expectedType: any, actualType: TypeCode, actualValue: any = null): boolean\n  expectedType: any - expected type to match. actualType: TypeCode - actual type to match. actualValue: any - optional value to match its type to the expected one. returns: boolean - true if types are matching and false if they don\u0026rsquo;t.  matchTypeByName Matches the expected type to an actual type.\n public static matchTypeByName(expectedType: string, actualType: TypeCode, actualValue: any = null): boolean\n  expectedType: string - expected type name to match. actualType: TypeCode - actual type to match defined by the type code. actualValue: any - optional value to match its type to the expected one. returns: boolean - true if types are matching and false if they don\u0026rsquo;t.  matchValueType Matches expected type to a type of a value. The expected type can be specified by a type, type name or TypeCode.\n public static matchValueType(expectedType: any, actualValue: any): boolean\n  expectedType: any - expected type to match. actualValue: any - value to match its type to the expected one. returns: boolean - true if types are matching and false if they don\u0026rsquo;t.  matchValueTypeByName Matches an expected type to a type of a value.\n public static matchValueTypeByName(expectedType: string, actualValue: any): boolean\n  expectedType: any - expected type name to match. actualValue: any - value to match its type to the expected one. returns: boolean - true if types are matching and false if they don\u0026rsquo;t.  See also   TypeCode   ","description":"Helper class that allows you to match value types based on equality.\n","image":null,"permalink":"/node/commons/reflect/type_matcher/","subtitle":null,"tags":null,"title":"TypeMatcher"},{"content":"Description The TypeMatcher class allows you to match value types based on equality.\nImportant points\n This class has symmetric implementation across all languages supported by the Pip.Services toolkit and it is used to support dynamic data processing.  Static methods match_type Matches expected type to an actual type. The types can be specified as types, type names or TypeCode.\n static match_type(expected_type: Any, actual_type: TypeCode, actual_value: Any = None): bool\n  expected_type: Any - an expected type to match. actual_type: TypeCode - an actual type to match. actual_value: Any - an optional value to match its type to the expected one. returns: bool - true if types are matching and false if they don\u0026rsquo;t.  match_type_by_name  static match_type_by_name(expected_type: str, actual_type: TypeCode, actual_value: Any = None): bool\n  expected_type: str - an expected type name to match. actual_type: TypeCode - an actual type to match defined by type code. actual_value: Any - an optional value to match its type to the expected one. returns: bool - true if types are matching and false if they don\u0026rsquo;t.  match_value_type Matches expected type to a type of a value. The expected type can be specified by a type, type name or TypeCode.\n static match_value_type(expected_type: Any, actual_value: Any): bool\n  expected_type: Any - an expected type to match. actual_value: Any - a value to match its type to the expected one. returns: bool - true if types are matching and false if they don\u0026rsquo;t.  match_value_type_by_name Matches expected type to a type of a value.\n static match_value_type_by_name(expected_type: str, actual_value: Any): bool\n  expected_type: Any - an expected type name to match. actual_value: Any - a value to match its type to the expected one. returns: bool - true if types are matching and false if they don\u0026rsquo;t.  See also   TypeCode   ","description":"Helper class that allows you to match value types based on equality.\n","image":null,"permalink":"/python/commons/reflect/type_matcher/","subtitle":null,"tags":null,"title":"TypeMatcher"},{"content":"Description The TypeReflector class allows you to examine the type of an object, and create instancies of objects based on their type.\nImportant points\n This class has a symmetric implementation across all languages supported by the Pip.Services toolkit and used to support dynamic data processing. Because all languages have different casing and case sensitivity rules, the TypeReflector class treats all type names as case insensitive.  Methods CreateInstanceByType Creates an instance of an object type.\n (c *TTypeReflector) CreateInstanceByType(typ refl.Type, args \u0026hellip;interface{}) (interface{}, error)\n  typ: refl.Type - object type (factory function) to create. args: \u0026hellip;interface{} - arguments for the object constructor. returns: (interface{}, error) - created object instance.  CreateInstanceByDescriptor Creates an instance of an object type specified by a type descriptor.\n (c *TTypeReflector) CreateInstanceByDescriptor(typ *TypeDescriptor, args \u0026hellip;interface{}) (interface{}, error)\n  typ: *TypeDescriptor - type descriptor that points to an object type args: \u0026hellip;interface{} - arguments for the object constructor. returns: (interface{}, error) - created object instance.  CreateInstanceByType Creates an instance of an object type.\n (c *TTypeReflector) CreateInstanceByType(typ refl.Type, args \u0026hellip;interface{}) (interface{}, error)\n  type: refl.Type - object type (factory function) to create. args: \u0026hellip;interface{} - arguments for the object constructor. returns: (interface{}, error) - created object instance.  GetType Gets an object\u0026rsquo;s type by its name and library where it is defined.\n (c *TTypeReflector) GetType(name string, pkg string) refl.Type\n  name: string - object type name. pkg: string - library where the type is defined returns: refl.Type - object type or nil is the type wasn\u0026rsquo;t found.  GetTypeByDescriptor Gets an object\u0026rsquo;s type by type descriptor.\n (c *TTypeReflector) GetTypeByDescriptor(typ *TypeDescriptor) refl.Type\n  typ: *TypeDescriptor - type descriptor that points to an object type returns: refl.Type - object type or nil is the type wasn\u0026rsquo;t found.  IsPrimitive! Note: this is not implemented for this language yet\nChecks if a value has a primitive type.\nPrimitive types are: numbers, strings, booleans, date and time. Complex (non-primitive types are): objects, maps and arrays.\nSee TypeConverter.ToTypeCode, TypeCode\n public static isPrimitive(value: any): bool\n  value: any - value to check returns:boolean - true if the value has primitive type and false if value type is complex.  Examples descriptor := NewTypeDescriptor(\u0026#34;MyObject\u0026#34;, \u0026#34;mylibrary\u0026#34;); TypeReflector.GetTypeByDescriptor(descriptor); myObj = TypeReflector.CreateInstanceByDescriptor(descriptor); See also   TypeDescriptor   ","description":"Helper class that allows you to examine the type of an object, and create instancies of objects based on their type.\n","image":null,"permalink":"/golang/commons/reflect/type_reflector/","subtitle":null,"tags":null,"title":"TypeReflector"},{"content":"Description The TypeReflector class allows you to examine the type of an object and create instancies of objects based on their type.\nImportant points\n This class has symmetric implementation across all languages supported by the Pip.Services toolkit and used to support dynamic data processing. Because all languages have different casing and case sensitivity rules, the TypeReflector class treats all type names as case insensitive.  Static methods CreateInstance Creates an instance of an object type specified by its name and library where it is defined.\n public static object CreateInstance(string name, string library, params object[] args)\n  name: string - object type name. library: string - library (module) where the object type is defined. args: object[] - arguments for the object constructor. returns: object - created object instance.  CreateInstance Creates an instance of an object type specified by its name.\n public static object CreateInstance(string name, params object[] args)\n  name: string - object type name. args: object[] - arguments for the object\u0026rsquo;s constructor. returns: object - created object\u0026rsquo;s instance.  CreateInstanceByDescriptor Creates an instance of an object type specified by a type descriptor.\n public static object CreateInstanceByDescriptor(TypeDescriptor descriptor, params object[] args)\n  descriptor: TypeDescriptor - type descriptor that points to an object type args: object[] - arguments for the object\u0026rsquo;s constructor. returns: object - created object instance.  CreateInstanceByType Creates an instance of an object type.\n public static object CreateInstanceByType(Type type, params object[] args)\n  type: Type - object type (factory function) to create. args: object[] - arguments for the object\u0026rsquo;s constructor. returns: object - created object\u0026rsquo;s instance.  GetType Gets an object\u0026rsquo;s type by its name and library where it is defined.\n public static Type GetType(string name, string library)\n  name: string - object\u0026rsquo;s type name. library: string - library where the type is defined returns: Type - the object type or null is the type wasn\u0026rsquo;t found.  GetType Gets an object\u0026rsquo;s type by its name and library where it is defined.\n public static Type GetType(string name, string library)\n  name: string - object type name. library: string - library where the type is defined returns: Type - object type or null is the type wasn\u0026rsquo;t found.  GetTypeByDescriptor Gets an object type by its type descriptor.\n public static Type GetTypeByDescriptor(TypeDescriptor descriptor)\n  descriptor: TypeDescriptor - type descriptor that points to an object type returns: Type - object type or null is the type wasn\u0026rsquo;t found.  IsPrimitive! Note: this method is not available for this language\nChecks if value has a primitive type.\nPrimitive types are: numbers, strings, booleans, date and time. Complex (non-primitive types are): objects, maps and arrays.\nSee TypeConverter.ToTypeCode, TypeCode\n public static bool IsPrimitive(object value)\n  value: object - value to check returns: bool - true if the value has primitive type and false if value type is complex.  Examples var descriptor = new TypeDescriptor(\u0026#34;MyObject\u0026#34;, \u0026#34;mylibrary\u0026#34;); TypeReflector.GetTypeByDescriptor(descriptor); var myObj = TypeReflector.CreateInstanceByDescriptor(descriptor); TypeDescriptor.IsPrimitive(myObject); // Result: false TypeDescriptor.IsPrimitive(123); // Result: true  See also   TypeDescriptor   ","description":"Helper class that allows you to examine the type of an object and create instancies of objects based on their type.\n","image":null,"permalink":"/net/commons/reflect/type_reflector/","subtitle":null,"tags":null,"title":"TypeReflector"},{"content":"Description The TypeReflector class allows you to examine the type of an object, and create instancies of objects based on their type.\nImportant points\n This class has symmetric implementation across all languages supported by the Pip.Services toolkit and used to support dynamic data processing. Because all languages have different casing and case sensitivity rules, the TypeReflector class treats all type names as case insensitive.  Static methods createInstanceByType Creates an instance of an object type.\n public static createInstanceByType(type: any, \u0026hellip;args: any[]): any\n  type: any - object type (factory function) to create. args: any[] - arguments for the object constructor. returns: any - created object\u0026rsquo;s instance.  createInstanceByDescriptor Creates an instance of an object type specified by a type descriptor.\n public static createInstanceByDescriptor(descriptor: TypeDescriptor, \u0026hellip;args: any[]): any\n  descriptor: TypeDescriptor - type descriptor that points to an object type args: any[] - arguments for the object constructor. returns: any - created object instance.  createInstanceByType Creates an instance of an object\u0026rsquo;s type.\n public static createInstanceByType(type: any, \u0026hellip;args: any[]): any\n  type: any - object type (factory function) to create. args: any[] - arguments for the object\u0026rsquo;s constructor. returns: any - created object instance.  getType Gets an object\u0026rsquo;s type by its name and library where it is defined.\n public static getType(name: string, library: string): any\n  name: string - object type name. library: string - library where the type is defined. returns: any - object type or null is the type wasn\u0026rsquo;t found.  getTypeByDescriptor Gets an object\u0026rsquo;s type by type descriptor.\n public static getTypeByDescriptor(descriptor: TypeDescriptor): any\n  descriptor: TypeDescriptor - type descriptor that points to an object type. returns: any - object type or null is the type wasn\u0026rsquo;t found.  isPrimitive Checks if a value has a primitive type.\nPrimitive types are: numbers, strings, booleans, date and time. Complex (non-primitive types are): objects, maps and arrays.\nSee TypeConverter.toTypeCode, TypeCode\n public static isPrimitive(value: any): boolean\n  value: any - value to check returns:boolean - true if the value has primitive type and false if value type is complex.  Examples let descriptor = new TypeDescriptor(\u0026#34;MyObject\u0026#34;, \u0026#34;mylibrary\u0026#34;); Typeeflector.getTypeByDescriptor(descriptor); let myObj = TypeReflector.createInstanceByDescriptor(descriptor); TypeDescriptor.isPrimitive(myObject); // Result: false TypeDescriptor.isPrimitive(123); // Result: true  See also   TypeDescriptor   ","description":"Helper class that allows you to examine the type of an object, and create instancies of objects based on their type.\n","image":null,"permalink":"/node/commons/reflect/type_reflector/","subtitle":null,"tags":null,"title":"TypeReflector"},{"content":"Description The TypeReflector class allows you to examine the type of an object, and create instancies of objects based on their type.\nImportant points\n This class has symmetric implementation across all languages supported by Pip.Services toolkit and used to support dynamic data processing. Because all languages have different casing and case sensitivity rules, the TypeReflector class treats all type names as case insensitive.  Static methods create_instance_by_type Creates an instance of an object type.\n static create_instance_by_type(obj_type: Any, *args: Any): Any\n  type: Any - an object type (factory function) to create. args: Any - arguments for the object constructor. returns: Any - the created object instance.  create_instance_by_descriptor Creates an instance of an object type specified by type descriptor.\n static create_instance_by_descriptor(descriptor: TypeDescriptor, *args: Any): Any\n  descriptor: TypeDescriptor - a type descriptor that points to an object type args: Any - arguments for the object constructor. returns: Any - the created object instance.  create_instance_by_type Creates an instance of an object type.\n static create_instance_by_type(obj_type: Any, *args: Any): Any:\n  type: Any - an object type (factory function) to create. args: Any - arguments for the object constructor. returns: Any - the created object instance.  get_type Gets object type by its name and library where it is defined.\n static get_type(name: str, library: str): Any\n  name: str - an object type name. library: str - a library where the type is defined returns: Any - the object type or None is the type wasn\u0026rsquo;t found.  get_type_by_descriptor Gets object type by type descriptor.\n static get_type_by_descriptor(descriptor: TypeDescriptor): Any\n  descriptor: TypeDescriptor - a type descriptor that points to an object type returns: Any - the object type or None is the type wasn\u0026rsquo;t found.  is_primitive Checks if value has primitive type.\nPrimitive types are: numbers, strings, booleans, date and time. Complex (non-primitive types are): objects, maps and arrays.\nSee TypeConverter.to_type_code, TypeCode\n static is_primitive(value: Any): bool\n  value: Any - a value to check returns: bool - true if the value has primitive type and false if value type is complex.  Examples descriptor = TypeDescriptor(\u0026#34;MyObject\u0026#34;, \u0026#34;mylibrary\u0026#34;) Typeeflector.get_type_by_descriptor(descriptor) myObj = TypeReflector.create_instance_by_descriptor(descriptor) TypeDescriptor.is_primitive(myObject) # Result: false TypeDescriptor.is_primitive(123) # Result: true See also   TypeDescriptor   ","description":"Helper class that allows you to examine the type of an object, and create instancies of objects based on their type.\n","image":null,"permalink":"/python/commons/reflect/type_reflector/","subtitle":null,"tags":null,"title":"TypeReflector"},{"content":"Extends: AbstractVariantOperations\nDescription The TypeSafeVariantOperations class allows you to implement a strongly typed (type safe) variant manager object.\nInstance methods convert Converts a variant to a specified type.\n public convert(value: Variant, newType: VariantType): Variant\n  value: Variant - variant value to be converted. newType: VariantType - type of object to be returned. returns: Variant - converted Variant value.  ","description":"Implements a strongly typed (type safe) variant operations manager object.\n","image":null,"permalink":"/node/expressions/variants/type_safe_variant_operations/","subtitle":null,"tags":null,"title":"TypeSafeVariantOperations"},{"content":"Extends: AbstractVariantOperations\nDescription The TypeUnsafeVariantOperations class allows you to implement a type unsafe variant operations manager object.\nInstance methods convert Converts a variant to a specified type.\n public convert(value: Variant, newType: VariantType): Variant\n  value: Variant - variant value to be converted. newType: VariantType - type of object to be returned. returns: Variant - converted Variant value.  ","description":"Implements a type unsafe variant operations manager object.\n","image":null,"permalink":"/node/expressions/variants/type_unsafe_variant_operations/","subtitle":null,"tags":null,"title":"TypeUnsafeVariantOperations"},{"content":"Description The UnauthorizedError class is used to manage access errors caused by missing user identity (authentication error) or incorrect security permissions (authorization error).\nConstructors NewUnauthorizedError Creates an error instance and assigns its values.\n NewUnauthorizedError(correlationId, code, message string) *ApplicationError\n  correlationId: string - (optional) unique transaction id used to trace execution through the call chain. code: string - (optional) unique error code. Default: \u0026ldquo;UNKNOWN\u0026rdquo; message: string - (optional) a human-readable description of the error.  ","description":"Access errors caused by missing user identity (authentication error) or incorrect security permissions (authorization error).\n","image":null,"permalink":"/golang/commons/errors/unauthorized_error/","subtitle":null,"tags":null,"title":"UnauthorizedError"},{"content":"Inherits: ApplicationException\nDescription The UnauthorizedException class is used to manage access errors caused by missing user identity (authentication error) or incorrect security permissions (authorization error).\nConstructors Creates an error instance and assigns its values.\n public UnauthorizedException(string correlationId = null, string code = null, string message = null)\n  correlationId: string - (optional) unique transaction id used to trace execution through the call chain. code: string - (optional) unique error code. Default: \u0026ldquo;UNKNOWN\u0026rdquo; message: string - (optional) human-readable description of the error.  Creates an error instance with error message\n public UnauthorizedException(string message)\n  message: string - human-readable description of the error.  Creates an error instance and assigns its values.\n public UnauthorizedException(Exception innerException)\n  innerException: Exception - error object  Creates an error instance by processing native C# Exceptions.\n protected UnauthorizedException(SerializationInfo info, StreamingContext context)\n  info: SerializationInfo - serialized information containing the serialized object data about the exception being thrown. context: StreamingContext - streaming context containing contextual information about the source or destination.  ","description":"Access errors caused by missing user identity (authentication error) or incorrect security permissions (authorization error).\n","image":null,"permalink":"/net/commons/errors/unauthorized_exception/","subtitle":null,"tags":null,"title":"UnauthorizedException"},{"content":"Extends: ApplicationException\nDescription The UnauthorizedException class is used to manage access errors caused by missing user identity (authentication error) or incorrect security permissions (authorization error).\nConstructors Creates an error instance and assigns its values.\n public constructor(correlation_id: string = null, code: string = null, message: string = null)\n  correlation_id: string - (optional) unique transaction id used to trace execution through a call chain. code: string - (optional) unique error code. Default: \u0026ldquo;UNKNOWN\u0026rdquo; message: string - (optional) human-readable description of the error.  ","description":"Access errors caused by missing user identity (authentication error) or incorrect security permissions (authorization error).\n","image":null,"permalink":"/node/commons/errors/unauthorized_exception/","subtitle":null,"tags":null,"title":"UnauthorizedException"},{"content":"Implements: ApplicationException\nDescription The UnauthorizedException class is used to manage access errors caused by missing user identity (authentication error) or incorrect security permissions (authorization error).\nConstructors Creates an error instance and assigns its values.\n UnauthorizedException(correlation_id: Optional[str] = None, code: str = None, message: str = None)\n  correlation_id: Optional[str] - (optional) a unique transaction id to trace execution through call chain. code: str - (optional) a unique error code. Default: \u0026ldquo;UNKNOWN\u0026rdquo; message: str - (optional) a human-readable description of the error.  ","description":"Access errors caused by missing user identity (authentication error) or incorrect security permissions (authorization error).\n","image":null,"permalink":"/python/commons/errors/unauthorized_exception/","subtitle":null,"tags":null,"title":"UnauthorizedException"},{"content":"Description The UnknownError class is used to manage unknown or unexpected errors.\nConstructors NewUnknownError Creates an error instance and assigns its values.\n NewUnknownError(correlationId, code, message string) *ApplicationError\n  correlationId: string - (optional) unique transaction id used to trace execution through the call chain. code: string - (optional) unique error code. Default: \u0026ldquo;UNKNOWN\u0026rdquo; message: string - (optional) a human-readable description of the error.  ","description":"Unknown or unexpected errors.\n","image":null,"permalink":"/golang/commons/errors/unknown_error/","subtitle":null,"tags":null,"title":"UnknownError"},{"content":"Inherits: ApplicationException\nDescription The UnknownException class is used to manage unknown or unexpected errors.\nConstructors Creates an error instance and assigns its values.\n public UnknownException(string correlationId = null, string code = null, string message = null)\n  correlationId: string - (optional) unique transaction id used to trace execution through the call chain. code: string - (optional) unique error code. Default: \u0026ldquo;UNKNOWN\u0026rdquo; message: string - (optional) human-readable description of the error.  Creates an error instance with error message\n public UnknownException(string message)\n  message: string - human-readable description of the error.  Creates an error instance and assigns its values.\n public UnknownException(Exception innerException)\n  innerException: Exception - error object  Creates an error instance by processing native C# Exceptions.\n protected UnknownException(SerializationInfo info, StreamingContext context)\n  info: SerializationInfo - serialized information containing the serialized object data about the exception being thrown. context: StreamingContext - streaming context containing contextual information about the source or destination.  ","description":"Unknown or unexpected errors.\n","image":null,"permalink":"/net/commons/errors/unknown_exception/","subtitle":null,"tags":null,"title":"UnknownException"},{"content":"Extends: ApplicationException\nDescription The UnknownException class is used to manage unknown or unexpected errors.\nConstructors Creates an error instance and assigns its values.\n public constructor(correlation_id: string = null, code: string = null, message: string = null)\n  correlation_id: string - (optional) unique transaction id used to trace execution through a call chain. code: string - (optional) unique error code. Default: \u0026ldquo;UNKNOWN\u0026rdquo; message: string - (optional) human-readable description of the error.  ","description":"Unknown or unexpected errors.\n","image":null,"permalink":"/node/commons/errors/unknown_exception/","subtitle":null,"tags":null,"title":"UnknownException"},{"content":"Implements: ApplicationException\nDescription The UnknownException class is used to manage unknown or unexpected errors.\nConstructors Creates an error instance and assigns its values.\n UnknownException(correlation_id: Optional[str] = None, code: str = None, message: str = None)\n  correlation_id: Optional[str] - (optional) a unique transaction id to trace execution through call chain. code: str - (optional) a unique error code. Default: \u0026ldquo;UNKNOWN\u0026rdquo; message: str - (optional) a human-readable description of the error.  ","description":"Unknown or unexpected errors.\n","image":null,"permalink":"/python/commons/errors/unknown_exception/","subtitle":null,"tags":null,"title":"UnknownException"},{"content":"Description The UnsupportedError class is used to manage errors caused by calls to unsupported or not yet implemented functionality.\nConstructors NewUnsupportedError Creates an error instance and assigns its values.\n NewUnsupportedError(correlationId, code, message string) *ApplicationError\n  correlationId: string - (optional) unique transaction id used to trace execution through the call chain. code: string - (optional) unique error code. Default: \u0026ldquo;UNKNOWN\u0026rdquo; message: string - (optional) a human-readable description of the error.  ","description":"Errors caused by calls to unsupported or not yet implemented functionality.\n","image":null,"permalink":"/golang/commons/errors/unsupported_error/","subtitle":null,"tags":null,"title":"UnsupportedError"},{"content":"Inherits: ApplicationException\nDescription The UnsupportedException class is used to manage errors caused by calls to unsupported or not yet implemented functionality.\nConstructors Creates an error instance and assigns its values.\n public UnsupportedException(string correlationId = null, string code = null, string message = null)\n  correlationId: string - (optional) unique transaction id used to trace execution through the call chain. code: string - (optional) unique error code. Default: \u0026ldquo;UNKNOWN\u0026rdquo; message: string - (optional) human-readable description of the error.  Creates an error instance with error message.\n public UnsupportedException(string message)\n  message: string - human-readable description of the error.  Creates an error instance and assigns its values.\n public UnsupportedException(Exception innerException)\n  innerException: Exception - error object  Creates an error instance by processing native C# Exceptions.\n protected UnsupportedException(SerializationInfo info, StreamingContext context)\n  info: SerializationInfo - serialized information containing the serialized object data about the exception being thrown. context: StreamingContext - streaming context containing contextual information about the source or destination.  ","description":"Errors caused by calls to unsupported or not yet implemented functionality.\n","image":null,"permalink":"/net/commons/errors/unsupported_exception/","subtitle":null,"tags":null,"title":"UnsupportedException"},{"content":"Implements: ApplicationException\nDescription The UnsupportedException class is used to manage errors caused by calls to unsupported or not yet implemented functionality.\nConstructors Creates an error instance and assigns its values.\n public constructor(correlation_id: string = null, code: string = null, message: string = null)\n  correlation_id: string - (optional) unique transaction id used to trace execution through the call chain. code: string - (optional) unique error code. Default: \u0026ldquo;UNKNOWN\u0026rdquo;. message: string - (optional) human-readable description of the error.  ","description":"Errors caused by calls to unsupported or not yet implemented functionality.\n","image":null,"permalink":"/node/commons/errors/unsupported_exception/","subtitle":null,"tags":null,"title":"UnsupportedException"},{"content":"Implements: ApplicationException\nDescription The UnsupportedException class is used to manage errors caused by calls to unsupported or not yet implemented functionality.\nConstructors Creates an error instance and assigns its values.\n UnsupportedException(correlation_id: Optional[str] = None, code: str = None, message: str = None)\n  correlation_id: Optional[str] - (optional) a unique transaction id to trace execution through call chain. code: str - (optional) a unique error code. Default: \u0026ldquo;UNKNOWN\u0026rdquo; message: str - (optional) a human-readable description of the error.  ","description":"Errors caused by calls to unsupported or not yet implemented functionality.\n","image":null,"permalink":"/python/commons/errors/unsupported_exception/","subtitle":null,"tags":null,"title":"UnsupportedException"},{"content":"User account management microservice.\n  Registers users and creates their accounts\n  Keeps key user descriptions and settings (about, location, language, theme, \u0026hellip;)\n  Server implementations: NodeJS, Dart\n  Communication protocols: Direct, Commandable HTTP, Commandable GRPC, GRPC\n  Persistence: Memory, Flat Files, MongoDB, Couchbase\n  Deployment options: Monolith, Process, Docker, AWS Lambda\n  Client implementations: NodeJS, .NET, Golang, Dart\n  This microservice has optional dependencies on the following microservices:\n Party Activities - to log user activities (signup, signin, change settings)  ","description":null,"image":null,"permalink":"/microservices/users/accounts/","subtitle":null,"tags":null,"title":"User Accounts Microservice"},{"content":"Keeps list of map invitations.\n Server implementations: NodeJS Communication protocols: Direct, Commandable HTTP, Commandable GRPC, GRPC Persistence: Memory, Flat Files, MongoDB, Couchbase Deployment options: Monolith, Process, Docker, AWS Lambda Client implementations: NodeJS, Golang  ","description":null,"image":null,"permalink":"/microservices/users/user_invitations/","subtitle":null,"tags":null,"title":"User invitations Microservice"},{"content":"Manages roles for user organizations.\n Server implementations: NodeJS Communication protocols: Direct, Commandable HTTP, Commandable GRPC, GRPC Persistence: Memory, Flat Files, MongoDB, Couchbase Deployment options: Monolith, Process, Docker, AWS Lambda Client implementations: NodeJS  ","description":null,"image":null,"permalink":"/microservices/users/user_roles/","subtitle":null,"tags":null,"title":"User roles Microservice"},{"content":"Description The ValidationException class is used to define errors in a schema validation.\nImportant points\n Validation errors are usually generated based in ValidationResult. If using strict mode, warnings will also raise validation exceptions.  Constructors NewValidationError Creates a new instance of validation exception and assigns its values.\n NewValidationError(correlationId string, message string, results []*ValidationResult) *errors.ApplicationError\n  correlationId: string - (optional) unique transaction id used to trace execution through the call chain. message: string - (optional) human-readable description of the error. results: []*ValidationResult - (optional) list of validation results  NewValidationErrorFromResults Creates a new ValidationError based on errors in validation results. If validation results have no errors, then nil is returned.\n NewValidationErrorFromResults(correlationId string, results []*ValidationResult, strict bool) *errors.ApplicationError\n  correlationId: string - transaction id used to trace execution through the call chain. results: []*ValidationResult - list of validation results that may contain errors strict: bool - true to treat warnings as errors.  Methods composeErrorMessage Composes human readable error message based on validation results.\n composeErrorMessage(results []*ValidationResult) string\n  results: []*ValidationResult - list of validation results. returns: string - composed error message.  ThrowValidationErrorIfNeeded Throws ValidationException based on errors in validation results. If validation results have no errors, then no exception is thrown.\n ThrowValidationErrorIfNeeded(correlationId string, results []*ValidationResult, strict bool)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. results: ValidationResult[] - list of validation results that may contain errors strict: bool - true to treat warnings as errors.  See also   BadRequestException   ValidationResult   ","description":"Errors in schema validation.\n","image":null,"permalink":"/golang/commons/validate/validation_exception/","subtitle":null,"tags":null,"title":"ValidationException"},{"content":"Inherits: BadRequestException\nDescription The ValidationException is used to define errors in schema validation.\nImportant points\n Validation errors are usually generated based in ValidationResult. If using strict mode, warnings will also raise validation exceptions.  Constructors Creates a new instance of a validation exception and assigns its values.\n public ValidationException(string correlationId, string message, IList\u0026lt;ValidationResult\u0026gt; results)\n  correlationId: string - (optional) unique transaction id used to trace execution through the call chain. message: string - (optional) human-readable description of the error. results: IList\u0026lt;ValidationResult\u0026gt; - (optional) list of validation results  Creates a new instance of a validation exception and assigns its values.\n public ValidationException(string correlationId, string message)\n  correlationId: string - (optional) unique transaction id used to trace execution through the call chain. message: string - (optional) human-readable description of the error.  Static methods ComposeMessage Composes a human readable error message based on validation results.\n public static string ComposeMessage(IList\u0026lt;ValidationResult\u0026gt; results)\n  results: IList\u0026lt;ValidationResult\u0026gt; - list of validation results. returns: string - composed error message.  FromResults! Note: this method is not available for this language\nCreates a new ValidationException based on errors in validation results. If validation results have no errors, then null is returned.\n public static ValidationException FromResults(correlationId: string, IList\u0026lt;ValidationResult\u0026gt; IList\u0026lt;ValidationResult\u0026gt; results, bool strict)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. results: IList\u0026lt;ValidationResult\u0026gt; - list of validation results that may contain errors. strict: bool - true to treat warnings as errors. returns: ValidationException - newly created ValidationException or null if no errors in found.  ThrowExceptionIfNeeded Throws ValidationException based on errors in validation results. If validation results have no errors, then no exception is thrown.\n public static void ThrowExceptionIfNeeded(string correlationId, IList\u0026lt;ValidationResult\u0026gt; results, bool strict)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. results: IList\u0026lt;ValidationResult\u0026gt; - list of validation results that may contain errors strict: bool - true to treat warnings as errors.  See also   BadRequestException   ValidationResult   ","description":"Errors in schema validation.\n","image":null,"permalink":"/net/commons/validate/validation_exception/","subtitle":null,"tags":null,"title":"ValidationException"},{"content":"Extends: BadRequestException\nDescription The ValidationException is used to define errors in a schema validation.\nImportant points\n Validation errors are usually generated based in ValidationResult. If using strict mode, warnings will also raise validation exceptions.  Constructors Creates a new instance of validation exception and assigns its values.\n public constructor(correlationId: string, message?: string, results?: ValidationResult[])\n  correlationId: string - (optional) unique transaction id used to trace execution through the call chain. message: string - (optional) human-readable description of the error. results: ValidationResult[] - (optional) list of validation results.  Static methods composeMessage Composes human readable error message based on validation results.\n public static composeMessage(results: ValidationResult[]): string\n  results: ValidationResult[] - list of validation results. returns: string - composed error message.  fromResults Creates a new ValidationException based on errors in validation results. If validation results have no errors, then null is returned.\n public static fromResults(correlationId: string, results: ValidationResult[], strict: boolean): ValidationException\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. results: ValidationResult[] - list of validation results that may contain errors. strict: boolean - true to treat warnings as errors. returns: ValidationException - newly created ValidationException or null if no errors were found.  throwExceptionIfNeeded Throws ValidationException based on errors in validation results. If validation results have no errors, then no exception is thrown.\n public static throwExceptionIfNeeded(correlationId: string, results: ValidationResult[], strict: boolean): void\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. results: ValidationResult[] - list of validation results that may contain errors. strict: boolean - true to treat warnings as errors.  See also   BadRequestException   ValidationResult   ","description":"Errors in schema validation.\n","image":null,"permalink":"/node/commons/validate/validation_exception/","subtitle":null,"tags":null,"title":"ValidationException"},{"content":"Implements: BadRequestException\nDescription The ValidationException is used to define errors in schema validation.\nImportant points\n Validation errors are usually generated based in ValidationResult. If using strict mode, warnings will also raise validation exceptions.  Constructors Creates a new instance of validation exception and assigns its values.\n ValidationException(correlation_id: Optional[str], message: Optional[str], results: List[ValidationResult])\n  correlation_id: Optional[str] - (optional) a unique transaction id to trace execution through call chain. message: Optional[str] - (optional) a human-readable description of the error. results: List[ValidationResult] - (optional) a list of validation results  Static methods compose_message Composes a human readable error message based on validation results.\n static compose_message(results: List[ValidationResult]): str\n  results: List[ValidationResult] - a list of validation results. returns: str - a composed error message.  from_results Creates a new ValidationException based on errors in validation results. If validation results have no errors, then None is returned.\n static from_results(correlation_id: Optional[str], results: List[ValidationResult], strict: bool)\n  correlation_id: Optional[str] - (optional) transaction id to trace execution through call chain. results: List[ValidationResult] - list of validation results that may contain errors strict: bool - true to treat warnings as errors. returns: ValidationException - a newly created ValidationException or None if no errors in found.  throw_exception_if_needed Throws ValidationException based on errors in validation results. If validation results have no errors, then no exception is thrown.\n static throw_exception_if_needed(correlation_id: Optional[str], results: List[ValidationResult], strict: bool)\n  correlation_id: Optional[str] - (optional) transaction id to trace execution through call chain. results: List[ValidationResult] - list of validation results that may contain errors strict: bool - true to treat warnings as errors.  See also   BadRequestException   ValidationResult   ","description":"Errors in schema validation.\n","image":null,"permalink":"/python/commons/validate/validation_exception/","subtitle":null,"tags":null,"title":"ValidationException"},{"content":"Description The ValidationResult class provides a representation of the result generated by a schema validation.\nConstructors NewValidationResult Creates a new instance of a validation result and sets its values. See ValidationResultType\n NewValidationResult(path string, typ ValidationResultType, code string, message string, expected interface{}, actual interface{}) *ValidationResult\n  path: string - dot notation path of the validated element. typ: ValidationResultType - type of the validation result: Information, Warning, or Error. code: string - error code. message: string - human readable message. expected: interface{} - value expected by a schema validation. actual: interface{} - actual value found by a schema validation.  Methods Actual Gets the actual value found by a schema validation.\n (c *ValidationResult) Actual() interface{}\n  returns: interface{} - actual value.  Code Gets the error code.\n (c *ValidationResult) Code() string\n  returns: string - error code  Expected Gets the value expected by a schema validation.\n (c *ValidationResult) Expected() interface{}\n  returns: interface{} - expected value.  Message Gets the human readable message.\n (c *ValidationResult) Message() string\n  returns: string - result message.  Path Gets the dot notation path of the validated element.\n (c *ValidationResult) Path() string\n  returns: string - path of the validated element.  getType Gets dot notation path of the validated element.\n (c *ValidationResult) Type() ValidationResultType\n  returns: ValidationResultType - type of the validation result.  ","description":"Result generated by a schema validation\n","image":null,"permalink":"/golang/commons/validate/validation_result/","subtitle":null,"tags":null,"title":"ValidationResult"},{"content":"Description The ValidationResult class provides a representation of the result generated by a schema validation.\nConstructors Creates a new instance of a validation ressult and sets its values. See ValidationResultType\n public ValidationResult(string path, ValidationResultType type, string code, string message, object expected, object actual)\n  path: string - dot notation path of the validated element. type: ValidationResultType = null - type of the validation result: Information, Warning, or Error. code: string - error code. message: string - human readable message. expected: object - value expected by schema validation. actual: object - actual value found by schema validation.  Creates a new instance of validation result.\n public ValidationResult()\n Properties Path Gets and sets a dot notation path of the validated element.\n public string Path { get; set; }\n Type Gets and sets dot notation path of the validated element.\n public ValidationResultType Type { get; set; }\n Code Gets and sets the error code.\n publicstring Code { get; set; }\n Message Gets and sets the human readable message.\n publicstring Message { get; set; }\n Expected Gets and sets the value expected by a schema validation.\n publicobject Expected { get; set; }\n Actual Gets and sets the actual value found by a schema validation.\n publicobject Actual { get; set; }\n ","description":"Result generated by a schema validation.\n","image":null,"permalink":"/net/commons/validate/validation_result/","subtitle":null,"tags":null,"title":"ValidationResult"},{"content":"Description The ValidationResult class provides a representation of the result generated by a schema validation.\nConstructors Creates a new instance of a validation ressult and sets its values. See ValidationResultType\n public constructor(path: string = null, type: ValidationResultType = null, code: string = null, message: string = null, expected: any = null, actual: any = null)\n  path: string - dot notation path of the validated element. type: ValidationResultType = null - type of the validation result: Information, Warning, or Error. code: string - error code. message: string - human readable message. expected: any - value expected by a schema validation. actual: any - actual value found by a schema validation.  Instance methods getActual Gets the actual value found by a schema validation.\n public getActual(): any\n  returns: any - actual value.  getCode Gets the error code.\n public getCode(): string\n  returns: string - error code  getExpected Gets the value expected by a schema validation.\n public getExpected(): any\n  returns: any - expected value.  getMessage Gets the human readable message.\n public getMessage(): string\n  returns: string - result message.  getPath Gets the dot notation path of the validated element.\n public getPath(): string\n  returns: string - path of the validated element.  getType Gets the dot notation path of the validated element.\n public getType(): ValidationResultType\n  returns: ValidationResultType - type of the validation result.  toJSON Returns the validation result in JSON format.\n public toJSON(): object\n ","description":"Result generated by a schema validation.\n","image":null,"permalink":"/node/commons/validate/validation_result/","subtitle":null,"tags":null,"title":"ValidationResult"},{"content":"Description The ValidationResult class provides a representation of the result generated by a schema validation.\nConstructors Creates a new instance of a validation result and sets its values. See ValidationResultType\n ValidationResult(path: str = None, type: ValidationResultType = None, code: str = None, message: str = None, expected: Any = None, actual: Any = None)\n  path: str - a dot notation path of the validated element. type: ValidationResultType - a type of the validation result: Information, Warning, or Error. code: str - an error code. message: str - a human readable message. expected: Any - an value expected by schema validation. actual: Any - an actual value found by schema validation.  Instance methods get_actual Gets the actual value found by schema validation.\n get_actual(): Any\n  returns: Any - the actual value.  get_code Gets the error code.\n get_code(): str\n  returns: str - the error code  get_expected Gets the value expected by schema validation.\n get_expected(): Any\n  returns: Any - the expected value.  get_message Gets the human readable message.\n get_message(): str\n  returns: str - the result message.  get_path Gets dot notation path of the validated element.\n get_path(): str\n  returns: str - the path of the validated element.  get_type Gets dot notation path of the validated element.\n get_type(): ValidationResultType\n  returns: ValidationResultType - the type of the validation result.  to_json Returns the validation result in JSON format.\n to_json(): object\n ","description":"Result generated by a schema validation\n","image":null,"permalink":"/python/commons/validate/validation_result/","subtitle":null,"tags":null,"title":"ValidationResult"},{"content":"Description The ValidationResultType class defines the types of validation results generated by validation schemas.\nEnumeration members  Information = iota - General information (not an error). Warning = iota - Warning about something suspecious. In strict mode is treated as an error Error = iota - Validation error.  See also   ValidationResult   ","description":"Types of validation results generated by validation schemas.\n","image":null,"permalink":"/golang/commons/validate/validation_result_type/","subtitle":null,"tags":null,"title":"ValidationResultType"},{"content":"Description The ValidationResultType class defines the types of validation results generated by validation schemas.\nEnumeration members  Information = 0 - General information (not an error). Warning = 1 - Warning about something suspecious. In strict mode is treated as error. Error = 2 - Validation error.  See also   ValidationResult   ","description":"Types of validation results generated by validation schemas.\n","image":null,"permalink":"/net/commons/validate/validation_result_type/","subtitle":null,"tags":null,"title":"ValidationResultType"},{"content":"Description The ValidationResultType class defines the types of validation results generated by validation schemas.\nEnumeration members  Information = 0 - General information (not an error). Warning = 1 - Warning about something suspecious. In strict mode is treated as error Error = 2 - Validation error.  See also   ValidationResult   ","description":"Types of validation results generated by validation schemas.\n","image":null,"permalink":"/node/commons/validate/validation_result_type/","subtitle":null,"tags":null,"title":"ValidationResultType"},{"content":"Description The ValidationResultType class defines the types of validation results generated by validation schemas.\nEnumeration members  Information = 0 - General information (not an error). Warning = 1 - Warning about something suspecious. In strict mode is treated as error Error = 2 - Validation error.  See also   ValidationResult   ","description":"Types of validation results generated by validation schemas.\n","image":null,"permalink":"/python/commons/validate/validation_result_type/","subtitle":null,"tags":null,"title":"ValidationResultType"},{"content":"Description The ValueComparisonRule class allows you to create a validation rule that compares a value to a constant.\nConstructors NewValueComparisonRule Creates a new validation rule and sets its values.\n NewValueComparisonRule(operation string, value interface{}) *ValueComparisonRule\n  operation: string - comparison operation: \u0026quot;==\u0026quot; (\u0026quot;=\u0026quot;, \u0026ldquo;EQ\u0026rdquo;), \u0026ldquo;!= \u0026quot; (\u0026quot;\u0026lt;\u0026gt;\u0026rdquo;, \u0026ldquo;NE\u0026rdquo;); \u0026ldquo;\u0026lt;\u0026quot;/\u0026quot;\u0026gt;\u0026rdquo; (\u0026ldquo;LT\u0026rdquo;/\u0026ldquo;GT\u0026rdquo;), \u0026ldquo;\u0026lt;=\u0026quot;/\u0026quot;\u0026gt;=\u0026rdquo; (\u0026ldquo;LE\u0026rdquo;/\u0026ldquo;GE\u0026rdquo;); \u0026ldquo;LIKE\u0026rdquo;. value: interface{} - constant value to compare to  Methods Validate Validates a given value against this rule.\n (c *ValueComparisonRule) Validate(path string, schema ISchema, value interface{}) []*ValidationResult\n  path: string - dot notation path to the value. schema: ISchema - schema this rule is called from value: interface{} - value to be validated. results: []*ValidationResult - list with validation results to add new results.  Examples var schema = NewSchema() .WithRule(NewValueComparisonRule(\u0026#34;EQ\u0026#34;, 1)); schema.Validate(1); // Result: no errors schema.Validate(2); // Result: 2 is not equal to 1 See also   IValidationRule   ","description":"Validation rule that compares a value to a constant.\n","image":null,"permalink":"/golang/commons/validate/value_comparison_rule/","subtitle":null,"tags":null,"title":"ValueComparisonRule"},{"content":"Inherits: IValidationRule\nDescription The ValueComparisonRule class allows you to create a validation rule that compares a value to a constant.\nConstructors Creates a new validation rule and sets its values.\n public ValueComparisonRule(string operation, object value)\n  operation: string - comparison operation: \u0026quot;==\u0026quot; (\u0026quot;=\u0026quot;, \u0026ldquo;EQ\u0026rdquo;), \u0026ldquo;!= \u0026quot; (\u0026quot;\u0026lt;\u0026gt;\u0026rdquo;, \u0026ldquo;NE\u0026rdquo;); \u0026ldquo;\u0026lt;\u0026quot;/\u0026quot;\u0026gt;\u0026rdquo; (\u0026ldquo;LT\u0026rdquo;/\u0026ldquo;GT\u0026rdquo;), \u0026ldquo;\u0026lt;=\u0026quot;/\u0026quot;\u0026gt;=\u0026rdquo; (\u0026ldquo;LE\u0026rdquo;/\u0026ldquo;GE\u0026rdquo;); \u0026ldquo;LIKE\u0026rdquo;. value: object - constant value to compare to  Instance methods Validate Validates a given value against this rule.\n public void Validate(string path, Schema schema, object value, List\u0026lt;ValidationResult\u0026gt; results)\n  path: string - dot notation path to the value. schema: Schema - schema this rule is called from value: object - value to be validated. results: List\u0026lt;ValidationResult\u0026gt; - list with validation results to add new results.  Examples var schema = new Schema().WithRule(new ValueComparisonRule(\u0026#34;EQ\u0026#34;, 1)); schema.Validate(1); // Result: no errors schema.Validate(2); // Result: 2 is not equal to 1 See also   IValidationRule   ","description":"Validation rule that compares a value to a constant.\n","image":null,"permalink":"/net/commons/validate/value_comparison_rule/","subtitle":null,"tags":null,"title":"ValueComparisonRule"},{"content":"Implements: IValidationRule\nDescription The ValueComparisonRule class allows you to create a validation rule that compares a value to a constant.\nConstructors Creates a new validation rule and sets its values.\n public constructor(operation: string, value: any)\n  operation: string - comparison operation: \u0026quot;==\u0026quot; (\u0026quot;=\u0026quot;, \u0026ldquo;EQ\u0026rdquo;), \u0026ldquo;!= \u0026quot; (\u0026quot;\u0026lt;\u0026gt;\u0026rdquo;, \u0026ldquo;NE\u0026rdquo;); \u0026ldquo;\u0026lt;\u0026quot;/\u0026quot;\u0026gt;\u0026rdquo; (\u0026ldquo;LT\u0026rdquo;/\u0026ldquo;GT\u0026rdquo;), \u0026ldquo;\u0026lt;=\u0026quot;/\u0026quot;\u0026gt;=\u0026rdquo; (\u0026ldquo;LE\u0026rdquo;/\u0026ldquo;GE\u0026rdquo;); \u0026ldquo;LIKE\u0026rdquo;. value: any - constant value to compare to  Instance methods validate Validates a given value against this rule.\n public validate(path: string, schema: Schema, value: any, results: ValidationResult[]): void\n  path: string - dot notation path to the value. schema: Schema - schema this rule is called from value: any - value to be validated. results: ValidationResult[] - list with validation results to add new results.  Examples let schema = Schema().withRule(ValueComparisonRule(\u0026#34;EQ\u0026#34;, 1)) schema.validate(1) // Result: no errors schema.validate(2) // Result: 2 is not equal to 1 See also   IValidationRule   ","description":"Validation rule that compares a value to a constant.\n","image":null,"permalink":"/node/commons/validate/value_comparison_rule/","subtitle":null,"tags":null,"title":"ValueComparisonRule"},{"content":"Implements: IValidationRule\nDescription The ValueComparisonRule class allows you to create a validation rule that compares a value to a constant.\nConstructors Creates a new validation rule and sets its values.\n ValueComparisonRule(operation: str, value: Any)\n  operation: str - a comparison operation: \u0026quot;==\u0026quot; (\u0026quot;=\u0026quot;, \u0026ldquo;EQ\u0026rdquo;), \u0026ldquo;!= \u0026quot; (\u0026quot;\u0026lt;\u0026gt;\u0026rdquo;, \u0026ldquo;NE\u0026rdquo;); \u0026ldquo;\u0026lt;\u0026quot;/\u0026quot;\u0026gt;\u0026rdquo; (\u0026ldquo;LT\u0026rdquo;/\u0026ldquo;GT\u0026rdquo;), \u0026ldquo;\u0026lt;=\u0026quot;/\u0026quot;\u0026gt;=\u0026rdquo; (\u0026ldquo;LE\u0026rdquo;/\u0026ldquo;GE\u0026rdquo;); \u0026ldquo;LIKE\u0026rdquo;. value: Any - a constant value to compare to  Instance methods validate Validates a given value against this rule.\n validate(path: str, schema: Schema, value: Any, results: List[ValidationResult])\n  path: str - a dot notation path to the value. schema: Schema - a schema this rule is called from value: Any - a value to be validated. results: List[ValidationResult] - a list with validation results to add new results.  Examples schema = Schema().with_rule(ValueComparisonRule(\u0026#34;EQ\u0026#34;, 1)) schema.validate(1) # Result: no errors schema.validate(2) # Result: 2 is not equal to 1 See also   IValidationRule   ","description":"Validation rule that compares a value to a constant.\n","image":null,"permalink":"/python/commons/validate/value_comparison_rule/","subtitle":null,"tags":null,"title":"ValueComparisonRule"},{"content":"Implements: IVariable\nDescription The Variable class allows you to implement a variable holder object.\nConstructors  public constructor(name: string, value?: Variant)\n  name: string - name of this variable. value: Variant - variable\u0026rsquo;s value.  Properties name Variable\u0026rsquo;s name.\n public name(): string\n  returns: string - variable name.  value Gets the variable value.\n public value(): Variant\n  returns: Variant - variable value.  Sets the variable value.\n public value(value: Variant)\n  value: Variant - variable\u0026rsquo;s value.  ","description":"Implements a variable holder object.\n","image":null,"permalink":"/node/expressions/calculator/variables/variable/","subtitle":null,"tags":null,"title":"Variable"},{"content":"Implements: IVariableCollection\nDescription The VariableCollection allows you to implement a list of variables.\nProperties length Gets a number of variables stored in the collection.\n public length(): number\n  returns: number - number of stored variables.  Instance methods add Adds a new variable to the collection.\n public add(variable: IVariable): void\n  variable: IVariable - variable to be added.  clear Clears the collection.\n public clear(): void\n clearValues Clears all stored variables (assigns null values).\n public clearValues(): void\n findByName Clears all stored variables (assigns null values).\n public findByName(name: string): IVariable\n findIndexByName Finds variable index in the list by it\u0026rsquo;s name.\n public findIndexByName(name: string): number\n  name: string - The variable name to be found. returns: number - Variable index in the list or -1 if variable was not found.  get Get a variable by its index.\n public get(index: number): IVariable\n  index: string - variable index. returns: IVariable - retrieved variable.  getAll Get all variables stored in the collection\n public getAll(): IVariable[]\n  returns: IVariable[] - list with variables.  locate Finds a variable in the list or creates a new one if the variable was not found.\n public locate(name: string): IVariable\n  name: string - name of the variable to be found. returns: IVariable - found or created variable.  remove Removes a variable by its index.\n public remove(index: number): void\n  index: number - index of the variable to be removed.  removeByName Removes a variable by it\u0026rsquo;s name.\n public removeByName(name: string): void\n  name: string - variable name to be removed.  ","description":"Implements a list of variables.\n","image":null,"permalink":"/node/expressions/calculator/variables/variable_collection/","subtitle":null,"tags":null,"title":"VariableCollection"},{"content":"Description The Variant class allows you to define a container for variant values.\nConstructors Constructs this class and assignes a variant value.\n public constructor(value?: any)\n  value: any - value to be assigned to this variant.  Fields TODO: add description\n public static Empty = new Variant(null)\n  Properties asArray Gets a variant value as a variant array.\n public asArray(): Variant[]\n  returns: Variant[] - value as variant array.  Sets a variant value as variant array.\n public asArray(value: Variant[])\n  value: Variant[] - a value to be set.  asBoolean Gets a variant value as boolean.\n public asBoolean(): boolean\n  returns: boolean - value as boolean.  Sets a variant value as boolean.\n public asBoolean(value: boolean)\n  value: boolean - value to be set  asDateTime Gets a variant value as DateTime.\n public asDateTime(): Date\n  returns: Date - value as DateTime.  Sets a variant value as DateTime\n public asDateTime(value: Date)\n  value: Date - a value to be set  asDouble Gets a variant value as double.\n public asDouble(): number\n  returns: number - value as double.  Sets a variant value as double\n public asDouble(value: number)\n  value: number - value to be set.  asFloat Gets a variant value as float.\n public asFloat(): number\n  returns: number - value as float.  Sets a variant value as float.\n public asFloat(value: number)\n  value: number - value as float.  asInteger Gets a variant value as integer.\n public asInteger(): number\n  returns: number - value as integer.  Sets a variant value as integer.\n public asInteger(value: number)\n  value: number - value as integer.  asLong Gets a variant value as long.\n public asLong(): number\n  returns: number - value as long.  Sets a variant value as long\n public asLong(value: number)\n  value: number - value as long.  asObject Gets a variant value as object.\n public asObject(): any\n  returns: any - value as object.  Sets a variant value as object\n public asObject(value: any)\n  value: any - value as object.  asString Gets a variant value as string.\n public asString(): string\n  returns: string - value as string.  Sets a variant value as string.\n public asString(value: string)\n  value: string - value as string.  asTimeSpan Gets a variant value as TimeSpan.\n public asTimeSpan(): number\n  returns: number - value as TimeSpan.  Sets a variant value as TimeSpan.\n public asTimeSpan(value: number)\n  value: number - value as TimeSpan.  length Gets the length of the array\n public length(): number\n  returns: number - length of the array or 0.  Sets a new array length\n public length(value: number)\n  value: number - new array length  type Gets a type of the variant value\n public type(): VariantType\n  returns: VariantType - variant value type.  Instance methods assign Assignes a new value to this object.\n public assign(value: Variant): void\n  value: Variant - new value to be assigned.  clear Clears this object and assignes a VariantType.Null type.\n public clear(): void\n clear Cloning the variant value\n public clone(): Variant\n  value: Variant - cloned value of this variant  equals Compares this object to the specified one.\n public equals(obj: any): boolean\n  obj: any - object to be compared. returns: boolean - true if the objects are equal.  getByIndex Gets an array element by its index.\n public getByIndex(index: number): Variant\n  index: number - element\u0026rsquo;s index. returns: Variant - requested array element.  isEmpty Checks is this variant value is empty.\n public isEmpty(): boolean\n  returns: boolean - true is this variant value is empty.  isNull Checks is this variant value is Null.\n public isNull(): boolean\n  returns: boolean - true if this variant value is Null.  setByIndex Sets an array element by its index.\n public setByIndex(index: number, element: Variant): void\n  index: number - element index. element: Variant - element value.  toString Returns a string value for this object.\n public toString(): string\n  returns: string - string value for this object.  Static methods fromArray Creates a new variant from Array value.\n public static fromArray(value: Variant[]): Variant\n  value: Variant[] - variant value. returns: Variant - created variant object.  fromBoolean Creates a new variant from a Boolean value.\n public static fromBoolean(value: boolean): Variant\n  value: boolean - variant value. returns: Variant - created variant object.  fromDateTime Creates a new variant from a DateTime value.\n public static fromDateTime(value: Date): Variant\n  value: Date - variant value. returns: Variant - created variant object.  fromDouble Creates a new variant from a DateTime value.\n public static fromDouble(value: number): Variant\n  value: number - variant value. returns: Variant - created variant object.  fromFloat Creates a new variant from a Float value.\n public static fromFloat(value: number): Variant\n  value: number - variant value. returns: Variant - created variant object.  fromInteger Creates a new variant from an Integer value.\n public static fromInteger(value: number): Variant\n  value: number - variant value. returns: Variant - created variant object.  fromLong Creates a new variant from a Long value.\n public static fromLong(value: number): Variant\n  value: number - variant value. returns: Variant - created variant object.  fromObject Creates a new variant from an Object value.\n public static fromObject(value: any): Variant\n  value: any - variant value. returns: Variant - created variant object.  fromString Creates a new variant from a String value.\n public static fromString(value: string): Variant\n  value: string - variant value. returns: Variant - created variant object.  fromTimeSpan Creates a new variant from a TimeSpan value.\n public static fromTimeSpan(value: number): Variant\n  value: number - variant value. returns: Variant - created variant object.  ","description":"Defines a container for variant values.\n","image":null,"permalink":"/node/expressions/variants/variant/","subtitle":null,"tags":null,"title":"Variant"},{"content":"Description The VariantType enum defines supported types of variant values.\nEnumeration members The codes are as follows:\n Null = 0 Integer = 1 Long = 2 Float = 3 Double = 4 String = 5 Boolean = 6 DateTime = 7 TimeSpan = 8 Object = 9 Array = 10  ","description":"Defines supported types of variant values.\n","image":null,"permalink":"/node/expressions/variants/variant_type/","subtitle":null,"tags":null,"title":"VariantType"},{"content":"Implements: FileConfigReader\nDescription The YamlConfigReader allows you to create a config reader that reads a configuration from a YAML file.\nConfiguration parameters  path: path to the configuration file parameters: this entire section is used as template parameters \u0026hellip;  Constructors NewYamlConfigReader Creates a new instance of the config reader.\n NewYamlConfigReader(path string) *YamlConfigReader\n  path: string - (optional) path to the configuration file.  NewEmptyYamlConfigReader Creates a new instance of the config reader.\n NewEmptyYamlConfigReader() *YamlConfigReader\n Methods ReadConfig Reads a configuration and parameterizes it with given values.\n (c *YamlConfigReader) ReadConfig(correlationId string, parameters *cconfig.ConfigParams) (result *cconfig.ConfigParams, err error)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. parameters: *cconfig.ConfigParams - values of the configuration parameters or nil to skip parameterization. returns: (result *cconfig.ConfigParams, err error) - ConfigParams configuration.  ReadObject Reads a configuration file, parameterizes its content and converts it into a YAML object.\n (c *YamlConfigReader) ReadObject(correlationId string, parameters *cconfig.ConfigParams) (interface{}, error)\n  correlationId: string - (optional) transaction id used to trace execution through the call chain. parameters: *cconfig.ConfigParams - values of the configuration parameters. returns: (interface{}, error) - YAML object with a configuration.  ReadYamlConfig Reads a configuration from a file, parameterizes it with given values, and returns a new ConfigParams object.\n ReadYamlConfig(correlationId string, path string, parameters *cconfig.ConfigParams) (*cconfig.ConfigParams, error)\n  correlationId: string - (optional) transaction id used to trace the execution through the call chain. path: string - path to a configuration file. parameters: *cconfig.ConfigParams - values of the configuration parameters. returns: (*cconfig.ConfigParams, error) - ConfigParams configuration.  ReadYamlObject Reads a configuration file, parameterizes its content and converts it into a YAML object.\n ReadYamlObject(correlationId string, path string, parameters *cconfig.ConfigParams) (interface{}, error)\n  correlationId: string - (optional) transaction id used to trace the execution through the call chain. path: string - path to configuration file. parameters: *cconfig.ConfigParams - values of the configuration parameters. returns: (interface{}, error) - YAML object containing a configuration.  Examples key1: \u0026#34;{{KEY1_VALUE}}\u0026#34; key2: \u0026#34;{{KEY2_VALUE}}\u0026#34; configReader := NewYamlConfigReader(\u0026#34;config.yml\u0026#34;) parameters := NewConfigParamsFromTuples(\u0026#34;KEY1_VALUE\u0026#34;, 123, \u0026#34;KEY2_VALUE\u0026#34;, \u0026#34;ABC\u0026#34;); res, err := configReader.ReadConfig(\u0026#34;123\u0026#34;, parameters); // Result: key1=123;key2=ABC See also   IConfigReader   FileConfigReader   ","description":"Config reader that reads configuration from YAML file.\n","image":null,"permalink":"/golang/components/config/yaml_config_reader/","subtitle":null,"tags":null,"title":"YamlConfigReader"},{"content":"Inherits: FileConfigReader\nDescription The YamlConfigReader allows you to create a config reader that reads a configuration from a YAML file.\nConfiguration parameters  path: path to the configuration file parameters: this entire section is used as template parameters \u0026hellip;  Constructors Creates a new instance of the config reader.\n public YamlConfigReader(string path = null)\n  path: string - (optional) path to the configuration file.  Instance methods ReadConfig Reads a configuration and parameterizes it with given values.\n public override ConfigParams ReadConfig(string correlationId, ConfigParams parameters)\n  correlationId: string - (optional) transaction id to trace execution through a call chain. parameters: ConfigParams - values of the configuration parameters or null to skip parameterization. returns: ConfigParams - ConfigParams configuration.  ReadObject Reads a configuration file, parameterizes its content and converts it into a YAML object.\n public object ReadObject(string correlationId, ConfigParams parameters)\n  correlationId: string - (optional) transaction id to trace execution through a call chain. parameters: ConfigParams - values of the configuration parameters. returns: object - a YAML object with a configuration.  Static methods ReadConfig Reads a configuration from a file, parameterizes it with given values and returns a new ConfigParams object.\n public static ConfigParams ReadConfig(string correlationId, string path, ConfigParams parameters)\n  correlationId: string - (optional) transaction id to trace the execution through a call chain. path: string - a path to configuration file. parameters: ConfigParams - values of the configuration parameters. returns: ConfigParams - ConfigParams configuration.  ReadObject Reads a configuration file, parameterizes its content and converts it into a YAML object.\n public static object ReadObject(string correlationId, string path, ConfigParams parameters)\n  correlationId: string - (optional) transaction id to trace the execution through a call chain. path: string - a path to configuration file. parameters: ConfigParams - values of the configuration parameters. returns: object - a YAML object containing a configuration.  Examples key1: \u0026#34;{{KEY1_VALUE}}\u0026#34; key2: \u0026#34;{{KEY2_VALUE}}\u0026#34; var configReader = new YamlConfigReader(\u0026#34;config.yml\u0026#34;); var parameters = ConfigParams.FromTuples(\u0026#34;KEY1_VALUE\u0026#34;, 123, \u0026#34;KEY2_VALUE\u0026#34;, \u0026#34;ABC\u0026#34;); configReader.ReadConfig(\u0026#34;123\u0026#34;, parameters); See also   IConfigReader   FileConfigReader   ","description":"Config reader that reads configuration from YAML file.\n","image":null,"permalink":"/net/components/config/yaml_config_reader/","subtitle":null,"tags":null,"title":"YamlConfigReader"},{"content":"Extends: FileConfigReader\nDescription The YamlConfigReader allows you to create a config reader that reads a configuration from a YAML file.\nConfiguration parameters  path: path to the configuration file parameters: this entire section is used as template parameters \u0026hellip;  Constructors Creates a new instance of the config reader.\n public constructor(path: string = null)\n  path: string - (optional) path to the configuration file.  Instance methods readConfig Reads a configuration and parameterizes it with given values.\n public readConfig(correlationId: string, parameters: ConfigParams): Promise\u0026lt;ConfigParams\u0026gt;\n  correlationId: string - (optional) transaction id to trace execution through a call chain. parameters: ConfigParams - values of the configuration parameters or null to skip parameterization. returns: Promise\u0026lt;ConfigParams\u0026gt; - ConfigParams configuration.  readObject Reads a configuration file, parameterizes its content and converts it into a YAML object.\n public readObject(correlationId: string, parameters: ConfigParams): any\n  correlationId: string - (optional) transaction id to trace execution through a call chain. parameters: ConfigParams - values of the configuration parameters. returns: any - a YAML object with a configuration.  Static methods readConfig Reads a configuration from a file, parameterizes it with given values and returns a new ConfigParams object.\n public static readConfig(correlationId: string, path: string, parameters: ConfigParams): ConfigParams\n  correlationId: string - (optional) transaction id to trace the execution through a call chain. path: string - a path to configuration file. parameters: ConfigParams - values of the configuration parameters. returns: ConfigParams - ConfigParams configuration.  readObject Reads a configuration file, parameterizes its content and converts it into a YAML object.\n public static readObject(correlationId: string, path: string, parameters: ConfigParams): any\n  correlationId: string - (optional) transaction id to trace the execution through a call chain. path: string - a path to configuration file. parameters: ConfigParams - values of the configuration parameters. returns: any - a YAML object containing a configuration.  Examples key1: \u0026#34;{{KEY1_VALUE}}\u0026#34; key2: \u0026#34;{{KEY2_VALUE}}\u0026#34; let configReader = new YamlConfigReader(\u0026#34;config.yml\u0026#34;); let parameters = ConfigParams.fromTuples(\u0026#34;KEY1_VALUE\u0026#34;, 123, \u0026#34;KEY2_VALUE\u0026#34;, \u0026#34;ABC\u0026#34;); let config = await configReader.readConfig(\u0026#34;123\u0026#34;, parameters); // Result: key1=123;key2=ABC See also   IConfigReader   FileConfigReader   ","description":"Config reader that reads configuration from YAML file.\n","image":null,"permalink":"/node/components/config/yaml_config_reader/","subtitle":null,"tags":null,"title":"YamlConfigReader"},{"content":"Implements: FileConfigReader\nDescription The YamlConfigReader allows you to create a config reader that reads a configuration from a YAML file.\nConfiguration parameters  path: path to the configuration file parameters: this entire section is used as template parameters \u0026hellip;  Constructors Creates a new instance of the config reader.\n YamlConfigReader(path: str = None)\n  path: str - (optional) path to the configuration file.  Instance methods _read_config Reads a configuration and parameterizes it with given values.\n _read_config(correlation_id: Optional[str], parameters: ConfigParams): ConfigParams\n  correlation_id: Optional[str] - (optional) transaction id to trace execution through a call chain. parameters: ConfigParams - values of the configuration parameters or None to skip parameterization. returns: ConfigParams - ConfigParams configuration.  _read_object Reads a configuration file, parameterizes its content and converts it into a YAML object.\n _read_object(correlation_id: Optional[str], parameters: ConfigParams): Any\n  correlation_id: Optional[str] - (optional) transaction id to trace execution through a call chain. parameters: ConfigParams - values of the configuration parameters. returns: Any - a YAML object with a configuration.  read_config Reads a configuration from a file, parameterizes it with given values and returns a new ConfigParams object.\n static read_config(correlation_id: Optional[str], path: str, parameters: ConfigParams): ConfigParams\n  correlation_id: Optional[str] - (optional) transaction id to trace the execution through a call chain. path: str - a path to configuration file. parameters: ConfigParams - values of the configuration parameters. returns: ConfigParams - ConfigParams configuration.  read_object Reads a configuration file, parameterizes its content and converts it into a YAML object.\n static read_object(correlation_id: Optional[str], path: str, parameters: ConfigParams): Any\n  correlation_id: Optional[str] - (optional) transaction id to trace the execution through a call chain. path: str - a path to configuration file. parameters: ConfigParams - values of the configuration parameters. returns: Any - a YAML object containing a configuration.  Examples key1: \u0026#34;{{KEY1_VALUE}}\u0026#34; key2: \u0026#34;{{KEY2_VALUE}}\u0026#34; configReader = YamlConfigReader(\u0026#34;config.yml\u0026#34;) parameters = ConfigParams.from_tuples(\u0026#34;KEY1_VALUE\u0026#34;, 123, \u0026#34;KEY2_VALUE\u0026#34;, \u0026#34;ABC\u0026#34;) configReader._read_config(\u0026#34;123\u0026#34;, parameters) See also   IConfigReader   FileConfigReader   ","description":"Config reader that reads configuration from YAML file.\n","image":null,"permalink":"/python/components/config/yaml_config_reader/","subtitle":null,"tags":null,"title":"YamlConfigReader"}]