<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title> â€“ Generic</title>
    <link>/node/expressions/tokenizers/generic/</link>
    <description>Recent content in Generic on </description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    
	  <atom:link href="/node/expressions/tokenizers/generic/index.xml" rel="self" type="application/rss+xml" />
    
    
      
        
      
    
    
    <item>
      <title>Node: CCommentState</title>
      <link>/node/expressions/tokenizers/generic/c_comment_state/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/node/expressions/tokenizers/generic/c_comment_state/</guid>
      <description>
        
        
        &lt;h3 id=&#34;description&#34;&gt;Description&lt;/h3&gt;
&lt;p&gt;The CCommentState class allows you to create a state that will either delegate to a comment-handling state, or return a token with just a slash in it.&lt;/p&gt;
&lt;h3 id=&#34;instance-methods&#34;&gt;Instance methods&lt;/h3&gt;
&lt;h4 id=&#34;nexttoken&#34;&gt;nextToken&lt;/h4&gt;
&lt;p&gt;Either delegate to a comment-handling state, or return a token with just a slash in it.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;public&lt;/code&gt; nextToken(scanner: &lt;a href=&#34;../../../io/iscanner&#34;&gt;IScanner&lt;/a&gt;, tokenizer: &lt;a href=&#34;../../itokenizer&#34;&gt;ITokenizer&lt;/a&gt;): &lt;a href=&#34;../../token&#34;&gt;Token&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;scanner&lt;/strong&gt;: &lt;a href=&#34;../../../io/iscanner&#34;&gt;IScanner&lt;/a&gt; - textual string to be tokenized.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;tokenizer&lt;/strong&gt;: &lt;a href=&#34;../../itokenizer&#34;&gt;ITokenizer&lt;/a&gt; - tokenizer class that controls the process.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;returns&lt;/strong&gt;: &lt;a href=&#34;../../token&#34;&gt;Token&lt;/a&gt; - next token from the top of the stream.&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
    
    <item>
      <title>Node: CppCommentState</title>
      <link>/node/expressions/tokenizers/generic/cpp_comment_state/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/node/expressions/tokenizers/generic/cpp_comment_state/</guid>
      <description>
        
        
        &lt;p&gt;&lt;strong&gt;Extends&lt;/strong&gt;: &lt;a href=&#34;../generic_comment_state&#34;&gt;GenericCommentState&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;description&#34;&gt;Description&lt;/h3&gt;
&lt;p&gt;The CppCommentState class allows you to create a state that will either delegate to a comment-handling state, or return a token with just a slash in it.&lt;/p&gt;
&lt;h3 id=&#34;fields&#34;&gt;Fields&lt;/h3&gt;
&lt;span class=&#34;hide-title-link&#34;&gt;
&lt;h4 id=&#34;star&#34;&gt;STAR&lt;/h4&gt;
&lt;p&gt;Represents a star (*) char&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;protected&lt;/code&gt; &lt;strong&gt;STAR&lt;/strong&gt;: number = &amp;lsquo;*&#39;.charCodeAt(0)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;slash&#34;&gt;SLASH&lt;/h4&gt;
&lt;p&gt;Represents a forward slash (/) char.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;protected&lt;/code&gt; &lt;strong&gt;SLASH&lt;/strong&gt;: number = &amp;lsquo;/&#39;.charCodeAt(0)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/span&gt;
&lt;h3 id=&#34;instance-methods&#34;&gt;Instance methods&lt;/h3&gt;
&lt;h4 id=&#34;getmultilinecomment&#34;&gt;getMultiLineComment&lt;/h4&gt;
&lt;p&gt;Ignore everything up to a closing star and slash, and then return the tokenizer&amp;rsquo;s next token.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;protected&lt;/code&gt; getMultiLineComment(scanner: &lt;a href=&#34;../../../io/iscanner&#34;&gt;IScanner&lt;/a&gt;): string&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;scanner&lt;/strong&gt;: &lt;a href=&#34;../../../io/iscanner&#34;&gt;IScanner&lt;/a&gt; - scanner&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;returns&lt;/strong&gt;: string - comment&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;getsinglelinecomment&#34;&gt;getSingleLineComment&lt;/h4&gt;
&lt;p&gt;Ignore everything up to an end-of-line and return the tokenizer&amp;rsquo;s next token.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;protected&lt;/code&gt; getSingleLineComment(scanner: &lt;a href=&#34;../../../io/iscanner&#34;&gt;IScanner&lt;/a&gt;): string&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;scanner&lt;/strong&gt;: &lt;a href=&#34;../../../io/iscanner&#34;&gt;IScanner&lt;/a&gt; - scanner&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;returns&lt;/strong&gt;: string - comment&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;nexttoken&#34;&gt;nextToken&lt;/h4&gt;
&lt;p&gt;Either delegate to a comment-handling state, or return a token with just a slash in it.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;public&lt;/code&gt; nextToken(scanner: &lt;a href=&#34;../../../io/iscanner&#34;&gt;IScanner&lt;/a&gt;, tokenizer: &lt;a href=&#34;../../itokenizer&#34;&gt;ITokenizer&lt;/a&gt;): &lt;a href=&#34;../../token&#34;&gt;Token&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;scanner&lt;/strong&gt;: &lt;a href=&#34;../../../io/iscanner&#34;&gt;IScanner&lt;/a&gt; - A textual string to be tokenized.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;tokenizer&lt;/strong&gt;: &lt;a href=&#34;../../itokenizer&#34;&gt;ITokenizer&lt;/a&gt; - A tokenizer class that controls the process.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;returns&lt;/strong&gt;: &lt;a href=&#34;../../token&#34;&gt;Token&lt;/a&gt; - The next token from the top of the stream.&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
    
    <item>
      <title>Node: GenericCommentState</title>
      <link>/node/expressions/tokenizers/generic/generic_comment_state/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/node/expressions/tokenizers/generic/generic_comment_state/</guid>
      <description>
        
        
        &lt;p&gt;&lt;strong&gt;Implements&lt;/strong&gt;: &lt;a href=&#34;../../icomment_state&#34;&gt;ICommentState&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;description&#34;&gt;Description&lt;/h3&gt;
&lt;p&gt;The GenericCommentState class allows you to create a CommentState object that returns a comment from a scanner.&lt;/p&gt;
&lt;h3 id=&#34;fields&#34;&gt;Fields&lt;/h3&gt;
&lt;span class=&#34;hide-title-link&#34;&gt;
&lt;h4 id=&#34;cr&#34;&gt;CR&lt;/h4&gt;
&lt;p&gt;Carrige return or \n character&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;protected&lt;/code&gt; &lt;strong&gt;CR&lt;/strong&gt;: number = &amp;lsquo;\n&amp;rsquo;.charCodeAt(0)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;lf&#34;&gt;LF&lt;/h4&gt;
&lt;p&gt;Line feed or \r character&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;protected&lt;/code&gt; &lt;strong&gt;LF&lt;/strong&gt;: number = &amp;lsquo;\r&amp;rsquo;.charCodeAt(0)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/span&gt;
&lt;h3 id=&#34;instance-methods&#34;&gt;Instance methods&lt;/h3&gt;
&lt;h4 id=&#34;nexttoken&#34;&gt;nextToken&lt;/h4&gt;
&lt;p&gt;Either delegates to a comment-handling state, or returns a token with just a slash in it.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;public&lt;/code&gt; nextToken(scanner: &lt;a href=&#34;../../../io/iscanner&#34;&gt;IScanner&lt;/a&gt;, tokenizer: &lt;a href=&#34;../../itokenizer&#34;&gt;ITokenizer&lt;/a&gt;): &lt;a href=&#34;../../token&#34;&gt;Token&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;scanner&lt;/strong&gt;: &lt;a href=&#34;../../../io/iscanner&#34;&gt;IScanner&lt;/a&gt; - textual string to be tokenized.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;tokenizer&lt;/strong&gt;: &lt;a href=&#34;../../itokenizer&#34;&gt;ITokenizer&lt;/a&gt; - tokenizer class that controls the process.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;returns&lt;/strong&gt;: &lt;a href=&#34;../../token&#34;&gt;Token&lt;/a&gt; - next token from the top of the stream.&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
    
    <item>
      <title>Node: GenericNumberState</title>
      <link>/node/expressions/tokenizers/generic/generic_number_state/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/node/expressions/tokenizers/generic/generic_number_state/</guid>
      <description>
        
        
        &lt;p&gt;&lt;strong&gt;Implements&lt;/strong&gt;: &lt;a href=&#34;../../icomment_state&#34;&gt;ICommentState&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;description&#34;&gt;Description&lt;/h3&gt;
&lt;p&gt;The GenericNumberState class allows you to create a NumberState object returns a number from a scanner.&lt;/p&gt;
&lt;p&gt;Important points&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;This state&amp;rsquo;s idea of a number allows an optional, initial minus sign, followed by one or more digits. A decimal point and another string of digits may follow these digits.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;fields&#34;&gt;Fields&lt;/h3&gt;
&lt;span class=&#34;hide-title-link&#34;&gt;
&lt;h4 id=&#34;dot&#34;&gt;DOT&lt;/h4&gt;
&lt;p&gt;Represents a dot (.) character.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;protected&lt;/code&gt; &lt;strong&gt;DOT&lt;/strong&gt;: number = &amp;lsquo;.&#39;.charCodeAt(0);&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;minus&#34;&gt;MINUS&lt;/h4&gt;
&lt;p&gt;Represents a minus (-) character.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;protected&lt;/code&gt; &lt;strong&gt;MINUS&lt;/strong&gt;: number = &amp;lsquo;-&#39;.charCodeAt(0);&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/span&gt;
&lt;h3 id=&#34;instance-methods&#34;&gt;Instance methods&lt;/h3&gt;
&lt;h4 id=&#34;nexttoken&#34;&gt;nextToken&lt;/h4&gt;
&lt;p&gt;Gets the next token from the stream started from the character linked to this state.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;public&lt;/code&gt; nextToken(scanner: &lt;a href=&#34;../../../io/iscanner&#34;&gt;IScanner&lt;/a&gt;, tokenizer: &lt;a href=&#34;../../itokenizer&#34;&gt;ITokenizer&lt;/a&gt;): &lt;a href=&#34;../../token&#34;&gt;Token&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;scanner&lt;/strong&gt;: &lt;a href=&#34;../../../io/iscanner&#34;&gt;IScanner&lt;/a&gt; - textual string to be tokenized.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;tokenizer&lt;/strong&gt;: &lt;a href=&#34;../../itokenizer&#34;&gt;ITokenizer&lt;/a&gt; - tokenizer class that controls the process.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;returns&lt;/strong&gt;: &lt;a href=&#34;../../token&#34;&gt;Token&lt;/a&gt; - next token from the top of the stream.&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
    
    <item>
      <title>Node: GenericQuoteState</title>
      <link>/node/expressions/tokenizers/generic/generic_quote_state/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/node/expressions/tokenizers/generic/generic_quote_state/</guid>
      <description>
        
        
        &lt;p&gt;&lt;strong&gt;Implements&lt;/strong&gt;: &lt;a href=&#34;../../iquote_state&#34;&gt;IQuoteState&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;description&#34;&gt;Description&lt;/h3&gt;
&lt;p&gt;The GenericQuoteState allows you to create a quoteState that returns a quoted string token from a scanner.&lt;/p&gt;
&lt;p&gt;Important points&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;This state will collect characters until it sees a match to the character that the tokenizer used to switch to this state.&lt;/li&gt;
&lt;li&gt;For example, if a tokenizer uses a double-quote character to enter this state, then &lt;em&gt;nextToken()&lt;/em&gt; will search for another double-quote until it finds one or finds the end of the scanner.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;fields&#34;&gt;Fields&lt;/h3&gt;
&lt;span class=&#34;hide-title-link&#34;&gt;
&lt;h4 id=&#34;dot&#34;&gt;DOT&lt;/h4&gt;
&lt;p&gt;Represents a dot (.) character.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;protected&lt;/code&gt; &lt;strong&gt;DOT&lt;/strong&gt;: number = &amp;lsquo;.&#39;.charCodeAt(0);&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;minus&#34;&gt;MINUS&lt;/h4&gt;
&lt;p&gt;Represents a minus (-) character.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;protected&lt;/code&gt; &lt;strong&gt;MINUS&lt;/strong&gt;: number = &amp;lsquo;-&#39;.charCodeAt(0);&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/span&gt;
&lt;h3 id=&#34;instance-methods&#34;&gt;Instance methods&lt;/h3&gt;
&lt;h4 id=&#34;decodestring&#34;&gt;decodeString&lt;/h4&gt;
&lt;p&gt;Decodes a string value.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;public&lt;/code&gt; decodeString(value: string, quoteSymbol: number): string&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;value&lt;/strong&gt;: string - string value to be decoded.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;quoteSymbol&lt;/strong&gt;: number - string quote character.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;returns&lt;/strong&gt;: string - decoded string.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;encodestring&#34;&gt;encodeString&lt;/h4&gt;
&lt;p&gt;Encodes a string value.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;public&lt;/code&gt; encodeString(value: string, quoteSymbol: number): string&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;value&lt;/strong&gt;: string - string value to be encoded.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;quoteSymbol&lt;/strong&gt;: number - string quote character.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;returns&lt;/strong&gt;: string - encoded string.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;nexttoken&#34;&gt;nextToken&lt;/h4&gt;
&lt;p&gt;Returns a quoted string token from a scanner. This method will collect
characters until it sees a match to the character that the tokenizer used
to switch to this state.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;public&lt;/code&gt; nextToken(scanner: &lt;a href=&#34;../../../io/iscanner&#34;&gt;IScanner&lt;/a&gt;, tokenizer: &lt;a href=&#34;../../itokenizer&#34;&gt;ITokenizer&lt;/a&gt;): &lt;a href=&#34;../../token&#34;&gt;Token&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;scanner&lt;/strong&gt;: &lt;a href=&#34;../../../io/iscanner&#34;&gt;IScanner&lt;/a&gt; - textual string to be tokenized.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;tokenizer&lt;/strong&gt;: &lt;a href=&#34;../../itokenizer&#34;&gt;ITokenizer&lt;/a&gt; - tokenizer class that controls the process.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;returns&lt;/strong&gt;: &lt;a href=&#34;../../token&#34;&gt;Token&lt;/a&gt; - next token from the top of the stream.&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
    
    <item>
      <title>Node: GenericSymbolState</title>
      <link>/node/expressions/tokenizers/generic/generic_symbol_state/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/node/expressions/tokenizers/generic/generic_symbol_state/</guid>
      <description>
        
        
        &lt;p&gt;&lt;strong&gt;Implements&lt;/strong&gt;: &lt;a href=&#34;../../isymbol_state&#34;&gt;ISymbolState&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;description&#34;&gt;Description&lt;/h3&gt;
&lt;p&gt;The GenericSymbolState class allows you to add multi-character symbols and obtain a symbol token from a scanner.&lt;/p&gt;
&lt;p&gt;Important points&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The idea of a symbol is a character that stands on its own, such as an ampersand or a parenthesis.&lt;/li&gt;
&lt;li&gt;For example, when tokenizing the expression &lt;em&gt;(isReady)&amp;amp; (isWilling)&lt;/em&gt;, a typical tokenizer would return 7 tokens, including one for each parenthesis and one for the ampersand. Thus a series of symbols such as &lt;em&gt;)&amp;amp;(&lt;/em&gt; becomes three tokens, while a series of letters such as &lt;em&gt;isReady&lt;/em&gt; becomes a single word token.&lt;/li&gt;
&lt;li&gt;Multi-character symbols are an exception to the rule that a symbol is a standalone character.&lt;/li&gt;
&lt;li&gt;For example, a tokenizer may want less-than-or-equals to tokenize as a single token. This class provides a method for establishing which multi-character symbols an object of this class should treat as single symbols. This allows, for example, &lt;em&gt;&amp;ldquo;cat &amp;lt;= dog&amp;rdquo;&lt;/em&gt; to tokenize as three tokens, rather than splitting the less-than and equals symbols into separate tokens.&lt;/li&gt;
&lt;li&gt;By default, this state recognizes the following multi-character symbols: &lt;em&gt;!=, :-, &amp;lt;=, &amp;gt;=&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;instance-methods&#34;&gt;Instance methods&lt;/h3&gt;
&lt;h4 id=&#34;add&#34;&gt;add&lt;/h4&gt;
&lt;p&gt;Adds a multi-character symbol.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;public&lt;/code&gt; add(value: string, tokenType: &lt;a href=&#34;../../token_type&#34;&gt;TokenType&lt;/a&gt;): void&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;value&lt;/strong&gt;: string - symbol to add, such as &lt;em&gt;&amp;quot;=:=&amp;quot;&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;tokenType&lt;/strong&gt;: &lt;a href=&#34;../../token_type&#34;&gt;TokenType&lt;/a&gt; - type of token&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;nexttoken&#34;&gt;nextToken&lt;/h4&gt;
&lt;p&gt;Returns a symbol token from a scanner.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;public&lt;/code&gt; nextToken(scanner: &lt;a href=&#34;../../../io/iscanner&#34;&gt;IScanner&lt;/a&gt;, tokenizer: &lt;a href=&#34;../../itokenizer&#34;&gt;ITokenizer&lt;/a&gt;): &lt;a href=&#34;../../token&#34;&gt;Token&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;scanner&lt;/strong&gt;: &lt;a href=&#34;../../../io/iscanner&#34;&gt;IScanner&lt;/a&gt; - textual string to be tokenized.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;tokenizer&lt;/strong&gt;: &lt;a href=&#34;../../itokenizer&#34;&gt;ITokenizer&lt;/a&gt; - tokenizer class that controls the process.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;returns&lt;/strong&gt;: &lt;a href=&#34;../../token&#34;&gt;Token&lt;/a&gt; - next token from the top of the stream.&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
    
    <item>
      <title>Node: GenericTokenizer</title>
      <link>/node/expressions/tokenizers/generic/generic_tokenizer/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/node/expressions/tokenizers/generic/generic_tokenizer/</guid>
      <description>
        
        
        &lt;p&gt;&lt;strong&gt;Extends&lt;/strong&gt;: &lt;a href=&#34;../../abstract_tokenizer&#34;&gt;AbstractTokenizer&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;description&#34;&gt;Description&lt;/h3&gt;
&lt;p&gt;The GenericTokenizer allows you to implement a default tokenizer class.&lt;/p&gt;
&lt;h3 id=&#34;constructors&#34;&gt;Constructors&lt;/h3&gt;
&lt;p&gt;Creates an instance of GenericTokenizer&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;public&lt;/code&gt; constructor()&lt;/p&gt;
&lt;/blockquote&gt;

      </description>
    </item>
    
    <item>
      <title>Node: GenericWhitespaceState</title>
      <link>/node/expressions/tokenizers/generic/generic_whitespace_state/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/node/expressions/tokenizers/generic/generic_whitespace_state/</guid>
      <description>
        
        
        &lt;p&gt;&lt;strong&gt;Implements&lt;/strong&gt;: &lt;a href=&#34;../../iwhitespace_state&#34;&gt;IWhitespaceState&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;description&#34;&gt;Description&lt;/h3&gt;
&lt;p&gt;The GenericWhitespaceState allows you to create a whitespace state.&lt;/p&gt;
&lt;p&gt;Important points&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A whitespace state ignores whitespace (such as blanks and tabs), and returns the tokenizer&amp;rsquo;s next token. By default, all characters from 0 to 32 are whitespace.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;constructors&#34;&gt;Constructors&lt;/h3&gt;
&lt;p&gt;Constructs a whitespace state with a default idea of what characters are, in fact, whitespace.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;public&lt;/code&gt; constructor()&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;instance-methods&#34;&gt;Instance methods&lt;/h3&gt;
&lt;h4 id=&#34;clearwhitespacechars&#34;&gt;clearWhitespaceChars&lt;/h4&gt;
&lt;p&gt;Clears definitions of whitespace characters.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;public&lt;/code&gt; clearWhitespaceChars(): void&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;nexttoken&#34;&gt;nextToken&lt;/h4&gt;
&lt;p&gt;Ignores whitespace (such as blanks and tabs), and returns the tokenizer&amp;rsquo;s next token.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;public&lt;/code&gt; nextToken(scanner: &lt;a href=&#34;../../../io/iscanner&#34;&gt;IScanner&lt;/a&gt;, tokenizer: &lt;a href=&#34;../../itokenizer&#34;&gt;ITokenizer&lt;/a&gt;): &lt;a href=&#34;../../token&#34;&gt;Token&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;scanner&lt;/strong&gt;: &lt;a href=&#34;../../../io/iscanner&#34;&gt;IScanner&lt;/a&gt; - textual string to be tokenized.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;tokenizer&lt;/strong&gt;: &lt;a href=&#34;../../itokenizer&#34;&gt;ITokenizer&lt;/a&gt; - tokenizer class that controls the process.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;returns&lt;/strong&gt;: &lt;a href=&#34;../../token&#34;&gt;Token&lt;/a&gt; - next token from the top of the stream.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;setwhitespacechars&#34;&gt;setWhitespaceChars&lt;/h4&gt;
&lt;p&gt;Establishes the given characters as whitespace to ignore.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;public&lt;/code&gt; setWhitespaceChars(fromSymbol: number, toSymbol: number, enable: boolean): void&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;fromSymbol&lt;/strong&gt;: number - first character index of the interval.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;toSymbol&lt;/strong&gt;: number - last character index of the interval.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;enable&lt;/strong&gt;: boolean - &lt;em&gt;true&lt;/em&gt; if this state should ignore characters in the given range.&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
    
    <item>
      <title>Node: GenericWordState</title>
      <link>/node/expressions/tokenizers/generic/generic_word_state/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/node/expressions/tokenizers/generic/generic_word_state/</guid>
      <description>
        
        
        &lt;p&gt;&lt;strong&gt;Implements&lt;/strong&gt;: &lt;a href=&#34;../../iword_state&#34;&gt;IWordState&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;description&#34;&gt;Description&lt;/h3&gt;
&lt;p&gt;The GenericWordState class allows you to create a WordState that returns a word from a scanner.&lt;/p&gt;
&lt;p&gt;Important points&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Like other states, a tokenizer transfers the job of reading to this state, depending on an initial character.&lt;/li&gt;
&lt;li&gt;This state determines which characters may appear as a second or later character in a word. These are typically different sets of characters; in particular, it is typical for digits to appear as parts of a word, but not as the initial character of a word.&lt;/li&gt;
&lt;li&gt;By default, the following characters may appear in a word (The method &lt;em&gt;setWordChars()&lt;/em&gt; allows customizing this):&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;&lt;pre&gt;
From     To
 &#39;a&#39;,    &#39;z&#39;
 &#39;A&#39;,    &#39;Z&#39;
 &#39;0&#39;,    &#39;9&#39;
  * 
&lt;p&gt;&lt;/pre&gt;&lt;/blockquote&gt;
As well as: minus sign, underscore, and apostrophe.&lt;/p&gt;
&lt;h3 id=&#34;constructors&#34;&gt;Constructors&lt;/h3&gt;
&lt;p&gt;Constructs a word state with a default idea of what characters
are admissible inside a word (as described in the class comment).&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;public&lt;/code&gt; constructor()&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;instance-methods&#34;&gt;Instance methods&lt;/h3&gt;
&lt;h4 id=&#34;clearwordchars&#34;&gt;clearWordChars&lt;/h4&gt;
&lt;p&gt;Clears definitions of word chars.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;public&lt;/code&gt; clearWordChars(): void&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;nexttoken&#34;&gt;nextToken&lt;/h4&gt;
&lt;p&gt;Ignores a word (such as blanks and tabs), and returns the tokenizer&amp;rsquo;s next token.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;public&lt;/code&gt; nextToken(scanner: &lt;a href=&#34;../../../io/iscanner&#34;&gt;IScanner&lt;/a&gt;, tokenizer: &lt;a href=&#34;../../itokenizer&#34;&gt;ITokenizer&lt;/a&gt;): &lt;a href=&#34;../../token&#34;&gt;Token&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;scanner&lt;/strong&gt;: &lt;a href=&#34;../../../io/iscanner&#34;&gt;IScanner&lt;/a&gt; - textual string to be tokenized.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;tokenizer&lt;/strong&gt;: &lt;a href=&#34;../../itokenizer&#34;&gt;ITokenizer&lt;/a&gt; - tokenizer class that controls the process.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;returns&lt;/strong&gt;: &lt;a href=&#34;../../token&#34;&gt;Token&lt;/a&gt; - next token from the top of the stream.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;setwhitespacechars&#34;&gt;setWhitespaceChars&lt;/h4&gt;
&lt;p&gt;Establishes characters in the given range as valid characters for part of a word after the first character. Note that the tokenizer must determine which characters are valid as the beginning character of a word.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;public&lt;/code&gt; setWordChars(fromSymbol: number, toSymbol: number, enable: boolean): void&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;fromSymbol&lt;/strong&gt;: number - first character index of the interval.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;toSymbol&lt;/strong&gt;: number - last character index of the interval.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;enable&lt;/strong&gt;: boolean - &lt;em&gt;true&lt;/em&gt; if this state should ignore characters in the given range.&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
    
    <item>
      <title>Node: SymbolNode</title>
      <link>/node/expressions/tokenizers/generic/symbol_node/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/node/expressions/tokenizers/generic/symbol_node/</guid>
      <description>
        
        
        &lt;h3 id=&#34;description&#34;&gt;Description&lt;/h3&gt;
&lt;p&gt;The SymbolNode class allows you to construct a SymbolNode.&lt;/p&gt;
&lt;p&gt;Important points&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A &lt;em&gt;SymbolNode&lt;/em&gt; object is a member of a tree that contains all possible prefixes of allowable symbols. Multi-character symbols appear in a &lt;em&gt;SymbolNode&lt;/em&gt; tree with one node for each character.&lt;/li&gt;
&lt;li&gt;For example, the symbol &lt;em&gt;=:~&lt;/em&gt; will appear in a tree as three nodes. The first node contains an equals sign, and has a child; that child contains a colon and has a child; this third child contains a tilde, and has no children of its own. If the colon node had another child for a dollar sign character, then the tree would contain the symbol &lt;em&gt;=:$&lt;/em&gt;.&lt;/li&gt;
&lt;li&gt;A tree of &lt;em&gt;SymbolNode&lt;/em&gt; objects collaborate to read a (potentially multi-character) symbol from an input stream. A root node with no character of its own finds an initial node
that represents the first character in the input. This node looks to see if the next character in the stream matches one of its children. If so, the node delegates its reading task to its child.&lt;/li&gt;
&lt;li&gt;This approach walks down the tree, pulling symbols from the input that match the path down the tree.&lt;/li&gt;
&lt;li&gt;When a node does not have a child that matches the next character, we will have read the longest possible symbol prefix. This prefix may or may not be a valid symbol.&lt;/li&gt;
&lt;li&gt;Consider a tree that has had &lt;em&gt;=:~&lt;/em&gt; added and has not had &lt;em&gt;=:&lt;/em&gt; added. In this tree, of the three nodes that contain &lt;em&gt;=:~&lt;/em&gt;, only the first and third contain
complete symbols. If, say, the input contains &lt;em&gt;=:a&lt;/em&gt;, the colon node will not have a child that matches the &amp;lsquo;a&amp;rsquo; and so it will stop reading. The colon node has to &amp;ldquo;unread&amp;rdquo;: it must push back its character, and ask its parent to unread. Unreading continues until it reaches an ancestor that represents a valid symbol.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;constructors&#34;&gt;Constructors&lt;/h3&gt;
&lt;p&gt;Constructs a SymbolNode with the given parent, representing the given character.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;public&lt;/code&gt; constructor(parent: &lt;a href=&#34;&#34;&gt;SymbolNode&lt;/a&gt;, character: number)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;parent&lt;/strong&gt;: &lt;a href=&#34;&#34;&gt;SymbolNode&lt;/a&gt; - node&amp;rsquo;s parent&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;character&lt;/strong&gt;: number - node&amp;rsquo;s associated character.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;properties&#34;&gt;Properties&lt;/h3&gt;
&lt;h4 id=&#34;tokentype&#34;&gt;tokenType&lt;/h4&gt;
&lt;p&gt;Token type&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;public&lt;/code&gt; tokenType(): &lt;a href=&#34;../../token_type&#34;&gt;TokenType&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;returns&lt;/strong&gt;: &lt;a href=&#34;../../token_type&#34;&gt;TokenType&lt;/a&gt; - token type&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;public&lt;/code&gt; tokenType(value: &lt;a href=&#34;../../token_type&#34;&gt;TokenType&lt;/a&gt;)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;value&lt;/strong&gt;: &lt;a href=&#34;../../token_type&#34;&gt;TokenType&lt;/a&gt; - token type&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;valid&#34;&gt;valid&lt;/h4&gt;
&lt;p&gt;Boolean variable&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;public&lt;/code&gt; valid(): boolean&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;returns&lt;/strong&gt;: boolean - true or false&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;public&lt;/code&gt; valid(value: boolean)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;value&lt;/strong&gt;: boolean - true or false&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;instance-methods&#34;&gt;Instance methods&lt;/h3&gt;
&lt;h4 id=&#34;adddescendantline&#34;&gt;addDescendantLine&lt;/h4&gt;
&lt;p&gt;Adds a line of descendants that represents the characters in the given string.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;public&lt;/code&gt; addDescendantLine(value: string, tokenType: &lt;a href=&#34;../../token_type&#34;&gt;TokenType&lt;/a&gt;): void&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;value&lt;/strong&gt;: string - given string&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;tokenType&lt;/strong&gt;: &lt;a href=&#34;../../token_type&#34;&gt;TokenType&lt;/a&gt; - token type&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;ancestry&#34;&gt;ancestry&lt;/h4&gt;
&lt;p&gt;Shows the symbol this node represents.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;public&lt;/code&gt; ancestry(): string&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;returns&lt;/strong&gt;: string - symbol this node represents.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;deepestread&#34;&gt;deepestRead&lt;/h4&gt;
&lt;p&gt;Establishes characters in the given range as valid characters for the part of a word after the first character. Note that the tokenizer must determine which characters are valid as the beginning character of a word.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;public&lt;/code&gt; deepestRead(scanner: &lt;a href=&#34;../../../io/iscanner&#34;&gt;IScanner&lt;/a&gt;): &lt;a href=&#34;&#34;&gt;SymbolNode&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;scanner&lt;/strong&gt;: &lt;a href=&#34;../../../io/iscanner&#34;&gt;IScanner&lt;/a&gt; - scanner&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;returns&lt;/strong&gt;: &lt;a href=&#34;&#34;&gt;SymbolNode&lt;/a&gt; - symbol&amp;rsquo;s node&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;ensurechildwithchar&#34;&gt;ensureChildWithChar&lt;/h4&gt;
&lt;p&gt;Finds or creates a child for the given character.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;public&lt;/code&gt; ensureChildWithChar(value: number): &lt;a href=&#34;&#34;&gt;SymbolNode&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;value&lt;/strong&gt;: number - chararacters&amp;rsquo;s&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;returns&lt;/strong&gt;: &lt;a href=&#34;&#34;&gt;SymbolNode&lt;/a&gt; - TODO: add description&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;findchildwithchar&#34;&gt;findChildWithChar&lt;/h4&gt;
&lt;p&gt;Finds a child with the given character.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;public&lt;/code&gt; findChildWithChar(value: number): &lt;a href=&#34;&#34;&gt;SymbolNode&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;value&lt;/strong&gt;: number - value&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;returns&lt;/strong&gt;: &lt;a href=&#34;&#34;&gt;SymbolNode&lt;/a&gt; - symbol&amp;rsquo;s node&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;unreadtovalid&#34;&gt;unreadToValid&lt;/h4&gt;
&lt;p&gt;Unwinds to a valid node; this node is &amp;ldquo;valid&amp;rdquo; if its ancestry represents a complete symbol.
If this node is not valid, puts back the character and asks the parent to unwind.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;public&lt;/code&gt; unreadToValid(scanner: &lt;a href=&#34;../../../io/iscanner&#34;&gt;IScanner&lt;/a&gt;): &lt;a href=&#34;&#34;&gt;SymbolNode&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;scanner&lt;/strong&gt;: &lt;a href=&#34;../../../io/iscanner&#34;&gt;IScanner&lt;/a&gt; - scanner&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;returns&lt;/strong&gt;: &lt;a href=&#34;&#34;&gt;SymbolNode&lt;/a&gt; - symbol&amp;rsquo;s node&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
    
    <item>
      <title>Node: SymbolNode</title>
      <link>/node/expressions/tokenizers/generic/symbol_root_node/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/node/expressions/tokenizers/generic/symbol_root_node/</guid>
      <description>
        
        
        &lt;p&gt;&lt;strong&gt;Extends&lt;/strong&gt;: &lt;a href=&#34;../symbol_node&#34;&gt;SymbolNode&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;description&#34;&gt;Description&lt;/h3&gt;
&lt;p&gt;TODO: add description&lt;/p&gt;
&lt;h3 id=&#34;constructors&#34;&gt;Constructors&lt;/h3&gt;
&lt;p&gt;Creates and initializes a root node.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;public&lt;/code&gt; constructor()&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;instance-methods&#34;&gt;Instance methods&lt;/h3&gt;
&lt;h4 id=&#34;add&#34;&gt;add&lt;/h4&gt;
&lt;p&gt;Add the given string as a symbol.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;public&lt;/code&gt; add(value: string, tokenType: &lt;a href=&#34;../../token_type&#34;&gt;TokenType&lt;/a&gt;): void&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;value&lt;/strong&gt;: string - The character sequence to add.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;tokenType&lt;/strong&gt;: &lt;a href=&#34;../../token_type&#34;&gt;TokenType&lt;/a&gt; - TODO: add description&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;ancestry&#34;&gt;ancestry&lt;/h4&gt;
&lt;p&gt;Show the symbol this node represents.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;public&lt;/code&gt; ancestry(): string&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;returns&lt;/strong&gt;: string - The symbol this node represents.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;nexttoken&#34;&gt;nextToken&lt;/h4&gt;
&lt;p&gt;Return a symbol string from a scanner.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;public&lt;/code&gt; nextToken(scanner: &lt;a href=&#34;../../../io/iscanner&#34;&gt;IScanner&lt;/a&gt;): &lt;a href=&#34;../../token&#34;&gt;Token&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;scanner&lt;/strong&gt;: &lt;a href=&#34;../../../io/iscanner&#34;&gt;IScanner&lt;/a&gt; - A scanner to read from&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;returns&lt;/strong&gt;: &lt;a href=&#34;&#34;&gt;SymbolNode&lt;/a&gt; - A symbol string from a scanner&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
    
  </channel>
</rss>
