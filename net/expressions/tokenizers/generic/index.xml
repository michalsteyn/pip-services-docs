<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title> â€“ Generic</title>
    <link>/net/expressions/tokenizers/generic/</link>
    <description>Recent content in Generic on </description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    
	  <atom:link href="/net/expressions/tokenizers/generic/index.xml" rel="self" type="application/rss+xml" />
    
    
      
        
      
    
    
    <item>
      <title>Net: CCommentState</title>
      <link>/net/expressions/tokenizers/generic/c_comment_state/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/net/expressions/tokenizers/generic/c_comment_state/</guid>
      <description>
        
        
        &lt;h3 id=&#34;description&#34;&gt;Description&lt;/h3&gt;
&lt;p&gt;The CCommentState class allows you to create a state that will either delegate to a comment-handling state, or return a token with just a slash in it.&lt;/p&gt;
&lt;h3 id=&#34;instance-methods&#34;&gt;Instance methods&lt;/h3&gt;
&lt;h4 id=&#34;nexttoken&#34;&gt;NextToken&lt;/h4&gt;
&lt;p&gt;Either delegates to a comment-handling state, or returns a token with just a slash in it.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;public override&lt;/code&gt; &lt;a href=&#34;../../token&#34;&gt;Token&lt;/a&gt; NextToken(&lt;a href=&#34;../../../io/iscanner&#34;&gt;IScanner&lt;/a&gt; scanner, &lt;a href=&#34;../../itokenizer&#34;&gt;ITokenizer&lt;/a&gt; tokenizer)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;scanner&lt;/strong&gt;: &lt;a href=&#34;../../../io/iscanner&#34;&gt;IScanner&lt;/a&gt; - text string to be tokenized.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;tokenizer&lt;/strong&gt;: &lt;a href=&#34;../../itokenizer&#34;&gt;ITokenizer&lt;/a&gt; - tokenizer class that controls the process.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;returns&lt;/strong&gt;: &lt;a href=&#34;../../token&#34;&gt;Token&lt;/a&gt; - next token from the top of the stream.&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
    
    <item>
      <title>Net: CppCommentState</title>
      <link>/net/expressions/tokenizers/generic/cpp_comment_state/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/net/expressions/tokenizers/generic/cpp_comment_state/</guid>
      <description>
        
        
        &lt;p&gt;&lt;strong&gt;Inherits&lt;/strong&gt;: &lt;a href=&#34;../generic_comment_state&#34;&gt;GenericCommentState&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;description&#34;&gt;Description&lt;/h3&gt;
&lt;p&gt;The CppCommentState class allows you to create a state that will either delegate to a comment-handling state, or return a token with just a slash in it.&lt;/p&gt;
&lt;h3 id=&#34;instance-methods&#34;&gt;Instance methods&lt;/h3&gt;
&lt;h4 id=&#34;getmultilinecomment&#34;&gt;GetMultiLineComment&lt;/h4&gt;
&lt;p&gt;Ignores everything up to a closing star and slash, and then returns the tokenizer&amp;rsquo;s next token.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;protected static&lt;/code&gt; string GetMultiLineComment(&lt;a href=&#34;../../../io/iscanner&#34;&gt;IScanner&lt;/a&gt; scanner)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;scanner&lt;/strong&gt;: &lt;a href=&#34;../../../io/iscanner&#34;&gt;IScanner&lt;/a&gt; - scanner&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;returns&lt;/strong&gt;: string - comment&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;getsinglelinecomment&#34;&gt;GetSingleLineComment&lt;/h4&gt;
&lt;p&gt;Ignores everything up to an end-of-line, and then returns the tokenizer&amp;rsquo;s next token.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;protected static&lt;/code&gt; string GetSingleLineComment(&lt;a href=&#34;../../../io/iscanner&#34;&gt;IScanner&lt;/a&gt; scanner)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;scanner&lt;/strong&gt;: &lt;a href=&#34;../../../io/iscanner&#34;&gt;IScanner&lt;/a&gt; - scanner&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;returns&lt;/strong&gt;: string - comment&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;nexttoken&#34;&gt;NextToken&lt;/h4&gt;
&lt;p&gt;Either delegates to a comment-handling state, or returns a token with just a slash in it.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;public virtual&lt;/code&gt; &lt;a href=&#34;../../token&#34;&gt;Token&lt;/a&gt; NextToken(&lt;a href=&#34;../../../io/iscanner&#34;&gt;IScanner&lt;/a&gt; scanner, &lt;a href=&#34;../../itokenizer&#34;&gt;ITokenizer&lt;/a&gt; tokenizer)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;scanner&lt;/strong&gt;: &lt;a href=&#34;../../../io/iscanner&#34;&gt;IScanner&lt;/a&gt; - text string to be tokenized.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;tokenizer&lt;/strong&gt;: &lt;a href=&#34;../../itokenizer&#34;&gt;ITokenizer&lt;/a&gt; - tokenizer class that controls the process.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;returns&lt;/strong&gt;: &lt;a href=&#34;../../token&#34;&gt;Token&lt;/a&gt; - next token from the top of the stream.&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
    
    <item>
      <title>Net: GenericCommentState</title>
      <link>/net/expressions/tokenizers/generic/generic_comment_state/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/net/expressions/tokenizers/generic/generic_comment_state/</guid>
      <description>
        
        
        &lt;p&gt;&lt;strong&gt;Inherits&lt;/strong&gt;: &lt;a href=&#34;../../icomment_state&#34;&gt;ICommentState&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;description&#34;&gt;Description&lt;/h3&gt;
&lt;p&gt;The GenericCommentState class allows you to create a CommentState object that returns a comment from a scanner.&lt;/p&gt;
&lt;h3 id=&#34;instance-methods&#34;&gt;Instance methods&lt;/h3&gt;
&lt;h4 id=&#34;nexttoken&#34;&gt;nextToken&lt;/h4&gt;
&lt;p&gt;Either delegates to a comment-handling state, or returns a token with just a slash in it.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;public virtual&lt;/code&gt; &lt;a href=&#34;../../token&#34;&gt;Token&lt;/a&gt; NextToken(&lt;a href=&#34;../../../io/iscanner&#34;&gt;IScanner&lt;/a&gt; scanner, &lt;a href=&#34;../../itokenizer&#34;&gt;ITokenizer&lt;/a&gt; tokenizer)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;scanner&lt;/strong&gt;: &lt;a href=&#34;../../../io/iscanner&#34;&gt;IScanner&lt;/a&gt; - text string to be tokenized.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;tokenizer&lt;/strong&gt;: &lt;a href=&#34;../../itokenizer&#34;&gt;ITokenizer&lt;/a&gt; - tokenizer class that controls the process.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;returns&lt;/strong&gt;: &lt;a href=&#34;../../token&#34;&gt;Token&lt;/a&gt; - next token from the top of the stream.&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
    
    <item>
      <title>Net: GenericNumberState</title>
      <link>/net/expressions/tokenizers/generic/generic_number_state/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/net/expressions/tokenizers/generic/generic_number_state/</guid>
      <description>
        
        
        &lt;p&gt;&lt;strong&gt;Inherits&lt;/strong&gt;: &lt;a href=&#34;../../inumber_state&#34;&gt;INumberState&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;description&#34;&gt;Description&lt;/h3&gt;
&lt;p&gt;The GenericNumberState class allows you to create a NumberState object returns a number from a scanner.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Important points&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;This state&amp;rsquo;s idea of a number allows an optional, initial minus sign, followed by one or more digits. A decimal point and another string of digits may follow these digits.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;instance-methods&#34;&gt;Instance methods&lt;/h3&gt;
&lt;h4 id=&#34;nexttoken&#34;&gt;NextToken&lt;/h4&gt;
&lt;p&gt;Gets the next token from the stream started from the character linked to this state.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;public virtual&lt;/code&gt; &lt;a href=&#34;../../token&#34;&gt;Token&lt;/a&gt; NextToken(&lt;a href=&#34;../../../io/iscanner&#34;&gt;IScanner&lt;/a&gt; scanner, &lt;a href=&#34;../../itokenizer&#34;&gt;ITokenizer&lt;/a&gt; tokenizer)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;scanner&lt;/strong&gt;: &lt;a href=&#34;../../../io/iscanner&#34;&gt;IScanner&lt;/a&gt; - text string to be tokenized.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;tokenizer&lt;/strong&gt;: &lt;a href=&#34;../../itokenizer&#34;&gt;ITokenizer&lt;/a&gt; - tokenizer class that controls the process.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;returns&lt;/strong&gt;: &lt;a href=&#34;../../token&#34;&gt;Token&lt;/a&gt; - next token from the top of the stream.&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
    
    <item>
      <title>Net: GenericQuoteState</title>
      <link>/net/expressions/tokenizers/generic/generic_quote_state/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/net/expressions/tokenizers/generic/generic_quote_state/</guid>
      <description>
        
        
        &lt;p&gt;&lt;strong&gt;Inherits&lt;/strong&gt;: &lt;a href=&#34;../../iquote_state&#34;&gt;IQuoteState&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;description&#34;&gt;Description&lt;/h3&gt;
&lt;p&gt;The GenericQuoteState allows you to create a quoteState that returns a quoted string token from a scanner.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Important points&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;This state will collect characters until it sees a match to the character that the tokenizer used to switch to this state.&lt;/li&gt;
&lt;li&gt;For example, if a tokenizer uses a double-quote character to enter this state, then &lt;em&gt;nextToken()&lt;/em&gt; will search for another double-quote until it finds one or finds the end of the scanner.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;instance-methods&#34;&gt;Instance methods&lt;/h3&gt;
&lt;h4 id=&#34;decodestring&#34;&gt;DecodeString&lt;/h4&gt;
&lt;p&gt;Decodes a string value.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;public virtual&lt;/code&gt; string DecodeString(string value, char quoteSymbol)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;value&lt;/strong&gt;: string - string value to be decoded.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;quoteSymbol&lt;/strong&gt;: char - string quote character.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;returns&lt;/strong&gt;: string - decoded string.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;encodestring&#34;&gt;EncodeString&lt;/h4&gt;
&lt;p&gt;Encodes a string value.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;public virtual&lt;/code&gt; string EncodeString(string value, char quoteSymbol)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;value&lt;/strong&gt;: string - string value to be encoded.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;quoteSymbol&lt;/strong&gt;: char - string quote character.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;returns&lt;/strong&gt;: string - encoded string.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;nexttoken&#34;&gt;NextToken&lt;/h4&gt;
&lt;p&gt;Returns a quoted string token from a scanner. This method will collect
characters until it sees a match to the character that the tokenizer used
to switch to this state.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;public virtual&lt;/code&gt; &lt;a href=&#34;../../token&#34;&gt;Token&lt;/a&gt; NextToken(&lt;a href=&#34;../../../io/iscanner&#34;&gt;IScanner&lt;/a&gt; scanner, &lt;a href=&#34;../../itokenizer&#34;&gt;ITokenizer&lt;/a&gt; tokenizer)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;scanner&lt;/strong&gt;: &lt;a href=&#34;../../../io/iscanner&#34;&gt;IScanner&lt;/a&gt; - text string to be tokenized.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;tokenizer&lt;/strong&gt;: &lt;a href=&#34;../../itokenizer&#34;&gt;ITokenizer&lt;/a&gt; - tokenizer class that controls the process.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;returns&lt;/strong&gt;: &lt;a href=&#34;../../token&#34;&gt;Token&lt;/a&gt; - next token from the top of the stream.&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
    
    <item>
      <title>Net: GenericSymbolState</title>
      <link>/net/expressions/tokenizers/generic/generic_symbol_state/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/net/expressions/tokenizers/generic/generic_symbol_state/</guid>
      <description>
        
        
        &lt;p&gt;&lt;strong&gt;Inherits&lt;/strong&gt;: &lt;a href=&#34;../../isymbol_state&#34;&gt;ISymbolState&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;description&#34;&gt;Description&lt;/h3&gt;
&lt;p&gt;The GenericSymbolState class allows you to add multi-character symbols and obtain a symbol token from a scanner.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Important points&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The idea of a symbol is a character that stands on its own, such as an ampersand or a parenthesis.&lt;/li&gt;
&lt;li&gt;For example, when tokenizing the expression &lt;em&gt;(isReady)&amp;amp; (isWilling)&lt;/em&gt;, a typical tokenizer would return 7 tokens, including one for each parenthesis and one for the ampersand. Thus, a series of symbols such as &lt;em&gt;)&amp;amp;(&lt;/em&gt; becomes three tokens, while a series of letters such as &lt;em&gt;isReady&lt;/em&gt; becomes a single word token.&lt;/li&gt;
&lt;li&gt;Multi-character symbols are an exception to the rule that a symbol is a standalone character.&lt;/li&gt;
&lt;li&gt;For example, a tokenizer may want less-than-or-equals to tokenize as a single token. This class provides a method for establishing which multi-character symbols an object of this class should treat as single symbols. This allows, for example, &lt;em&gt;&amp;ldquo;cat &amp;lt;= dog&amp;rdquo;&lt;/em&gt; to tokenize as three tokens, rather than splitting the less-than and equals symbols into separate tokens.&lt;/li&gt;
&lt;li&gt;By default, this state recognizes the following multi-character symbols: &lt;em&gt;!=, :-, &amp;lt;=, &amp;gt;=&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;instance-methods&#34;&gt;Instance methods&lt;/h3&gt;
&lt;h4 id=&#34;add&#34;&gt;Add&lt;/h4&gt;
&lt;p&gt;Adds a multi-character symbol.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;public&lt;/code&gt; void Add(string value, &lt;a href=&#34;../../token_type&#34;&gt;TokenType&lt;/a&gt; tokenType)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;value&lt;/strong&gt;: string - symbol to add, such as &lt;em&gt;&amp;quot;=:=&amp;quot;&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;tokenType&lt;/strong&gt;: &lt;a href=&#34;../../token_type&#34;&gt;TokenType&lt;/a&gt; - type of token&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;nexttoken&#34;&gt;NextToken&lt;/h4&gt;
&lt;p&gt;Returns a symbol token from a scanner.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;public virtual&lt;/code&gt; &lt;a href=&#34;../../token&#34;&gt;Token&lt;/a&gt; NextToken(&lt;a href=&#34;../../../io/iscanner&#34;&gt;IScanner&lt;/a&gt; scanner, &lt;a href=&#34;../../itokenizer&#34;&gt;ITokenizer&lt;/a&gt; tokenizer)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;scanner&lt;/strong&gt;: &lt;a href=&#34;../../../io/iscanner&#34;&gt;IScanner&lt;/a&gt; - text string to be tokenized.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;tokenizer&lt;/strong&gt;: &lt;a href=&#34;../../itokenizer&#34;&gt;ITokenizer&lt;/a&gt; - tokenizer class that controls the process.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;returns&lt;/strong&gt;: &lt;a href=&#34;../../token&#34;&gt;Token&lt;/a&gt; - next token from the top of the stream.&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
    
    <item>
      <title>Net: GenericTokenizer</title>
      <link>/net/expressions/tokenizers/generic/generic_tokenizer/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/net/expressions/tokenizers/generic/generic_tokenizer/</guid>
      <description>
        
        
        &lt;p&gt;&lt;strong&gt;Extends&lt;/strong&gt;: &lt;a href=&#34;../../abstract_tokenizer&#34;&gt;AbstractTokenizer&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;description&#34;&gt;Description&lt;/h3&gt;
&lt;p&gt;The GenericTokenizer allows you to implement a default tokenizer class.&lt;/p&gt;
&lt;h3 id=&#34;constructors&#34;&gt;Constructors&lt;/h3&gt;
&lt;p&gt;Creates an instance of GenericTokenizer.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;public&lt;/code&gt; GenericTokenizer()&lt;/p&gt;
&lt;/blockquote&gt;

      </description>
    </item>
    
    <item>
      <title>Net: GenericWhitespaceState</title>
      <link>/net/expressions/tokenizers/generic/generic_whitespace_state/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/net/expressions/tokenizers/generic/generic_whitespace_state/</guid>
      <description>
        
        
        &lt;p&gt;&lt;strong&gt;Inherits&lt;/strong&gt;: &lt;a href=&#34;../../iwhitespace_state&#34;&gt;IWhitespaceState&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;description&#34;&gt;Description&lt;/h3&gt;
&lt;p&gt;The GenericWhitespaceState allows you to create a whitespace state.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Important points&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A whitespace state ignores whitespace (such as blanks and tabs), and returns the tokenizer&amp;rsquo;s next token. By default, all characters from 0 to 32 are whitespace.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;constructors&#34;&gt;Constructors&lt;/h3&gt;
&lt;p&gt;Constructs a whitespace state with a default idea of what characters are, in fact, whitespace.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;public&lt;/code&gt; GenericWhitespaceState()&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;instance-methods&#34;&gt;Instance methods&lt;/h3&gt;
&lt;h4 id=&#34;clearwhitespacechars&#34;&gt;ClearWhitespaceChars&lt;/h4&gt;
&lt;p&gt;Clears definitions of whitespace characters.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;public&lt;/code&gt; void ClearWhitespaceChars()&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;nexttoken&#34;&gt;NextToken&lt;/h4&gt;
&lt;p&gt;Ignores whitespace (such as blanks and tabs), and returns the tokenizer&amp;rsquo;s next token.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;public virtual&lt;/code&gt; &lt;a href=&#34;../../token&#34;&gt;Token&lt;/a&gt; NextToken(&lt;a href=&#34;../../../io/iscanner&#34;&gt;IScanner&lt;/a&gt; scanner, &lt;a href=&#34;../../itokenizer&#34;&gt;ITokenizer&lt;/a&gt; tokenizer)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;scanner&lt;/strong&gt;: &lt;a href=&#34;../../../io/iscanner&#34;&gt;IScanner&lt;/a&gt; - text string to be tokenized.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;tokenizer&lt;/strong&gt;: &lt;a href=&#34;../../itokenizer&#34;&gt;ITokenizer&lt;/a&gt; - tokenizer class that controls the process.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;returns&lt;/strong&gt;: &lt;a href=&#34;../../token&#34;&gt;Token&lt;/a&gt; - next token from the top of the stream.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;setwhitespacechars&#34;&gt;SetWhitespaceChars&lt;/h4&gt;
&lt;p&gt;Establishes the given characters as whitespace to ignore.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;public&lt;/code&gt; void SetWhitespaceChars(char fromSymbol, char toSymbol, bool enable)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;fromSymbol&lt;/strong&gt;: char - first character index of the interval.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;toSymbol&lt;/strong&gt;: char - last character index of the interval.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;enable&lt;/strong&gt;: bool - &lt;em&gt;true&lt;/em&gt; if this state should ignore characters in the given range.&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
    
    <item>
      <title>Net: GenericWordState</title>
      <link>/net/expressions/tokenizers/generic/generic_word_state/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/net/expressions/tokenizers/generic/generic_word_state/</guid>
      <description>
        
        
        &lt;p&gt;&lt;strong&gt;Inherits&lt;/strong&gt;: &lt;a href=&#34;../../iword_state&#34;&gt;IWordState&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;description&#34;&gt;Description&lt;/h3&gt;
&lt;p&gt;The GenericWordState class allows you to create a WordState that returns a word from a scanner.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Important points&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Like other states, a tokenizer transfers the job of reading to this state, depending on an initial character.&lt;/li&gt;
&lt;li&gt;This state determines which characters may appear as a second or later character in a word. These are typically different sets of characters. In particular, it is typical for digits to appear as parts of a word, but not as the initial character of a word.&lt;/li&gt;
&lt;li&gt;By default, the following characters may appear in a word (The method &lt;em&gt;setWordChars()&lt;/em&gt; allows customizing this):&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;&lt;pre&gt;
From     To
 &#39;a&#39;,    &#39;z&#39;
 &#39;A&#39;,    &#39;Z&#39;
 &#39;0&#39;,    &#39;9&#39;
&lt;p&gt;&lt;/pre&gt;&lt;/blockquote&gt;
As well as: minus sign, underscore, and apostrophe.&lt;/p&gt;
&lt;h3 id=&#34;constructors&#34;&gt;Constructors&lt;/h3&gt;
&lt;p&gt;Constructs a word state with a default idea of what characters
are admissible inside a word (as described in the class comment).&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;public&lt;/code&gt; GenericWordState()&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;instance-methods&#34;&gt;Instance methods&lt;/h3&gt;
&lt;h4 id=&#34;clearwordchars&#34;&gt;ClearWordChars&lt;/h4&gt;
&lt;p&gt;Clears definitions of word chars.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;public&lt;/code&gt; void ClearWordChars()&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;nexttoken&#34;&gt;NextToken&lt;/h4&gt;
&lt;p&gt;Ignores a word (such as blanks and tabs), and returns the tokenizer&amp;rsquo;s next token.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;public virtual&lt;/code&gt; &lt;a href=&#34;../../token&#34;&gt;Token&lt;/a&gt; NextToken(&lt;a href=&#34;../../../io/iscanner&#34;&gt;IScanner&lt;/a&gt; scanner, &lt;a href=&#34;../../itokenizer&#34;&gt;ITokenizer&lt;/a&gt; tokenizer)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;scanner&lt;/strong&gt;: &lt;a href=&#34;../../../io/iscanner&#34;&gt;IScanner&lt;/a&gt; - textual string to be tokenized.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;tokenizer&lt;/strong&gt;: &lt;a href=&#34;../../itokenizer&#34;&gt;ITokenizer&lt;/a&gt; - tokenizer class that controls the process.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;returns&lt;/strong&gt;: &lt;a href=&#34;../../token&#34;&gt;Token&lt;/a&gt; - next token from the top of the stream.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;setwordchars&#34;&gt;SetWordChars&lt;/h4&gt;
&lt;p&gt;Establishes characters in the given range as valid characters for part of a word after the first character. Note that the tokenizer must determine which characters are valid as the beginning character of a word.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;public&lt;/code&gt; void SetWordChars(char fromSymbol, char toSymbol, bool enable)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;fromSymbol&lt;/strong&gt;: char - first character index of the interval.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;toSymbol&lt;/strong&gt;: char - last character index of the interval.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;enable&lt;/strong&gt;: bool - &lt;em&gt;true&lt;/em&gt; if this state should ignore characters in the given range.&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
    
    <item>
      <title>Net: SymbolNode</title>
      <link>/net/expressions/tokenizers/generic/symbol_node/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/net/expressions/tokenizers/generic/symbol_node/</guid>
      <description>
        
        
        &lt;h3 id=&#34;description&#34;&gt;Description&lt;/h3&gt;
&lt;p&gt;The SymbolNode class allows you to construct a SymbolNode.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Important points&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A &lt;em&gt;SymbolNode&lt;/em&gt; object is a member of a tree that contains all possible prefixes of allowable symbols. Multi-character symbols appear in a &lt;em&gt;SymbolNode&lt;/em&gt; tree with one node for each character.&lt;/li&gt;
&lt;li&gt;For example, the symbol &lt;em&gt;=:~&lt;/em&gt; will appear in a tree as three nodes. The first node contains an equals sign and has a child. That child contains a colon and has a child. This third child contains a tilde, and has no children of its own. If the colon node had another child for a dollar sign character, then the tree would contain the symbol &lt;em&gt;=:$&lt;/em&gt;.&lt;/li&gt;
&lt;li&gt;A tree of &lt;em&gt;SymbolNode&lt;/em&gt; objects collaborate to read a (potentially multi-character) symbol from an input stream. A root node with no character of its own finds an initial node
that represents the first character in the input. This node looks to see if the next character in the stream matches one of its children. If so, the node delegates its reading task to its child.&lt;/li&gt;
&lt;li&gt;This approach walks down the tree, pulling symbols from the input that match the path down the tree.&lt;/li&gt;
&lt;li&gt;When a node does not have a child that matches the next character, we will have read the longest possible symbol prefix. This prefix may or may not be a valid symbol.&lt;/li&gt;
&lt;li&gt;Consider a tree that has had &lt;em&gt;=:~&lt;/em&gt; added and has not had &lt;em&gt;=:&lt;/em&gt; added. In this tree, of the three nodes that contain &lt;em&gt;=:~&lt;/em&gt;, only the first and third contain
complete symbols. If, say, the input contains &lt;em&gt;=:a&lt;/em&gt;, the colon node will not have a child that matches the &amp;lsquo;a&amp;rsquo; and so it will stop reading. The colon node has to &amp;ldquo;unread&amp;rdquo;: it must push back its character, and ask its parent to unread. Unreading continues until it reaches an ancestor that represents a valid symbol.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;constructors&#34;&gt;Constructors&lt;/h3&gt;
&lt;p&gt;Constructs a SymbolNode with the given parent, representing the given character.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;public&lt;/code&gt; SymbolNode(&lt;a href=&#34;&#34;&gt;SymbolNode&lt;/a&gt; parent, char character)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;parent&lt;/strong&gt;: &lt;a href=&#34;&#34;&gt;SymbolNode&lt;/a&gt; - node&amp;rsquo;s parent&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;character&lt;/strong&gt;: char - node&amp;rsquo;s associated character.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;properties&#34;&gt;Properties&lt;/h3&gt;
&lt;h4 id=&#34;tokentype&#34;&gt;TokenType&lt;/h4&gt;
&lt;p&gt;Token type&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;public&lt;/code&gt; &lt;a href=&#34;../../token_type&#34;&gt;TokenType&lt;/a&gt; TokenType { get; set; }&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;valid&#34;&gt;Valid&lt;/h4&gt;
&lt;p&gt;Boolean variable&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;internal&lt;/code&gt; bool Valid { get; set; }&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;instance-methods&#34;&gt;Instance methods&lt;/h3&gt;
&lt;h4 id=&#34;adddescendantline&#34;&gt;AddDescendantLine&lt;/h4&gt;
&lt;p&gt;Adds a line of descendants that represents the characters in the given string.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;internal&lt;/code&gt; void AddDescendantLine(string value, &lt;a href=&#34;../../token_type&#34;&gt;TokenType&lt;/a&gt; tokenType)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;value&lt;/strong&gt;: string - given string&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;tokenType&lt;/strong&gt;: &lt;a href=&#34;../../token_type&#34;&gt;TokenType&lt;/a&gt; - token type&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;ancestry&#34;&gt;Ancestry&lt;/h4&gt;
&lt;p&gt;Shows the symbol this node represents.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;public&lt;/code&gt; string Ancestry()&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;returns&lt;/strong&gt;: string - symbol this node represents.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;deepestread&#34;&gt;DeepestRead&lt;/h4&gt;
&lt;p&gt;Establishes characters in the given range as valid characters for the part of a word after the first character. Note that the tokenizer must determine which characters are valid as the beginning character of a word.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;internal&lt;/code&gt; &lt;a href=&#34;&#34;&gt;SymbolNode&lt;/a&gt; DeepestRead(&lt;a href=&#34;../../../io/iscanner&#34;&gt;IScanner&lt;/a&gt; scanner)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;scanner&lt;/strong&gt;: &lt;a href=&#34;../../../io/iscanner&#34;&gt;IScanner&lt;/a&gt; - scanner&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;returns&lt;/strong&gt;: &lt;a href=&#34;&#34;&gt;SymbolNode&lt;/a&gt; - symbol&amp;rsquo;s node&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;ensurechildwithchar&#34;&gt;EnsureChildWithChar&lt;/h4&gt;
&lt;p&gt;Finds or creates a child for the given character.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;internal&lt;/code&gt; &lt;a href=&#34;&#34;&gt;SymbolNode&lt;/a&gt; EnsureChildWithChar(char value)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;value&lt;/strong&gt;: char - chararacters&amp;rsquo;s value&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;returns&lt;/strong&gt;: &lt;a href=&#34;&#34;&gt;SymbolNode&lt;/a&gt; - symbol&amp;rsquo;s node&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;findchildwithchar&#34;&gt;FindChildWithChar&lt;/h4&gt;
&lt;p&gt;Finds a child with the given character.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;internal virtual&lt;/code&gt; &lt;a href=&#34;&#34;&gt;SymbolNode&lt;/a&gt; FindChildWithChar(char value)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;value&lt;/strong&gt;: char - value&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;returns&lt;/strong&gt;: &lt;a href=&#34;&#34;&gt;SymbolNode&lt;/a&gt; - symbol&amp;rsquo;s node&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;unreadtovalid&#34;&gt;UnreadToValid&lt;/h4&gt;
&lt;p&gt;Unwinds to a valid node. This node is &amp;ldquo;valid&amp;rdquo; if its ancestry represents a complete symbol.
If this node is not valid, puts back the character and asks the parent to unwind.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;internal&lt;/code&gt; &lt;a href=&#34;&#34;&gt;SymbolNode&lt;/a&gt; UnreadToValid(&lt;a href=&#34;../../../io/iscanner&#34;&gt;IScanner&lt;/a&gt; scanner)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;scanner&lt;/strong&gt;: &lt;a href=&#34;../../../io/iscanner&#34;&gt;IScanner&lt;/a&gt; - scanner&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;returns&lt;/strong&gt;: &lt;a href=&#34;&#34;&gt;SymbolNode&lt;/a&gt; - symbol&amp;rsquo;s node&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
    
    <item>
      <title>Net: SymbolRootNode</title>
      <link>/net/expressions/tokenizers/generic/symbol_root_node/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/net/expressions/tokenizers/generic/symbol_root_node/</guid>
      <description>
        
        
        &lt;p&gt;&lt;strong&gt;Inherits&lt;/strong&gt;: &lt;a href=&#34;../symbol_node&#34;&gt;SymbolNode&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;description&#34;&gt;Description&lt;/h3&gt;
&lt;p&gt;The SymbolRootNode class is a special case of &lt;em&gt;SymbolNode&lt;/em&gt;. A &lt;em&gt;SymbolRootNode&lt;/em&gt; object has no symbol of its own, but has children that represent all possible symbols.&lt;/p&gt;
&lt;h3 id=&#34;constructors&#34;&gt;Constructors&lt;/h3&gt;
&lt;p&gt;Creates and initializes a root node.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;public&lt;/code&gt; SymbolRootNode()&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;instance-methods&#34;&gt;Instance methods&lt;/h3&gt;
&lt;h4 id=&#34;add&#34;&gt;Add&lt;/h4&gt;
&lt;p&gt;Adds the given string as a symbol.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;public&lt;/code&gt; void Add(string value, &lt;a href=&#34;../../token_type&#34;&gt;TokenType&lt;/a&gt; tokenType)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;value&lt;/strong&gt;: string - character sequence to add.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;tokenType&lt;/strong&gt;: &lt;a href=&#34;../../token_type&#34;&gt;TokenType&lt;/a&gt; - token type&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;nexttoken&#34;&gt;NextToken&lt;/h4&gt;
&lt;p&gt;Returns a symbol string from a scanner.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;public&lt;/code&gt; &lt;a href=&#34;../../token&#34;&gt;Token&lt;/a&gt; NextToken(&lt;a href=&#34;../../../io/iscanner&#34;&gt;IScanner&lt;/a&gt; scanner, &lt;a href=&#34;../../itokenizer&#34;&gt;ITokenizer&lt;/a&gt; tokenizer)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;scanner&lt;/strong&gt;: &lt;a href=&#34;../../../io/iscanner&#34;&gt;IScanner&lt;/a&gt; - scanner to read from&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;returns&lt;/strong&gt;: &lt;a href=&#34;../../token&#34;&gt;Token&lt;/a&gt; - symbol string from a scanner&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
    
  </channel>
</rss>
