<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title> – Tutorials</title>
    <link>/net/tutorials/</link>
    <description>Recent content in Tutorials on </description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    
	  <atom:link href="/net/tutorials/index.xml" rel="self" type="application/rss+xml" />
    
    
      
        
      
    
    
    <item>
      <title>Net: Client Library</title>
      <link>/net/tutorials/client_library/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/net/tutorials/client_library/</guid>
      <description>
        
        
        &lt;h3 id=&#34;general-considerations&#34;&gt;General considerations&lt;/h3&gt;
&lt;p&gt;Knowing how to create a client library for your microservice is almost as important as knowing how to create the microservice itself.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../images/tutorials/client_library/client_library_diagram.png&#34; alt=&#34;Client Library Diagram&#34;&gt;&lt;/p&gt;
&lt;p&gt;At PIP.Services, we strongly recommend the use of client libraries due to the following reasons:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Client libraries are created once and can be used by all users of the microservice, which significantly reduces development time.&lt;/li&gt;
&lt;li&gt;In addition to providing a ready interaction protocol, client libraries can also contain well written mocks. These allow users to cut off dependencies to the actual microservice and use its local mock replacement for unit tests.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;That said, to make client libraries more efficient, we favor the use of the following guidelines:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The microservices external interface should use interoperable protocols and be well documented. This is done so that, if the need occurs (e.g. no clients exist for a new programming language), users of the microservice would be able to create a client on their own&lt;/li&gt;
&lt;li&gt;It’s necessary to keep to the principle of ”smart endpoints - dumb pipes”. I.e. client libraries shouldn’t contain any business logic. All business logic should be implemented in the microservice itself, to avoid ending up with multiple implementations that unexpectedly start conflicting with each other.&lt;/li&gt;
&lt;li&gt;The only exception to the previous point is optimizing requests to the server and providing a client API that is more convenient than the one that is supported on the protocol’s level.&lt;/li&gt;
&lt;li&gt;The number of external dependencies should be minimized in client libraries. The use of 3rd party libraries is acceptable only if they lack conflicting versions and provide complete backwards compatibility. Otherwise, client libraries that are written using conflicting versions of 3rd party libraries will start getting in each other’s way, when used in the same process. This rule is applicable to most programming languages, like .NET, Java, and Golang. The Pip.Services Toolkit fully complies with this rule and can safely be used to write client libraries.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Additionally, as we mentioned earlier, it’s highly recommended to implement mock versions of clients, as well as random data generators for simplifying the process of writing unit tests. And all mock clients should be tested using the same tests that are used to test the real clients, to exclude any and all differences in their implementation.&lt;/p&gt;
&lt;h3 id=&#34;creating-your-client-library&#34;&gt;Creating your client library&lt;/h3&gt;
&lt;p&gt;The client library that we will be creating in this tutorial is for the microservice described in the &lt;a href=&#34;../data_microservice&#34;&gt;Data microservice&lt;/a&gt; tutorial. To better understand the client’s logic, it’s a good idea to familiarize yourself with that tutorial first, if you haven’t done so already.
To make it easier to follow along, we’ve broken up the tutorial on writing your first client library into the following steps:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;step1&#34;&gt;Step 1. Setting up the project structure&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;step2&#34;&gt;Step 2. Designing a Direct Client&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;step3&#34;&gt;Step 3. Designing an HTTP Client&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;step4&#34;&gt;Step 4. Implementing a Mock client (with tests)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;step5&#34;&gt;Step 5. Testing the Client with a Remote Microservice&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;span class=&#34;hide-title-link&#34;&gt;
&lt;h4 id=&#34;step-1-setting-up-the-project-structurestep1&#34;&gt;&lt;a href=&#34;step1&#34;&gt;Step 1. Setting up the project structure&lt;/a&gt;&lt;/h4&gt;
&lt;h4 id=&#34;step-2-designing-a-direct-clientstep2&#34;&gt;&lt;a href=&#34;step2&#34;&gt;Step 2. Designing a Direct Client&lt;/a&gt;&lt;/h4&gt;
&lt;h4 id=&#34;step-3-designing-an-http-clientstep3&#34;&gt;&lt;a href=&#34;step3&#34;&gt;Step 3. Designing an HTTP Client&lt;/a&gt;&lt;/h4&gt;
&lt;h4 id=&#34;step-4-implementing-a-mock-clientstep4&#34;&gt;&lt;a href=&#34;step4&#34;&gt;Step 4. Implementing a Mock Client&lt;/a&gt;&lt;/h4&gt;
&lt;h4 id=&#34;step-5-testing-the-client-with-a-remote-microservicestep5&#34;&gt;&lt;a href=&#34;step5&#34;&gt;Step 5. Testing the Client with a Remote Microservice&lt;/a&gt;&lt;/h4&gt;
&lt;/span&gt;
&lt;p&gt;Let&amp;rsquo;s get started! Head on over to Step 1. Setting up the project.&lt;/p&gt;
&lt;h3 id=&#34;see-also&#34;&gt;See also&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../microservice_facade&#34;&gt;Tutorial how to create microservice facade&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../microservice_dockerization&#34;&gt;Tutorial how to dockerize a microservice&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;span class=&#34;hide-title-link&#34;&gt;
&lt;h4 id=&#34;microservice-facademicroservice_facade&#34;&gt;&lt;a href=&#34;../microservice_facade&#34;&gt;Microservice Facade&lt;/a&gt;&lt;/h4&gt;
&lt;h4 id=&#34;microservice-dockerizationmicroservice_dockerization&#34;&gt;&lt;a href=&#34;../microservice_dockerization&#34;&gt;Microservice Dockerization&lt;/a&gt;&lt;/h4&gt;
&lt;/span&gt;

      </description>
    </item>
    
    <item>
      <title>Net: Data Microservice</title>
      <link>/net/tutorials/data_microservice/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/net/tutorials/data_microservice/</guid>
      <description>
        
        
        &lt;hr&gt;
&lt;h3 id=&#34;overview&#34;&gt;Overview&lt;/h3&gt;
&lt;p&gt;In this tutorial, we’ll be writing from scratch a fully-functional Data microservice, using the patterns and mechanisms available in the Pip.Services toolkit, as well as the programming language you have selected. The microservice that we are going to be using as an example in this tutorial is called &lt;a href=&#34;../../../microservices/iot/beacons/&#34;&gt;The Beacons microservice&lt;/a&gt;, which is part of &lt;a href=&#34;../../../microservices/iot/&#34;&gt;The IoT Microservices Collection&lt;/a&gt;. This microservice is meant to perform the following simple tasks:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Store a list of BLE beacons (a.k.a. iBeacons), their unique identifiers, and the positions at which they were installed.&lt;/li&gt;
&lt;li&gt;Calculate the position of a device, using the beacons it “sees” in its vicinity.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;../../images/tutorials/data_microservice/beacon.png&#34; alt=&#34;Beacon&#34;&gt;&lt;/p&gt;
&lt;p&gt;To understand how this works, imagine the following situation: you are walking through a building that has beacons installed at various locations throughout the entire building. These beacons are broadcasting signals via bluetooth, at regular time intervals, which can be “seen” from about 200 feet away. The beacons, along with their positions, are stored in our microservice. When your smartphone starts “seeing” some of these signals, it sends a list of the beacons it “sees” to the microservice, which then calculates the position of your phone as being in the middle of the beacons it “sees”. Simple, but effective - wouldn’t you agree?&lt;/p&gt;
&lt;p&gt;The Beacons microservice that we are going to be developing will consist of a number of loosely-coupled components, following the &lt;a href=&#34;../../getting_started&#34;&gt;componentized microservice design&lt;/a&gt;. The structure of this microservice is displayed on the diagram below:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../images/tutorials/data_microservice/beacon_diagram.png&#34; alt=&#34;BeaconDiagram&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;creating-the-data-microservice&#34;&gt;Creating the data microservice&lt;/h3&gt;
&lt;p&gt;To make it easier to follow along, this tutorial is divided into the following 7 steps:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;step1&#34;&gt;Step 1. Setting up the project&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;step2&#34;&gt;Step 2. Data model development&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;step3&#34;&gt;Step 3. Implementing persistence components (with tests)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;step4&#34;&gt;Step 4. Implementing a controller (with tests)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;step5&#34;&gt;Step 5. Implementing an HTTP service (with tests)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;step6&#34;&gt;Step 6. Wrapping microservice into container&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;step7&#34;&gt;Step 7. Running and testing the microservice&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;span class=&#34;hide-title-link&#34;&gt;
&lt;h4 id=&#34;step-1-setting-up-the-projectstep1&#34;&gt;&lt;a href=&#34;step1&#34;&gt;Step 1. Setting up the project&lt;/a&gt;&lt;/h4&gt;
&lt;h4 id=&#34;step-2-data-model-developmentstep2&#34;&gt;&lt;a href=&#34;step2&#34;&gt;Step 2. Data model development&lt;/a&gt;&lt;/h4&gt;
&lt;h4 id=&#34;step-3-implementing-persistence-components-with-testsstep3&#34;&gt;&lt;a href=&#34;step3&#34;&gt;Step 3. Implementing persistence components (with tests)&lt;/a&gt;&lt;/h4&gt;
&lt;h4 id=&#34;step-4-implementing-a-controller-with-testsstep4&#34;&gt;&lt;a href=&#34;step4&#34;&gt;Step 4. Implementing a controller (with tests)&lt;/a&gt;&lt;/h4&gt;
&lt;h4 id=&#34;step-5-implementing-an-http-service-with-testsstep5&#34;&gt;&lt;a href=&#34;step5&#34;&gt;Step 5. Implementing an HTTP service (with tests)&lt;/a&gt;&lt;/h4&gt;
&lt;h4 id=&#34;step-6-wrapping-microservice-into-containerstep6&#34;&gt;&lt;a href=&#34;step6&#34;&gt;Step 6. Wrapping microservice into container&lt;/a&gt;&lt;/h4&gt;
&lt;h4 id=&#34;step-7-running-and-testing-the-microservicestep7&#34;&gt;&lt;a href=&#34;step7&#34;&gt;Step 7. Running and testing the microservice&lt;/a&gt;&lt;/h4&gt;
&lt;/span&gt;
&lt;h3 id=&#34;see-also&#34;&gt;See also&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../client_library&#34;&gt;Tutorial how to create a client library&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../microservice_dockerization&#34;&gt;Tutorial how to dockerize a microservice&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;span class=&#34;hide-title-link&#34;&gt;
&lt;h4 id=&#34;client-libraryclient_library&#34;&gt;&lt;a href=&#34;../client_library&#34;&gt;Client Library&lt;/a&gt;&lt;/h4&gt;
&lt;h4 id=&#34;microservice-dockerizationmicroservice_dockerization&#34;&gt;&lt;a href=&#34;../microservice_dockerization&#34;&gt;Microservice Dockerization&lt;/a&gt;&lt;/h4&gt;
&lt;/span&gt;

      </description>
    </item>
    
    <item>
      <title>Net: Microservice Dockerization</title>
      <link>/net/tutorials/microservice_dockerization/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/net/tutorials/microservice_dockerization/</guid>
      <description>
        
        
        &lt;hr&gt;
&lt;h3 id=&#34;introduction&#34;&gt;Introduction&lt;/h3&gt;
&lt;p&gt;Running microservices in Docker containers has become one of the most popular ways of deploying a system. However, Docker can be used for much more. Containers can be used for automating builds and testing, resulting in a 100% standardized process between developers and the CI/CD pipelines on build servers.&lt;/p&gt;
&lt;p&gt;In this tutorial, we will be demonstrating the entire process of building a microservice using Docker containers - from compiling the source code, to composing the built microservice in a container and publishing it to a repository. This can be done with any language that is supported by the Pip.Services Toolkit.&lt;/p&gt;
&lt;p&gt;The scripts used in this tutorial are meant to be used by developers, as well as by CI/CD pipelines. At the same time however, the CI/CD pipelines are always simple and look alike, no matter the language or features of the microservice itself. Build, Test, Package, and Publish scripts make up the standard set that we use in our projects.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../images/tutorials/microservice_dockerization/pipeline_scheme.png&#34; alt=&#34;Pipeline scheme&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;creating-a-dockerized-microservice&#34;&gt;Creating a dockerized microservice&lt;/h3&gt;
&lt;p&gt;To make it easier to follow along, we’ve broken up this tutorial into the following steps:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;step1&#34;&gt;Step 1. Building a microservice&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;step2&#34;&gt;Step 2. Running automated tests&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;step3&#34;&gt;Step 3. Packaging a microservice into a container&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;step4&#34;&gt;Step 4. Publishing a microservice container to a registry&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;step5&#34;&gt;Step 5. Running a dockerized microservice&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;span class=&#34;hide-title-link&#34;&gt;
&lt;h4 id=&#34;step-1-building-a-microservicestep1&#34;&gt;&lt;a href=&#34;step1&#34;&gt;Step 1. Building a microservice&lt;/a&gt;&lt;/h4&gt;
&lt;h4 id=&#34;step-2-running-automated-testsstep2&#34;&gt;&lt;a href=&#34;step2&#34;&gt;Step 2. Running automated tests&lt;/a&gt;&lt;/h4&gt;
&lt;h4 id=&#34;step-3-packaging-a-microservice-into-a-containerstep3&#34;&gt;&lt;a href=&#34;step3&#34;&gt;Step 3. Packaging a microservice into a container&lt;/a&gt;&lt;/h4&gt;
&lt;h4 id=&#34;step-4-publishing-a-microservice-container-to-a-registrystep4&#34;&gt;&lt;a href=&#34;step4&#34;&gt;Step 4. Publishing a microservice container to a registry&lt;/a&gt;&lt;/h4&gt;
&lt;h4 id=&#34;step-5-running-a-dockerized-microservicestep5&#34;&gt;&lt;a href=&#34;step5&#34;&gt;Step 5. Running a dockerized microservice&lt;/a&gt;&lt;/h4&gt;
&lt;/span&gt;

      </description>
    </item>
    
    <item>
      <title>Net: Microservice Facade</title>
      <link>/net/tutorials/microservice_facade/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/net/tutorials/microservice_facade/</guid>
      <description>
        
        
        &lt;hr&gt;
&lt;h3 id=&#34;introduction&#34;&gt;Introduction&lt;/h3&gt;
&lt;p&gt;A Facade is a microservice that serves as a point of entry to a system for external clients. The facade provides a stable external interface and hides the inner workings of a system. All requests made by external clients first arrive at the facade, which then forwards them to the appropriate microservices. The facade can also implement additional functionality, such as: authenticating and authorizing users, caching and aggregating requests, logging, etc.&lt;/p&gt;
&lt;p&gt;Microservice-based systems change quickly and chaotically. During development, the relationships between microservices can usually be tracked and fixed as needed. When intentional and/or accidental changes to an interface are rolled out to production though, they can break external clients and lead to serious business problems. This is why it’s so critical to have a facade, providing a stable interface, by hiding any and all internal changes.&lt;/p&gt;
&lt;p&gt;Oftentimes, developers use 3rd party API gateways to implement an external interface. This approach isn’t half bad and does have certain advantages, such as faster development time, existing documentation, and integration with cloud services. However, 3rd party API gateways bring along considerable limitations and are extremely inconvenient for test system deployment. Because of this, additional facade implementations still make sense, even when using API Gateways.&lt;/p&gt;
&lt;p&gt;Routing requests is one of the key functions of a facade. Some API calls can simply be redirected to the appropriate service. However, a facade doesn’t stop at just routing requests. Oftentimes there occurs the need to perform complex requests, when data must be extracted from a number of microservices, aggregated in the facade, and sent to the client as one object. This approach significantly simplifies the development of clients and speeds up the process of receiving data. For example: a mobile app can make a request to the facade, which extracts order data from various services, and send an already aggregated response.&lt;/p&gt;
&lt;p&gt;Facades can also be used to switch between protocols. For example: HTTP/RESTful, being one of the most popular external client protocols, can be used between the service and the client, while intra-microservice communication might utilize REST, gRPC, asynchronous messages, etc.&lt;/p&gt;
&lt;p&gt;A facade can additionally be used for the following:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Authentication — verifying the identity of the user making the request;&lt;/li&gt;
&lt;li&gt;Authorization — making sure that a client is allowed to perform a certain operation;&lt;/li&gt;
&lt;li&gt;Limiting the frequency of request — controlling how many request a certain client (or all clients together) can make per - second;&lt;/li&gt;
&lt;li&gt;Caching — caching responses to reduce the number of requests actually being made to services;&lt;/li&gt;
&lt;li&gt;Analytics — collecting API usage statistics for analytics that can be used for billing;&lt;/li&gt;
&lt;li&gt;Keeping a request journal — writing requests to a journal.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The general architecture of a system that uses a facade is presented in the diagram below:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../images/tutorials/microservice_facade/facade_architecture_diagram1.png&#34; alt=&#34;facade architecture diagram&#34;&gt;&lt;/p&gt;
&lt;p&gt;Large systems that have a vast external interface might include a number of facades, each of which provides a logically isolated API. Moreover, specialized facades can be developed for specific clients, providing operations that are optimized for a specific user interface.&lt;/p&gt;
&lt;h3 id=&#34;creating-a-facade&#34;&gt;Creating a Facade&lt;/h3&gt;
&lt;p&gt;In this tutorial, we will be taking a look at how to implement a simple facade that will provide a versioned external API for the microservice implemented in &lt;a href=&#34;../data_microservice&#34;&gt;the Data Microservice&lt;/a&gt; tutorial. Additionally, our facade will implement client authentication and authorization using microservices from the Pip.Services Library.&lt;/p&gt;
&lt;p&gt;To make it easier to follow along, this tutorial is broken up into the following steps:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;step1&#34;&gt;Step 1. Creating the project’s structure&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;step2&#34;&gt;Step 2. Business operations&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;step3&#34;&gt;Step 3. Authentication and sessions&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;step4&#34;&gt;Step 4. Authorization&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;step5&#34;&gt;Step 5. Service and version support&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;step6&#34;&gt;Step 6. Testing operations&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;step7&#34;&gt;Step 7. Running the facade&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;step7&#34;&gt;Step 8. Manually Testing the Facade&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The code for this tutorial can be found on &lt;a href=&#34;https://github.com/pip-services-samples/&#34;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;To start developing your first facade, head on over to &lt;a href=&#34;step1&#34;&gt;Step 1. Creating the project’s structure.&lt;/a&gt;&lt;/p&gt;
&lt;span class=&#34;hide-title-link&#34;&gt;
&lt;h4 id=&#34;step-1-creating-the-projects-structurestep1&#34;&gt;&lt;a href=&#34;step1&#34;&gt;Step 1. Creating the project’s structure&lt;/a&gt;&lt;/h4&gt;
&lt;h4 id=&#34;step-2-business-operationsstep2&#34;&gt;&lt;a href=&#34;step2&#34;&gt;Step 2. Business operations&lt;/a&gt;&lt;/h4&gt;
&lt;h4 id=&#34;step-3-authentication-and-sessionsstep3&#34;&gt;&lt;a href=&#34;step3&#34;&gt;Step 3. Authentication and sessions&lt;/a&gt;&lt;/h4&gt;
&lt;h4 id=&#34;step-4-authorizationstep4&#34;&gt;&lt;a href=&#34;step4&#34;&gt;Step 4. Authorization&lt;/a&gt;&lt;/h4&gt;
&lt;h4 id=&#34;step-5-service-and-version-supportstep5&#34;&gt;&lt;a href=&#34;step5&#34;&gt;Step 5. Service and version support&lt;/a&gt;&lt;/h4&gt;
&lt;h4 id=&#34;step-6-testing-operationsstep6&#34;&gt;&lt;a href=&#34;step6&#34;&gt;Step 6. Testing operations&lt;/a&gt;&lt;/h4&gt;
&lt;h4 id=&#34;step-7-running-the-facadestep7&#34;&gt;&lt;a href=&#34;step7&#34;&gt;Step 7. Running the facade&lt;/a&gt;&lt;/h4&gt;
&lt;h4 id=&#34;step-8-manually-testing-the-facadestep7&#34;&gt;&lt;a href=&#34;step7&#34;&gt;Step 8. Manually Testing the Facade&lt;/a&gt;&lt;/h4&gt;
&lt;/span&gt;

      </description>
    </item>
    
  </channel>
</rss>
